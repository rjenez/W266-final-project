<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z4/student7346.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z4/student7346.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match164-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B2017/2018: ZadaÄ‡a 3, Zadatak 4
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;
#include &lt;iterator&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;list&gt;

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;

static const vector&lt;string&gt; Karte {"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"};
static const vector&lt;string&gt; boje {"Pik", "Tref", "Herc", "Karo"};
enum class Boje {Pik, Tref, Herc, Karo};
typedef std::list&lt;std::pair&lt;Boje, string&gt;&gt; Spil;
typedef std::pair&lt;Boje, string&gt; Karta;
typedef std::multimap&lt;Boje, string&gt; Dio;
typedef std::queue&lt;std::pair&lt;string, string&gt;&gt; Red ;

Spil KreirajSpil() {
    Spil full_spil;
    for (int i(0); i&lt;4; i++) {
        for (int j(0); j&lt;Karte.size(); j++) {
            full_spil.push_back(std::make_pair(static_cast&lt;Boje&gt;(i), Karte.at(j)));
        }
    }
    return full_spil;
}

bool IspravnostSpila (const Spil &amp;nekispil) {
    bool IspravnostSortiranja (const Spil &amp;nekispil);
    if(!IspravnostSortiranja(nekispil)) return false;
    for(auto klizeci(nekispil.begin()); klizeci!=nekispil.end(); klizeci++) 
        if((std::count(nekispil.begin(), nekispil.end(), *klizeci)&gt;=2) || !(std::count(Karte.begin(), Karte.end(), klizeci-&gt;second))) return false;
    if (nekispil.size()&gt;52) return false;
    
    return true;
}

bool IspravnostSortiranja (const Spil &amp;nekispil) {
    auto prvi(nekispil.begin());
    auto drugi(nekispil.begin());
    drugi++;
    while(drugi!=nekispil.end()) {
        if((prvi-&gt;first == drugi-&gt;first &amp;&amp; std::find(Karte.begin(), Karte.end(), prvi-&gt;second)&gt;(std::find(Karte.begin(), Karte.end(), drugi-&gt;second))) || prvi-&gt;first&gt;drugi-&gt;first) return false;
        prvi++;
        drugi++;
    }
    return true;
}

void IzbaciKarte (Spil &amp;nekispil, Dio &amp;kolekcija) {
    if(!IspravnostSpila(nekispil)) throw std::logic_error("Neispravna lista!");
    auto collit(kolekcija.begin());
    while(collit != kolekcija.end()) {
        bool treba_pomjeriti = true;
        if(std::find(nekispil.begin(), nekispil.end(), std::make_pair(collit-&gt;first, collit-&gt;second))!=nekispil.end()) {
            treba_pomjeriti = false;
            nekispil.erase(std::find(nekispil.begin(), nekispil.end(), std::make_pair(collit-&gt;first, collit-&gt;second)));
            collit = kolekcija.erase(collit);
        } 
        if(treba_pomjeriti) collit++;
    }
}

Red IzbaciKarteRazbrajanjem (Spil &amp;nekispil, const short int &amp;r, const int &amp;b) {
    if (r&gt;52 || r&lt;1 || b&lt;1) throw std::logic_error("Neispravni elementi za izbacivanje!");
    if (!IspravnostSpila(nekispil)) throw std::logic_error("Neispravna lista!");
    Red red;
    auto Klizac(nekispil.begin());
    for (int i(0); i&lt;b; i++) {
        for (int j(1); j&lt;r; j++) {
            if(Klizac==nekispil.end()) { 
                Klizac = nekispil.begin(); Klizac++;
            }
            else
                Klizac++;
        }
        if(nekispil.size()==0) break;
        red.push(std::make_pair(boje[static_cast&lt;int&gt;(Klizac-&gt;first)], Klizac-&gt;second));
        Klizac = nekispil.erase(Klizac);
    }
    return red;
}

void VratiJednuKartu (Spil &amp;nekispil, Karta cti) {
    auto Klizac(nekispil.begin());
    while (Klizac!=nekispil.end() &amp;&amp; ((static_cast&lt;int&gt;(cti.first))!=(static_cast&lt;int&gt;(Klizac-&gt;first))))
        Klizac++;
    while (Klizac!=nekispil.end() &amp;&amp; (static_cast&lt;int&gt;(cti.first) == static_cast&lt;int&gt;(Klizac-&gt;first)) &amp;&amp; (std::find(Karte.begin(), Karte.end(), cti.second) &gt; std::find(Karte.begin(), Karte.end(), Klizac-&gt;second)))
        Klizac++;
    nekispil.insert(Klizac, cti);
}

bool ProvjeriIspravnostReda(const std::pair&lt;string, string&gt; &amp;karta) {
    if (std::find(Karte.begin(), Karte.end(), karta.second) == Karte.end() || std::find(boje.begin(), boje.end(), karta.first) == boje.end())
        throw std::logic_error("Neispravne karte!");
    return true;
}

void IspisSpila (const Spil &amp;nekispil) {
    auto Klizeci(nekispil.begin());
    cout &lt;&lt; endl &lt;&lt; "Pik: ";
    while(Klizeci-&gt;first == Boje::Pik &amp;&amp; Klizeci!=nekispil.end()) {
        cout &lt;&lt; Klizeci-&gt;second &lt;&lt; " ";
        Klizeci++;
    }
    cout &lt;&lt; endl &lt;&lt; "Tref: ";
    while(Klizeci-&gt;first == Boje::Tref &amp;&amp; Klizeci!=nekispil.end()) {
        cout &lt;&lt; Klizeci-&gt;second &lt;&lt; " ";
        Klizeci++;
    }
    cout &lt;&lt; endl &lt;&lt; "Herc: ";
    while(Klizeci-&gt;first == Boje::Herc &amp;&amp; Klizeci!=nekispil.end()) {
        cout &lt;&lt; Klizeci-&gt;second &lt;&lt; " ";
        Klizeci++;
    }
    cout &lt;&lt; endl &lt;&lt; "Karo: ";
    while(Klizeci-&gt;first == Boje::Karo &amp;&amp; Klizeci!=nekispil.end()) {
        cout &lt;&lt; Klizeci-&gt;second &lt;&lt; " ";
        Klizeci++;
    }
}

void VratiPrvihNKarata(Spil &amp;nekispil, Red &amp;za_vratiti, int n) {
    if(n&lt;0) throw std::domain_error ("Broj n je besmislen!");
    if(n&gt;za_vratiti.size()) throw std::range_error ("Nedovoljno karata u redu!");
    if(!IspravnostSpila(nekispil)) throw std::range_error("Neispravna lista!");
    
    for(int i(0); i&lt;n; i++) {
        if(za_vratiti.size()==0) break;
        ProvjeriIspravnostReda(za_vratiti.front());
        Karta cti = std::make_pair(static_cast&lt;Boje&gt;(std::find(boje.begin(), boje.end(), za_vratiti.front().first)-boje.begin()), za_vratiti.front().second);
        if(std::find(nekispil.begin(), nekispil.end(), cti)!=nekispil.end()) { 
            continue;
        }
        VratiJednuKartu(nekispil, cti);
        za_vratiti.pop();
    }
}


int main ()
{
    cout &lt;&lt; "Unesite korak razbrajanja: ";
    short int k;
    cin &gt;&gt; k;
    cout &lt;&lt; "Unesite broj karata koje zelite izbaciti: ";
    int n;
    cin &gt;&gt; n;
    Spil full_spil = KreirajSpil();
    try
    {
        Red vratiti = IzbaciKarteRazbrajanjem(full_spil, k, n);
        cout &lt;&lt; "U spilu trenutno ima " &lt;&lt; full_spil.size() &lt;&lt; " karata, i to: " ;
        IspisSpila(full_spil);
        cout &lt;&lt; endl &lt;&lt; "Unesite broj karata koje zelite vratiti u spil: ";
        int bkv;
        cin &gt;&gt; bkv;
        VratiPrvihNKarata(full_spil, vratiti, bkv);
        cout &lt;&lt; "U spilu trenutno ima " &lt;&lt; full_spil.size() &lt;&lt; " karata, i to: " ;
        IspisSpila(full_spil);
    }
    catch(std::exception &amp;poruka) {
        cout &lt;&lt; "Izuzetak: " &lt;&lt; poruka.what();
    }
	return 0;
</font>}
</pre>
</body>
</html>
