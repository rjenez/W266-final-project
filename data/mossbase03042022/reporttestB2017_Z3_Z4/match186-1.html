<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z4/student5961.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z4/student7795.cpp<p></p><pre>
// updating, solved locally
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;queue&gt;

// predefined data
<a name="0"></a><font color="#FF0000"><a href="match186-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum class Boje { Pik, Tref, Herc, Karo };

constexpr int DECK_SIZE(52);
const std::vector&lt;std::string&gt; cardValues { "2","3","4","5","6","7","8","9","10","J","Q","K","A" };
const std::vector&lt;std::string&gt; cardNames { "Pik", "Tref", "Herc", "Karo" };

auto cardNumIndex = [](const std::string&amp; _str) {
     return std::find(cardValues.cbegin(), cardValues.cend(), _str);
};

typedef std::pair&lt;Boje, std::string&gt;                   Card;
typedef std::pair&lt;std::string, std::string&gt;            RemovedCards;
typedef std::list&lt;Card&gt;                                Spil;
typedef std::multimap&lt;Boje, std::string&gt;               KarteMapa;
typedef std::queue&lt;RemovedCards&gt;                       ObrisaneRed;

// print cards function
void ispisiDeck(const Spil&amp; _deck) {
     for (int i(0); i &lt; cardNames.size(); ++i) {
          std::cout &lt;&lt; std::endl &lt;&lt; cardNames.at(i) &lt;&lt; ": ";
          for (auto it(_deck.begin()); it != _deck.end(); ++it)
               if(it-&gt;first == static_cast&lt;Boje&gt;(i + int(Boje::Pik))) std::cout &lt;&lt; it-&gt;second &lt;&lt; " ";
     }
}

// sort function
bool sortFunction(const Card&amp; a, const Card&amp; b) {
     return (a.first &lt; b.first) || ((a.first == b.first) &amp;&amp; (cardNumIndex(a.second) &lt; cardNumIndex(b.second)));
}

// check if given card is valid
bool validCard(const std::string&amp; str, std::vector&lt;std::string&gt; _arr = cardValues) {
     return std::any_of(_arr.begin(), _arr.end(), [=](const std::string&amp; _val) { return _val == str; });
}

// check validity of elements in deck
template &lt;class container&gt; 
bool invalidDeck(const container&amp; _deck) {
     return std::any_of(_deck.begin(), _deck.end(), [](const Card&amp; a) {
          return (a.first &lt; Boje::Pik || a.first &gt; Boje::Karo || !validCard(a.second));
     });
}

// validate entire card deck
void checkDeckValidity(const Spil&amp; _deck) {
     if ( _deck.size() &gt; DECK_SIZE || invalidDeck&lt;Spil&gt;(_deck) ||
          (std::adjacent_find(_deck.begin(), _deck.end(), [](const Card&amp; a, const Card&amp; b) { 
               return !sortFunction(a, b); 
          }) != _deck.end()))
          throw std::logic_error("Neispravna lista!");
}

// validate queue cards
void validateCardQueue(ObrisaneRed _deck) {
     for (; !_deck.empty();) {
          auto _card (_deck.front());
          if(!(validCard(_card.first, cardNames) &amp;&amp; validCard(_card.second)))
               throw std::logic_error("Neispravne karte!");
          _deck.pop();
     }
}

/*   functions to implement   */
Spil KreirajSpil() {
     Spil _output;
     for (auto _znak(static_cast&lt;int&gt;(Boje::Pik)); _znak &lt;= static_cast&lt;int&gt;(Boje::Karo); ++_znak)
          std::for_each(cardValues.begin(), cardValues.end(), [&amp;_output, _znak](std::string _val) {
               _output.push_back(std::make_pair(static_cast&lt;Boje&gt;(_znak), _val));
          });
     return _output;
}

void IzbaciKarte(Spil&amp; _deck, KarteMapa &amp;_dmap) {
     checkDeckValidity(_deck);  // validity check

     for (bool _exist(false);;) {
          std::for_each(_deck.begin(), _deck.end(), [&amp;_dmap, &amp;_exist, &amp;_deck](Card&amp; karta) {
               _exist = false;
			auto _it(_dmap.find(karta.first));
			if (_it != _dmap.end() &amp;&amp; _it-&gt;second == karta.second) {
				_it = _dmap.erase(_it);
				_exist = true;
			}
               if (_exist) _deck.remove(karta);
          });
          if (!_exist) break; 
     }
}

ObrisaneRed IzbaciKarteRazbrajanjem(Spil&amp; _deck, const short int&amp; r, const int&amp; b) {
     // validity checks
     if (r &lt; 1 || r &gt; DECK_SIZE || b &lt; 1)
          throw std::logic_error("Neispravni elementi za izbacivanje!");
     checkDeckValidity(_deck);
     
     ObrisaneRed output;
     int _erased (0);
     auto karta (_deck.begin());
     
     for (int _currentPos (1); !_deck.empty() &amp;&amp; _erased &lt; b; ++_currentPos) {
          if (_currentPos == r) {
               ++_erased;
               output.push(std::make_pair(cardNames.at(int(karta-&gt;first) + int(Boje::Pik)), karta-&gt;second));
               karta = std::prev(_deck.erase(karta));
               _currentPos = 0;
          }
          ++karta;
          if (karta == _deck.end()) karta = _deck.begin();
     }
     return output;
}

void VratiPrvihNKarata(Spil&amp; _deck, ObrisaneRed&amp; _removedCards, int n) {
     // validations
     if (n &lt; 0) throw std::domain_error("Broj n je besmislen!");
     else if (n &gt; _removedCards.size()) throw std::range_error("Nedovoljno karata u redu!");
     validateCardQueue(_removedCards);
     checkDeckValidity(_deck);
     
     for (; n &gt; 0; --n) {
          auto _card (_removedCards.front());
          // map card accordingly from (string, string) to (Boje, string)
          int _pos (std::find(cardNames.begin(), cardNames.end(), _card.first) - cardNames.begin());
          
          auto _add (std::make_pair(static_cast&lt;Boje&gt;(_pos + int(Boje::Pik)), _card.second));
          if(_deck.size() &lt; DECK_SIZE &amp;&amp; std::find(_deck.begin(), _deck.end(), _add) == _deck.end())
               _deck.insert(_deck.begin(), _add);
          _removedCards.pop();
     }
     // sort list
     _deck.sort(sortFunction);
}

// main program logic
int main() {
     short int r;
     int b, n;
     Spil _deck (KreirajSpil());
     try {
		std::cout &lt;&lt; "Unesite korak razbrajanja: "; std::cin &gt;&gt; r;
		std::cout &lt;&lt; "Unesite broj karata koje zelite izbaciti: "; std::cin &gt;&gt; b;
		auto _removed (IzbaciKarteRazbrajanjem(_deck, r, b));
		
		std::cout &lt;&lt; "U spilu trenutno ima " &lt;&lt; _deck.size() &lt;&lt; " karata, i to: "; ispisiDeck(_deck);
		
		std::cout &lt;&lt; std::endl &lt;&lt; "Unesite broj karata koje zelite vratiti u spil: "; std::cin &gt;&gt; n;
		VratiPrvihNKarata(_deck, _removed, n);
		std::cout &lt;&lt; "U spilu trenutno ima " &lt;&lt; _deck.size() &lt;&lt; " karata, i to: "; ispisiDeck(_deck);
     }
     catch (const std::exception&amp; e) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what();
	}
     return 0;
}

int main() {</font></pre>
</body>
</html>
