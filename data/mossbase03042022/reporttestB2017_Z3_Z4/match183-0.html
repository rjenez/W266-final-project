<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z4/student9524.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z4/student9524.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match183-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_98.gif"/></a>

/B2017/2018: ZadaÄ‡a 3, Zadatak 4
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;utility&gt;
#include &lt;map&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;stdexcept&gt;

enum class Boje {Pik, Tref, Herc, Karo};

std::list&lt;std::pair&lt;Boje, std::string&gt;&gt; KreirajSpil(){
    std::list&lt;std::pair&lt;Boje, std::string&gt;&gt; spil;
    for(int i=0; i&lt;4; i++){
        for(int j=2; j&lt;=10; j++){
            spil.push_back(std::make_pair(Boje(i), std::to_string(j)));
        }
        spil.push_back(std::make_pair(Boje(i), "J"));
        spil.push_back(std::make_pair(Boje(i), "Q"));
        spil.push_back(std::make_pair(Boje(i), "K"));
        spil.push_back(std::make_pair(Boje(i), "A"));
    }
    return spil;
}

bool ProvjeriSpil(std::list&lt;std::pair&lt;Boje, std::string&gt;&gt; &amp;spil){
    if(spil.size()&gt;52)return true;
    auto pomocni_spil(KreirajSpil());
    auto it2(pomocni_spil.begin());
    bool ima_u_deku(false);
    for(auto it=spil.begin(); it!=spil.end(); it++){
        for(it2; it2!=pomocni_spil.end(); it2++){
            if(it-&gt;first==it2-&gt;first &amp;&amp; it-&gt;second==it2-&gt;second){
                ima_u_deku=true;
                it2++;
                break;
            }
        }
        if(!ima_u_deku)return true;
        ima_u_deku=false;
    }
    return false;
}

void IzbaciKarte(std::list&lt;std::pair&lt;Boje, std::string&gt;&gt; &amp;spil, std::multimap&lt;Boje, std::string&gt; za_izbacit){
    if(ProvjeriSpil(spil))throw std::logic_error("Neispravna lista!");
    for(auto it = za_izbacit.begin(); it!=za_izbacit.end(); it++){
        std::list&lt;std::pair&lt;Boje, std::string&gt;&gt;::iterator nadji_it (std::find(spil.begin(), spil.end(), std::make_pair(it-&gt;first, it-&gt;second)));
        if(nadji_it!=spil.end()){
            za_izbacit.erase(it);
            spil.erase(nadji_it);
        }
    }
}

std::queue&lt;std::pair&lt;Boje, std::string&gt;&gt;  IzbaciKarteRazbrajanjem(std::list&lt;std::pair&lt;Boje, std::string&gt;&gt; &amp;spil, const short int &amp;r, const int &amp;b){
    if(r&lt;1 || r&gt;52 || b&lt;1)throw std::logic_error("Neispravni elementi za izbacivanje!");
    if(ProvjeriSpil(spil))throw std::logic_error("Neispravna lista!");
    std::queue&lt;std::pair&lt;Boje, std::string&gt;&gt; izbacene_karte;
    
    int brojac_koraka(0), brojac_izbrisanih(0);
    bool gotovo(false);
    for(;;){
        //std::cout &lt;&lt; "\nbrojac_koraka=" &lt;&lt; brojac_koraka &lt;&lt; " brojac_izbrisanih=="
        auto it(spil.begin());
        if(spil.begin()==spil.end())break;
        for(it; it!=spil.end(); it++){
            //std::cout &lt;&lt; "\ntusam\n";
            brojac_koraka++;
            if(brojac_izbrisanih==b){
                gotovo=true;
                break;
            }
            if(brojac_koraka==r){// treba izbacit kartu
                //std::cout &lt;&lt; "\nnesto se desava\n";
                izbacene_karte.push(std::make_pair(it-&gt;first, it-&gt;second));
                it=spil.erase(it);
                it--;
                brojac_koraka=0;
                brojac_izbrisanih++;
            }
        }
        if(gotovo)break;
    }
    
    return izbacene_karte;
}

void VratiPrvihNKarata(std::list&lt;std::pair&lt;Boje, std::string&gt;&gt; &amp;spil, std::queue&lt;std::pair&lt;Boje, std::string&gt;&gt; &amp;izbacene_karte, int n){
    //std::cout &lt;&lt; "\nn=" &lt;&lt; n &lt;&lt; "  izbacene_karte.size=" &lt;&lt; izbacene_karte.size() &lt;&lt; "\n";
    if(n&lt;0)throw std::domain_error("Broj n je besmislen!");
    if(n&gt;izbacene_karte.size())throw std::range_error("Nedovoljno karata u redu!"); // size vrati unsigned int pa se moze poredit samo sa pozitivnim brojevima zato cu ispred stavit ovaj uslov gdje je n&lt;1
    if(ProvjeriSpil(spil))throw std::logic_error("Neispravna lista!");
    
    //provjera reda dal su karte uredu DODATI
    
    
    int brojac_ubacenih(0);
    while(brojac_ubacenih&lt;n){
        auto element_koji_se_ubacuje (izbacene_karte.front());
        
        //moram uradit ako vec ima u spilu taj element da ide continue ovde prije brojac_ubacenih++ a da se izbaci valjda iz reda i taj...
        bool uradi_continue(false);
        for(auto it=spil.begin(); it!=spil.end(); it++){
            if(it-&gt;first==element_koji_se_ubacuje.first &amp;&amp; it-&gt;second==element_koji_se_ubacuje.second){// onda vec ima u spilu
                izbacene_karte.pop();
                uradi_continue=true;
                break;
            }
        }
        if(uradi_continue)continue;
        
        auto pomocni_spil(KreirajSpil());
        auto it_pozicija(spil.begin());
        for(auto it=pomocni_spil.begin(); it!=pomocni_spil.end(); it++){
            
            if(it-&gt;first==element_koji_se_ubacuje.first &amp;&amp; it-&gt;second==element_koji_se_ubacuje.second){
                it_pozicija++;//posto on se ubaci na mjesto na koje pokazuje ovaj iterator a ono sto je bilo sve desno pomjeri od sebe...
                spil.insert(it_pozicija, element_koji_se_ubacuje);
                break;
            }
            
            for(auto it2=spil.begin(); it2!=spil.end(); it2++){
                if(it-&gt;first==it2-&gt;first &amp;&amp; it-&gt;second==it2-&gt;second)it_pozicija=it2;
            }
           
        }
        
        
        izbacene_karte.pop();
        brojac_ubacenih++;
    }
    
}

void IspisiSpil(std::list&lt;std::pair&lt;Boje, std::string&gt;&gt; &amp;spil){
    Boje pomocna(Boje::Karo);
    std::vector&lt;std::string&gt;boje_pomoc{"Pik", "Tref", "Herc", "Karo"};
    for(auto it=spil.begin(); it!=spil.end(); it++){
        if(it-&gt;first!=pomocna){
            std::cout &lt;&lt; "\n" &lt;&lt; boje_pomoc[int(it-&gt;first)] &lt;&lt; ": ";
            pomocna=it-&gt;first;
        }
        std::cout &lt;&lt; it-&gt;second &lt;&lt; " ";
    }
    
}

//PROVJERITI OVU FUNKCIJU IZBRISI OBICNU...

int main ()
{
    int r, b, n;
    std::cout &lt;&lt; "Unesite korak razbrajanja: ";
    std::cin &gt;&gt; r;
    std::cout &lt;&lt; "Unesite broj karata koje zelite izbaciti: ";
    std::cin &gt;&gt; b;
    auto spil(KreirajSpil());
    std::queue&lt;std::pair&lt;Boje, std::string&gt;&gt; izbacene_karte;
    try{
        izbacene_karte = IzbaciKarteRazbrajanjem(spil, r, b);
    }    
    catch(std::logic_error &amp;e){
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what();
        return 0;
    }
    std::cout &lt;&lt; "U spilu trenutno ima " &lt;&lt; spil.size() &lt;&lt; " karata, i to:";
    IspisiSpil(spil);
    std::cout &lt;&lt; "\nUnesite broj karata koje zelite vratiti u spil: ";
    std::cin &gt;&gt; n;
    try{
        VratiPrvihNKarata(spil, izbacene_karte, n);
        std::cout &lt;&lt; "U spilu trenutno ima " &lt;&lt; spil.size() &lt;&lt; " karata, i to:";
        IspisiSpil(spil);
    }
    catch(std::domain_error &amp;e){
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what();
    }
    catch(std::range_error &amp;e){
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what();
    }
    catch(std::logic_error &amp;e){
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what();
</font>    }
	return 0;
}
</pre>
</body>
</html>
