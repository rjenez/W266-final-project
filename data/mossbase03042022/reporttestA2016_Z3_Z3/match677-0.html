<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2016/Z3/Z3/student4415.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2016/Z3/Z3/student4415.c<p></p><pre>
#include &lt;stdio.h&gt;

int main()
{

	int i, j, k, t, c, x; // variable koje koristimo da se pomjeramo u 2d nizu ( i, j, k, t itd.)

	int niz[200][200], BR_RED, BR_KOL;

	// Unos broja redova i kolona matrice i provjera da li su u datom opsegu
	do {
		printf ("Unesite brojeve M i N: ");
		scanf ("%d %d", &amp;BR_RED, &amp;BR_KOL);

		if (BR_KOL &lt; 1 || BR_KOL &gt; 200 || BR_RED &lt; 1 || BR_RED &gt; 200 )
			printf ("Brojevi nisu u trazenom opsegu.\n");

	} while (BR_KOL &lt; 1 || BR_KOL &gt; 200 || BR_RED &lt; 1 || BR_RED &gt; 200 );

	printf ("Unesite elemente matrice: ");

	for ( i = 0; i &lt; BR_RED; i++) {
<a name="2"></a><font color="#0000FF"><a href="match677-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

		for (j = 0; j &lt; BR_KOL; j++) {
			scanf ("%d", &amp;niz[i][j]);
		}
	}
	// Izbacivanje reda ako se nalazi vec u nizu ( duplikat ), uz ocuvanje redoslijda

	// i , j nam sluze da se pomjeramo po redovima tako da ih mozemo porediti svaki sa svakim
	for ( i = 0; i &lt; BR_RED; i++) {
		for (j = 0; j &lt; BR_RED; j++) {
</font><a name="0"></a><font color="#FF0000"><a href="match677-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

			x = 1; 						// postavimo uslov istinit ( da su dva reda jednaka )

			if (j == i) continue; 		// Izbacivamo slucaj kada je i == j da nebi poredili red sam sa sobom

			// k nam sluzi da uporedimo sve clanove  prvog reda sa odgovarajucim clanovima drugog
			for (k = 0; k &lt; BR_KOL; k++) {
				if ( niz[i][k] != niz [j][k]) { 		// ako pronadjemo samo jedan element koji se razlikuje postavljamo x na 0 i zaustavljamo petlju
</font>					x = 0;
					break;
				}
			}

			// Ukoliko je uslov x = 1 ostao zadovoljen tj da su svi elementi jednog reda jednaki odgovarajucim elementima drugog reda, drugi red izbacivamo
			if (x &amp;&amp; i &lt; j) {
				for (t = j; t &lt; BR_RED -1; t++) {
					for (c = 0; c &lt; BR_KOL; c++)
<a name="3"></a><font color="#00FFFF"><a href="match677-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

						niz[t][c] = niz[t+1][c];
				}
				BR_RED --;
				j --;
			}
		}
	}
	// Izbacivanje kolona iz matrice ukoliko se vec nalazi ista u matrici ( duplikat), uz ocuvanje redoslijeda
	// Ista prica kao i za redove samo sto sada radimo za kolone i, j nam sluze da se pomjeramo po kolonama

	for ( i = 0; i &lt; BR_KOL; i++) {
		for (j =0; j &lt; BR_KOL; j++) {
</font><a name="1"></a><font color="#00FF00"><a href="match677-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

			x = 1;

			if (j == i) continue;

			for (k = 0; k &lt; BR_RED; k++) {
				if ( niz[k][i] != niz [k][j]) {
</font>					x = 0;
					break;
				}
			}

			if (x &amp;&amp; i &lt; j) {
				for (t = j; t &lt; BR_KOL -1; t++) {
					for (c = 0; c &lt; BR_RED; c++)
						niz[c][t] = niz[c][t+1];
				}
				BR_KOL--;
				j--;
			}
		}
	}
	//Nakon izbacivanje ispisivamo matricu

	printf("Nakon izbacivanja redova/kolona matrica glasi:\n");

	for (i = 0; i &lt; BR_RED; i++) {
		for (j = 0; j&lt; BR_KOL; j++) {
			printf ("%5d",niz[i][j]);
		}
		printf ("\n");

	}

	return 0;
}
</pre>
</body>
</html>
