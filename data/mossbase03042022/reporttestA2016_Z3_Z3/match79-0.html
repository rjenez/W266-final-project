<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2016/Z3/Z3/student5129.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2016/Z3/Z3/student5129.c<p></p><pre>
#include &lt;stdio.h&gt;

int main() {
	int mat[200][200]={{0}}, tp[200][200], m, n, br, i, j, k, l, a, x;
	
	/* Unos dimenzija matrice */
	while(1){
		printf("Unesite brojeve M i N: ");
		scanf("%d %d", &amp;m, &amp;n);
		
		/* Provjera pripadnosti intervalu [0,200] */
		if((m&lt;1 || m&gt;200) || (n&lt;1 || n&gt;200)) {
			printf("Brojevi nisu u trazenom opsegu.\n");
			continue;
		}
		
		break;
	}
	
	/* Unos elemenata matrice */
	printf("Unesite elemente matrice: ");
	for(i=0; i&lt;m; i++){
<a name="0"></a><font color="#FF0000"><a href="match79-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_71.gif"/></a>

		for(j=0; j&lt;n; j++){
			scanf("%d", &amp;mat[i][j]);
		}
	}
	
	
	/* Za Redove */
	for(i=0; i&lt;m; i++){
		/* Poredi se sa X, koje je za 1 vece tako da ne detektuje i obrise samo sebe */
		x=i+1;
		while(x&lt;m){
			br=0;
			for(j=0; j&lt;n; j++){
				/* Da ne izadje van opsega niza u neinicijalizirane */
				if(i!=m-1){
					/* Ako su clanovi isti, inkrementuje se brojac */
					if(mat[i][j]==mat[x][j]){
						br++;
						/* Ako su SVI clanovi isti, onda je brojac jednak ukupnom broju clanova reda, tj. jednak je broju kolona */
						if(br==n){
							/* Zamjena clanova i brisanje reda */
							for(k=x; k&lt;m; k++){
								for(l=0; l&lt;n; l++){
									mat[k][l]=mat[k+1][l];
								}
							}
						/* X se vraca na i tako da k=x bude ispravno */
						x=i;
						/* Smanjujemo broj redova jer smo obrisali jedan */
						m--;
						}
					}
				}
			}
		/* Inkrementuje se X tako da prolazi kroz ostatak matrice */
		x++;
		}
	}
	
	
	/* Za Kolone */
	for(j=0; j&lt;n; j++){
		/* Da ne izadje van opsega niza u neinicijalizirane */
		if(j!=n-1){
			/* Poredi se sa X, koje je za 1 vece tako da ne detektuje i obrise samo sebe */
			x=j+1;
			while(x&lt;n){
				/* Moraju im prvi clanovi biti isti tako da bi svi bili isti */
				if(mat[0][j]==mat[0][x]){
					br=0;
					for(k=0; k&lt;m; k++){
						/* Ako su clanovi isti, inkrementuje se brojac */
						if(mat[k][j]==mat[k][x]){
							br++;
							/* Ako su SVI clanovi isti, onda je brojac jednak ukupnom broju clanova kolone, tj. jednak je broju redova */
							if(br==m){
								/* Zamjena clanova i brisanje kolone */
								for(a=0; a&lt;m; a++){
									for(l=x; l&lt;n; l++){
										mat[a][l]=mat[a][l+1];
										/* Specijalni sluƒçaj kada imamo samo jedan red */
										if(m==1) x=j;
									}
								}
							/* Smanjujemo broj kolona jer smo obrisali jednu */
							n--;
							}
						}	
					}
				}
				/* Inkrementuje se X tako da prolazi kroz ostatak matrice */
				x++;
			}
		}
	}
	
	/* Ispis */
	printf("Nakon izbacivanja redova/kolona matrica glasi:\n");
	for(i=0; i&lt;m; i++){
		for(j=0; j&lt;n; j++){
			printf("%5d", mat[i][j]);
</font>		}
		printf("\n");
	}
	
	return 0;
}</pre>
</body>
</html>
