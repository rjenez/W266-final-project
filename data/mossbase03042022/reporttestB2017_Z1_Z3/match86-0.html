<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z3/student8789.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z3/student8789.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match86-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum Smjer{Rastuci,Opadajuci};

//Testira stepene dvojke tako sto uzima broj i poredi ga sa 2^n
bool TestStepeniDvojke(double broj)
{
	double pomocna(0), brojac(2);
	if(broj&lt;0) return false;
	if(broj==1||broj==2) return true;
	for(;;)
	{
		pomocna=pow(2,brojac);
		if(pomocna==broj) return true;
		if(pomocna&gt;broj) return false;
		brojac++;
	}
	return false;
}

//Popunjava vektor za zadati pocetak i kraj
std::vector&lt;int&gt; PopuniVektor(std::vector&lt;int&gt; vektor, int pocetak, int kraj)
{
	std::vector&lt;int&gt; novi;
	for(int i = pocetak; i &lt; kraj;i++)
		novi.push_back(vektor.at(i));
	return novi;
}

//Poredi n i n+1 element matrice u zavisnosti od enum unosa,
//za enum rastuci gleda da je prvi manji od drugog
//a za enum opadajuci gleda da je drugi manji od prvog
bool Uporedi(int a, int b, bool test)
{
	//if(!TestStepeniDvojke(a)||!TestStepeniDvojke(b)) return false;
	//std::cout&lt;&lt;"pozvan! a je: "&lt;&lt;a&lt;&lt;" b je: "&lt;&lt;b&lt;&lt;std::endl;
	if(!test&amp;&amp;a&lt;b){ /*std::cout&lt;&lt;"pozvan prvi!"&lt;&lt;std::endl;*/ return true;}
	if(test&amp;&amp;b&lt;a){ /*std::cout&lt;&lt;"pozvan drugi!"&lt;&lt;std::endl;*/ return true;}
	return false;
}

std::deque&lt;std::vector&lt;int&gt;&gt; MaksimalniPodnizoviStepenaDvojke(std::vector&lt;int&gt; vektor, Smjer neki)
{
	std::deque&lt;std::vector&lt;int&gt;&gt; novi;
	std::vector&lt;int&gt; elementi;
	int pocetak(0),kraj(0),brojac(0);
	bool smjer(false),test(false);
	if(neki==Opadajuci) smjer=true;
	for(auto i : vektor)
	{
		//testira da li je broj iz vektora stepen dvojke
		if(TestStepeniDvojke(i))
		{
			if(brojac&gt;0&amp;&amp;Uporedi(vektor.at(brojac-1),i,smjer)) 
			{
				//ako prodje i ako je prvi put da prolazi onda stavlja test na true
				//da podesi pocetak za dalje testiranje
				if(test==false) {pocetak=brojac-1; test=true; /*std::cout&lt;&lt;"pocetak je: "&lt;&lt;vektor.at(pocetak)&lt;&lt;std::endl;*/}
			}
			else
			{
				//ako element nije stepen dvojke postavlja kraj na vrijednost brojaca
				kraj=brojac;
				//za slucaj kad je kraj-pocetak==1 izbacuje jedan element a ne par elemenata
				//i testira da li se pozivala ikako funkcija koja ce postavljati pocetak
				if(abs(pocetak-kraj)&gt;1&amp;&amp;test==true)
				{
					//dodatno testiranje zbog kriticnih slucajeva kad pocetna if "preskoci" element koji
					//nije stepen dvojke a sljedeci prodje
					for(int k = pocetak; k&lt;kraj; k++)
					//ako nadje element koji nije stepen dvojke u opsegu pocetak kraj onda postavlja kraj na
					//vrijednost k
					if(!TestStepeniDvojke(vektor.at(k))){ kraj=k; break;}
					{
						elementi=PopuniVektor(vektor,pocetak,kraj);
						novi.push_back(elementi);
						elementi.clear();
					}
				}
				//postavlja pocetak na vrijednost brojac zbog ponavljanja podnizova
				//i test na false da moze ponovo uspostaviti brojac u slucaju da uspije if od ovog else
				pocetak=brojac;
				test=false;
			}
		}
		//U slucaju da prodje da se ne pozove else u slucaju iznad (kad je zadnji element zadovoljio uslov a nije pokrenut else)
		//vrsi dodatna testiranja
		if(test==true&amp;&amp;brojac==vektor.size()-1)
		{
			kraj=brojac;
			//testira za parove koji su veci od 2 da li je na kraju element koji je stepen dvojke
			//i ako jeste poveca kraj za jedan zbog toga sto for petlja ne ide do kraja
			if(kraj-pocetak&gt;=1&amp;&amp;TestStepeniDvojke(vektor.at(kraj))) kraj++;
			elementi=PopuniVektor(vektor,pocetak,kraj);
			novi.push_back(elementi);
			elementi.clear();
		}
		brojac++;
	}
	//if(vektor.size()==1) if(TestStepeniDvojke(vektor.at(0))) {elementi.push_back(vektor.at(0)); novi.push_back(elementi);}
	return novi;
}

int main ()
{
	Smjer smjer;
	std::vector&lt;int&gt; vektor;
	std::deque&lt;std::vector&lt;int&gt;&gt; dek;
	double testunosa(0);
	double brojvektora(0),brojac(0);
	std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
	//rigorozno testira za validan unos, postoji odstupanje u slucaju
	//da je unos vrijednosti broj koji je priblizno jednak cijelom broju
	//to jeste 2.00000000001 je priblizno jednak 2
	for(;;)
	{
		std::cin&gt;&gt;brojvektora;
		if((int(brojvektora)/brojvektora==1&amp;&amp;brojvektora&gt;0)){break;}
		else
		{
			std::cout&lt;&lt;"Unos nije validnog formata, pokusajte ponovo!";
			std::cin.clear();
			std::cin.ignore(1000,'\n');
		}
	}
	std::cout&lt;&lt;"Unesite elemente vektora: ";
	for(;;)
	{
		std::cin&gt;&gt;testunosa;
		if(int(testunosa)/testunosa==1)
		{
			vektor.push_back(testunosa); 
			brojac++;
			if(brojac==brojvektora) break;
		}
		else
		{
			std::cout&lt;&lt;"Unos nije validnog formata, pokusajte ponovo!";
			std::cin.clear();
			std::cin.ignore(1000,'\n');
		}
	}
	std::cout&lt;&lt;"Unesite: 1 - za rastuce podnizove, 2 - za opadajuce podnizove: ";
	for(;;)
	{
		std::cin&gt;&gt;testunosa;
		if(testunosa==1){smjer=Rastuci; break;}
		else if(testunosa==2){smjer=Opadajuci; break;}
		else{
			std::cout&lt;&lt;"Unos nije validnog formata, pokusajte ponovo!";
			std::cin.clear();
			std::cin.ignore(1000,'\n');
		}
	}
	dek=MaksimalniPodnizoviStepenaDvojke(vektor, smjer);
	if(dek.size()==0) {std::cout&lt;&lt;"Nema podnizova koji odgovaraju uslovima"; return 0;}
	else if(smjer==Rastuci)
	std::cout&lt;&lt;"Maksimalni rastuci podnizovi: ";
	else if(smjer==Opadajuci) std::cout&lt;&lt;"Maksimalni opadajuci podnizovi: ";
	std::cout&lt;&lt;std::endl;
	for(auto i : dek)
	{
		for(auto j : i)
		{
			std::cout&lt;&lt; j&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	return 0;
</font>}</pre>
</body>
</html>
