<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z3/student1688.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z3/student1688.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/
#include&lt;iostream&gt;
#include&lt;deque&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
<a name="0"></a><font color="#FF0000"><a href="match0-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum Smjer { Rastuci=1,Opadajuci};

std::deque&lt;std::vector&lt;int&gt;&gt;MaksimalniPodnizoviStepenaDvojke(std::vector&lt;int&gt;vec,enum Smjer s){
	std::deque&lt;std::vector&lt;int&gt;&gt;rastuci;
	std::deque&lt;std::vector&lt;int&gt;&gt;opadajuci;
	std::vector&lt;int&gt;pomocni;
	for(int i=1;i&lt;vec.size();i++){
		if(i==vec.size()) break;
		if(s==1){
			if(vec.at(i-1)&lt;vec.at(i)){
				pomocni.push_back(vec.at(i-1));
				pomocni.push_back(vec.at(i));
				if(i==vec.size()-1){
					for(int j=0;j&lt;pomocni.size();j++){
						for(int z=j+1;z&lt;pomocni.size();z++)
						if(pomocni.at(j)==pomocni.at(z)){
							for(int k=z;k&lt;pomocni.size()-1;k++)
							pomocni.at(k)=pomocni.at(k+1);
							z--;
							pomocni.resize(pomocni.size()-1);
						}
					}
					std::vector&lt;int&gt;v;
					for(int k=0;k&lt;pomocni.size();k++){
						if((pomocni.at(k)%2==0 || pomocni.at(k)==1) &amp;&amp; pomocni.at(k)!=0 &amp;&amp; pomocni.at(k)&gt;0) v.push_back(pomocni.at(k));
					}
					if(v.size()&gt;=2) rastuci.push_back(v);
				}
			}
			else{ 
				for(int j=0;j&lt;pomocni.size();j++){
					for(int z=j+1;z&lt;pomocni.size();z++)
					if(pomocni.at(j)==pomocni.at(z)){
						for(int k=z;k&lt;pomocni.size()-1;k++)
						pomocni.at(k)=pomocni.at(k+1);
						z--;
						pomocni.resize(pomocni.size()-1);
					}
				}
				std::vector&lt;int&gt;v;
				for(int k=0;k&lt;pomocni.size();k++){
					if((pomocni.at(k)%2==0 || pomocni.at(k)==1) &amp;&amp; pomocni.at(k)!=0 &amp;&amp; pomocni.at(k)&gt;0) v.push_back(pomocni.at(k));
				}
				
				if(v.size()&gt;=2) rastuci.push_back(v);
				pomocni.resize(0);
			}
		}
		
		if(s==2){
			if(vec.at(i)&lt;vec.at(i-1)){
				pomocni.push_back(vec.at(i-1));
				pomocni.push_back(vec.at(i));
				if(i==vec.size()-1){
					for(int j=0;j&lt;pomocni.size();j++){
						for(int z=j+1;z&lt;pomocni.size();z++)
						if(pomocni.at(j)==pomocni.at(z)){
							for(int k=z;k&lt;pomocni.size()-1;k++)
							pomocni.at(k)=pomocni.at(k+1);
							z--;
							pomocni.resize(pomocni.size()-1);
						}
					}
					std::vector&lt;int&gt;v;
					for(int k=0;k&lt;pomocni.size();k++){
						if(k&lt;pomocni.size()-1 &amp;&amp; pomocni.at(k)/2==pomocni.at(k+1) &amp;&amp; pomocni.at(k)!=0 &amp;&amp; pomocni.at(k+1)!=0 &amp;&amp; pomocni.at(k)&gt;0 &amp;&amp; pomocni.at(k+1)&gt;0){
							v.push_back(pomocni.at(k));
							v.push_back(pomocni.at(k+1));
						}
					}
					
					for(int j=0;j&lt;v.size();j++){
						for(int z=j+1;z&lt;v.size();z++)
						if(v.at(j)==v.at(j+1)){
							for(int k=z;k&lt;v.size()-1;k++)
							v.at(k)=v.at(k+1);
							z--;
							v.resize(v.size()-1);
						}
					}
					
					if(v.size()&gt;=2) opadajuci.push_back(v);
				}
			}
			else {
				for(int j=0;j&lt;pomocni.size();j++){
					for(int z=j+1;z&lt;pomocni.size();z++)
					if(pomocni.at(j)==pomocni.at(z)){
						for(int k=z;k&lt;pomocni.size()-1;k++)
						pomocni.at(k)=pomocni.at(k+1);
						z--;
						pomocni.resize(pomocni.size()-1);
					}
				}
				
				std::vector&lt;int&gt;v;
				for(int k=0;k&lt;pomocni.size();k++){
					if(k&lt;pomocni.size()-1 &amp;&amp; pomocni.at(k)/2==pomocni.at(k+1) &amp;&amp; pomocni.at(k)!=0 &amp;&amp; pomocni.at(k+1)!=0 &amp;&amp; pomocni.at(k)&gt;0 &amp;&amp; pomocni.at(k+1)&gt;0){
						v.push_back(pomocni.at(k));
						v.push_back(pomocni.at(k+1));
					}
					
				}
				for(int j=0;j&lt;v.size();j++){
					for(int z=j+1;z&lt;v.size();z++)
					if(v.at(j)==v.at(z)){
						for(int k=z;k&lt;v.size()-1;k++)
						v.at(k)=v.at(k+1);
						z--;
						v.resize(v.size()-1);
					}
				}
				
				if(v.size()&gt;=2) opadajuci.push_back(v);
				pomocni.resize(0);
			}
		}
	}
	if(s==1) return rastuci;
	return opadajuci;
}
int main ()
{
	std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
	int n;
	std::cin&gt;&gt;n;
	std::cout&lt;&lt;"Unesite elemente vektora: ";
	std::vector&lt;int&gt;vec(n);
	for(int i=0;i&lt;vec.size();i++) std::cin&gt;&gt;vec.at(i);
	std::cout&lt;&lt;"Unesite: 1 - za rastuce podnizove, 2 - za opadajuce podnizove: ";
	enum Smjer s;
	int m;
	std::cin&gt;&gt;m;
	s=Smjer(m);
	std::deque&lt;std::vector&lt;int&gt;&gt;maksimalni(MaksimalniPodnizoviStepenaDvojke(vec,s));
	if(s==1)
{	
	std::cout&lt;&lt;"Maksimalni rastuci podnizovi: "&lt;&lt;std::endl;
	int j;
	for(int i=0;i&lt;maksimalni.size();i++){
		for(j=0;j&lt;maksimalni[i].size()-1;j++)
		std::cout&lt;&lt;maksimalni.at(i).at(j)&lt;&lt;" ";
		std::cout&lt;&lt;maksimalni.at(i).at(j)&lt;&lt;" "&lt;&lt;std::endl;
	
}
}

if(s==2){
	std::cout&lt;&lt;"Maksimalni opadajuci podnizovi: "&lt;&lt;std::endl;
	int j;
	for(int i=0;i&lt;maksimalni.size();i++){
		for(j=0;j&lt;maksimalni[i].size()-1;j++)
		std::cout&lt;&lt;maksimalni.at(i).at(j)&lt;&lt;" ";
		std::cout&lt;&lt;maksimalni.at(i).at(j)&lt;&lt;" "&lt;&lt;std::endl;
</font>	}
}
return 0;
}
</pre>
</body>
</html>
