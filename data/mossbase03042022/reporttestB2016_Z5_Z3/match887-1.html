<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student2477.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student6706.cpp<p></p><pre>
<a name="2"></a><font color="#0000FF"><a href="match887-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

/B16/17 (Zadaća 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include&lt;iostream&gt;
#include &lt;stdexcept&gt;
#include&lt;cmath&gt;
using namespace std;
class Razlomak{
    long long int brojnik, nazivnik;
    //staticka fja za najveci zajednicki sadrzilac
    static long long int NZD(long long int x, long long int y);
</font>    public:
    Razlomak(long long int brojnik, long long int nazivnik);//konstruktor sa dva parametra
    Razlomak(){brojnik=0; nazivnik=1;} //konstruktor bez parametara
    Razlomak(long long int brojnik){ //konstruktor sa jednim parametrom
        Razlomak::brojnik=brojnik;
        nazivnik=1;
    }
    long long int DajBrojnik() const{ return brojnik;}
    long long int DajNazivnik() const {return nazivnik;}
    //operatori preklapanja fje obicne
    friend Razlomak operator + (const Razlomak &amp;r1, const Razlomak &amp;r2);//sabiranje
    friend Razlomak operator - (const Razlomak &amp;r1, const Razlomak &amp;r2); //oduzimanje
    friend Razlomak operator * (const Razlomak &amp;r1, const Razlomak &amp;r2); //mnozenje
    friend Razlomak operator / (const Razlomak &amp;r1, const Razlomak &amp;r2); //dijeljenje
    //operatori unarni fje obicne 
    friend Razlomak operator+(const Razlomak &amp;r){
        return {r.brojnik, r.nazivnik}; //vraća svoj operand neizmijenjen
    }
    friend Razlomak operator-(const Razlomak &amp;r){
        return{(-1)*r.brojnik, r.nazivnik}; // vraća razlomak na koji je primijenjen sa izvrnutim znakom 
    }
    //operatori binarni fje clanice
    Razlomak &amp;operator +=(const Razlomak &amp;r1); //sabiranje +=
    Razlomak &amp;operator -=(const Razlomak &amp;r1); //oduzimanje -=
    Razlomak &amp;operator *=(const Razlomak &amp;r1);//mnozenje *=
    Razlomak &amp;operator /=(const Razlomak &amp;r1); //dijeljenje /=
    //unarni operatori fje clanice
    Razlomak &amp;operator ++ ();//++r
    Razlomak operator ++(int); // r++
    Razlomak &amp;operator --();// --r
    Razlomak operator --(int); // r--
    //operatori poredjenja fje obicne
<a name="1"></a><font color="#00FF00"><a href="match887-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    friend bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2);// operator ==
    friend bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2); // operator !=
    friend bool operator &lt;(const Razlomak &amp;r1,const Razlomak &amp;r2);
    friend bool operator &gt;(const Razlomak &amp;r1,const Razlomak &amp;r2);
</font><a name="0"></a><font color="#FF0000"><a href="match887-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    friend bool operator &lt;=(const Razlomak &amp;r1,const Razlomak &amp;r2);
    friend bool operator &gt;=(const Razlomak &amp;r1,const Razlomak &amp;r2);
    friend ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;r); //ispis
    friend istream &amp;operator &gt;&gt;(istream &amp;tok, Razlomak &amp;r);//upis
      operator long double() const {
</font>      return (long double) brojnik/nazivnik;
}
};
Razlomak::Razlomak(long long brojnik, long long int nazivnik){ //konstruktor sa dva parametra
    if(nazivnik==0) throw logic_error("Nekorektan razlomak");
    long long int p=NZD(brojnik, nazivnik);
    if(nazivnik&lt;0 &amp;&amp; brojnik&gt;0) {
        Razlomak::brojnik=(brojnik/p)*(-1);
        Razlomak::nazivnik=(nazivnik/p)*(-1);
    }
    else if(nazivnik&lt;0 &amp;&amp; brojnik&lt;0){
        Razlomak::brojnik=(brojnik/p)*(-1);
        Razlomak::nazivnik=(nazivnik/p)*(-1);
    }
    else {
    Razlomak::brojnik=brojnik/p;
    Razlomak::nazivnik=nazivnik/p;
    }
}
    Razlomak operator + (const Razlomak &amp;r1, const Razlomak &amp;r2){ //sabiranje
    long long int m=-9223372036854775807; //radi prekoracenja
    long long int M=9223372036854775807;//radi prekoracenja
    long long int y=r2.brojnik/r2.nazivnik,x=r1.brojnik/r1.nazivnik;//radi prekoracenja
    if(y&gt;0 &amp;&amp; x&gt;M-y) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(y&lt;0 &amp;&amp; x&lt;m-y) throw overflow_error("Nemoguce dobiti tacan rezultat");
    long long int r=Razlomak::NZD(r1.nazivnik,r2.nazivnik);  
    long long int brojnik=r1.brojnik*(r2.nazivnik/r) + r2.brojnik*(r1.nazivnik/r);
    long long int nazivnik=r1.nazivnik*(r2.nazivnik/r);
    return Razlomak(brojnik, nazivnik);
    }
    Razlomak operator - (const Razlomak &amp;r1, const Razlomak &amp;r2){ //oduzimanje
    long long int m=-9223372036854775807; //radi prekoracenja
    long long int M=9223372036854775807;//radi prekoracenja
    long long int y=r2.brojnik/r2.nazivnik,x=r1.brojnik/r1.nazivnik;//radi prekoracenja
    if(y&lt;0 &amp;&amp; x&gt;M-y) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(y&gt;0 &amp;&amp; x&lt;m-y) throw overflow_error("Nemoguce dobiti tacan rezultat");
    long long int r=Razlomak::NZD(r1.nazivnik,r2.nazivnik);  
    long long int brojnik=r1.brojnik*(r2.nazivnik/r) - r2.brojnik*(r1.nazivnik/r);
    long long int nazivnik=r1.nazivnik*(r2.nazivnik/r);
    return Razlomak(brojnik,nazivnik);
    }
    Razlomak operator * (const Razlomak &amp;r1, const Razlomak &amp;r2){ //mnozenje
    long long int m=-9223372036854775807; //radi prekoracenja
    long long int M=9223372036854775807;//radi prekoracenja
    long long int y=r2.brojnik/r2.nazivnik,x=r1.brojnik/r1.nazivnik;//radi prekoracenja
    if(y&gt;0 &amp;&amp; (x&lt;m/y || x&gt;M/y)) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(y&lt;0 &amp;&amp; (x==m || (-1)*x&gt;M/((-1)*y) || (-1)*x&gt;m/((-1)*y))) throw overflow_error("Nemoguce dobiti tacan rezultat");
        long long int s=Razlomak::NZD(r1.brojnik,r2.nazivnik), t=Razlomak::NZD(r2.brojnik, r1.nazivnik);
        long long int brojnik=(r1.brojnik/s)*(r2.brojnik/t);
        long long int nazivnik=(r1.nazivnik/t)*(r2.nazivnik/s);
        return Razlomak(brojnik, nazivnik);
    }
    Razlomak operator / (const Razlomak &amp;r1, const Razlomak &amp;r2){ //dijeljenje
    long long int r=Razlomak::NZD(r1.nazivnik,r2.nazivnik),u=Razlomak::NZD(r1.brojnik, r2.brojnik);
    long long int brojnik=(r1.brojnik/u)*(r2.nazivnik/r);
    long long int nazivnik=(r1.nazivnik/r)*(r2.brojnik/u);
    return Razlomak(brojnik, nazivnik);
    }
    Razlomak &amp;Razlomak::operator +=(const Razlomak &amp;r1){ //sabiranje +=
    long long int m=-9223372036854775807; //radi prekoracenja
    long long int M=9223372036854775807;//radi prekoracenja
    long long int y=r1.brojnik/r1.nazivnik,x=brojnik/nazivnik;//radi prekoracenja
    if(y&gt;0 &amp;&amp; x&gt;M-y) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(y&lt;0 &amp;&amp; x&lt;m-y) throw overflow_error("Nemoguce dobiti tacan rezultat");
    long long int r=NZD(nazivnik,r1.nazivnik);  
    brojnik=brojnik*(r1.nazivnik/r) + r1.brojnik*(nazivnik/r);
    nazivnik=nazivnik*(r1.nazivnik/r);
    Razlomak(brojnik, nazivnik);
    return *this;
    }
    Razlomak &amp;Razlomak::operator -=(const Razlomak &amp;r1){ //oduzimanje -=
    long long int m=-9223372036854775807; //radi prekoracenja
    long long int M=9223372036854775807;//radi prekoracenja
    long long int y=r1.brojnik/r1.nazivnik,x=brojnik/nazivnik;//radi prekoracenja
    if(y&lt;0 &amp;&amp; x&gt;M-y) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(y&gt;0 &amp;&amp; x&lt;m-y) throw overflow_error("Nemoguce dobiti tacan rezultat");
    long long int r=NZD(nazivnik,r1.nazivnik);  
    brojnik=brojnik*(r1.nazivnik/r) - r1.brojnik*(nazivnik/r);
    nazivnik=nazivnik*(r1.nazivnik/r);
    Razlomak(brojnik,nazivnik); 
    return *this;
    }
    Razlomak &amp;Razlomak::operator *=(const Razlomak &amp;r1){//mnozenje *=
    long long int m=-9223372036854775807; //radi prekoracenja
    long long int M=9223372036854775807;//radi prekoracenja
    long long int y=r1.brojnik/r1.nazivnik,x=brojnik/nazivnik;//radi prekoracenja
    if(y&gt;0 &amp;&amp; (x&lt;m/y || x&gt;M/y)) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(y&lt;0 &amp;&amp; (x==m || (-1)*x&gt;M/((-1)*y) || (-1)*x&gt;m/((-1)*y))) throw overflow_error("Nemoguce dobiti tacan rezultat");
        long long int s=NZD(brojnik,r1.nazivnik), t=NZD(r1.brojnik,nazivnik);
        brojnik=(brojnik/s)*(r1.brojnik/t);
        nazivnik=(nazivnik/t)*(r1.nazivnik/s);
        Razlomak(brojnik, nazivnik); 
        return *this;
    }
    Razlomak &amp;Razlomak::operator /=(const Razlomak &amp;r1){ //dijeljenje /=
    long long int r=NZD(nazivnik,r1.nazivnik),u=NZD(brojnik, r1.brojnik);
    brojnik=(brojnik/u)*(r1.nazivnik/r);
    nazivnik=(nazivnik/r)*(r1.brojnik/u);
    Razlomak(brojnik, nazivnik);
    return *this;
    }
    Razlomak &amp;Razlomak::operator ++ (){ //++r
        brojnik=brojnik+nazivnik;
        return *this;
    }
    Razlomak Razlomak::operator ++(int){ // r++
        Razlomak pomocni(*this);
        brojnik=brojnik+nazivnik;
        return pomocni;
    }
    Razlomak &amp;Razlomak::operator --(){ // --r
        brojnik=brojnik-nazivnik;
        return *this;
    }
    Razlomak Razlomak::operator --(int){ // r--
        Razlomak pomocni(*this);
        brojnik=brojnik-nazivnik;
        return pomocni;
    }
bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2){ // operator !=
long double x=r1.brojnik/r1.nazivnik, y=r2.brojnik/r2.nazivnik;
return x!=y;
}
bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2){ // operator ==
        long double x=r1.brojnik/r1.nazivnik, y=r2.brojnik/r2.nazivnik;
        return x==y;
} 
bool operator &lt;(const Razlomak &amp;r1,const Razlomak &amp;r2){
    long long int raz1, raz2;
    raz1=r1.brojnik/r1.nazivnik;
<a name="3"></a><font color="#00FFFF"><a href="match887-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    raz2=r2.brojnik/r2.nazivnik;
    if(raz1&lt;raz2) return true;
    return false;
}

bool operator &gt;(const Razlomak &amp;r1,const Razlomak &amp;r2){
     long long int raz1, raz2;
</font>    raz1=r1.brojnik/r1.nazivnik;
<a name="4"></a><font color="#FF00FF"><a href="match887-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    raz2=r2.brojnik/r2.nazivnik;
    if(raz1&gt;raz2) return true;
    return false;
}

bool operator &lt;=(const Razlomak &amp;r1,const Razlomak &amp;r2){
</font>     long long int raz1, raz2;
    raz1=r1.brojnik/r1.nazivnik;
    raz2=r2.brojnik/r2.nazivnik;
    if(raz1&lt;=raz2) return true;
    return false;
}

bool operator &gt;=(const Razlomak &amp;r1,const Razlomak &amp;r2){
    long long int raz1, raz2;
    raz1=r1.brojnik/r1.nazivnik;
    raz2=r2.brojnik/r2.nazivnik;
    if(raz1&gt;=raz2) return true;
    return false;
}
long long int Razlomak::NZD(long long int x, long long int y){
    if(x%y==0) return y;
    else return NZD(y,x%y);
}
ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;r){ //ispis
        if(r.nazivnik==1) tok&lt;&lt;r.brojnik;
<a name="5"></a><font color="#FF0000"><a href="match887-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        else tok&lt;&lt;r.brojnik&lt;&lt;"/"&lt;&lt;r.nazivnik;
        return tok;
}
istream &amp;operator &gt;&gt;(istream &amp;tok, Razlomak &amp;r){ 
</font>        char znak;
        tok&gt;&gt;ws;
            if(tok.peek()==' ') {tok&gt;&gt;znak; tok.setstate(ios::failbit); }
            if(tok.peek()&lt;'1' || tok.peek()&gt;'9') tok.setstate(ios::failbit);
            tok&gt;&gt;r.brojnik;
            if(tok.peek()==' ' || tok.peek()=='\0' || tok.peek()=='\n' || tok.peek()==-1){r.nazivnik=1;
            return tok; }
            if(tok.peek()!='/' &amp;&amp; tok.peek()!='\0') tok.setstate(ios::failbit);
            if(tok.peek()=='\0'){r.nazivnik=1; tok.setstate(ios::failbit); }
            tok&gt;&gt;znak;
            if(tok.peek()&lt;'1' || tok.peek()&gt;'9') tok.setstate(ios::failbit);
            tok&gt;&gt;r.nazivnik;
            if(tok.peek()==' ' || tok.peek()=='\0' || tok.peek()=='\n' || tok.peek()==-1){ 
                long long int n=Razlomak::NZD(r.brojnik,r.nazivnik);
            r.brojnik=r.brojnik/n;
            r.nazivnik=r.nazivnik/n;
                return tok; }
            else tok.setstate(ios::failbit);
            long long int n=Razlomak::NZD(r.brojnik,r.nazivnik);
            r.brojnik=r.brojnik/n;
            r.nazivnik=r.nazivnik/n;
            return tok;
}

int main ()
{
Razlomak r (17, 18), t (21), v(17/18);
            std::cout &lt;&lt; "r = " &lt;&lt; r &lt;&lt; ", t = " &lt;&lt; t &lt;&lt; ", v = " &lt;&lt; v&lt;&lt;endl;
            bool n=r&gt;=v;
            cout&lt;&lt;n&lt;&lt;endl;
	return 0;
}</pre>
</body>
</html>
