<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student5172.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student2232.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;limits&gt;
#include &lt;initializer_list&gt;

class Razlomak{
  long long int brojnik,nazivnik;
  long long int NZD(long long int a, long long int b){
      a=std::abs(a); b=std::abs(b);
      long long int x,y;
      if(a&gt;b) x=a,y=b;
      else if(b&gt;a) x=b,y=a;
      else return a;
      long long int pomocni;
      while(1){
            pomocni=x%y;
          x=y; y=pomocni;
          if(y==0) break;
      }
      return x;
  }
  bool prekoracenje_mnozenja(long long int a, long long int b){
      long long int M(std::numeric_limits&lt;long long int&gt;::max()),m(std::numeric_limits&lt;long long int&gt;::min());
      if((b&gt;0 &amp;&amp; (a&gt;M/b || a&lt;m/b)) || (b&lt;0 &amp;&amp; (a==m || -a&gt;M/(-b) || -a&lt;m/(-b)))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
      return true;
  }
  bool prekoracenje_sabiranja(long long int a, long long int b){
      long long int M(std::numeric_limits&lt;long long int&gt;::max()),m(std::numeric_limits&lt;long long int&gt;::min());
      if((b&gt;0 &amp;&amp; a&gt;M-b) || (b&lt;0 &amp;&amp; a&lt;m-b)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
      return true;
  }
  bool prekoracenje_oduzimanja(long long int a, long long int b){
      long long int M(std::numeric_limits&lt;long long int&gt;::max()),m(std::numeric_limits&lt;long long int&gt;::min());
      if((b&gt;0 &amp;&amp; a&gt;M-b) || (b&lt;0 &amp;&amp; a&lt;m-b)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
      return true;
  }
  bool jednaki(long double a, long double b, double eps=1e-20){
      return std::fabs(a-b) &lt;=eps*(std::fabs(a)+std::fabs(b));
  }
  public:
  Razlomak(long long int a=0,long long int b=1){
      if(b==0) throw std::logic_error("Nekorektan razlomak");
      if((a&gt;0 &amp;&amp; b&lt;0) || (a&lt;0 &amp;&amp; b&lt;0)) {a*=(-1); b*=(-1); }
      brojnik=a; nazivnik=b;
      if(a!=0){
          long long int nzd=NZD(a,b);
          brojnik/=nzd; nazivnik/=nzd;
      }
  }
  Razlomak(std::initializer_list&lt;long long int&gt; lista){
      if(lista.size()==0) brojnik=0, nazivnik=1;
      else if(lista.size()==1){
          nazivnik=1;
          brojnik=*(lista.begin());
      }else if(lista.size()==2){
          auto it=lista.begin();
          long long int a=*it; it++;
          long long int b=*it;
          if(b==0) throw std::logic_error("Nekorektan razlomak");
          if((a&gt;0 &amp;&amp; b&lt;0) || (a&lt;0 &amp;&amp; b&lt;0)) { a*=(-1); b*=(-1); }
          brojnik=a; nazivnik=b;
          if(brojnik!=0){
              long long int nzd=NZD(a,b);
              brojnik/=nzd; nazivnik/=nzd;
          }
      }
  }
  long long int DajBrojnik() const { return brojnik; }
  long long int DajNazivnik() const { return nazivnik; }
  Razlomak &amp;operator +=(const Razlomak &amp;a);
  Razlomak &amp;operator -=(const Razlomak &amp;a);
  Razlomak &amp;operator *=(const Razlomak &amp;a);
  Razlomak &amp;operator /=(const Razlomak &amp;a);
  Razlomak operator -();
  Razlomak operator +();
  Razlomak &amp;operator ++();
  Razlomak &amp;operator --();
  bool operator &lt; (const Razlomak &amp;a);
  bool operator &lt;= (const Razlomak &amp;a);
  bool operator &gt; (const Razlomak &amp;a);
  bool operator &gt;= (const Razlomak &amp;a);
  bool operator == (const Razlomak &amp;a);
  bool operator != (const Razlomak &amp;a);
  friend Razlomak operator +(const Razlomak &amp;a, const Razlomak &amp;b);
  friend Razlomak operator -(const Razlomak &amp;a, const Razlomak &amp;b);
  friend Razlomak operator *(const Razlomak &amp;a, const Razlomak &amp;b);
  friend Razlomak operator /(const Razlomak &amp;a, const Razlomak &amp;b);
  friend Razlomak operator ++(Razlomak &amp;a, int);
  friend Razlomak operator --(Razlomak &amp;b, int);
  friend std::ostream &amp;operator &lt;&lt; (std::ostream &amp;tok, const Razlomak &amp;a);
  friend std::istream &amp;operator &gt;&gt; (std::istream &amp;tok, Razlomak &amp;a); 
  explicit operator long double () const;
  Razlomak &amp;operator =(const Razlomak &amp;a);
};
Razlomak &amp;Razlomak::operator =(const Razlomak &amp;a){
    if(this!=&amp;a){
        brojnik=a.brojnik; nazivnik=a.nazivnik;
    }
    return *this;
}
Razlomak::operator long double ()const{
    return ((long double)(brojnik))/nazivnik;
}
std::istream &amp;operator &gt;&gt; (std::istream &amp;tok, Razlomak &amp;a){
    char znak;
    tok &gt;&gt; std::ws;
    tok &gt;&gt; a.brojnik;
    if(tok.peek()!='/') a.nazivnik=1;
    else{
        long long int pomocni;
        tok &gt;&gt; znak  &gt;&gt; pomocni;
        Razlomak pom(a.brojnik,pomocni);
        a.brojnik=pom.brojnik; a.nazivnik=pom.nazivnik;
    }
    if(tok.peek()!=' ' &amp;&amp; tok.peek()!='\n' &amp;&amp; tok.peek()!='\t' &amp;&amp; tok.peek()!='\f' &amp;&amp; tok.peek()!='\v') tok.setstate(std::ios::failbit);
    return tok;
}
std::ostream &amp;operator  &lt;&lt; (std::ostream &amp;tok, const Razlomak &amp;a) {
    tok &lt;&lt; a.brojnik;
    if(a.brojnik!=0 &amp;&amp; a.nazivnik!=1){
        tok &lt;&lt; "/" &lt;&lt; a.nazivnik;
    }
    return tok;
}
bool Razlomak::operator ==(const Razlomak &amp;a){
    long double x=((long double)(brojnik))/nazivnik, y=((long double)(a.brojnik))/a.nazivnik;
    return jednaki(x,y);
}
inline bool Razlomak::operator !=(const Razlomak &amp;a){
    return !(*this==a);
}
bool Razlomak::operator &lt; (const Razlomak &amp;a){
    long double x=((long double)(brojnik))/nazivnik, y=((long double)(a.brojnik))/a.nazivnik;
    if(!jednaki(x,y) &amp;&amp; x&lt;y) return true;
    return false;
}
bool Razlomak::operator &lt;= (const Razlomak &amp;a){
    long double x=((long double)(brojnik))/nazivnik, y=((long double)(a.brojnik))/a.nazivnik;
    if(jednaki(x,y) ||  x&lt;y) return true;
    return false;
}
bool Razlomak::operator &gt; (const Razlomak &amp;a){
     long double x=((long double)(brojnik))/nazivnik, y=((long double)(a.brojnik))/a.nazivnik;
     if(!jednaki(x,y) &amp;&amp; x&gt;y) return true;
     return false;
}
bool Razlomak::operator &gt;=(const Razlomak &amp;a){
    long double x=((long double)(brojnik))/nazivnik, y=((long double)(a.brojnik))/a.nazivnik;
     if(jednaki(x,y) || x&gt;y) return true;
     return false;
}
Razlomak &amp;Razlomak::operator --(){
    if(prekoracenje_oduzimanja(brojnik,nazivnik)){
        Razlomak pomocni(brojnik-nazivnik,nazivnik);
        brojnik=pomocni.brojnik; nazivnik=pomocni.nazivnik;
    }
    return *this;
}
Razlomak &amp;Razlomak::operator ++(){
    if(prekoracenje_sabiranja(brojnik,nazivnik)){
        Razlomak pomocni(brojnik+nazivnik,nazivnik);
        brojnik=pomocni.brojnik; nazivnik=pomocni.nazivnik;
    }
    return *this;
}
Razlomak operator ++(Razlomak &amp;a, int){
    Razlomak pom(a.brojnik,a.nazivnik);
    ++a;
    return pom;
}
inline Razlomak operator --(Razlomak &amp;b, int){
    Razlomak pom(b.brojnik,b.nazivnik);
    --b;
    return pom;
}
Razlomak Razlomak::operator -(){
    Razlomak pom(brojnik,nazivnik);
    if(prekoracenje_mnozenja(pom.brojnik,-1)){
        pom.brojnik*=-1;
    }
    brojnik=pom.brojnik; nazivnik=pom.nazivnik;
    return *this;
}
Razlomak Razlomak::operator +(){
    return *this;
}
Razlomak &amp;Razlomak::operator +=(const Razlomak &amp;a) {
    long long int r=NZD(nazivnik,a.nazivnik);
    if(prekoracenje_mnozenja(nazivnik,a.nazivnik/r) &amp;&amp; prekoracenje_mnozenja(a.brojnik,nazivnik/r) &amp;&amp; prekoracenje_mnozenja(brojnik,a.nazivnik/r) &amp;&amp; prekoracenje_sabiranja(brojnik*(a.nazivnik/r),a.brojnik*(nazivnik/r))){
<a name="1"></a><font color="#00FF00"><a href="match999-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        long long int pomocni_brojnik=brojnik*(a.nazivnik/r) + a.brojnik*(nazivnik/r);
        long long int pomocni_nazivnik=nazivnik*(a.nazivnik/r);
        Razlomak pomocni(pomocni_brojnik,pomocni_nazivnik);
        brojnik=pomocni.brojnik; nazivnik=pomocni.nazivnik;
    }
    return *this;
}
Razlomak &amp;Razlomak::operator -=(const Razlomak &amp;a){
</font>    long long int r=NZD(nazivnik,a.nazivnik);
    if(prekoracenje_mnozenja(nazivnik,a.nazivnik/r) &amp;&amp; prekoracenje_mnozenja(a.brojnik,nazivnik/r) &amp;&amp; prekoracenje_mnozenja(brojnik,a.nazivnik/r) &amp;&amp; prekoracenje_oduzimanja(brojnik*(a.nazivnik/r),a.brojnik*(nazivnik/r))){
<a name="0"></a><font color="#FF0000"><a href="match999-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

        long long int pomocni_brojnik=brojnik*(a.nazivnik/r) - a.brojnik*(nazivnik/r);
        long long int pomocni_nazivnik=nazivnik*(a.nazivnik/r);
        Razlomak pomocni(pomocni_brojnik,pomocni_nazivnik);
        brojnik=pomocni.brojnik; nazivnik=pomocni.nazivnik;
    }
    return *this;
}
Razlomak &amp;Razlomak::operator *=(const Razlomak &amp;a){
</font>    long long int s=NZD(brojnik,a.nazivnik), t=NZD(a.brojnik,nazivnik);
    if(prekoracenje_mnozenja(brojnik/s,a.brojnik/t) &amp;&amp; prekoracenje_mnozenja(nazivnik/t,a.nazivnik/s)){
<a name="2"></a><font color="#0000FF"><a href="match999-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

        long long int pomocni_brojnik=(brojnik/s)*(a.brojnik/t);
        long long int pomocni_nazivnik=(nazivnik/t)*(a.nazivnik/s);
        Razlomak pomocni(pomocni_brojnik,pomocni_nazivnik);
        brojnik=pomocni.brojnik; nazivnik=pomocni.nazivnik;
    }
    return *this;
</font>}
Razlomak &amp;Razlomak::operator /=(const Razlomak &amp;a){
    long long int r=NZD(nazivnik,a.nazivnik), u=NZD(brojnik,a.brojnik);
    if(prekoracenje_mnozenja(brojnik/u,a.nazivnik/r) &amp;&amp; prekoracenje_mnozenja(nazivnik/r,a.brojnik/u)){
<a name="3"></a><font color="#00FFFF"><a href="match999-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

        long long int pomocni_brojnik=(brojnik/u)*(a.nazivnik/r);
        long long int pomocni_nazivnik=(nazivnik/r)*(a.brojnik/u);
        Razlomak pomocni(pomocni_brojnik,pomocni_nazivnik);
        brojnik=pomocni.brojnik; nazivnik=pomocni.nazivnik;
    }
    return *this;
</font>}
inline Razlomak operator +(const Razlomak &amp;a, const Razlomak &amp;b){
    Razlomak pom(a.brojnik,a.nazivnik);
    pom+=b;
    return pom;
}
inline Razlomak operator -(const Razlomak &amp;a, const Razlomak &amp;b){
    Razlomak pom(a.brojnik,a.nazivnik);
    pom-=b;
    return pom;
}
inline Razlomak operator *(const Razlomak &amp;a, const Razlomak &amp;b){
    Razlomak pom(a.brojnik,a.nazivnik);
    pom*=b;
    return pom;
}
inline Razlomak operator /(const Razlomak &amp;a, const Razlomak &amp;b){
    Razlomak pom(a.brojnik,a.nazivnik);
    pom/=b;
    return pom;
}
int main ()
{
   try{
       Razlomak b=3;
       Razlomak a{1,2};
       auto c=(a+2);
       std::cout &lt;&lt; (a*(a+b)+(a-b)/a);
       std::cout &lt;&lt; std::endl &lt;&lt; 2+a &lt;&lt; std::endl &lt;&lt; c &lt;&lt; std::endl &lt;&lt; static_cast&lt;long double&gt;(a*3+2/b-5);
   }catch (std::overflow_error e){
       std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
   }catch(std::logic_error e){
       std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
   }
	return 0;
}</pre>
</body>
</html>
