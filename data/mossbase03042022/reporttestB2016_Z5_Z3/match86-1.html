<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student1044.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student2586.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match86-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise

#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;stdexcept&gt;

class Razlomak
{
    typedef long long int lli;
    lli brojnik;
    lli nazivnik;
    
    static constexpr auto min = std::numeric_limits&lt;lli&gt;::min();
    static constexpr auto max = std::numeric_limits&lt;lli&gt;::max();
    
    static void baci()
    {
        throw std::overflow_error("Nemoguce dobiti tacan rezultat");
    }
    
    static lli NZD (lli p, lli q)
    {
        return q == 0 ? p : NZD(q, p % q);
    }
    static lli plus(lli x, lli y)
    {
        if( x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &gt; max - y)
            baci();
        if( x &gt; 0 &amp;&amp; y &lt; 0 &amp;&amp; x &lt; min  - y)
            baci();
        if(x &lt; 0 &amp;&amp; y &lt; 0)
            return -plus(-x, -y);
        if(x &lt; 0 &amp;&amp;  y &gt; 0)
            return plus(y, x);
        return x + y;
    }
    
    static lli minus(lli x, lli y)
    {
        return plus(x, -y);
    }
    
    static lli mnozenje(lli x, lli y)
    {
        if( x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp;  (x &lt; min / y || x &gt; max / y) )
            baci();
        if( x &gt; 0 &amp;&amp;  y &lt; 0 &amp;&amp; (x == min || -x &gt; max || -x &lt; min /(-y) ))
            baci();
        if(x &lt; 0 &amp;&amp; y &lt; 0)
            return mnozenje(-x, -y);
        if(x &lt; 0 &amp;&amp;  y &gt; 0)
            return mnozenje(y, x);
        return x * y;
    }
    
    static long double dijeli(const Razlomak&amp; r)
    {
        return static_cast&lt;long double&gt;(r.DajBrojnik()) / static_cast&lt;long double&gt;(r.DajNazivnik());
    }
    
public:
    
    Razlomak() : brojnik(0), nazivnik(1) {}
    Razlomak(lli x, lli y);
    Razlomak(lli x) : brojnik(x), nazivnik(1) {}
    lli DajBrojnik() const
    {
        return brojnik;
    }
    
    lli DajNazivnik()const
    {
        return nazivnik;
    }
    
    Razlomak&amp; operator+=(const Razlomak&amp; r);
    Razlomak&amp; operator-=(const Razlomak&amp; r);
    Razlomak&amp; operator*=(const Razlomak&amp; r);
    Razlomak&amp; operator/=(const Razlomak&amp; r);
    
    Razlomak&amp; operator ++()
    {
        *this += Razlomak(1);
        return *this;
    }
    
    Razlomak&amp; operator --()
    {
        *this -= Razlomak(1);
        return *this;
    }
    
    Razlomak operator ++(int)
    {
        operator ++();
        return *this;
    }
    
    Razlomak operator --(int)
    {
        operator--();
        return *this;
    }
    
    friend Razlomak operator- (const Razlomak&amp; r1, const Razlomak&amp; r2);
    friend Razlomak operator+ (const Razlomak&amp; r1, const Razlomak&amp; r2);
    friend Razlomak operator* (const Razlomak&amp; r1, const Razlomak&amp; r2);
    friend Razlomak operator/ (const Razlomak&amp; r1, const Razlomak&amp; r2);
    friend bool operator &lt; (const Razlomak&amp; r1, const Razlomak&amp; r2);
    friend bool operator &gt; (const Razlomak&amp; r1, const Razlomak&amp; r2);
    
    Razlomak operator+() const
    {
        return *this;
    }
    
    Razlomak operator-() const
    {
        if(DajBrojnik() == min)
            baci();
        return Razlomak(-DajBrojnik(), DajNazivnik());
    }   
    operator long double() const
    {
        return dijeli(*this);
    }
};

std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const Razlomak&amp; r)
{
    if(r.DajNazivnik() == 1)
        return os &lt;&lt; r.DajBrojnik();
    return os &lt;&lt; r.DajBrojnik() &lt;&lt; "/" &lt;&lt; r.DajNazivnik();
}

bool bjelina(char c)
{
    return c == ' ' || c == '\n' || c == '\t' || c == '\f' || c == '\v' || c == '\r';
}

std::istream&amp; operator&gt;&gt; (std::istream&amp; os, Razlomak&amp; r)
{
    long long int b, a;
    os &gt;&gt; b; // unesi broj preksace sve bjeline
    
    // ako nije broj ne valja unos od sebe prekid
    if(!os.good())
    {
        if(os.peek() == EOF)
            r = Razlomak(b);
        return os;
    }
        
        
    // ako ceka nazivnik
    if(os.peek() == '/')
    {
        char kosa;
        os &gt;&gt; kosa; // uzmi kosu
        os &gt;&gt; a; // unesi a
    }
    // ako nije kosa i bjelina je to je jedan broj unesi i prekini
    else if(bjelina(os.peek()) || os.peek() == EOF)
    {
        r = Razlomak(b);
        return os;
    }
    
    // unijeli smo drugi broj
    // vidi jel bjelina ako nije znaci ne valja unos
    if(!bjelina(os.peek()) &amp;&amp; os.peek() != EOF)
    {
        os.setstate(std::ios_base::failbit) ;
        return os;
    }
    // dobar unos dodijeli brojeve
    r = Razlomak(b, a);
    return os;
}

bool operator == (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    return (r1.DajBrojnik() == r2.DajBrojnik() &amp;&amp; r1.DajNazivnik() == r2.DajNazivnik());
}

bool operator != (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    return !(r1 == r2);
}

bool operator &lt; (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    return Razlomak::dijeli(r1) &lt; Razlomak::dijeli(r2);
}

bool operator &lt;= (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    return r1 &lt; r2 || r1 == r2;
}


bool operator &gt;= (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    return r1 &gt; r2 || r1 == r2;
}

bool operator &gt; (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    return Razlomak::dijeli(r1) &gt; Razlomak::dijeli(r2);
}



Razlomak&amp; Razlomak::operator*=(const Razlomak&amp; r)
{
    auto s = NZD(DajBrojnik(), r.DajNazivnik());
    auto t = NZD(r.DajBrojnik(), DajNazivnik());
    
    auto r1 = Razlomak(Razlomak::mnozenje(DajBrojnik() / s, r.DajBrojnik()/t), 
                      Razlomak::mnozenje(DajNazivnik() / t, r.DajNazivnik()/s) );
    return *this = r1;
}   

Razlomak&amp; Razlomak::operator/=(const Razlomak&amp; r2)
{
    auto r = NZD(DajNazivnik(), r2.DajNazivnik());
    auto u = NZD(DajBrojnik(), r2.DajBrojnik());
    
    auto r1 = Razlomak(Razlomak::mnozenje(DajBrojnik() / u, r2.DajNazivnik()/r), 
                      Razlomak::mnozenje(DajNazivnik() / r, r2.DajBrojnik()/u) );
    return *this = r1;
    
}

Razlomak operator/ (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    auto r = r1;
    return r/=r2;
}


Razlomak operator* (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    auto r = r1;
    return r*=r2;
}

Razlomak&amp; Razlomak::operator-=(const Razlomak&amp; r)
{
    auto nzd = NZD(DajNazivnik(), r.DajNazivnik());
    auto br_1 = Razlomak::mnozenje( DajBrojnik(), r.DajNazivnik()/nzd);
    auto br_2 = Razlomak::mnozenje( r.DajBrojnik(), DajNazivnik()/nzd);
    auto nz = Razlomak::mnozenje(DajNazivnik(), r.DajNazivnik() / nzd);
    auto nr = Razlomak(Razlomak::minus(br_1, br_2), nz);
    *this = nr;
    return *this;
}


Razlomak&amp; Razlomak::operator+=(const Razlomak&amp; r)
{
    auto nzd = NZD(DajNazivnik(), r.DajNazivnik());
    auto br_1 = Razlomak::mnozenje( DajBrojnik(), r.DajNazivnik()/nzd);
    auto br_2 = Razlomak::mnozenje( r.DajBrojnik(), DajNazivnik()/nzd);
    auto nz = Razlomak::mnozenje(DajNazivnik(), r.DajNazivnik() / nzd);
    auto nr = Razlomak(Razlomak::plus(br_1, br_2), nz);
    *this = nr;
    return *this;
}

Razlomak operator+ (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    auto r = r1;
    return r+=r2;
}

Razlomak operator- (const Razlomak&amp; r1, const Razlomak&amp; r2)
{
    auto r = r1;
    return r-=r2;
}

Razlomak::Razlomak(lli x, lli y)    
{
    if( y == 0)
        throw std::logic_error("Nekorektan razlomak");
    bool n = false, b = false;
    brojnik = x;
    nazivnik = y;
    if(brojnik == 0)
    {
        nazivnik = 1;
        return;
    }
    if(brojnik &lt; 0)
    {
        brojnik *= -1;
        b = true;
    }
    if(nazivnik &lt; 0)
    {
        nazivnik *= -1;
        n = true;
    }
    auto nzd = NZD(brojnik, nazivnik);
    
    if (brojnik &gt; nazivnik)
    {
        while ( nzd != 1 &amp;&amp; nazivnik % nzd == 0) {
           nazivnik /= nzd;
           brojnik /= nzd;
        }    
    }
    else
    {
        while ( nzd != 1 &amp;&amp; brojnik % nzd == 0) {
            nazivnik /= nzd;
            brojnik /= nzd;
        }    
    }
    if(n != b)
        brojnik *= -1;
}


int main ()
{
    try {
        Razlomak r(1), r1(2,3), r2;
        std::cout &lt;&lt; r &lt;&lt; " " &lt;&lt; r1 &lt;&lt; " " &lt;&lt; r2 &lt;&lt; "\n";
        ++r;--r1;r2++;
        std::cout &lt;&lt; r &lt;&lt; " " &lt;&lt; r1 &lt;&lt; " " &lt;&lt; r2 &lt;&lt; "\n";
        r--;
        -r1;
        +r2;
        std::cout &lt;&lt; r &lt;&lt; " " &lt;&lt; r1 &lt;&lt; " " &lt;&lt; r2 &lt;&lt; "\n";
        r+=r;
        r1-=r2;
        r2 *= r1;
        std::cout &lt;&lt; r &lt;&lt; " " &lt;&lt; r1 &lt;&lt; " " &lt;&lt; r2 &lt;&lt; "\n";
        r /= r2;
        std::cout &lt;&lt; r2 &lt;&lt; "\n";
        std::cout &lt;&lt; r + r1 &lt;&lt; " " &lt;&lt; r2 - r1 &lt;&lt; " " &lt;&lt; r1/r2 &lt;&lt; " " &lt;&lt; r2 * r2 &lt;&lt; "\n";
        std::cout &lt;&lt; static_cast&lt;long double&gt; (r) &lt;&lt; "\n";
        std::cout &lt;&lt; (r1 == r2) &lt;&lt; " " &lt;&lt; (r1 != r1) &lt;&lt; " " &lt;&lt; (r1 &lt; r2) &lt;&lt; " " &lt;&lt; (r &gt; r2) &lt;&lt; "\n";
        std::cout &lt;&lt; (r1 &lt;= r2) &lt;&lt; " " &lt;&lt; (r1 &gt;= r) &lt;&lt; "\n";
    }
    catch (...) {
</font>        
    }
    
}</pre>
</body>
</html>
