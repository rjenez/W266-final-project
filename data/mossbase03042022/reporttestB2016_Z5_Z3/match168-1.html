<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student2230.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student3856.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;limits&gt;
#include &lt;math.h&gt;

#define eps 0.00000001
class Razlomak{
    long long int brojnik, nazivnik;
<a name="11"></a><font color="#00FF00"><a href="match168-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    const static long long int m = std::numeric_limits&lt;long long int&gt;::min(); 
    const static long long int M = std::numeric_limits&lt;long long int&gt;::max();
</font>    static long long int NZD(long long int p, long long int q){
        if(p &lt; q){
            auto temp = p;
            p = q;
            q = temp;
        }
        while(q != 0){
            long long int g(p), h(q); 
            p = h; 
            q = g%h;
        }
        return p;
        
    }
    static void PrekoracenjeSabiranja(long long int x, long long int y){
        
        
        if( y &gt; 0){
            if(x &gt; M - y) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        }
        else if( y &lt; 0){
<a name="0"></a><font color="#FF0000"><a href="match168-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

            if(x &lt; m - y) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        }
        
    }
    static void PrekoracenjeOduzimanja(long long int x, long long int y){
        PrekoracenjeSabiranja(x,(-1)*y);
    }
    static void PrekoracenjeMnozenja(long long int x, long long int y){
        
        if( y &gt; 0){
            if(x &lt; m/y || x &gt; M/y) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
            
        }
        else if( y &lt; 0){
</font>            if(x == m || (-1)*x &gt; M/((-1)*y) || (-1)*x &lt; m/((-1)*y)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
<a name="3"></a><font color="#00FFFF"><a href="match168-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

        }
        
    }
    
public:
    
    
    Razlomak(long long int brojnik =0, long long int nazivnik=1){
</font>        if(nazivnik &lt; 0 &amp;&amp; (brojnik &gt; 0 || brojnik &lt; 0)) {
            brojnik*=-1;
            nazivnik*=-1;
        }
        if(nazivnik == 0) throw std::logic_error("Nekorektan razlomak");
        auto k = NZD(brojnik, nazivnik);
        brojnik/=k;
        nazivnik/=k;
        this-&gt;brojnik = brojnik;
        this-&gt;nazivnik = nazivnik;
    }
    //dodati operator = i konstruktor koji prima razlomak
    Razlomak(const Razlomak &amp;r){
        this-&gt;brojnik = r.brojnik;
        this-&gt;nazivnik = r.nazivnik;
    }
    
    Razlomak &amp;operator =(const Razlomak &amp;r){
        this-&gt;brojnik = r.brojnik;
        this-&gt;nazivnik = r.nazivnik;
        return *this;
    }
    
    Razlomak &amp;operator =(Razlomak &amp;&amp;r){
        this-&gt;brojnik = r.brojnik;
        this-&gt;nazivnik = r.nazivnik;
        return *this;
    }
    long long int DajBrojnik(){
        return brojnik;
    }
    long long int DajNazivnik(){
        return nazivnik;
    }
    friend Razlomak operator +(const Razlomak &amp;r2, const Razlomak &amp;r1){
        auto r = NZD(r2.nazivnik, r1.nazivnik);
        
        PrekoracenjeMnozenja(r2.brojnik,r1.nazivnik/r);
        PrekoracenjeMnozenja(r2.nazivnik,r1.nazivnik/r);
        PrekoracenjeMnozenja(r1.brojnik, r2.nazivnik/r);
        
<a name="7"></a><font color="#0000FF"><a href="match168-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        PrekoracenjeSabiranja(r2.brojnik * (r1.nazivnik/r), r1.brojnik *(r2.nazivnik /r));
        
        long long int br = r2.brojnik * (r1.nazivnik/r) + r1.brojnik *(r2.nazivnik /r);
        long long int na = r2.nazivnik *(r1.nazivnik/r);
</font>        
        Razlomak ra(br,na);
        return ra;
        
    }
    friend Razlomak operator -(const Razlomak &amp;r2, const Razlomak &amp;r1){
        auto r = NZD(r2.nazivnik, r1.nazivnik);
        
        PrekoracenjeMnozenja(r2.brojnik,r1.nazivnik/r);
        PrekoracenjeMnozenja(r2.nazivnik,r1.nazivnik/r);
        PrekoracenjeMnozenja(r1.brojnik, r2.nazivnik/r);
        
<a name="6"></a><font color="#00FF00"><a href="match168-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        PrekoracenjeOduzimanja(r2.brojnik * (r1.nazivnik/r), r1.brojnik *(r2.nazivnik /r));
        
        long long int br = r2.brojnik * (r1.nazivnik/r) - r1.brojnik *(r2.nazivnik /r);
        long long int na = r2.nazivnik *(r1.nazivnik/r);
</font>        
        Razlomak ra(br,na);
        return ra;
    }
    friend Razlomak operator *(const Razlomak &amp;r2, const Razlomak &amp;r1){
        auto s = NZD(r2.brojnik, r1.nazivnik);
        auto t = NZD(r1.brojnik, r2.nazivnik);
        
        PrekoracenjeMnozenja(r2.brojnik/s,r1.brojnik/t);
<a name="1"></a><font color="#00FF00"><a href="match168-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        PrekoracenjeMnozenja(r2.nazivnik/t,r1.nazivnik/s);
        
        long long int br= (r2.brojnik/s)*(r1.brojnik/t);
        long long int na = (r2.nazivnik/t)*(r1.nazivnik/s);
        
        Razlomak ra(br,na);
        return ra;
</font>        
    }
    friend Razlomak operator /(const Razlomak &amp;r2,const Razlomak &amp;r1){
        auto u = NZD(r2.brojnik, r1.brojnik);
        auto r = NZD(r2.nazivnik, r1.nazivnik);
        
        PrekoracenjeMnozenja(r2.brojnik/u,r1.nazivnik/r);
<a name="2"></a><font color="#0000FF"><a href="match168-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

        PrekoracenjeMnozenja(r2.nazivnik/r,r1.brojnik/u);
        
        long long int br = (r2.brojnik/u)*(r1.nazivnik/r);
        long long int na = (r2.nazivnik/r)*(r1.brojnik/u);
        
        Razlomak ra(br,na);
        return ra;
</font>    }
    
    friend Razlomak &amp;operator +=(Razlomak &amp;r2, const Razlomak &amp;r1){
        auto r = NZD(r2.nazivnik, r1.nazivnik);
        
        PrekoracenjeMnozenja(r2.brojnik,r1.nazivnik/r);
        PrekoracenjeMnozenja(r2.nazivnik,r1.nazivnik/r);
        PrekoracenjeMnozenja(r1.brojnik, r2.nazivnik/r);
        
<a name="4"></a><font color="#FF00FF"><a href="match168-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

        PrekoracenjeSabiranja(r2.brojnik * (r1.nazivnik/r), r1.brojnik *(r2.nazivnik /r));
        
        r2.brojnik = r2.brojnik * (r1.nazivnik/r) + r1.brojnik *(r2.nazivnik /r);
</font>        r2.nazivnik = r2.nazivnik *(r1.nazivnik/r);
        
        auto k = NZD(r2.brojnik, r2.nazivnik);
        r2.brojnik/=k;
        r2.nazivnik/=k;
        return r2;
    }
    
    friend Razlomak &amp;operator -=(Razlomak &amp;r2, const Razlomak &amp;r1){
        auto r = NZD(r2.nazivnik, r1.nazivnik);
        
        PrekoracenjeMnozenja(r2.brojnik,r1.nazivnik/r);
        PrekoracenjeMnozenja(r2.nazivnik,r1.nazivnik/r);
        PrekoracenjeMnozenja(r1.brojnik, r2.nazivnik/r);
        
<a name="12"></a><font color="#0000FF"><a href="match168-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        PrekoracenjeOduzimanja(r2.brojnik * (r1.nazivnik/r), r1.brojnik *(r2.nazivnik /r));
        
        r2.brojnik = r2.brojnik * (r1.nazivnik/r) - r1.brojnik *(r2.nazivnik /r);
</font>        r2.nazivnik = r2.nazivnik *(r1.nazivnik/r);
        
        auto k = NZD(r2.brojnik, r2.nazivnik);
        r2.brojnik/=k;
        r2.nazivnik/=k;
        return r2;
        
    }
    
    friend Razlomak &amp;operator *=(Razlomak &amp;r2, const Razlomak &amp;r1){
        auto s = NZD(r2.brojnik, r1.nazivnik);
        auto t = NZD(r1.brojnik, r2.nazivnik);
        
        PrekoracenjeMnozenja(r2.brojnik/s,r1.brojnik/t);
<a name="9"></a><font color="#FF00FF"><a href="match168-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        PrekoracenjeMnozenja(r2.nazivnik/t,r1.nazivnik/s);
        
        r2.brojnik = (r2.brojnik/s)*(r1.brojnik/t);
        r2.nazivnik = (r2.nazivnik/t)*(r1.nazivnik/s);
</font>        
        auto k = NZD(r2.brojnik, r2.nazivnik);
        r2.brojnik/=k;
        r2.nazivnik/=k;
        return r2;
        
    }
    
    friend Razlomak &amp;operator /=(Razlomak &amp;r2, const Razlomak &amp;r1){
         auto u = NZD(r2.brojnik, r1.brojnik);
        auto r = NZD(r2.nazivnik, r1.nazivnik);
        
        PrekoracenjeMnozenja(r2.brojnik/u,r1.nazivnik/r);
<a name="10"></a><font color="#FF0000"><a href="match168-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        PrekoracenjeMnozenja(r2.nazivnik/r,r1.brojnik/u);
        
        r2.brojnik = (r2.brojnik/u)*(r1.nazivnik/r);
        r2.brojnik = (r2.nazivnik/r)*(r1.brojnik/u);
</font>        
        auto k = NZD(r2.brojnik, r2.nazivnik);
        r2.brojnik/=k;
        r2.nazivnik/=k;
        return r2;
    }
    
    friend Razlomak &amp;operator ++(Razlomak &amp;r2){
        Razlomak r(1);
        r2+=r;
        return r2;
    }
    
    friend Razlomak operator ++(Razlomak &amp;r2, int){
        auto pom = r2;
        ++r2;
        return pom;
    }
    friend Razlomak &amp;operator --(Razlomak &amp;r2){
        Razlomak r(1);
        r2 -= r;
        return r2;
    }
    
    friend Razlomak operator --(Razlomak &amp;r2, int){
        auto pom = r2;
        --r2;
        return pom;
    }
    
<a name="5"></a><font color="#FF0000"><a href="match168-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    friend bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2){
        long double raz1 = r1.brojnik/r1.nazivnik;
        long double raz2 = r2.brojnik/r2.nazivnik;
        if(fabs(raz1-raz2)&lt;eps) return true;
</font>        return false;
    }
    
    friend bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2){
        return !(r1 == r2);
    }
    
<a name="8"></a><font color="#00FFFF"><a href="match168-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    friend bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2){
        long double raz1 = r1.brojnik/r1.nazivnik;
        long double raz2 = r2.brojnik/r2.nazivnik;
        if(raz1-raz2&gt; eps) return true;
</font>        return false;
    }
    friend bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2){
        return r2 &gt; r1;
    }
    friend bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2){
        return (r1 &gt; r2 || r1 == r2);
    }
    friend bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2){
        return (r1 &lt; r2 || r1 == r2);
    }
    
<a name="13"></a><font color="#00FFFF"><a href="match168-0.html#13" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const Razlomak &amp;r){
        if(r.nazivnik == 1) return tok &lt;&lt; r.brojnik;
</font>        return tok &lt;&lt; r.brojnik &lt;&lt; "/" &lt;&lt; r.nazivnik;
    }
    
    friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, Razlomak &amp;r){
        //std::cout &lt;&lt; "in";
        char znak = 'a';
        r.brojnik = 0;
        r.nazivnik = 1;
        
        tok &gt;&gt; std::ws; //sa predavanja
        if((tok.peek() &gt;= 'A' &amp;&amp; tok.peek() &lt;='Z') || (tok.peek() &gt;= 'a' &amp;&amp; tok.peek() &lt;='z')) {
            tok.setstate(std::ios::failbit); return tok;
        }
        tok &gt;&gt; r.brojnik; 
        znak = tok.peek();
        if( znak == '/') {
            tok.get();
            tok &gt;&gt; r.nazivnik; 
            
           
           if(tok.peek() != '\n' &amp;&amp; tok.peek() != ' '  &amp;&amp; tok.peek() != '\r' &amp;&amp; tok.peek() != '\f' &amp;&amp; tok.peek() != '\v' 
                &amp;&amp; tok.peek() != '\t' &amp;&amp; tok.peek() != EOF) {tok.setstate(std::ios::failbit); return tok;}
            r.skrati();
            
        }
        else if(znak == '\n' || znak == ' ' ||  znak == '\r' || znak == '\f' || znak == '\v' 
            || znak == '\t' || znak == EOF) {
            r.nazivnik = 1;
            
            //std::cout &lt;&lt; "In";
        }
        
        
        
        return tok;
    }
    operator long double() const {
        return brojnik/(long double)nazivnik;
    }
    private:
    void skrati(){
         auto k = NZD(brojnik, nazivnik);
       brojnik/=k;
       nazivnik/=k;
    }
};
int main ()
{
    Razlomak a(6);
    ++a;
    a++;
    a--;
    --a;
    std::cout &lt;&lt;a;
    
	return 0;
}</pre>
</body>
</html>
