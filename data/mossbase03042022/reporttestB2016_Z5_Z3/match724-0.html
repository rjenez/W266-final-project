<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student1547.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student1547.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;limits&gt;
#include &lt;cmath&gt;

class Razlomak
{
    long long int brojnik, nazivnik;
    static long long int NZD (long long int br, long long int naz) {
        if(naz==0) return br;
        return NZD(naz, br%naz);
    }
    void SkratiRazlomak(long long int &amp;br, long long int &amp;naz) {
        auto x(NZD(br,naz));
        br/=x;
        naz/=x;
    };
    static void TestOwerflowaPlus(long long int prvi, long long int drugi);
    static void TestOwerflowaPuta(long long int prvi, long long int drugi);
<a name="1"></a><font color="#00FF00"><a href="match724-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

public:
    Razlomak (long long int br=0, long long int naz=1);
    long long int DajBrojnik() const{ return brojnik;}
    long long int DajNazivnik() const { return nazivnik;}
    friend Razlomak operator +(const Razlomak&amp; x, const Razlomak &amp;y);
</font>    friend Razlomak operator -(const Razlomak&amp; x, const Razlomak &amp;y);
<a name="5"></a><font color="#FF0000"><a href="match724-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    friend Razlomak operator *(const Razlomak&amp; x, const Razlomak &amp;y);
    friend Razlomak operator /(const Razlomak&amp; x, const Razlomak &amp;y);
    Razlomak&amp; operator -();
</font>    Razlomak&amp; operator +();
<a name="2"></a><font color="#0000FF"><a href="match724-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    Razlomak&amp; operator +=(const Razlomak &amp;y);
    Razlomak&amp; operator -=(const Razlomak &amp;y);
    Razlomak&amp; operator *=(const Razlomak &amp;y);
    Razlomak&amp; operator /=(const Razlomak &amp;y);
    friend bool operator &gt;(const Razlomak&amp; x, const Razlomak &amp;y);
</font>    friend bool operator &lt;(const Razlomak&amp; x, const Razlomak &amp;y);
    friend bool operator &lt;=(const Razlomak&amp; x, const Razlomak &amp;y);
    friend bool operator &gt;=(const Razlomak&amp; x, const Razlomak &amp;y);
    friend bool operator ==(const Razlomak&amp; x, const Razlomak &amp;y);
    friend bool operator !=(const Razlomak&amp; x, const Razlomak &amp;y);
    friend std::ostream &amp;operator &lt;&lt; (std::ostream &amp;tok, const Razlomak &amp;y);
    friend std::istream operator &gt;&gt; (std::istream &amp;ulaz, const Razlomak &amp;y);
    operator long double() const{
        return (long double)(brojnik)/nazivnik;
    }
};

void Razlomak::TestOwerflowaPlus(long long int prvi, long long int drugi)
{
    if(drugi&gt;0 and prvi&gt;std::numeric_limits&lt;long long int&gt;::max()-drugi) throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
    else if(drugi&lt;0 and prvi&lt;std::numeric_limits&lt;long long int&gt;::lowest()-drugi) throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
}

void Razlomak::TestOwerflowaPuta(long long int prvi, long long int drugi){
    if(drugi&gt;0 and prvi&lt;std::numeric_limits&lt;long long int&gt;::lowest()/drugi) throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
    else if( prvi==std::numeric_limits&lt;long long int&gt;::lowest() or (drugi&lt;0 and -prvi&gt;std::numeric_limits&lt;long long int&gt;::max()/(-drugi))) throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
}

Razlomak::Razlomak (long long int br, long long int naz)
{
    if(naz==0) throw std::logic_error ("Nekorektan razlomak");
    if(br&gt;0 and naz&lt;0) {
        br=-br;
        naz=-naz;
    }
    if(br&lt;0 and naz&lt;0) {
        br=-br;
        naz=-naz;
    }
    SkratiRazlomak(br,naz);
    brojnik=br;
    nazivnik=naz;
}
                                                                //operatori
Razlomak operator +(const Razlomak&amp; x, const Razlomak &amp;y)
{
    auto r(Razlomak::NZD(x.nazivnik, y.nazivnik));
    long long int prvi(x.brojnik*(y.nazivnik/r)), drugi(y.brojnik*(x.nazivnik/r));
    Razlomak::TestOwerflowaPlus(prvi, drugi);
    return Razlomak(x.brojnik*(y.nazivnik/r)+y.brojnik*(x.nazivnik/r), x.nazivnik*(y.nazivnik/r));
}
Razlomak operator -(const Razlomak&amp; x, const Razlomak &amp;y)
{
    auto r(Razlomak::NZD(x.nazivnik, y.nazivnik));
    long long int prvi(x.brojnik*(y.nazivnik/r)), drugi(-y.brojnik*(x.nazivnik/r));
    Razlomak::TestOwerflowaPlus(prvi, drugi);
    return Razlomak(x.brojnik*(y.nazivnik/r)-y.brojnik*(x.nazivnik/r), x.nazivnik*(y.nazivnik/r));
}
Razlomak operator *(const Razlomak&amp; x, const Razlomak &amp;y)
{
    auto s(Razlomak::NZD(x.brojnik, y.nazivnik)), t(Razlomak::NZD(y.brojnik, x.nazivnik));
    long long int prvi(x.brojnik/s), drugi(y.brojnik/t);
    Razlomak::TestOwerflowaPuta(prvi, drugi);
    Razlomak::TestOwerflowaPuta(x.nazivnik/t, y.nazivnik/s);
    return Razlomak(prvi*drugi, (x.nazivnik/t)* (y.nazivnik/s));
}
Razlomak operator /(const Razlomak&amp; x, const Razlomak &amp;y)
{
    auto r(Razlomak::NZD(x.nazivnik, y.nazivnik)), u(Razlomak::NZD(x.brojnik, y.brojnik));
    long long int prvi(x.brojnik/u), drugi(y.nazivnik/r);
    Razlomak::TestOwerflowaPuta(prvi, drugi);
    Razlomak::TestOwerflowaPuta(x.nazivnik/r, y.brojnik/u);
    return Razlomak((prvi*drugi), ((x.nazivnik/r)* (y.brojnik/u)));
}
 Razlomak&amp; Razlomak::operator -(){
     if(brojnik==std::numeric_limits&lt;long long int&gt;::lowest()) throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
     brojnik=-brojnik;
     return*this;
 };
Razlomak&amp; Razlomak::operator +(){
    return*this;
}
Razlomak&amp; Razlomak::operator +=(const Razlomak&amp; y){
    auto r(Razlomak::NZD(nazivnik, y.nazivnik));
    long long int prvi(brojnik*(y.nazivnik/r)), drugi(y.brojnik*(nazivnik/r));
<a name="0"></a><font color="#FF0000"><a href="match724-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    Razlomak::TestOwerflowaPlus(prvi, drugi);
    brojnik=brojnik*(y.nazivnik/r)+y.brojnik*(nazivnik/r);
    nazivnik= nazivnik*(y.nazivnik/r);
    return*this;
}
Razlomak&amp; Razlomak::operator -=(const Razlomak&amp; y){
    auto r(Razlomak::NZD(nazivnik, y.nazivnik));
</font>    auto brojniky=-y.brojnik;
    long long int prvi(brojnik*(y.nazivnik/r)), drugi(brojniky*(nazivnik/r));
    Razlomak::TestOwerflowaPlus(prvi, drugi);
<a name="3"></a><font color="#00FFFF"><a href="match724-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    brojnik=brojnik*(y.nazivnik/r)+y.brojnik*(nazivnik/r);
    nazivnik= nazivnik*(y.nazivnik/r);
    return*this;
}
Razlomak&amp; Razlomak::operator *=(const Razlomak&amp;y){
    auto s(Razlomak::NZD(brojnik, y.nazivnik)), t(Razlomak::NZD(y.brojnik, nazivnik));
</font>    long long int prvi(brojnik/s), drugi(y.brojnik/t);
    Razlomak::TestOwerflowaPuta(prvi, drugi);
    Razlomak::TestOwerflowaPuta(nazivnik/t, y.nazivnik/s);
    brojnik=prvi*drugi;
<a name="4"></a><font color="#FF00FF"><a href="match724-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    nazivnik=(nazivnik/t)* (y.nazivnik/s);
    return *this;
}
Razlomak&amp; Razlomak::operator /=(const Razlomak &amp;y){
    auto r(Razlomak::NZD(nazivnik, y.nazivnik)), u(Razlomak::NZD(brojnik, y.brojnik));
</font>    long long int prvi(brojnik/u), drugi(y.nazivnik/r);
    Razlomak::TestOwerflowaPuta(prvi, drugi);
    Razlomak::TestOwerflowaPuta(nazivnik/r, y.brojnik/u);
    brojnik=prvi*drugi,
    nazivnik=(nazivnik/r)* (y.brojnik/u);
    return *this;
}
bool operator &lt;(const Razlomak&amp; x, const Razlomak &amp;y){
    long double xx(static_cast&lt;long double&gt;(x.brojnik)/x.nazivnik);
    long double yy(static_cast&lt;long double&gt;(y.brojnik)/y.nazivnik);
    return xx&lt;yy;
}
bool operator &gt;(const Razlomak&amp; x, const Razlomak &amp;y){
    long double xx(static_cast&lt;long double&gt;(x.brojnik)/x.nazivnik), yy(static_cast&lt;long double&gt;(y.brojnik)/y.nazivnik);
    return xx&gt;yy;
}
bool operator &lt;=(const Razlomak&amp; x, const Razlomak &amp;y){
    long double xx(static_cast&lt;long double&gt;(x.brojnik)/x.nazivnik), yy(static_cast&lt;long double&gt;(y.brojnik)/y.nazivnik);
    return xx&lt;=yy;
}
bool operator &gt;=(const Razlomak&amp; x, const Razlomak &amp;y){
<a name="6"></a><font color="#00FF00"><a href="match724-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    long double xx(static_cast&lt;long double&gt;(x.brojnik)/x.nazivnik), yy(static_cast&lt;long double&gt;(y.brojnik)/y.nazivnik);
    return xx&gt;=yy;
}
bool operator ==(const Razlomak&amp; x, const Razlomak &amp;y){
    long double xx(static_cast&lt;long double&gt;(x.brojnik)/x.nazivnik), yy(static_cast&lt;long double&gt;(y.brojnik)/y.nazivnik);
</font>    return xx==yy;
}
bool operator !=(const Razlomak&amp; x, const Razlomak &amp;y){
    long double xx(static_cast&lt;long double&gt;(x.brojnik)/x.nazivnik), yy(static_cast&lt;long double&gt;(y.brojnik)/y.nazivnik);
    return xx!=yy;
}
std::ostream &amp;operator &lt;&lt; (std::ostream&amp; tok, const Razlomak &amp;y){
    tok &lt;&lt; y.brojnik;
    if(y.nazivnik!=1) tok &lt;&lt; "/" &lt;&lt; y.nazivnik;
    return tok;
}
std::istream &amp;operator &gt;&gt;(std::istream &amp;ulaz,Razlomak &amp;p)
{
    char znak;
    long long int q,r;
    if(!(ulaz&gt;&gt;q)){
        ulaz.setstate(std::ios::failbit);
        return ulaz;
    }
    if((ulaz.peek()==EOF) or (ulaz.peek()=='\t') or (ulaz.peek()=='\v') or (ulaz.peek()=='\f') or (ulaz.peek()==' ') or (ulaz.peek()=='\n') or (ulaz.peek()=='\r')){
        p=Razlomak(q,1);
        return ulaz;
    }
    else if(ulaz.peek()=='/'){
        ulaz&gt;&gt;znak;
        if(ulaz.peek()&gt;'9' or ulaz.peek()&lt;'0'){
            ulaz.setstate(std::ios::failbit);
            return ulaz;
        }
        if(!(ulaz&gt;&gt;r) or ((ulaz.peek()!=EOF) and (ulaz.peek()!='\t') and (ulaz.peek()!='\v') and (ulaz.peek()!='\f') and (ulaz.peek()!=' ') and (ulaz.peek()!='\n') and (ulaz.peek()!='\r'))){
            ulaz.setstate(std::ios::failbit);
            return ulaz;
        }
        p=Razlomak(q,r);
        return ulaz;
    }
    ulaz.setstate(std::ios::failbit);
    return ulaz;
}
using std::cin;
using std::cout;
int main ()
{ 
    try{
        Razlomak r1, r2;
    std::cout &lt;&lt; "Unesite prvi razlomak: ";
    cin &gt;&gt; r1;
    std::cout &lt;&lt;"Unesite drugi razlomak: ";
    cin &gt;&gt; r2;
    cout &lt;&lt; "Zbir razlomka je: "&lt;&lt; r1+r2;
    cout &lt;&lt; "Razlika razlomka je: "&lt;&lt; r1-r2;
    cout &lt;&lt; "Proizvod razlomka je: "&lt;&lt; r1*r2;
    cout &lt;&lt; "Prvi razlomak podijeljen sa drugim iznosi: "&lt;&lt;r1/r2;
    } catch(std::overflow_error e){
        cout &lt;&lt; e.what();
    }
    return 0;
}</pre>
</body>
</html>
