<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student5122.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student1317.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;initializer_list&gt;
#include &lt;limits&gt;
#include &lt;string&gt;

using namespace std;

class Razlomak
{
    long long int brojnik, nazivnik;
    static long long int NZD(long long int p, long long int q);
    static bool PrekoracenjeZaSabiranje(long long int x, long long int y);
    static bool PrekoracenjeZaOduzimanje(long long int x, long long int y);
    static bool PrekoracenjeZaMnozenje(long long int x, long long int y);
    static bool JesuLiJednaki(long double x, long double y, long double Eps = 1e-10) 
    { return fabs(x - y) &lt;= Eps * (fabs(x) + fabs(y)); }
    public:
        Razlomak(long long int brojnik=0, long long int nazivnik=1);
        Razlomak(initializer_list&lt;long long int&gt; lista);
        long long int DajBrojnik() const { return brojnik; }
        long long int DajNazivnik() const { return nazivnik; }
        friend Razlomak operator +(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak operator -(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak operator *(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak operator /(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak operator +(const Razlomak &amp;r);
        friend Razlomak operator -(Razlomak &amp;r);
        Razlomak &amp;operator +=(const Razlomak &amp;r);
        Razlomak &amp;operator -=(const Razlomak &amp;r);
        Razlomak &amp;operator *=(const Razlomak &amp;r);
        Razlomak &amp;operator /=(const Razlomak &amp;r);
<a name="4"></a><font color="#FF00FF"><a href="match323-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        friend Razlomak &amp;operator ++(Razlomak &amp;r);
		friend Razlomak operator ++(Razlomak &amp;r, int);
		friend Razlomak &amp;operator --(Razlomak &amp;r);
		friend Razlomak operator --(Razlomak &amp;r, int);
		friend bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2);
		friend bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2);
</font>		friend bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2);
		friend bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2);
		friend bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2);
		friend bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2);
		friend ostream &amp;operator &lt;&lt;(ostream &amp;tok, Razlomak r);
		friend istream &amp;operator &gt;&gt;(istream &amp;tok, Razlomak &amp;r);
		operator long double() const { return ((long double)brojnik/(long double)nazivnik); }
};

Razlomak::Razlomak(long long int brojnik, long long int nazivnik)
{
    if(nazivnik==0) throw logic_error("Nekorektan razlomak");
    if(nazivnik&lt;0)
    {
        nazivnik*=(-1);
        brojnik*=(-1);
    }
    long long int nzd(NZD(abs(brojnik), abs(nazivnik)));
    brojnik/=nzd;
    nazivnik/=nzd;
    this-&gt;brojnik=brojnik;
    this-&gt;nazivnik=nazivnik;
}

Razlomak::Razlomak(initializer_list&lt;long long int&gt; lista)
{
    if(lista.size()==0)
    {
        brojnik=0;
        nazivnik=1;
    }
    else if(lista.size()==1)
    {
        brojnik=*lista.begin();
        nazivnik=1;
    }
    else if(lista.size()==2)
    {
        auto it(lista.begin());
        it++;
        if(*it==0) throw logic_error("Nekorektan razlomak");
        if(*it&lt;0)
        {
            nazivnik=*it*(-1);
            brojnik=*lista.begin()*(-1);
        }
        else
        {
            nazivnik=*it;
            brojnik=*lista.begin();
        }
        long long int nzd(NZD(brojnik, nazivnik));
        brojnik/=nzd;
        nazivnik/=nzd;
    }
    else throw logic_error("Prekoracen broj parametara");
}

long long int Razlomak::NZD(long long int p, long long int q)
{
    while(1)
    {
        if(q==0) return p;
        long long int pomocna(p);
        p=q, 
        q=pomocna%q;
    }
}
    
bool Razlomak::PrekoracenjeZaSabiranje(long long int x, long long int y)
{
    long long int M(numeric_limits&lt;long long int&gt;::max());
    long long int m(numeric_limits&lt;long long int&gt;::min());
    if(y&gt;0 &amp;&amp; x&gt;M-y) return true;
    else if(y&lt;0 &amp;&amp; x&lt;m-y) return true;
    return false;
}

bool Razlomak::PrekoracenjeZaOduzimanje(long long int x, long long int y)
{
    long long int m(numeric_limits&lt;long long int&gt;::min());
    if(y&gt;0 &amp;&amp; x&lt;m+y) return true;
    else if(y&lt;0 &amp;&amp; Razlomak::PrekoracenjeZaSabiranje(x, -y)) return true;
    return false;
}

bool Razlomak::PrekoracenjeZaMnozenje(long long int x, long long int y)
{
    long long int M(numeric_limits&lt;long long int&gt;::max());
    long long int m(numeric_limits&lt;long long int&gt;::min());
    if(y&gt;0 &amp;&amp; (x&lt;(m/y) || x&gt;(M/y))) return true;
    else if(y&lt;0 &amp;&amp; (x==m || -x&gt;M/(-y) || -x&lt;m/(-y))) return true;
    return false;
}

Razlomak operator +(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    if(Razlomak::PrekoracenjeZaMnozenje(r1.brojnik, (r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje(r2.brojnik, (r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaSabiranje(r1.brojnik*(r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)), r2.brojnik*(r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje(r1.nazivnik, (r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    Razlomak zbir;
<a name="2"></a><font color="#0000FF"><a href="match323-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    zbir.brojnik=r1.brojnik*(r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik))+r2.brojnik*(r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik));
    zbir.nazivnik=r1.nazivnik*(r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik));
</font>    
    zbir=Razlomak(zbir.brojnik, zbir.nazivnik);
    
    return zbir;
}

Razlomak operator -(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    if(Razlomak::PrekoracenjeZaMnozenje(r1.brojnik, (r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje(r2.brojnik, (r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaOduzimanje(r1.brojnik*(r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)), r2.brojnik*(r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje(r1.nazivnik, (r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    Razlomak razlika;
<a name="3"></a><font color="#00FFFF"><a href="match323-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    razlika.brojnik=r1.brojnik*(r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik))-r2.brojnik*(r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik));
    razlika.nazivnik=r1.nazivnik*(r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik));
</font>    
    razlika=Razlomak(razlika.brojnik, razlika.nazivnik);
    
    return razlika;
}

Razlomak operator *(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    if(Razlomak::PrekoracenjeZaMnozenje((r1.brojnik/Razlomak::NZD(r1.brojnik, r2.nazivnik)), (r2.brojnik/Razlomak::NZD(r1.nazivnik, r2.brojnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje((r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.brojnik)), (r2.nazivnik/Razlomak::NZD(r1.brojnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    
    Razlomak proizvod;
<a name="0"></a><font color="#FF0000"><a href="match323-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    proizvod.brojnik=(r1.brojnik/Razlomak::NZD(r1.brojnik, r2.nazivnik))*(r2.brojnik/Razlomak::NZD(r1.nazivnik, r2.brojnik));
    proizvod.nazivnik=(r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.brojnik))*(r2.nazivnik/Razlomak::NZD(r1.brojnik, r2.nazivnik));
    
    proizvod=Razlomak(proizvod.brojnik, proizvod.nazivnik);
</font>    return proizvod;
}

Razlomak operator /(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    if(Razlomak::PrekoracenjeZaMnozenje((r1.brojnik/Razlomak::NZD(r1.brojnik, r2.brojnik)), (r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje((r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik)), (r2.brojnik/Razlomak::NZD(r1.brojnik, r2.brojnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    
    Razlomak kolicnik;
<a name="1"></a><font color="#00FF00"><a href="match323-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    kolicnik.brojnik=(r1.brojnik/Razlomak::NZD(r1.brojnik, r2.brojnik))*(r2.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik));
    kolicnik.nazivnik=(r1.nazivnik/Razlomak::NZD(r1.nazivnik, r2.nazivnik))*(r2.brojnik/Razlomak::NZD(r1.brojnik, r2.brojnik));
    
    kolicnik=Razlomak(kolicnik.brojnik, kolicnik.nazivnik);
</font>    return kolicnik;
}

Razlomak operator +(const Razlomak &amp;r)
{ return r; }

Razlomak operator -(Razlomak &amp;r)
{
    if(r.brojnik==numeric_limits&lt;long long int&gt;::min()) throw overflow_error("Nemoguce dobiti tacan rezultat");
    r.brojnik*=(-1);
    return r;
}

Razlomak &amp;Razlomak::operator +=(const Razlomak &amp;r)
{
    if(Razlomak::PrekoracenjeZaMnozenje(brojnik, (r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje(r.brojnik, (nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaSabiranje(brojnik*(r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)), r.brojnik*(nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje(nazivnik, (r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    
    brojnik=brojnik*(r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik))+r.brojnik*(nazivnik/Razlomak::NZD(nazivnik, r.nazivnik));
    nazivnik=nazivnik*(r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik));
    
    *this=Razlomak(brojnik, nazivnik);
    
    return *this;
}

Razlomak &amp;Razlomak::operator -=(const Razlomak &amp;r)
{
    if(Razlomak::PrekoracenjeZaMnozenje(brojnik, (r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje(r.brojnik, (nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaOduzimanje(brojnik*(r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)), r.brojnik*(nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje(nazivnik, (r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    
    brojnik=brojnik*(r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik))-r.brojnik*(nazivnik/Razlomak::NZD(nazivnik, r.nazivnik));
    nazivnik=nazivnik*(r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik));
    
    *this=Razlomak(brojnik, nazivnik);
    
    return *this;
}

Razlomak &amp;Razlomak::operator *=(const Razlomak &amp;r)
{
    if(Razlomak::PrekoracenjeZaMnozenje((brojnik/Razlomak::NZD(brojnik, r.nazivnik)), (r.brojnik/Razlomak::NZD(nazivnik, r.brojnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje((nazivnik/Razlomak::NZD(nazivnik, r.brojnik)), (r.nazivnik/Razlomak::NZD(brojnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    auto pom(brojnik);
    brojnik=(brojnik/Razlomak::NZD(brojnik, r.nazivnik))*(r.brojnik/Razlomak::NZD(nazivnik, r.brojnik));
    nazivnik=(nazivnik/Razlomak::NZD(r.brojnik, nazivnik))*(r.nazivnik/Razlomak::NZD(pom, r.nazivnik));
    
    *this=Razlomak(brojnik, nazivnik);
    return *this;
}

Razlomak &amp;Razlomak::operator /=(const Razlomak &amp;r)
{
    if(Razlomak::PrekoracenjeZaMnozenje((brojnik/Razlomak::NZD(brojnik, r.brojnik)), (r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    if(Razlomak::PrekoracenjeZaMnozenje((nazivnik/Razlomak::NZD(nazivnik, r.nazivnik)), (r.brojnik/Razlomak::NZD(brojnik, r.brojnik)))) throw overflow_error("Nemoguce dobiti tacan rezultat");
    auto pom(brojnik);
    brojnik=(brojnik/Razlomak::NZD(brojnik, r.brojnik))*(r.nazivnik/Razlomak::NZD(nazivnik, r.nazivnik));
    nazivnik=(nazivnik/Razlomak::NZD(nazivnik, r.nazivnik))*(r.brojnik/Razlomak::NZD(pom, r.brojnik));
    
    *this=Razlomak(brojnik, nazivnik);
    return *this;
}

Razlomak &amp;operator ++(Razlomak &amp;r)
{   return r+=Razlomak(1, 1);    }

Razlomak operator ++(Razlomak &amp;r, int)
{
    Razlomak pomocni(r);
    r+=Razlomak(1, 1);
    return pomocni;
}

Razlomak &amp;operator --(Razlomak &amp;r)
{   return r-=Razlomak(1, 1);    }

Razlomak operator --(Razlomak &amp;r, int)
{
    Razlomak pomocni(r);
    r-=Razlomak(1, 1);
    return pomocni;
}

bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    long double prvi((long double)r1.brojnik/(long double)r1.nazivnik), drugi((long double)r2.brojnik/(long double)r2.nazivnik);
    if(prvi&gt;drugi) return true;
    return false;
}

bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    long double prvi((long double)r1.brojnik/(long double)r1.nazivnik), drugi((long double)r2.brojnik/(long double)r2.nazivnik);
    if(prvi&gt;drugi || Razlomak::JesuLiJednaki(prvi, drugi)) return true;
    return false;
}

bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    long double prvi((long double)r1.brojnik/(long double)r1.nazivnik), drugi((long double)r2.brojnik/(long double)r2.nazivnik);
    if(prvi&lt;drugi) return true;
    return false;
}

bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    long double prvi((long double)r1.brojnik/(long double)r1.nazivnik), drugi((long double)r2.brojnik/(long double)r2.nazivnik);
    if(prvi&lt;drugi || Razlomak::JesuLiJednaki(prvi, drugi)) return true;
    return false;
}

bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    long double prvi((long double)r1.brojnik/(long double)r1.nazivnik), drugi((long double)r2.brojnik/(long double)r2.nazivnik);
    if(Razlomak::JesuLiJednaki(prvi, drugi)) return true;
    return false;
}

bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    long double prvi((long double)r1.brojnik/(long double)r1.nazivnik), drugi((long double)r2.brojnik/(long double)r2.nazivnik);
    if(Razlomak::JesuLiJednaki(prvi, drugi)) return false;
    return true;;
}

ostream &amp;operator &lt;&lt;(ostream &amp;tok, Razlomak r)
{
    r=Razlomak(r.brojnik, r.nazivnik);
    
    if(r.nazivnik==1) tok &lt;&lt; r.brojnik;
    else tok &lt;&lt; r.brojnik &lt;&lt; "/" &lt;&lt; r.nazivnik;
    
    return tok;
}

istream &amp;operator &gt;&gt;(istream &amp;tok, Razlomak &amp;r)
{
    long long int broj;
    char znak;
    
    tok &gt;&gt; broj;
    r.brojnik=broj;
    r.nazivnik=1;
    if(tok.peek()==' ' || tok.peek()==10 || tok.peek()==EOF || tok.peek()==13 ||  tok.peek()==11 || tok.peek()==12 || tok.peek()==9) return tok;
    else if(tok.peek()=='/')
    {
        long long int pom;
        tok &gt;&gt; znak;
        if(!(tok.peek()&gt;='0' &amp;&amp; tok.peek()&lt;='9'))
        {
            tok.setstate(ios::failbit);
            return tok;
        }
        tok &gt;&gt; pom;
        
        if(tok.peek()==' ' || tok.peek()==10 || tok.peek()==EOF || tok.peek()==13 ||  tok.peek()==11 || tok.peek()==12 || tok.peek()==9)
        {
            r.brojnik=broj;
            r.nazivnik=pom;
            return tok;
        }
        else tok.setstate(ios::failbit);
    }
    else tok.setstate(ios::failbit);
    
    return tok;
}

int main ()
{
	Razlomak r1, r2{4, 2}, r3(10, 15), r4(6);
	cout &lt;&lt; "Unesite brojnik i nazivnik prvog razlomka: ";
	
	cin &gt;&gt; r1;
	if(!cin)
	{
	    cout &lt;&lt; "Neispravan tok." &lt;&lt; endl;
	    return 0;
	}
	cout &lt;&lt; "Ovaj ralomak glasi: " &lt;&lt; r1 &lt;&lt; endl;
	cout &lt;&lt; "Zbir prvog i drugog razlomka: " &lt;&lt; r1+r2 &lt;&lt; endl;
	cout &lt;&lt; "Razlika treceg i drugog razlomka: " &lt;&lt; r3-r2 &lt;&lt; endl;
	if(r1&gt;r2) cout &lt;&lt; "Prvi razlomak je veci od drugog." &lt;&lt; endl;
	else if(r1&lt;r2) cout &lt;&lt; "Prvi razlomak je manji od drugog." &lt;&lt; endl;
	else if(r1==r2) cout &lt;&lt; "Prvi i drugi razlomak su isti." &lt;&lt; endl;
	
	
	
	return 0;
}


</pre>
</body>
</html>
