<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student1468.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student1468.cpp<p></p><pre>
/B16/17 (Zadaća 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise



#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;limits&gt;
#include &lt;cmath&gt;


class Razlomak 
{
  long long int brojnik;
  long  long int nazivnik;
  static long long int NZD (long long int p,long long int q){ if (q==0) return p; else return NZD(q, p%q); }
  
  
<a name="2"></a><font color="#0000FF"><a href="match889-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

  static long long int Sabiranje (long long int X,long long int Y)
  {
        long long int m(std::numeric_limits&lt;long long int&gt;::min()), M(std::numeric_limits&lt;long long int&gt;::max());
</font>        if (Y &gt;= 0 &amp;&amp; X &gt; M - Y) throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
        else if(Y &lt; 0 &amp;&amp; X &lt; m - Y) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        return X+Y;
  }
<a name="3"></a><font color="#00FFFF"><a href="match889-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

  static long long int Oduzimanje (long long int X, long long int Y)
  {
      long long int m(std::numeric_limits&lt;long long int&gt;::min()), M(std::numeric_limits&lt;long long int&gt;::max());
</font>       if (Y &gt;= 0 &amp;&amp; X &lt; m + Y) throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
        else if(Y &lt; 0 &amp;&amp; X &gt; M + Y) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        return X-Y;
  }
<a name="4"></a><font color="#FF00FF"><a href="match889-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

  static long long int Mnozenje (long long int X, long long int Y)
  {
      long long int m(std::numeric_limits&lt;long long int&gt;::min()), M(std::numeric_limits&lt;long long int&gt;::max());
</font>       if (Y &gt;= 0 &amp;&amp; (X &lt; m / Y || X &gt; M / Y)) throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
       else if (Y &lt; 0 &amp;&amp; (X == m || -X &gt; M / (-Y) || -X &lt; m / (-Y))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
       return X*Y;
  }
  
  
  
  public:
  // aritmetičke operacije bacaju izuzetak ukoliko rezultat nije egzaktno reprezentabilan ?
  

  Razlomak (long long int br=0,long long int naz=1);
  // vrši automatska pretvorba int u Razlomak
    Razlomak(std::initializer_list&lt;long long int&gt; lista);
  // zabrana da brojnik i nazivnik budu realni brojevi
 Razlomak &amp;operator +=(Razlomak Y) { return *this = *this + Y; }
 Razlomak &amp;operator -=(Razlomak Y) { return *this = *this - Y; }
 Razlomak &amp;operator *=(Razlomak Y) { return *this = *this * Y; }
<a name="0"></a><font color="#FF0000"><a href="match889-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

 Razlomak &amp;operator /=(Razlomak Y) { return *this = *this / Y; }
  
  long long int DajBrojnik()const {return brojnik;};
 long long int  DajNazivnik()const {return nazivnik;};
 friend Razlomak operator + (Razlomak X, Razlomak Y);
friend Razlomak operator - (Razlomak X, Razlomak Y);
friend Razlomak operator * (Razlomak X, Razlomak Y);
friend Razlomak operator / (Razlomak X, Razlomak Y);
friend Razlomak operator +(Razlomak X);
</font>friend Razlomak operator -(Razlomak Y);
friend Razlomak &amp;operator ++ (Razlomak &amp;X);
friend Razlomak operator ++ (Razlomak &amp;X, int);
friend Razlomak &amp;operator -- (Razlomak &amp;X);
friend Razlomak operator -- (Razlomak &amp;X, int);
<a name="1"></a><font color="#00FF00"><a href="match889-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

friend bool operator &lt; (Razlomak X, Razlomak Y);
friend bool operator &gt; (Razlomak X, Razlomak Y);
friend bool operator &lt;= (Razlomak X, Razlomak Y);
friend bool operator &gt;= (Razlomak X, Razlomak Y);
friend bool operator == (Razlomak X, Razlomak Y);
friend bool operator != (Razlomak X, Razlomak Y);
</font>friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, Razlomak X);
friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, Razlomak &amp;X);

  
 
  operator long double () const { return (long double) brojnik / nazivnik; } // unose kao p/q

  
};

// kopirano iz klase 
Razlomak::Razlomak(long long int br, long long int naz)
{
   if(naz==0) throw std::logic_error ("Nekorektan razlomak"); 
   if (naz&lt;0)
   {
    brojnik=(-1)*br; nazivnik=(-1)*naz; 
    
   }
   long long int nzd(NZD (std::abs(br),std::abs(naz))); 
   br/=nzd; naz/=nzd; 
   brojnik=br;nazivnik=naz;
   
  }  
  
  Razlomak::Razlomak(std::initializer_list&lt;long long int&gt; lista)
  {
      if(lista.size() == 0)
      {
          brojnik = 0;
          nazivnik = 1;
      }
      else if(lista.size() == 1)
      {
          brojnik = *lista.begin();
          nazivnik = 1;
      }
      else if(lista.size() == 2)
      {
          std::initializer_list&lt;long long int&gt;::iterator it(lista.begin());
          brojnik = *it / NZD(std::abs(*it), std::abs(*(it + 1)));
          nazivnik = *(it + 1) / NZD(std::abs(*it), std::abs(*(it + 1)));
          if(nazivnik &lt; 0)
          {
              brojnik *= -1;
              nazivnik *= -1;
          }
          long long int nzd(NZD(std::abs(brojnik), std::abs(nazivnik)));
          brojnik /= nzd;
          nazivnik /= nzd;
      }
  }

   Razlomak operator +(Razlomak X,Razlomak Y)
  {
     Razlomak zbir;
     int r (Razlomak::NZD(std::abs(X.nazivnik),std::abs(Y.nazivnik)));
     int p1(X.brojnik),p2(Y.brojnik),q1(X.nazivnik),q2(Y.nazivnik);
     
     zbir.brojnik=Razlomak::Sabiranje(Razlomak::Mnozenje(p1,(q2/r)),Razlomak::Mnozenje(p2,(q1/r)));
     zbir.nazivnik=Razlomak::Mnozenje(q1,(q2/r));
     zbir = Razlomak(zbir.brojnik, zbir.nazivnik);
     return zbir; 
  }
 Razlomak operator -(Razlomak X,Razlomak Y)
  {
    Razlomak razlika;
    int r(Razlomak::NZD(std::abs(X.nazivnik),std::abs(Y.nazivnik)));
    int p1(X.brojnik),p2(Y.brojnik),q1(X.nazivnik),q2(Y.nazivnik);
    razlika.brojnik=Razlomak::Oduzimanje(Razlomak::Mnozenje(p1,(q2/r)),Razlomak::Mnozenje(p2,(q1/r)));
    razlika.nazivnik=Razlomak::Mnozenje(q1,(q2/r));
    razlika = Razlomak(razlika.brojnik,razlika.nazivnik);
    return razlika;
  }
  
  Razlomak operator *(Razlomak X, Razlomak Y)
  {
    Razlomak proizvod;
    int p1(X.brojnik),p2(Y.brojnik),q1(X.nazivnik),q2(Y.nazivnik);   // kopirano iz operator -
    int s (Razlomak::NZD (std::abs(p1),std::abs(q2))),t(Razlomak::NZD(std::abs(p2),std::abs(q1)));
    
   proizvod.brojnik=(Razlomak::Mnozenje((p1/s),(p2/t)));
   proizvod.nazivnik=Razlomak::Mnozenje((q1/t),(q2/s));
    proizvod=Razlomak(proizvod.brojnik,proizvod.nazivnik);
    return proizvod;
  }
   Razlomak operator / (Razlomak X,Razlomak Y)
  {
    Razlomak kolicnik;
    int p1(X.brojnik),p2(Y.brojnik),q1(X.nazivnik),q2(Y.nazivnik); // kopirano iz operator *
    int  r(Razlomak::NZD(std::abs(X.nazivnik),std::abs(Y.nazivnik))),u(std::abs(Razlomak::NZD (p1,p2))); // kopirano
    kolicnik.brojnik=Razlomak::Mnozenje((p1/u),(q2/r));
    kolicnik.nazivnik=Razlomak::Mnozenje((q1/r),(p2/u));
    kolicnik=Razlomak(kolicnik.brojnik,kolicnik.nazivnik);
    return kolicnik;
    
  }
  
  // SVE KOPIRANO   
  
    Razlomak operator - (Razlomak X) { if(X.brojnik == std::numeric_limits&lt;long long int&gt;::min()) throw std::overflow_error("Nemoguce dobiti tacan rezultat"); X.brojnik = -X.brojnik; return X; }   // vraća razlomak sa izvrnutim znakom
   
   Razlomak operator + (Razlomak Y) {return Y;} // vraća operand neizmjenjen
   
   
   Razlomak &amp;operator ++ (Razlomak &amp;X) {return X=operator + (Razlomak(1,1),X);} // DA LI JE OVO ISPRAVNO ?
   Razlomak operator ++ (Razlomak &amp;X, int){Razlomak Y(X); X=operator +(Razlomak(1,1),Y); return Y;} // postfiksni
   Razlomak &amp;operator --  (Razlomak &amp;X) {return X=operator -(X,Razlomak(1,1));} // prefiksni
   Razlomak operator -- (Razlomak &amp;X, int) {Razlomak Y(X); X=operator -(X,Razlomak(1,1)); return Y;}  // postfiksni
   
   // PROVJERITI
   
   bool operator &lt; (Razlomak X,Razlomak Y)
   {
       long double p,q;
       p=(long double)X.brojnik/X.nazivnik;
<a name="5"></a><font color="#FF0000"><a href="match889-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

       q=(long double)Y.brojnik/Y.nazivnik;
       if ( p&lt;q) return true;  
       return false;
   }        
   bool  operator &gt; (Razlomak X, Razlomak Y)
   {
       long double p,q;
</font>       p=X.brojnik/X.nazivnik;
       q=Y.brojnik/Y.nazivnik;
       if (p&gt;q) return true;
       return false;
   }
   bool operator &lt;=(Razlomak X, Razlomak Y)
   {
       return X &lt; Y || X == Y;
   }
   bool operator &gt;=(Razlomak X, Razlomak Y)
   {
       return X &gt; Y || X == Y;
   }
   
   
   bool operator == (Razlomak X,Razlomak Y)
   {
       long double p,q;
       p=X.brojnik/X.nazivnik;
       q=Y.brojnik/Y.nazivnik;
       long double eps(1e-15);
       if (std::fabs(p-q) &lt; eps) return true;
       return false;
   }
   bool operator != (Razlomak X,Razlomak Y)
   {
    long double p,q;
       p=X.brojnik/X.nazivnik;
       q=Y.brojnik/Y.nazivnik;
       long double eps(1e-15);
      if (!(std::fabs(p-q) &lt; eps)) return true;  
      return false;
   }
   std::ostream &amp;operator &lt;&lt; (std::ostream &amp;tok,Razlomak X)
   {
       if (X.nazivnik==1) tok &lt;&lt; X.brojnik;
       else tok &lt;&lt; X.brojnik &lt;&lt; "/"&lt;&lt; X.nazivnik;
       return tok;
       
   }
   std::istream &amp;operator &gt;&gt; (std::istream &amp;tok, Razlomak &amp;X)
   {
        long long int brojnik(0), nazivnik(0);
        char znak(0);
        tok &gt;&gt; brojnik;
        tok &gt;&gt; znak;
        if(znak == '/')
        {
            tok &gt;&gt; nazivnik;
            tok &gt;&gt; znak;
            if(znak == ' ' || znak == '\n')
            {
                X = Razlomak(brojnik, nazivnik);
                return tok;
            }
            else
            {
                tok.setstate(std::ios::failbit);
                return tok;
            }
        }
        else if(znak == ' ' || znak == '\n')
        {
            X = Razlomak(brojnik, 1);
            return tok;
        }
        else
            tok.setstate(std::ios::failbit);
       return tok;
   }
   
  // neispravno stanje
  

int main ()
{
    Razlomak prvi(105,374), drugi(1267,1367);
    Razlomak treci(prvi + drugi);
    std::cout &lt;&lt; treci &lt;&lt; std::endl;
    Razlomak cetvrti(treci);
    if(treci == cetvrti)
        std::cout &lt;&lt; "Jednaki su" &lt;&lt; std::endl;
    else if(treci != cetvrti)
        std::cout &lt;&lt; "Nisu jednaki" &lt;&lt; std::endl;
    if(treci &lt;= drugi)
        std::cout &lt;&lt; "Drugi je veci od treceg" &lt;&lt; std::endl;
    else if(treci &gt; drugi)
        std::cout &lt;&lt; "Treci je veci od drugog" &lt;&lt; std::endl;
    ++++++treci;
    cetvrti++;
    ----drugi;
    prvi--;
    std::cout &lt;&lt; -prvi &lt;&lt; " " &lt;&lt; +drugi &lt;&lt; std::endl;
    std::cout &lt;&lt; prvi * drugi &lt;&lt; " " &lt;&lt; prvi / drugi &lt;&lt; " " &lt;&lt; prvi - drugi &lt;&lt; std::endl;
    Razlomak peti{12,14};
    std::cout &lt;&lt; peti &lt;&lt; std::endl;
    std::cout &lt;&lt; Razlomak({5,3}) &lt;&lt; " " &lt;&lt; Razlomak() &lt;&lt; std::endl;
	return 0;
}</pre>
</body>
</html>
