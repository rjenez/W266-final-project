<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student2477.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student2477.cpp<p></p><pre>
<a name="1"></a><font color="#00FF00"><a href="match697-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;limits&gt;
using namespace std;

class Razlomak {
        long long int brojnik, nazivnik;
        static long long int NZD(long long int p, long long int q) {
</font>            long long int nzd(0), temp;
            while(1) {
                temp=p;
                p=q;
                q=temp%q;
                if(q==0) {
                    nzd=p;
                    break;
                }
            }
            return nzd;
        }
        static bool PrekoracnjeSabiranje(long long int x, long long int y) {
            long long int M(numeric_limits&lt;long long int&gt;::max()), m;
            m=-M-1;
            if(y&gt;0) {
                if(x&gt;M-y) return true;
            }
            else if(y&lt;0) {
                if(x&lt;m-y) return true;
            }
            return false;
        }
        static bool PrekoracnjeOduzimanje(long long int x, long long int y) {
            long long int M(numeric_limits&lt;long long int&gt;::max()), m;
            m=-M-1;
            if(y&gt;0) {
                if(x&lt;m+y) return true;
            }
            else if(y&lt;0) {
                if(x&gt;M+y) return true;
            }
            return false;
        }
        static bool PrekoracnjeMnozenje(long long int x, long long int y) {
            long long int M(numeric_limits&lt;long long int&gt;::max()), m;
            m=-M-1;
            if(y&gt;0) {
                if(x&lt;m/y) return true;
                else if(x&gt;M/y) return true;
            }
            if(y&lt;0) {
                if(x==m) return true;
                else if(-x&gt;M/(-y)) return true;
                else if(-x&lt;m/(-y)) return true;
            }
            return false;
        }
    public:
        Razlomak(long long int br, long long int nz);
        Razlomak(long long int br);
<a name="4"></a><font color="#FF00FF"><a href="match697-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

        Razlomak();
        long long int DajBrojnik() const {
            return brojnik;
        }
        long long int DajNazivnik() const {
            return nazivnik;
        }
        friend Razlomak operator +(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
</font>        friend Razlomak operator -(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator *(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator /(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator +(const Razlomak &amp;raz);
        friend Razlomak operator -(const Razlomak &amp;raz);
        friend Razlomak operator +=(Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator -=(Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator *=(Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator /=(Razlomak &amp;prvi, const Razlomak &amp;drugi);
        Razlomak &amp;operator ++() {
            Razlomak jedinica(1);
            *this = *this + jedinica;
 			*this=Razlomak(this-&gt;brojnik, this-&gt;nazivnik);
            return *this;
        }
        Razlomak &amp;operator --() {
            Razlomak jedinica(1);
            *this = *this - jedinica;
 			*this=Razlomak(this-&gt;brojnik, this-&gt;nazivnik);
            return *this;
        }
        Razlomak operator ++(int) {
            Razlomak stari(*this), jedinica(1);
            *this = *this + jedinica;
            *this=Razlomak(this-&gt;brojnik, this-&gt;nazivnik);
            return stari;
        }
        Razlomak operator --(int) {
            Razlomak stari(*this), jedinica(1);
            *this = *this - jedinica;
            *this=Razlomak(this-&gt;brojnik, this-&gt;nazivnik);
            return stari;
        }
        friend bool operator ==(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator !=(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator &lt;(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator &gt;(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator &lt;=(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator &gt;=(const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;raz);
        friend istream &amp;operator &gt;&gt;(istream &amp;tok, Razlomak &amp;raz);
        operator long double() const;
};

    Razlomak::Razlomak(long long int br, long long int nz) {
        if(nz==0) throw logic_error("Nekorektan razlomak");
        auto nzd(NZD(br,nz));
        br=br/nzd; nz=nz/nzd;
        if(nz&lt;0) {
            nz=-nz;
            br=-br;
        }
        brojnik=br; nazivnik=nz;
    }
    Razlomak::Razlomak(long long int br) {
        brojnik=br; nazivnik=1;
    }
    Razlomak::Razlomak() {
        brojnik=0; nazivnik=1;
    }
    
<a name="2"></a><font color="#0000FF"><a href="match697-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    Razlomak operator +(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long long int r(Razlomak::NZD(prvi.DajNazivnik(),drugi.DajNazivnik()));
        if(Razlomak::PrekoracnjeMnozenje(prvi.DajBrojnik(),(drugi.DajNazivnik()/r))==true ||
</font>            Razlomak::PrekoracnjeMnozenje(drugi.DajBrojnik(),drugi.DajBrojnik())==true ||
            Razlomak::PrekoracnjeMnozenje(prvi.DajNazivnik(),(drugi.DajNazivnik()/r))==true ||
            Razlomak::PrekoracnjeSabiranje(prvi.DajBrojnik()*(drugi.DajNazivnik()/r),drugi.DajBrojnik()*drugi.DajBrojnik())==true)
                throw overflow_error("Nemoguce dobiti tacan rezultat");
        Razlomak novi;
        
        novi.brojnik = prvi.DajBrojnik()*(drugi.DajNazivnik()/r) + drugi.DajBrojnik()*(prvi.DajNazivnik()/r);
        novi.nazivnik = prvi.DajNazivnik()*(drugi.DajNazivnik()/r);
        novi=Razlomak(novi.brojnik, novi.nazivnik);
        return novi;
    }
<a name="3"></a><font color="#00FFFF"><a href="match697-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    Razlomak operator -(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long long int r(Razlomak::NZD(prvi.DajNazivnik(),drugi.DajNazivnik()));
        if(Razlomak::PrekoracnjeMnozenje(prvi.DajBrojnik(),(drugi.DajNazivnik()/r))==true ||
</font>            Razlomak::PrekoracnjeMnozenje(drugi.DajBrojnik(),drugi.DajBrojnik())==true ||
            Razlomak::PrekoracnjeMnozenje(prvi.DajNazivnik(),(drugi.DajNazivnik()/r))==true ||
            Razlomak::PrekoracnjeOduzimanje(prvi.DajBrojnik()*(drugi.DajNazivnik()/r),drugi.DajBrojnik()*drugi.DajBrojnik())==true)
                throw overflow_error("Nemoguce dobiti tacan rezultat");
        Razlomak novi;
        novi.brojnik = prvi.DajBrojnik()*(drugi.DajNazivnik()/r) - drugi.DajBrojnik()*(prvi.DajNazivnik()/r);
        novi.nazivnik = prvi.DajNazivnik()*(drugi.DajNazivnik()/r);
        novi=Razlomak(novi.brojnik, novi.nazivnik);
<a name="0"></a><font color="#FF0000"><a href="match697-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        return novi;
    }
    Razlomak operator *(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long long int s(Razlomak::NZD(prvi.DajBrojnik(),drugi.DajNazivnik())),
            t(Razlomak::NZD(drugi.DajBrojnik(),prvi.DajNazivnik()));
        if(Razlomak::PrekoracnjeMnozenje((prvi.DajBrojnik()/s),(drugi.DajBrojnik()/t))==true ||
</font>            Razlomak::PrekoracnjeMnozenje((prvi.DajNazivnik()/t),(drugi.DajNazivnik()/s))==true)
                throw overflow_error("Nemoguce dobiti tacan rezultat");
        Razlomak novi;
        novi.brojnik = (prvi.DajBrojnik()/s) * (drugi.DajBrojnik()/t);
        novi.nazivnik = (prvi.DajNazivnik()/t) * (drugi.DajNazivnik()/s);
        novi=Razlomak(novi.brojnik, novi.nazivnik);
<a name="5"></a><font color="#FF0000"><a href="match697-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

        return novi;
    }
    Razlomak operator /(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long long int r(Razlomak::NZD(prvi.DajNazivnik(),drugi.DajNazivnik())),
</font>            u(Razlomak::NZD(prvi.DajBrojnik(),drugi.DajBrojnik()));
        if(Razlomak::PrekoracnjeMnozenje((prvi.DajBrojnik()/u),(drugi.DajNazivnik()/r))==true ||
            Razlomak::PrekoracnjeMnozenje((prvi.DajNazivnik()/r),(drugi.DajBrojnik()/u))==true)
                throw overflow_error("Nemoguce dobiti tacan rezultat");
        Razlomak novi;
        novi.brojnik = (prvi.DajBrojnik()/u) * (drugi.DajNazivnik()/r);
        novi.nazivnik = (prvi.DajNazivnik()/r) * (drugi.DajBrojnik()/u);
        novi=Razlomak(novi.brojnik, novi.nazivnik);
        return novi;
    }

    Razlomak operator +(const Razlomak &amp;raz) {
        return raz;
    }
    Razlomak operator -(const Razlomak &amp;raz) {
        if(Razlomak::PrekoracnjeMnozenje(-1,raz.DajBrojnik())) throw overflow_error("Nemoguce dobiti tacan rezultat");
        return {-raz.brojnik, raz.nazivnik};
    }
    
    Razlomak operator +=(Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long long int r(Razlomak::NZD(prvi.DajNazivnik(),drugi.DajNazivnik()));
        if(Razlomak::PrekoracnjeMnozenje(prvi.DajBrojnik(),(drugi.DajNazivnik()/r))==true ||
            Razlomak::PrekoracnjeMnozenje(drugi.DajBrojnik(),drugi.DajBrojnik())==true ||
            Razlomak::PrekoracnjeMnozenje(prvi.DajNazivnik(),(drugi.DajNazivnik()/r))==true ||
            Razlomak::PrekoracnjeSabiranje(prvi.DajBrojnik()*(drugi.DajNazivnik()/r),drugi.DajBrojnik()*drugi.DajBrojnik())==true)
                throw overflow_error("Nemoguce dobiti tacan rezultat");
        Razlomak novi;
        novi.brojnik = prvi.DajBrojnik()*(drugi.DajNazivnik()/r) + drugi.DajBrojnik()*(drugi.DajNazivnik()/r);
        novi.nazivnik = prvi.DajNazivnik()*(drugi.DajNazivnik()/r);
        novi=Razlomak(novi.brojnik, novi.nazivnik);
        prvi=novi;
        return prvi;
    }
    Razlomak operator -=(Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long long int r(Razlomak::NZD(prvi.DajNazivnik(),drugi.DajNazivnik()));
        if(Razlomak::PrekoracnjeMnozenje(prvi.DajBrojnik(),(drugi.DajNazivnik()/r))==true ||
            Razlomak::PrekoracnjeMnozenje(drugi.DajBrojnik(),drugi.DajBrojnik())==true ||
            Razlomak::PrekoracnjeMnozenje(prvi.DajNazivnik(),(drugi.DajNazivnik()/r))==true ||
            Razlomak::PrekoracnjeSabiranje(prvi.DajBrojnik()*(drugi.DajNazivnik()/r),drugi.DajBrojnik()*drugi.DajBrojnik())==true)
                throw overflow_error("Nemoguce dobiti tacan rezultat");
        Razlomak novi;
        novi.brojnik = prvi.DajBrojnik()*(drugi.DajNazivnik()/r) - drugi.DajBrojnik()*drugi.DajBrojnik();
        novi.nazivnik = prvi.DajNazivnik()*(drugi.DajNazivnik()/r);
        novi=Razlomak(novi.brojnik, novi.nazivnik);
        prvi=novi;
        return prvi;
    }
    Razlomak operator *=(Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long long int s(Razlomak::NZD(prvi.DajBrojnik(),drugi.DajNazivnik())),
            t(Razlomak::NZD(drugi.DajBrojnik(),prvi.DajNazivnik()));
        if(Razlomak::PrekoracnjeMnozenje((prvi.DajBrojnik()/s),(drugi.DajBrojnik()/t))==true ||
            Razlomak::PrekoracnjeMnozenje((prvi.DajNazivnik()/t),(drugi.DajNazivnik()/s))==true)
                throw overflow_error("Nemoguce dobiti tacan rezultat");
        Razlomak novi;
        novi.brojnik = (prvi.DajBrojnik()/s) * (drugi.DajBrojnik()/t);
        novi.nazivnik = (prvi.DajNazivnik()/t) * (drugi.DajNazivnik()/s);
        novi=Razlomak(novi.brojnik, novi.nazivnik);
        prvi=novi;
        return prvi;
    }
    Razlomak operator /=(Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long long int r(Razlomak::NZD(prvi.DajNazivnik(),drugi.DajNazivnik())),
            u(Razlomak::NZD(prvi.DajBrojnik(),drugi.DajBrojnik()));
        if(Razlomak::PrekoracnjeMnozenje((prvi.DajBrojnik()/u),(drugi.DajNazivnik()/r))==true ||
            Razlomak::PrekoracnjeMnozenje((prvi.DajNazivnik()/r),(drugi.DajBrojnik()/u))==true)
                throw overflow_error("Nemoguce dobiti tacan rezultat");
        Razlomak novi;
        novi.brojnik = (prvi.DajBrojnik()/u) * (drugi.DajNazivnik()/r);
        novi.nazivnik = (prvi.DajNazivnik()/r) * (drugi.DajBrojnik()/u);
        novi=Razlomak(novi.brojnik, novi.nazivnik);
        prvi=novi;
        return prvi;
    }
  
    bool operator ==(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        if(prvi.DajBrojnik()==drugi.DajBrojnik() &amp;&amp; prvi.DajNazivnik()==drugi.DajNazivnik()) return true;
        return false;
    }  
    bool operator !=(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        if(prvi.DajBrojnik()!=drugi.DajBrojnik() || prvi.DajNazivnik()!=drugi.DajNazivnik()) return true;
        return false;
    }
    bool operator &lt;(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long double x(prvi.DajBrojnik()/prvi.DajNazivnik()), y(drugi.DajBrojnik()/drugi.DajNazivnik());
        if(x&lt;y) return true;
        return false;
    }
    bool operator &gt;(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        long double x1=prvi.DajBrojnik(), x2=prvi.DajNazivnik(), y1=drugi.DajBrojnik(), y2=drugi.DajNazivnik();
        long double x(x1/x2), y(y1/y2);
        if(x&gt;y) return true;
        return false;
    }
    bool operator &lt;=(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        if(prvi==drugi) return true;
        long double x(prvi.DajBrojnik()/prvi.DajNazivnik()), y(drugi.DajBrojnik()/drugi.DajNazivnik());
        if(x&lt;y) return true;
        return false;
    }
    bool operator &gt;=(const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        if(prvi==drugi) return true;
        long double x(prvi.DajBrojnik()/prvi.DajNazivnik()), y(drugi.DajBrojnik()/drugi.DajNazivnik());
        if(x&gt;y) return true;
        return false;
    }
    
    ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;raz) {
        Razlomak novi=raz;
        novi=Razlomak(novi.DajBrojnik(),novi.DajNazivnik());
        if(novi.DajNazivnik()==1) tok &lt;&lt; novi.DajBrojnik();
        else if(novi.DajBrojnik()==0) tok &lt;&lt; 0;
<a name="6"></a><font color="#00FF00"><a href="match697-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

        else tok &lt;&lt; novi.DajBrojnik() &lt;&lt; "/" &lt;&lt; novi.DajNazivnik();
        return tok;
    }

    istream &amp;operator &gt;&gt;(istream &amp;tok, Razlomak &amp;raz) {
</font>        raz.nazivnik=1;
        tok &gt;&gt; ws;
        if(!tok) tok.setstate(ios::failbit);
        char znak='o';
        tok &gt;&gt; raz.brojnik &gt;&gt; znak;
        if(tok.peek()=='\0') { raz=Razlomak(raz.brojnik, raz.nazivnik); return tok; }
        if(znak=='/') {
            tok &gt;&gt; raz.nazivnik;
            if(tok.peek()!=' ' &amp;&amp; tok.peek()!='\n' &amp;&amp; tok.peek()!='\v' &amp;&amp; tok.peek()!='\f' &amp;&amp; tok.peek()!='\t' &amp;&amp; tok.peek()!='\r') tok.setstate(ios::failbit);
            raz=Razlomak(raz.brojnik, raz.nazivnik);
            return tok;
        }
        else if(znak==' ' || znak=='\n' || znak=='\v' || znak=='\f' || znak=='\t' || znak=='\r') {
            tok &gt;&gt; ws;
            if(!tok) tok.setstate(ios::failbit);
            else { raz=Razlomak(raz.brojnik, raz.nazivnik); return tok; }
        }
        raz=Razlomak(raz.brojnik, raz.nazivnik);
        return tok;
    }       
   
    Razlomak::operator long double() const {
        long double x(this-&gt;DajBrojnik()), y(this-&gt;DajNazivnik());
        return x/y;
    }
    
int main () {
    Razlomak r1, r2;
    cin &gt;&gt; r1;
    cin &gt;&gt; r2;
    cout &lt;&lt; r1 &lt;&lt; endl;
    cout &lt;&lt; r2 &lt;&lt; endl;
    cout &lt;&lt; r1+r2 &lt;&lt; endl;
    cout &lt;&lt; r1-r2 &lt;&lt; endl;
    cout &lt;&lt; r1*r2 &lt;&lt; endl;
    cout &lt;&lt; r1/r2 &lt;&lt; endl;
    cout &lt;&lt; +r1 &lt;&lt; endl;
    cout &lt;&lt; -r1 &lt;&lt; endl;
    r1*=r2;
    r2+=r1;
    r1/=r2;
    r2-=r1;
    ++r1;
    --r2;
    r1++;
    r2--;
    cout &lt;&lt; r1 &lt;&lt; endl;
    cout &lt;&lt; r2 &lt;&lt; endl;
    if(r1==r2) cout &lt;&lt; "Jednaki" &lt;&lt; endl;
    if(r1!=r2) cout &lt;&lt; "Nisu jednaki" &lt;&lt; endl;
    if(r1&gt;=r2) cout &lt;&lt; "Prvi veci ili jednaki" &lt;&lt; endl;
    if(r1&lt;=r2) cout &lt;&lt; "Drugi veci ili jednaki" &lt;&lt; endl;
    return 0;
}</pre>
</body>
</html>
