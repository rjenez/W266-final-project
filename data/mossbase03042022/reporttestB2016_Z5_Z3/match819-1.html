<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student5496.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student8957.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;initializer_list&gt;
#include &lt;cmath&gt;
#include &lt;limits&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
using namespace std;

class Razlomak {
    long long int brojnik, nazivnik;
    
    static long long int NZD(long long int a, long long int b);
    public:
    Razlomak(long long int brojnik = 0, long long int nazivnik = 1);
    Razlomak(const initializer_list&lt;long long int&gt; &amp;lista);
<a name="0"></a><font color="#FF0000"><a href="match819-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

    long long int DajBrojnik() const {
        return brojnik;
    }
    long long int DajNazivnik() const {
        return nazivnik;
    }
    Razlomak &amp;operator +=(const Razlomak &amp;razlomak) {
        return *this = *this + razlomak;
    }
    Razlomak &amp;operator -=(const Razlomak &amp;razlomak) {
        return *this = *this - razlomak;
    }
    Razlomak &amp;operator *=(const Razlomak &amp;razlomak) {
        return *this = *this * razlomak;
    }
    Razlomak &amp;operator /=(const Razlomak &amp;razlomak) {
        return *this = *this / razlomak;
</font>    }
    operator long double() const {
        return (long double)(brojnik) / (long double)(nazivnik);
    }
    
    friend Razlomak operator +(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
    friend Razlomak operator -(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
<a name="1"></a><font color="#00FF00"><a href="match819-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    friend Razlomak operator *(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
    friend Razlomak operator /(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
    friend Razlomak operator +(const Razlomak &amp;razlomak);
    friend Razlomak operator -(const Razlomak &amp;razlomak);
    friend Razlomak &amp;operator ++(Razlomak &amp;razlomak);
</font>    friend Razlomak operator ++(Razlomak &amp;razlomak, int broj);
    friend Razlomak &amp;operator --(Razlomak &amp;razlomak);
    friend Razlomak operator --(Razlomak &amp;razlomak, int broj);
    friend bool operator &lt;(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
    friend bool operator &gt;(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
    friend bool operator &lt;=(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
    friend bool operator &gt;=(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
    friend bool operator ==(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
    friend bool operator !=(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2);
    friend ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;razlomak);
    friend istream &amp;operator &gt;&gt;(istream &amp;tok, Razlomak &amp;razlomak);
    
    
};

long long int Razlomak::NZD(long long int p, long long int q) {
    if(q == 0){
        return p;
    } else {
        return NZD(q, p%q);
    }
}

Razlomak::Razlomak(long long int brojnik, long long int nazivnik) {
    if(nazivnik &lt; 0) {
        nazivnik*=-1;
        brojnik*=-1;
    }
    Razlomak::brojnik=brojnik/NZD(abs(brojnik),abs(nazivnik));
    Razlomak::nazivnik=nazivnik/NZD(abs(brojnik),abs(nazivnik));
}

Razlomak::Razlomak(const initializer_list&lt;long long int&gt; &amp;lista) {
    if(lista.size()==0) {
        brojnik=0;
        nazivnik=1;
    } else if(lista.size()==1) {
        brojnik=*lista.begin();
        nazivnik=1;
    } else if(lista.size()==2) {
        initializer_list&lt;long long int&gt;::iterator it(lista.begin());
        brojnik=*it/NZD(abs(*it),abs(*(it+1)));
        nazivnik=*(it+1)/NZD(abs(*it),abs(*(it+1)));
    }
}

<a name="2"></a><font color="#0000FF"><a href="match819-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

Razlomak operator +(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    long long int p1(razlomak1.DajBrojnik()), p2(razlomak2.DajBrojnik()), q1(razlomak1.DajNazivnik()), q2(razlomak2.DajNazivnik()), m(numeric_limits&lt;long long int&gt;::min()), M(numeric_limits&lt;long long int&gt;::max());
</font>    long long int r(Razlomak::NZD(abs(q1),abs(q2)));
    long long int temp1(q2/r), temp2(q1/r);
    if(temp1&gt;=0) {
        if(p1&lt;m/temp1 || p1&gt;M/temp1) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(p1==m || -p1&gt;M/(-temp1) || -p1&lt;m/(-temp1)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    long long int temp3(p1*temp1);
    if(temp2&gt;=0) {
        if(p2&lt;m/temp2 || p2&gt;M/temp2) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(p2==m || -p2&gt;M/(-temp2) || -p2&lt;m/(-temp2)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    long long int temp4(p2*temp2);
    if(temp1&gt;=0) {
        if(q1&lt;m/temp1 || q1&gt;M/temp1) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(q1==m || -q1&gt;M/(-temp1) || -q1&lt;m/(-temp1)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    long long int temp5(q1*temp1);
    if(temp4&gt;=0) {
        if(temp3&gt;M-temp4) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(temp3&lt;m-temp4) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    return Razlomak(temp3 + temp4, temp5);
}

<a name="3"></a><font color="#00FFFF"><a href="match819-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

Razlomak operator -(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    long long int p1(razlomak1.DajBrojnik()), p2(razlomak2.DajBrojnik()), q1(razlomak1.DajNazivnik()), q2(razlomak2.DajNazivnik()), m(numeric_limits&lt;long long int&gt;::min()), M(numeric_limits&lt;long long int&gt;::max());
</font>    long long int r(Razlomak::NZD(abs(q1),abs(q2)));
    long long int temp1(q2/r), temp2(q1/r);
    if(temp1&gt;=0) {
        if(p1&lt;m/temp1 || p1&gt;M/temp1) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(p1==m || -p1&gt;M/(-temp1) || -p1&lt;m/(-temp1)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    long long int temp3(p1*temp1);
    if(temp2&gt;=0) {
        if(p2&lt;m/temp2 || p2&gt;M/temp2) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(p2==m || -p2&gt;M/(-temp2) || -p2&lt;m/(-temp2)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    long long int temp4(p2*temp2);
    if(temp1&gt;=0) {
        if(q1&lt;m/temp1 || q1&gt;M/temp1) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(q1==m || -q1&gt;M/(-temp1) || -q1&lt;m/(-temp1)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    long long int temp5(q1*temp1);
    if(temp4&gt;=0) {
        if(temp3&lt;m+temp4) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(temp3&gt;M+temp4) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    return Razlomak(temp3 - temp4, temp5);
}

<a name="4"></a><font color="#FF00FF"><a href="match819-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

Razlomak operator *(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    long long int p1(razlomak1.DajBrojnik()), p2(razlomak2.DajBrojnik()), q1(razlomak1.DajNazivnik()), q2(razlomak2.DajNazivnik()), m(numeric_limits&lt;long long int&gt;::min()), M(numeric_limits&lt;long long int&gt;::max());
</font>    long long int s(Razlomak::NZD(abs(p1), abs(q2))), t(Razlomak::NZD(abs(p2),abs(q1)));
    long long int temp1(p1/s), temp2(p2/t), temp3(q1/t), temp4(q2/s);
    if(temp2&gt;=0) {
        if(temp1&lt;m/temp2 || temp1&gt;M/temp2) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(temp1==m || -temp1&gt;M/(-temp2) || -temp1&lt;m/(-temp2)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    if(temp4&gt;=0) {
        if(temp3&lt;m/temp4 || temp3&gt;M/temp4) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(temp3==m || -temp3&gt;M/(-temp4) || -temp3&lt;m/(-temp4)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    return Razlomak(temp1*temp2, temp3*temp4);
}

<a name="5"></a><font color="#FF0000"><a href="match819-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

Razlomak operator /(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    long long int p1(razlomak1.DajBrojnik()), p2(razlomak2.DajBrojnik()), q1(razlomak1.DajNazivnik()), q2(razlomak2.DajNazivnik()), m(numeric_limits&lt;long long int&gt;::min()), M(numeric_limits&lt;long long int&gt;::max());
</font>    long long int u(Razlomak::NZD(abs(p1),abs(p2))), r(Razlomak::NZD(abs(q1),abs(q2)));
    long long int temp1(p1/u), temp2(q2/r), temp3(q1/r), temp4(p2/u);
    if(temp2&gt;=0) {
        if(temp1&lt;m/temp2 || temp1&gt;M/temp2) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(temp1==m || -temp1&gt;M/(-temp2) || -temp1&lt;m/(-temp2)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    if(temp4&gt;=0) {
        if(temp3&lt;m/temp4 || temp3&gt;M/temp4) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else {
        if(temp3==m || -temp3&gt;M/(-temp4) || -temp3&lt;m/(-temp4)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    return Razlomak(temp1*temp2, temp3*temp4);
}

Razlomak operator +(const Razlomak &amp;razlomak) {
    return razlomak;
}

Razlomak operator -(const Razlomak &amp;razlomak) {
    if(razlomak.brojnik == numeric_limits&lt;long long int&gt;::min())
        throw overflow_error("Nemoguce dobiti tacan rezultat");
    return Razlomak(-razlomak.brojnik, razlomak.nazivnik);
}

Razlomak &amp;operator ++(Razlomak &amp;razlomak) {
    long long int M(numeric_limits&lt;long long int&gt;::max());
    if(razlomak.brojnik&gt;M-1)
        throw overflow_error("Nemoguce dobiti tacan rezultat");
    razlomak.brojnik = razlomak.brojnik + 1;
    return razlomak;
}

Razlomak operator ++(Razlomak &amp;razlomak, int broj) {
    Razlomak temp(razlomak);
    ++razlomak;
    return temp;
}

Razlomak &amp;operator --(Razlomak &amp;razlomak) {
    long long int m(numeric_limits&lt;long long int&gt;::min());
    if(razlomak.brojnik&lt;m+1)
        throw overflow_error("Nemoguce dobiti tacan rezultat");
    razlomak.brojnik = razlomak.brojnik - 1;
    return razlomak;
}

Razlomak operator --(Razlomak &amp;razlomak, int broj) {
    Razlomak temp(razlomak);
    --razlomak;
    return temp;
}

bool operator &lt;(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    return (long double)(razlomak1) &lt; (long double)(razlomak2);
}

bool operator &gt;(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    return (long double)(razlomak1) &lt; (long double)(razlomak2);
}

bool operator ==(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    long double eps(0.0000000000000001);
    return fabs((long double)(razlomak1) - (long double)(razlomak2)) &lt; eps;
}

bool operator &lt;=(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    return razlomak1 &lt; razlomak2 || razlomak1 == razlomak2;
}

bool operator &gt;=(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    return razlomak1 &gt; razlomak2 || razlomak1 == razlomak2;
}

bool operator !=(const Razlomak &amp;razlomak1, const Razlomak &amp;razlomak2) {
    return !(razlomak1 == razlomak2);
}

ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;razlomak) {
    if(razlomak.nazivnik != 1) {
        tok &lt;&lt; razlomak.brojnik &lt;&lt; "/" &lt;&lt; razlomak.nazivnik;
    } else {
        tok &lt;&lt; razlomak.brojnik;
    }
    return tok;
}

//popraviti
istream &amp;operator &gt;&gt;(istream &amp;tok, Razlomak &amp;razlomak) {
    long long int brojnik(0), nazivnik(1);
    char znak(0);
    tok &gt;&gt; brojnik;
    znak = tok.peek();
    if(znak &lt;= 32 || znak == '\n' || znak == ' ') {
        tok.get();
        nazivnik = 1;
        razlomak = Razlomak(brojnik, nazivnik);
    } else if(znak == '/') {
        tok.get();
        tok &gt;&gt; nazivnik;
        znak = tok.peek();
        if(znak &gt; 32) {
            tok.setstate(ios::failbit);
            return tok;
        }
        razlomak = Razlomak(brojnik, nazivnik);
    } else {
        tok.setstate(ios::failbit);
    }
    return tok;
}

int main() {
    //orbob
    Razlomak r1(166,77232);
    Razlomak r2(1375,6366);
    cout &lt;&lt; r1 &lt;&lt; " " &lt;&lt; r2 &lt;&lt; endl;
    Razlomak r3(r1 - r2);
    Razlomak r4(r3);
    if(r3 != r4) {
        cout &lt;&lt; "Nije jednako" &lt;&lt; endl;
    } else if(r3 == r4) {
        cout &lt;&lt; "Jednako" &lt;&lt; endl;
    }
    if(r3 &gt;= r2) {
        cout &lt;&lt; "R2 manje jednako od R3" &lt;&lt; endl;
    } else if (r3 &lt; r2) {
        cout &lt;&lt; "R3 manje od R2" &lt;&lt; endl;
    }
    ++r3;
    r2--;
    r1++;
    ------r4;
    cout &lt;&lt; -r3 &lt;&lt; " " &lt;&lt; r3 &lt;&lt; " " &lt;&lt; +r2 &lt;&lt; endl;
    Razlomak r6(r3 + r1), r7({2,3}), r9{3,4};
    cout &lt;&lt; r6 &lt;&lt; " " &lt;&lt; r7 &lt;&lt; " " &lt;&lt; r9 &lt;&lt; endl;
    return 0;
}</pre>
</body>
</html>
