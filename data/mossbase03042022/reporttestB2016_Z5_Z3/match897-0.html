<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student3442.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student3442.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;limits&gt;
#include &lt;sstream&gt;
#include &lt;type_traits&gt;

class Razlomak {
    long long int brojnik, nazivnik;
    static long long int EuklidovAlgoritam(long long int a, long long int b);
    static bool DaLiJePrekoracenje(long long int a, long long int b);
    static void IzbaciRazmake(std::string &amp;s);
    static bool DaLiJeBroj(const std::string &amp;s);
public:
    Razlomak() : brojnik(0), nazivnik(1) {}
    Razlomak(long long int brojnik, long long int nazivnik);
    long long int DajBrojnik() const { return brojnik; }
    long long int DajNazivnik() const { return nazivnik; }
    // Binarni operatori
    friend Razlomak operator + (const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak operator - (const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak operator * (const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak operator / (const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak&amp; operator += (Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak&amp; operator -= (Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak&amp; operator *= (Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak&amp; operator /= (Razlomak &amp;r1, const Razlomak &amp;r2);
    // Unarni operatori
    friend Razlomak operator - (const Razlomak &amp;r);
    friend Razlomak operator + (const Razlomak &amp;r);
    friend Razlomak&amp; operator -- (Razlomak &amp;r);
    friend Razlomak operator -- (Razlomak &amp;r, int);
    friend Razlomak&amp; operator ++ (Razlomak &amp;r);
    friend Razlomak operator ++ (Razlomak &amp;r, int);
    // Logicki operatori
    friend bool operator &lt; (const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator &gt; (const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator &lt;= (const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator &gt;= (const Razlomak &amp;r1, const Razlomak &amp;r2);
<a name="0"></a><font color="#FF0000"><a href="match897-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

    friend bool operator == (const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator != (const Razlomak &amp;r1, const Razlomak &amp;r2);
    // Ulazni / Izlazni operatori
    friend std::ostream&amp; operator &lt;&lt; (std::ostream &amp;tok, const Razlomak &amp;r);
    friend std::istream&amp; operator &gt;&gt; (std::istream &amp;tok, Razlomak &amp;r);
    // konverzija tipa razlomak u tip long double
    operator long double() const ;
};

Razlomak::Razlomak(long long int brojnik, long long int nazivnik = 1) {
</font>    if(nazivnik == 0) throw std::logic_error("Nekoretan razlomak");
    auto NZD = EuklidovAlgoritam(brojnik, nazivnik);
    brojnik /= NZD; nazivnik /= NZD;
    if(nazivnik &lt; 0) {
        nazivnik *= -1; brojnik *= -1;
    }
    Razlomak::brojnik = brojnik;
    Razlomak::nazivnik = nazivnik;
}
long long int Razlomak::EuklidovAlgoritam(long long int a, long long int b) {
    if(b == 0) return a;
    return EuklidovAlgoritam(b, a % b);
}

// Binarni operatori
Razlomak operator + (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    auto r = Razlomak::EuklidovAlgoritam(r1.nazivnik, r2.nazivnik);
    auto a = (r1.brojnik * (r2.nazivnik/r)) + r2.brojnik * (r1.nazivnik/r);
    auto b = r1.nazivnik * (r2.nazivnik/r);
    return Razlomak(a, b);
}
Razlomak operator - (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    auto r = Razlomak::EuklidovAlgoritam(r1.nazivnik, r2.nazivnik);
    auto a = (r1.brojnik * (r2.nazivnik/r)) - r2.brojnik * (r1.nazivnik/r);
    auto b = r1.nazivnik * (r2.nazivnik/r);
<a name="2"></a><font color="#0000FF"><a href="match897-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    return Razlomak(a, b);
}
Razlomak operator * (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    auto s = Razlomak::EuklidovAlgoritam(r1.brojnik, r2.nazivnik);
    auto t = Razlomak::EuklidovAlgoritam(r2.brojnik, r1.nazivnik);
    auto a = (r1.brojnik/s) * (r2.brojnik/t);
</font>    auto b = (r1.nazivnik/t) * (r2.nazivnik/s);
<a name="3"></a><font color="#00FFFF"><a href="match897-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    return Razlomak(a,b);
}
Razlomak operator / (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    auto r = Razlomak::EuklidovAlgoritam(r1.nazivnik, r2.nazivnik);
    auto u = Razlomak::EuklidovAlgoritam(r1.brojnik, r2.brojnik);
    auto a = (r1.brojnik/u) * (r2.nazivnik/r);
</font>    auto b = (r1.nazivnik/r) * (r2.brojnik/u);
    return Razlomak(a,b);
}
Razlomak&amp; operator += (Razlomak &amp;r1, const Razlomak &amp;r2) {
    r1 = r1 + r2;
    return r1;
}
Razlomak&amp; operator -= (Razlomak &amp;r1, const Razlomak &amp;r2) {
    r1 = r1 - r2;
    Razlomak pomocni(r1.brojnik, r1.nazivnik);
    r1 = pomocni;
    return r1;
}
Razlomak&amp; operator *= (Razlomak &amp;r1, const Razlomak &amp;r2) {
    r1 = r1 * r2;
    return r1;
}
Razlomak&amp; operator /= (Razlomak &amp;r1, const Razlomak &amp;r2) {
    r1 = r1 / r2;
    Razlomak pomocni(r1.brojnik, r1.nazivnik);
    r1 = pomocni;
    return r1;
}

// Unarni operatori
Razlomak operator - (const Razlomak &amp;r) {
    return {-r.brojnik, r.nazivnik};
}
Razlomak operator + (const Razlomak &amp;r) {
    return r;
}
Razlomak&amp; operator -- (Razlomak &amp;r) {
    r = r - Razlomak(1,1);
    return r;
}
Razlomak operator -- (Razlomak &amp;r, int) {
    auto original(r);
    --r;
    return original;
}
Razlomak&amp; operator ++ (Razlomak &amp;r) {
    r = r + Razlomak(1,1);
    return r;
}
Razlomak operator ++ (Razlomak &amp;r, int) {
    auto original(r);
    ++r;
    return original;
}

// Logicki operatori
bool operator &lt; (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    auto r = Razlomak::EuklidovAlgoritam(r1.brojnik, r2.nazivnik);
    auto s = Razlomak::EuklidovAlgoritam(r1.nazivnik, r2.nazivnik);
    return (r1.brojnik/r) * (r2.nazivnik/s) &lt; (r2.brojnik/r) * (r1.nazivnik/s);
}
bool operator &gt; (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    auto r = Razlomak::EuklidovAlgoritam(r1.brojnik, r2.nazivnik);
    auto s = Razlomak::EuklidovAlgoritam(r1.nazivnik, r2.nazivnik);
    return (r1.brojnik/r) * (r2.nazivnik/s) &gt; (r2.brojnik/r) * (r1.nazivnik/s);
}
bool operator &lt;= (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    auto r = Razlomak::EuklidovAlgoritam(r1.brojnik, r2.nazivnik);
    auto s = Razlomak::EuklidovAlgoritam(r1.nazivnik, r2.nazivnik);
    return (r1.brojnik/r) * (r2.nazivnik/s) &lt;= (r2.brojnik/r) * (r1.nazivnik/s);
}
bool operator &gt;= (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    auto r = Razlomak::EuklidovAlgoritam(r1.brojnik, r2.nazivnik);
    auto s = Razlomak::EuklidovAlgoritam(r1.nazivnik, r2.nazivnik);
    return (r1.brojnik/r) * (r2.nazivnik/s) &gt;= (r2.brojnik/r) * (r1.nazivnik/s);
}
bool operator == (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    auto a = Razlomak(r1.brojnik, r1.nazivnik);
    auto b = Razlomak(r2.brojnik, r2.nazivnik);
    return a.brojnik == b.brojnik &amp;&amp; a.nazivnik == a.nazivnik;
}
bool operator != (const Razlomak &amp;r1, const Razlomak &amp;r2) {
    return !(r1 == r2);
}

// Ulazni / Izlazni operatori
<a name="1"></a><font color="#00FF00"><a href="match897-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

std::ostream&amp; operator &lt;&lt; (std::ostream &amp;tok, const Razlomak &amp;r) {
    if(r.nazivnik == 1)
        tok &lt;&lt; r.brojnik;
    else
        tok &lt;&lt; r.brojnik &lt;&lt; "/" &lt;&lt; r.nazivnik;
    return tok;
}
std::istream&amp; operator &gt;&gt; (std::istream &amp;tok, Razlomak &amp;r) {
    char znak;
    long long int a = 1, b = 1;
</font>    tok &gt;&gt; std::ws &gt;&gt; a;
    if(tok.peek() == '/') {
        tok &gt;&gt; znak &gt;&gt; b;
        if(tok.peek() != ' ' &amp;&amp; tok.peek() != '\t' &amp;&amp; tok.peek() != '\n' &amp;&amp; tok.peek() != '\v' &amp;&amp; tok.peek() != '\f')
            tok.setstate(std::ios::failbit);
    }
    Razlomak pomocni(a,b); 
    r = pomocni;
    return tok;
}

// konverzija tipa razlomak u tip long double
Razlomak::operator long double() const {
    Razlomak pomocni(brojnik, nazivnik);
    return pomocni.brojnik / static_cast&lt;long double&gt;(pomocni.nazivnik);
}

// ---------------------------------- Test funkcije ----------------------------------

long long int Test(long long int a, long long int b) {
    if(b == 0) return a;
    return Test(b, a % b);
}
void Razlomak::IzbaciRazmake(std::string &amp;s) {
    std::string pomocni;
    for(auto &amp;x : s) 
        if(x != ' ') 
            pomocni.push_back(x);
    s = pomocni;
}
bool Razlomak::DaLiJeBroj(const std::string &amp;s) {
    for(auto &amp;x : s) 
        if(!(x &gt;= '0' &amp;&amp; x &lt;= '9'))
            return false;
    return true;
}

// ---------------------------------- Test funkcije ----------------------------------

int main() {
    std::cout &lt;&lt; "Unesite dva razlomka u formatu a/b\n";
    std::cout &lt;&lt; "Unesite 1. razlomak: "; 
    Razlomak r1; std::cin &gt;&gt; r1;
    std::cout &lt;&lt; "Unesite brojnik i nazivnik drugog ralomaka: ";
    long long int brojnik, nazivnik; std::cin &gt;&gt; brojnik &gt;&gt; nazivnik;
    Razlomak r2(brojnik, nazivnik);
    
    while(true) {
        try {
            std::cout &lt;&lt; std::endl;
            std::cout &lt;&lt; "Odaberite opciju:\n";
            
            std::cout &lt;&lt; "1 - Ispis ralomaka" &lt;&lt; std::endl;
            std::cout &lt;&lt; "2 - Binarni operatori" &lt;&lt; std::endl;
            std::cout &lt;&lt; "3 - Unarni operatori" &lt;&lt; std::endl;
            std::cout &lt;&lt; "4 - Logicki operatori" &lt;&lt; std::endl;
            std::cout &lt;&lt; "5 - Rezultat dva razlomka" &lt;&lt; std::endl;
            std::cout &lt;&lt; "6 - Izlaz" &lt;&lt; std::endl;
            
            std::cout &lt;&lt; "Opcija: ";
            int opcija; std::cin &gt;&gt; opcija;
            
            if(opcija == 1) {
                std::cout &lt;&lt; "Prvi razlomak: " &lt;&lt; r1.DajBrojnik() &lt;&lt; "/" &lt;&lt; r1.DajNazivnik();
                std::cout &lt;&lt; "\nDrugi razlomak: " &lt;&lt; r2;
            }
            else if(opcija == 2) {
                std::cout &lt;&lt; "operator + : " &lt;&lt; r1 + r2;
                std::cout &lt;&lt; "\noperator - : " &lt;&lt; r1 - r2;
                std::cout &lt;&lt; "\noperator * : " &lt;&lt; r1 * r2;
                std::cout &lt;&lt; "\noperator / : " &lt;&lt; r1 / r2;
                r1 += r2;
                std::cout &lt;&lt; "\noperator += : " &lt;&lt; r1;
                r1 -= r2;
                std::cout &lt;&lt; "\noperator -= : " &lt;&lt; r1;
                r1 *= r2;
                std::cout &lt;&lt; "\noperator *= : " &lt;&lt; r1;
                r1 /= r2;
                std::cout &lt;&lt; "\noperator /= : " &lt;&lt; r1;
            }
            else if(opcija == 3) {
                std::cout &lt;&lt; "Svi unarni operatori su primijenjeni na prvi razlomak:\n";
                std::cout &lt;&lt; "\noperator - : " &lt;&lt; -r1;
                std::cout &lt;&lt; "\noperator + : " &lt;&lt; +r1;
                std::cout &lt;&lt; "\noperator -- (prefiksni) : " &lt;&lt; --r1;
                std::cout &lt;&lt; "\noperator -- : " &lt;&lt; r1-- &lt;&lt; " " &lt;&lt; r1;
                std::cout &lt;&lt; "\noperator ++ (prefiksni) : " &lt;&lt; ++r1;
                std::cout &lt;&lt; "\noperator ++ : " &lt;&lt; r1++ &lt;&lt; " " &lt;&lt; r1;
            }
            else if(opcija == 4) {
                std::cout &lt;&lt; "operator &lt; : " &lt;&lt; std::boolalpha &lt;&lt; (r1 &lt; r2);
                std::cout &lt;&lt; "\noperator &gt; : " &lt;&lt; std::boolalpha &lt;&lt; (r1 &gt; r2);
                std::cout &lt;&lt; "\noperator &lt;= : " &lt;&lt; std::boolalpha &lt;&lt; (r1 &lt;= r2);
                std::cout &lt;&lt; "\noperator &gt;= : " &lt;&lt; std::boolalpha &lt;&lt; (r1 &gt;= r2);
                std::cout &lt;&lt; "\noperator == : " &lt;&lt; std::boolalpha &lt;&lt; (r1 == r2);
                std::cout &lt;&lt; "\noperator != : " &lt;&lt; std::boolalpha &lt;&lt; (r1 != r2);
            }
            else if(opcija == 5) {
                std::cout &lt;&lt; "Rezultat ralomka 1: " &lt;&lt; static_cast&lt;long double&gt;(r1);
                std::cout &lt;&lt; "\nRezultat ralomka 2: " &lt;&lt; static_cast&lt;long double&gt;(r2);
            }
            else if(opcija == 6) {
                break;
            }
            else {
                std::cout &lt;&lt; "Greska pri unosu opcije\n";
            }
        }
        catch(...) {
            std::cout &lt;&lt; "\nGreska";
            break;
        }
    }
	return 0;
}</pre>
</body>
</html>
