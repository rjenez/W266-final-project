<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student3219.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student3219.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
#define eps 1E-18
#define M LLONG_MAX
#define m LLONG_MIN

using namespace std;

<a name="4"></a><font color="#FF00FF"><a href="match781-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

class Razlomak {
    long long int brojnik,nazivnik;
    static long long int NZD(long long int p, long long int q) {p=abs(p);  long long int p1; while(1) { p1=p%q; p=q; q=p1; if(q==0) break; } return p; }
</font>    static bool Isti(long double p, long double d) { if( fabs(p-d)&lt;=eps*(fabs(p)+ fabs(d))) return true; else return false; }
    static bool t_s(long long int x, long long int y)   { if(y&gt;0) { if(x&gt;M-y) return true; return false; } else { if(x&lt;m-y) return true; return false; } }
<a name="3"></a><font color="#00FFFF"><a href="match781-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    static bool t_o(long long int x, long long int y)   { y=-y; if(y&gt;0) { if(x&gt;M-y) return true; return false; } else { if(x&lt;m-y) return true; return false; } }
    static bool t_m(long long int x, long long int y)   { if(y&gt;0) { if(x&lt;m/y || x&gt;M/y) return true; return false; } else { if(x==m || -x&gt;M/(-y) || -x&lt;m/(-y)) return true; return false; } }
</font><a name="5"></a><font color="#FF0000"><a href="match781-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

   
    public:
</font>    Razlomak(long long int b=0,long long int n=1);
    Razlomak(initializer_list&lt;long long int&gt;  b_n);
    long long int DajBrojnik() const { return brojnik; };
    long long int DajNazivnik() const { return nazivnik; };
    friend Razlomak operator +(Razlomak r1, const Razlomak &amp;r2);
    friend Razlomak operator -(Razlomak r1, const Razlomak &amp;r2);
    friend Razlomak operator *(Razlomak r1, const Razlomak &amp;r2);
    friend Razlomak operator /(Razlomak r1, const Razlomak &amp;r2);
    friend Razlomak operator +(const Razlomak &amp;r1);
    friend Razlomak operator -(Razlomak &amp;r1);
    friend Razlomak &amp;operator +=(Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak &amp;operator -=(Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak &amp;operator *=(Razlomak &amp;r1, const Razlomak &amp;r2);
<a name="0"></a><font color="#FF0000"><a href="match781-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    friend Razlomak &amp;operator /=(Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak &amp;operator ++(Razlomak &amp;r1);
    friend Razlomak &amp;operator --(Razlomak &amp;r1);
    friend Razlomak operator ++(Razlomak &amp;r1, int);
    friend Razlomak operator --(Razlomak &amp;r1, int);
</font>    friend bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;r1);
    friend istream &amp;operator &gt;&gt;(istream &amp;tok,Razlomak &amp;r1);
    explicit operator long double() const { return (double)brojnik/nazivnik; }
    
    
};

    Razlomak::Razlomak(long long int b, long long int n) {
        if(n&lt;0) { n*=(-1); b*=(-1); }
        
        if(n==0) throw logic_error ("Nekorektan razlomak");
        int nzd=NZD(b,n);
        b/=nzd;
        n/=nzd;
        brojnik=b; nazivnik=n;
    }
    Razlomak::Razlomak(initializer_list&lt;long long int&gt;  b_n) {
        if(b_n.size()==1) { 
            auto it=b_n.begin();
            brojnik=*it;
            nazivnik=1;
        }
        else{
            auto it=b_n.begin();
            auto it2=it; it2++;
            int nzd=NZD(*it,*it2);
            brojnik=*it/nzd;
            nazivnik=*it2/nzd;
        }
    }
    Razlomak operator +(Razlomak r1, const Razlomak &amp;r2) {
        r1+=r2;
        Razlomak r3(r1.brojnik,r1.nazivnik);
        return r3;
    }            
    Razlomak operator -(Razlomak r1, const Razlomak &amp;r2) {
        r1-=r2;
        Razlomak r3(r1.brojnik,r1.nazivnik);
        return r3;
    }
    Razlomak operator *(Razlomak r1, const Razlomak &amp;r2) {
        r1*=r2;
        Razlomak r3(r1.brojnik,r1.nazivnik);
        
        return r3;
    }
    Razlomak operator /(Razlomak r1, const Razlomak &amp;r2) {
        r1/=r2;
        Razlomak r3(r1.brojnik,r1.nazivnik);
        return r3;
    }
    Razlomak operator +(const Razlomak &amp;r1) {
        return r1;
    }
    Razlomak operator -(Razlomak &amp;r1) {
        if(r1.brojnik==m) throw overflow_error ("Nemoguce dobiti tacan rezultat");
        r1.brojnik=-r1.brojnik;
        return r1;
    }
    Razlomak &amp;operator +=(Razlomak &amp;r1, const Razlomak &amp;r2) {
        Razlomak pom(r1);
        int r=Razlomak::NZD(r1.DajNazivnik(),r2.DajNazivnik());
        if(Razlomak::t_m(pom.brojnik, r2.nazivnik/r) || Razlomak::t_m(r2.brojnik, pom.nazivnik/r) || Razlomak::t_m(pom.nazivnik, r2.nazivnik/r) || Razlomak::t_s(pom.brojnik*(r2.nazivnik/r), r2.brojnik*(pom.nazivnik/r))) throw overflow_error ("Nemoguce dobiti tacan rezultat");
        r1.brojnik=pom.brojnik*(r2.nazivnik/r) + r2.brojnik*(pom.nazivnik/r);
        r1.nazivnik=pom.nazivnik*(r2.nazivnik/r);
        return r1;
    }
    Razlomak &amp;operator -=(Razlomak &amp;r1, const Razlomak &amp;r2) {
        Razlomak pom(r1);
        int r=Razlomak::NZD(r1.nazivnik,r2.nazivnik);
        if(Razlomak::t_m(pom.brojnik, r2.nazivnik/r) || Razlomak::t_m(r2.brojnik, pom.nazivnik/r) || Razlomak::t_m(pom.nazivnik, r2.nazivnik/r) || Razlomak::t_o(pom.brojnik*(r2.nazivnik/r), r2.brojnik*(pom.nazivnik/r))) throw overflow_error ("Nemoguce dobiti tacan rezultat");
<a name="2"></a><font color="#0000FF"><a href="match781-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        r1.brojnik=pom.brojnik*(r2.nazivnik/r) - r2.brojnik*(pom.nazivnik/r);
        r1.nazivnik=pom.nazivnik*(r2.nazivnik/r);
</font>        return r1;
    }
    Razlomak &amp;operator *=(Razlomak &amp;r1, const Razlomak &amp;r2) {
        int s=Razlomak::NZD(r1.brojnik,r2.nazivnik);
        int t=Razlomak::NZD(r2.brojnik,r1.nazivnik);
        Razlomak pom(r1);
        if(Razlomak::t_m(pom.brojnik/s, r2.brojnik/t) || Razlomak::t_m(pom.nazivnik/t, r2.nazivnik/s)) throw overflow_error ("Nemoguce dobiti tacan rezultat");
        r1.brojnik=(pom.brojnik/s)*(r2.brojnik/t);
        r1.nazivnik=(pom.nazivnik/t)*(r2.nazivnik/s);
        return r1;
    }
    Razlomak &amp;operator /=(Razlomak &amp;r1, const Razlomak &amp;r2) {
        int r=Razlomak::NZD(r1.nazivnik,r2.nazivnik);
        int u=Razlomak::NZD(r1.brojnik,r2.brojnik);
        Razlomak pom(r1);
        if(Razlomak::t_m(pom.brojnik/u, r2.nazivnik/r) || Razlomak::t_m(pom.nazivnik/r, r2.brojnik/u)) throw overflow_error ("Nemoguce dobiti tacan rezultat");
        r1.brojnik=(pom.brojnik/u)*(r2.nazivnik/r);
        r1.nazivnik=(pom.nazivnik/r)*(r2.brojnik/u);
        return r1;
    }
    Razlomak &amp;operator ++(Razlomak &amp;r1) {
        Razlomak jedan(1);
        return r1+=jedan;
    }
    Razlomak &amp;operator --(Razlomak &amp;r1) {
        Razlomak jedan(1);
        return r1-=jedan;
    }
    Razlomak operator ++(Razlomak &amp;r1, int) {
        Razlomak jedan(1);
        Razlomak pom(r1.brojnik,r1.nazivnik);
        r1+=jedan;
        return pom;
    }
    Razlomak operator --(Razlomak &amp;r1, int) {
        Razlomak jedan(1);
        Razlomak pom(r1.brojnik,r1.nazivnik);
        r1-=jedan;
        return pom;
    }
    bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2) {
        long double prvi=(double)r1.brojnik/r1.nazivnik;
        long double drugi=(double)r2.brojnik/r2.nazivnik;
        return prvi&lt;drugi;
    }
    bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2) {
        long double prvi=(double)r1.brojnik/r1.nazivnik;
        long double drugi=(double)r2.brojnik/r2.nazivnik;
        return prvi&gt;drugi;
    }
    bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2) {
        long double prvi=(double)r1.brojnik/r1.nazivnik;
        long double drugi=(double)r2.brojnik/r2.nazivnik;
        if(prvi&lt;drugi || Razlomak::Isti(prvi,drugi)) return true;
        else return false;
    }
    bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2) {
        long double prvi=(double)r1.brojnik/r1.nazivnik;
        long double drugi=(double)r2.brojnik/r2.nazivnik;
        if(prvi&gt;drugi || Razlomak::Isti(prvi,drugi)) return true;
        else return false;
    }
    bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2) {
        long double prvi=(double)r1.brojnik/r1.nazivnik;
        long double drugi=(double)r2.brojnik/r2.nazivnik;
        return Razlomak::Isti(prvi,drugi);
    }
    bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2) {
        long double prvi=(double)r1.brojnik/r1.nazivnik;
        long double drugi=(double)r2.brojnik/r2.nazivnik;
        return !Razlomak::Isti(prvi,drugi);
    }
    ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;r1) {
        if(r1.nazivnik==1) tok&lt;&lt;r1.brojnik;
        else tok&lt;&lt;r1.brojnik&lt;&lt;"/"&lt;&lt;r1.nazivnik;
        return tok;
    }
<a name="1"></a><font color="#00FF00"><a href="match781-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    istream &amp;operator &gt;&gt;(istream &amp;tok,Razlomak &amp;r1) {
        char znak;
        tok&gt;&gt;std::ws;
        tok&gt;&gt;r1.brojnik;
        if(tok.peek()!= '/') { r1.nazivnik=1; return tok; }
        else {
            tok&gt;&gt;znak&gt;&gt;r1.nazivnik;
</font><a name="6"></a><font color="#00FF00"><a href="match781-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        }
        if(tok.peek()!=' ' &amp;&amp; tok.peek()!='\t' &amp;&amp; tok.peek()!='\n' &amp;&amp; tok.peek()!='\v' &amp;&amp; tok.peek()!='\f') tok.setstate(std::ios::failbit);
</font>        int nzd=Razlomak::NZD(r1.brojnik,r1.nazivnik);
        r1.brojnik/=nzd;
        r1.nazivnik/=nzd;
        
       
        return tok;
    }

   
int main ()
{
    Razlomak r (127,17), t (57,11);
    cout&lt;&lt;"Zbir 127/17 i 57/11 je: "&lt;&lt; r + t &lt;&lt;endl;
    cout&lt;&lt;"Razlika 127/17 i 57/11 je: "&lt;&lt; r - t &lt;&lt;endl;
    cout&lt;&lt;"Proizvod 127/17 i 57/11 je: "&lt;&lt; r * t &lt;&lt;endl;
    cout&lt;&lt;"Kolicnik 127/17 i 57/11 je: "&lt;&lt; r / t &lt;&lt;endl;
    cout&lt;&lt;"Prefiksno inkrementirani daju sljedece razlomke: "&lt;&lt; ++r &lt;&lt;" "&lt;&lt;++t&lt;&lt;endl;
    cout&lt;&lt;"Postfiksno dekrementirani daju: "&lt;&lt;r-- &lt;&lt;" "&lt;&lt;t--&lt;&lt; " a oni su sada: "&lt;&lt;r&lt;&lt;" "&lt;&lt;t&lt;&lt;endl;
    t+=r;
    t-=r;
    t*=r;
    t/=r;
    cout&lt;&lt;"Nakon izvodjenja operatora += , -= , *= i /= razlomci su: "&lt;&lt;r&lt;&lt;" "&lt;&lt;t&lt;&lt;endl;
	return 0;
}</pre>
</body>
</html>
