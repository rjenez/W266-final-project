<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student5370.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student5370.cpp<p></p><pre>
<a name="1"></a><font color="#00FF00"><a href="match73-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_18.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise

#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;stdexcept&gt;

using std::cout;
using std::cin;
using std::numeric_limits;
using std::overflow_error;
using std::ostream;

typedef long long int llint;

const llint M = numeric_limits&lt;llint&gt;::max(), m = numeric_limits&lt;llint&gt;::min();

class Razlomak {
    
    long long int brojnik, nazivnik;
    
    static llint NZD(llint p, llint q);
    static llint plus(llint p, llint q);
    static llint minus(llint p, llint q);
    static llint puta(llint p, llint q);
    static llint dijeli(llint p, llint q);
    
    // Binarni ne-relacioni
    friend Razlomak &amp;operator +=(Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak operator +(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak &amp;operator -=(Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak operator -(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak &amp;operator *=(Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak operator *(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak &amp;operator /=(Razlomak &amp;r1, const Razlomak &amp;r2);
    friend Razlomak operator /(const Razlomak &amp;r1, const Razlomak &amp;r2);
    
    // Unarni
    friend Razlomak operator +(const Razlomak &amp;r);
    friend Razlomak operator -(const Razlomak &amp;r);
    friend Razlomak &amp;operator ++(Razlomak &amp;r1);
    friend Razlomak operator ++(Razlomak &amp;r1, int);
    friend Razlomak &amp;operator --(Razlomak &amp;r1);
    friend Razlomak operator --(Razlomak &amp;r1, int);
    
    // Binarni relacioni
    friend bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2);
</font><a name="0"></a><font color="#FF0000"><a href="match73-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_79.gif"/></a>

    friend bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2);
    friend bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2);
    
    // I/O
    friend ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;r);

    public :
        Razlomak(llint brojnik = 0, llint nazivnik = 1);
        
        operator long double() const;
        
        llint DajBrojnik() const { return brojnik; }
        llint DajNazivnik() const { return nazivnik; }
};

llint Razlomak::NZD(llint p, llint q) {
    llint temp;
    while(q != 0) {
        temp = p;
        p = q;
        q = temp % q;
    }
    
    return p;
}

Razlomak::Razlomak(llint brojnik, llint nazivnik)
{
    int predznak1, predznak2;
    predznak1 = brojnik &lt; 0 ? -1 : 1;
    predznak2 = nazivnik &lt; 0 ? -1 : 1;
    
    if (brojnik == nazivnik) {
        brojnik = 1; nazivnik = 1;
        predznak1 = 1; predznak2 = 1;
    } else if (predznak1 == -1 &amp;&amp; predznak2 == -1) {
        if (brojnik == m || nazivnik == m) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
        brojnik *= -1; nazivnik *= -1;
        predznak1 = 1; predznak2 = 1;
    } else if (predznak1 == -1) {
        if (brojnik == m) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
        brojnik *= -1;
    } else if (predznak2 == -1) {
        if (nazivnik == m) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
        nazivnik *= -1;
        predznak1 = -1;
        predznak2 = 1;
    }
    
    llint nzd = NZD(brojnik, nazivnik); // Moze i obicni int? maxint * maxint?
    
    Razlomak::brojnik = predznak1 * brojnik / nzd;
    Razlomak::nazivnik = nazivnik / nzd;
}

llint Razlomak::plus(llint p, llint q)
{
    if (q &gt; 0) {
        if (p &gt; M - q) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else if (q &lt; 0) {
        if (p &lt; m - q) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    
    return p + q;
}

llint Razlomak::minus(llint p, llint q) {
    if (q == m) {
        if (p &gt; -1) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        } else {
            return plus(p + 1, M);
        }
    }
    
    return plus(p, -q);
}

llint Razlomak::puta(llint p, llint q)
{
    if (q &gt; 0) {
        if ((p &lt; m / q) || (p &gt; M / q)) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    } else if (q &lt; 0) {
        if ( p == m || ((-p) &lt; m / (-q)) || ((-p) &gt; M / (-q)) ) {
            throw overflow_error("Nemoguce dobiti tacan rezultat");
        }
    }
    
    return p * q;
}

llint Razlomak::dijeli(llint p, llint q) {
    return puta(p, 1 / q);
}


Razlomak &amp;operator +=(Razlomak &amp;r1, const Razlomak &amp;r2)
{
    llint b1(r1.brojnik), n1(r1.nazivnik), b2(r2.brojnik), n2(r2.nazivnik), nzd = Razlomak::NZD(n1, n2);
    
    b1 = Razlomak::plus( Razlomak::puta(b1, n2 / nzd), Razlomak::puta(b2, n1 / nzd));
    n1 = Razlomak::puta(n1, n2 / nzd);
    
    r1 = Razlomak(b1, n1);

    return r1;
}

Razlomak operator +(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    Razlomak r3(r1);
    r3 += r2;
    return r3;
}

Razlomak &amp;operator -=(Razlomak &amp;r1, const Razlomak &amp;r2)
{
    llint b1(r1.brojnik), n1(r1.nazivnik), b2(r2.brojnik), n2(r2.nazivnik), nzd = Razlomak::NZD(n1, n2);
    
    b1 = Razlomak::minus( Razlomak::puta(b1, n2 / nzd), Razlomak::puta(b2, n1 / nzd));
    n1 = Razlomak::puta(n1, n2 / nzd);
    
    r1 = Razlomak(b1, n1);

    return r1;
}

Razlomak operator -(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    Razlomak r3(r1);
    r3 -= r2;
    return r3;
}

Razlomak &amp;operator *=(Razlomak &amp;r1, const Razlomak &amp;r2)
{
    llint b1(r1.brojnik), n1(r1.nazivnik), b2(r2.brojnik), n2(r2.nazivnik),
        nzd1 = Razlomak::NZD(b1, n2), nzd2 = Razlomak::NZD(b2, n1);
    
    b1 = Razlomak::puta(b1 / nzd1, b2 / nzd2);
    n1 = Razlomak::puta(n1 / nzd2, n2 / nzd1);
    
    r1 = Razlomak(b1, n1);

    return r1;
}

Razlomak operator *(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    Razlomak r3(r1);
    r3 *= r2;
    return r3;
}

Razlomak &amp;operator /=(Razlomak &amp;r1, const Razlomak &amp;r2)
{
    llint b1(r1.brojnik), n1(r1.nazivnik), b2(r2.brojnik), n2(r2.nazivnik),
        nzd1 = Razlomak::NZD(b1, b2), nzd2 = Razlomak::NZD(n1, n2);
    
    b1 = Razlomak::puta(b1 / nzd1, n2 / nzd2);
    n1 = Razlomak::puta(n1 / nzd2, b2 / nzd1);
    
    r1 = Razlomak(b1, n1);

    return r1;
}

Razlomak operator /(const Razlomak &amp;r1, const Razlomak &amp;r2)
{
    Razlomak r3(r1);
    r3 /= r2;
    return r3;
}

Razlomak operator +(const Razlomak &amp;r) {
    return r;
}

Razlomak operator -(const Razlomak &amp;r)
{
    if (r. brojnik == m) {
        throw overflow_error("Nemoguce dobiti tacan rezultat");
    }
    return Razlomak(-r.brojnik, r.nazivnik);
}

Razlomak &amp;operator ++(Razlomak &amp;r1)
{
    r1.brojnik = Razlomak::plus(r1.brojnik, r1.nazivnik);
    return r1;
}

Razlomak operator ++(Razlomak &amp;r1, int)
{
    Razlomak pomocni(r1);
    r1.brojnik = Razlomak::plus(r1.brojnik, r1.nazivnik);
    return pomocni;
}

Razlomak &amp;operator --(Razlomak &amp;r1)
{
    r1.brojnik = Razlomak::minus(r1.brojnik, r1.nazivnik);
    return r1;
}

Razlomak operator --(Razlomak &amp;r1, int)
{
    Razlomak pomocni(r1);
    r1.brojnik = Razlomak::minus(r1.brojnik, r1.nazivnik);
    return pomocni;
}

bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2) {
    return ((long double)r1.brojnik) / r1.nazivnik == ((long double) r2.brojnik / r2.nazivnik);
}

bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2) {
    return !(r1 == r2);
}

bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2) {
    return ((long double)r1.brojnik) / r1.nazivnik &lt;= ((long double) r2.brojnik / r2.nazivnik);
}

bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2) {
    return ((long double)r1.brojnik) / r1.nazivnik &lt; ((long double) r2.brojnik / r2.nazivnik);
}

bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2) {
    return !(r1 &lt; r2);
}

bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2) {
    return !(r1 &lt;= r2);
}

ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;r)
{
    tok &lt;&lt; r.brojnik;
    if (r.nazivnik == 1)
        return tok;
    else
        return tok &lt;&lt; "/" &lt;&lt; r.nazivnik;
}

Razlomak::operator long double() const {
    return ((long double) brojnik) / nazivnik;
}

int main ()
{
    cout &lt;&lt; "Unesite brojeve: \n";
    Razlomak r1(1000, -512), r2(100000000000000, 3);
    cout &lt;&lt; r1 + r2 &lt;&lt; " " &lt;&lt; r1 - r2 &lt;&lt; " " &lt;&lt; r1 * r2 &lt;&lt; " " &lt;&lt; r1 / r2 &lt;&lt; " "
        &lt;&lt; (r1 == r2) &lt;&lt; " " &lt;&lt; (r1 &lt;= r1) &lt;&lt; " " &lt;&lt; (r1 &lt; r2) &lt;&lt; " " &lt;&lt; (r1 &gt;= r2)
        &lt;&lt; " " &lt;&lt; (r1 &gt; r2);
    r1++;
    r2--;
    --r1;
    ++r2;
    cout &lt;&lt; +r1 &lt;&lt; " " &lt;&lt; -r2;
    r1 += r2;
    r1 -= r2;
    r2 *= r1;
    r2 /= r1;
    
    cout &lt;&lt; r1 &lt;&lt; " " &lt;&lt; r2 &lt;&lt; "\n";
    
    try {
        Razlomak(1, m);
    } catch(overflow_error &amp;e) {
        cout &lt;&lt; e.what();
    }
    cout &lt;&lt; "\n";
    
    cout &lt;&lt; 2.45 + (long double)Razlomak{255, 100};
    cout &lt;&lt; Razlomak{5} + Razlomak() + Razlomak{} + Razlomak(1);
    cout &lt;&lt; (int) Razlomak(256, 71);
</font>
	return 0;
}</pre>
</body>
</html>
