<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student6010.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student6010.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;initializer_list&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
class Razlomak{
    long long int brojnik, nazivnik;
    public:
    Razlomak(long long int b=0, long long int n=1) {
        brojnik=b;
        nazivnik=n;
        if(n==0) throw std::logic_error("Nekorektan razlomak");
        auto djelilac=NZD(brojnik, nazivnik);
        brojnik/=djelilac; nazivnik/=djelilac;
        if(nazivnik&lt;0) {brojnik*=-1; nazivnik*=-1;}
    }
    Razlomak(std::initializer_list&lt;long long int&gt; l) {
        if(l.size()&gt;2) throw;
        brojnik=*(l.begin());
        if(l.size()==2) {
        for(auto it=l.begin(); it!= l.end(); it++){
        nazivnik=*it;}}
        else nazivnik=1;
    }
    static long long int NZD(long long int p, long long int q);
    long long int DajBrojnik() const {return brojnik;}
    long long int DajNazivnik() const {return nazivnik;}
    bool MozeLiSeMnoziti(long long int zamnozenje1, long long int zamnozenje2) {
         if(zamnozenje2&gt;0 &amp;&amp; (zamnozenje1&lt;LLONG_MIN/zamnozenje2 || zamnozenje1&gt;LLONG_MAX/zamnozenje2)) return false;
        else if(zamnozenje2&lt;0 &amp;&amp; (zamnozenje1==LLONG_MIN || -zamnozenje1&gt;LLONG_MAX/(-zamnozenje2) || -zamnozenje1&lt;LLONG_MIN/(-zamnozenje2))) return false;
        return true;
    }
 bool MozeLiSeSabrati(long long int zasabiranje1, long long int zasabiranje2) {
         if(zasabiranje2&gt;0 &amp;&amp; zasabiranje1&gt;LLONG_MAX-zasabiranje2) return false;
        else if(zasabiranje2&lt;0 &amp;&amp; zasabiranje1&lt;LLONG_MIN-zasabiranje2) return false;
        return true;
    }
    
    friend Razlomak operator+(const Razlomak r1, const Razlomak r2) {
        long long int a, b;
        auto r=NZD(r1.DajNazivnik(),r2.DajNazivnik());
        auto zasabiranje1=r1.brojnik*(r2.nazivnik/r), zasabiranje2=r2.brojnik*(r1.nazivnik/r), zamnozenje1=r1.brojnik, zamnozenje2=r2.nazivnik/r, zamnozenje3=r2.brojnik, zamnozenje4=r1.nazivnik/r;
        auto zamnozenje5=r1.nazivnik, zamnozenje6=r2.nazivnik/r;
        if(zamnozenje2&gt;0 &amp;&amp; (zamnozenje1&gt;LLONG_MAX/zamnozenje2 || zamnozenje1&lt;LLONG_MIN/zamnozenje2)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje2&lt;0 &amp;&amp; (zamnozenje1==LLONG_MIN || -zamnozenje1&gt;LLONG_MAX/(-zamnozenje2))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
         if(zamnozenje4&gt;0 &amp;&amp; (zamnozenje3&gt;LLONG_MAX/zamnozenje4 || zamnozenje3&lt;LLONG_MIN/zamnozenje4)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje4&lt;0 &amp;&amp; (zamnozenje3==LLONG_MIN || -zamnozenje3&gt;LLONG_MAX/(-zamnozenje4))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
         if(zamnozenje6&gt;0 &amp;&amp; (zamnozenje5&gt;LLONG_MAX/zamnozenje6 || zamnozenje5&lt;LLONG_MIN/zamnozenje6)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje6&lt;0 &amp;&amp; (zamnozenje5==LLONG_MIN || -zamnozenje5&gt;LLONG_MAX/(-zamnozenje6))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        if(zasabiranje2&gt;0 &amp;&amp; zasabiranje1&gt;LLONG_MAX-zasabiranje2) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zasabiranje2&lt;0 &amp;&amp; zasabiranje1&lt;LLONG_MIN-zasabiranje2) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
<a name="3"></a><font color="#00FFFF"><a href="match581-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        a=r1.brojnik*(r2.nazivnik/r)+r2.brojnik*(r1.nazivnik/r);
        b=r1.nazivnik*(r2.nazivnik/r);
        Razlomak rezultat(a,b);
        return rezultat;
</font>    }
    friend Razlomak operator-(const Razlomak r1, const Razlomak r2) {
        long long int a,b;
        auto r=NZD(r1.DajNazivnik(), r2.DajNazivnik());
        auto zasabiranje1=r1.brojnik*(r2.nazivnik/r), zasabiranje2=r2.brojnik*(r1.nazivnik/r), zamnozenje1=r1.brojnik, zamnozenje2=r2.nazivnik/r, zamnozenje3=r2.brojnik, zamnozenje4=r1.nazivnik/r;
        auto zamnozenje5=r1.nazivnik, zamnozenje6=r2.nazivnik/r;
               if(zamnozenje2&gt;0 &amp;&amp; (zamnozenje1&gt;LLONG_MAX/zamnozenje2 || zamnozenje1&lt;LLONG_MIN/zamnozenje2)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje2&lt;0 &amp;&amp; (zamnozenje1==LLONG_MIN || -zamnozenje1&gt;LLONG_MAX/(-zamnozenje2))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
         if(zamnozenje4&gt;0 &amp;&amp; (zamnozenje3&gt;LLONG_MAX/zamnozenje4 || zamnozenje3&lt;LLONG_MIN/zamnozenje4)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje4&lt;0 &amp;&amp; (zamnozenje3==LLONG_MIN || -zamnozenje3&gt;LLONG_MAX/(-zamnozenje4))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
         if(zamnozenje6&gt;0 &amp;&amp; (zamnozenje5&gt;LLONG_MAX/zamnozenje6 || zamnozenje5&lt;LLONG_MIN/zamnozenje6)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje6&lt;0 &amp;&amp; (zamnozenje5==LLONG_MIN || -zamnozenje5&gt;LLONG_MAX/(-zamnozenje6))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        if(zasabiranje2&lt;0 &amp;&amp; zasabiranje1&gt;LLONG_MAX+zasabiranje2) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zasabiranje2&gt;0 &amp;&amp; zasabiranje1&lt;LLONG_MIN-zasabiranje2) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
<a name="2"></a><font color="#0000FF"><a href="match581-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        a=r1.brojnik*(r2.nazivnik/r)-r2.brojnik*(r1.nazivnik/r);
        b=r1.nazivnik*(r2.nazivnik/r);
        Razlomak rezultat(a,b);
        return rezultat;
</font>    }
    friend Razlomak operator*(const Razlomak r1, const Razlomak r2) {
        long long int a,b;
        auto s=NZD(r1.brojnik, r2.nazivnik);
        auto t=NZD(r2.brojnik, r1.nazivnik);
        auto zamnozenje1=r1.brojnik/s, zamnozenje2=r2.brojnik/t, zamnozenje3=r1.nazivnik/t, zamnozenje4=r2.nazivnik/s;
        if(zamnozenje2&gt;0 &amp;&amp; (zamnozenje1&lt;LLONG_MIN/zamnozenje2 || zamnozenje1&gt;LLONG_MAX/zamnozenje2)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje2&lt;0 &amp;&amp; (zamnozenje1==LLONG_MIN || -zamnozenje1&gt;LLONG_MAX/(-zamnozenje2) || -zamnozenje1&lt;LLONG_MIN/(-zamnozenje2))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        if(zamnozenje4&gt;0 &amp;&amp; (zamnozenje3&lt;LLONG_MIN/zamnozenje4 || zamnozenje3&gt;LLONG_MAX/zamnozenje4)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
<a name="0"></a><font color="#FF0000"><a href="match581-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        else if(zamnozenje4&lt;0 &amp;&amp; (zamnozenje3==LLONG_MIN || -zamnozenje3&gt;LLONG_MAX/(-zamnozenje4) || -zamnozenje3&lt;LLONG_MIN/(-zamnozenje4))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        a=(r1.brojnik/s)*(r2.brojnik/t);
        b=(r1.nazivnik/t)*(r2.nazivnik/s);
        Razlomak rezultat(a,b);
        return rezultat;
    }
    friend Razlomak operator/(const Razlomak r1, const Razlomak r2) {
</font>        auto r=NZD(r1.nazivnik, r2.nazivnik);
        auto u=NZD(r1.brojnik, r2.brojnik);
        long long int a,b;
        auto zamnozenje1=r1.brojnik/u, zamnozenje2=r2.nazivnik/r, zamnozenje3=r1.nazivnik/r, zamnozenje4=r2.brojnik/u;
        if(zamnozenje2&gt;0 &amp;&amp; (zamnozenje1&lt;LLONG_MIN/zamnozenje2 || zamnozenje1&gt;LLONG_MAX/zamnozenje2)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje2&lt;0 &amp;&amp; (zamnozenje1==LLONG_MIN || -zamnozenje1&gt;LLONG_MAX/(-zamnozenje2) || -zamnozenje1&lt;LLONG_MIN/(-zamnozenje2))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        if(zamnozenje4&gt;0 &amp;&amp; (zamnozenje3&lt;LLONG_MIN/zamnozenje4 || zamnozenje3&gt;LLONG_MAX/zamnozenje4)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
<a name="1"></a><font color="#00FF00"><a href="match581-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        else if(zamnozenje4&lt;0 &amp;&amp; (zamnozenje3==LLONG_MIN || -zamnozenje3&gt;LLONG_MAX/(-zamnozenje4) || -zamnozenje3&lt;LLONG_MIN/(-zamnozenje4))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        a=(r1.brojnik/u)*(r2.nazivnik/r);
        b=(r1.nazivnik/r)*(r2.brojnik/u);
        Razlomak rezultat(a,b);
        return rezultat;
    }
    friend Razlomak operator+=(Razlomak r1,  Razlomak r2) {
</font>        auto r=NZD(r1.nazivnik, r2.nazivnik);
         auto zasabiranje1=r1.brojnik*(r2.nazivnik/r), zasabiranje2=r2.brojnik*(r1.nazivnik/r), zamnozenje1=r1.brojnik, zamnozenje2=r2.nazivnik/r, zamnozenje3=r2.brojnik, zamnozenje4=r1.nazivnik/r;
        auto zamnozenje5=r1.nazivnik, zamnozenje6=r2.nazivnik/r;
        if(zamnozenje2&gt;0 &amp;&amp; (zamnozenje1&gt;LLONG_MAX/zamnozenje2 || zamnozenje1&lt;LLONG_MIN/zamnozenje2)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje2&lt;0 &amp;&amp; (zamnozenje1==LLONG_MIN || -zamnozenje1&gt;LLONG_MAX/(-zamnozenje2))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
         if(zamnozenje4&gt;0 &amp;&amp; (zamnozenje3&gt;LLONG_MAX/zamnozenje4 || zamnozenje3&lt;LLONG_MIN/zamnozenje4)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje4&lt;0 &amp;&amp; (zamnozenje3==LLONG_MIN || -zamnozenje3&gt;LLONG_MAX/(-zamnozenje4))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
         if(zamnozenje6&gt;0 &amp;&amp; (zamnozenje5&gt;LLONG_MAX/zamnozenje6 || zamnozenje5&lt;LLONG_MIN/zamnozenje6)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje6&lt;0 &amp;&amp; (zamnozenje5==LLONG_MIN || -zamnozenje5&gt;LLONG_MAX/(-zamnozenje6))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        if(zasabiranje2&gt;0 &amp;&amp; zasabiranje1&gt;LLONG_MAX-zasabiranje2) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zasabiranje2&lt;0 &amp;&amp; zasabiranje1&lt;LLONG_MIN-zasabiranje2) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        auto a=r1.brojnik*(r2.nazivnik/r)+r2.brojnik*(r1.nazivnik/r);
        auto b=(r1.nazivnik*r2.nazivnik/r);
        Razlomak rezultat(a,b);
        return rezultat;
    }
    friend Razlomak operator-=(const Razlomak r1, const Razlomak r2) {
        auto r=NZD(r1.nazivnik, r2.nazivnik);
         auto zasabiranje1=r1.brojnik*(r2.nazivnik/r), zasabiranje2=r2.brojnik*(r1.nazivnik/r), zamnozenje1=r1.brojnik, zamnozenje2=r2.nazivnik/r, zamnozenje3=r2.brojnik, zamnozenje4=r1.nazivnik/r;
        auto zamnozenje5=r1.nazivnik, zamnozenje6=r2.nazivnik/r;
               if(zamnozenje2&gt;0 &amp;&amp; (zamnozenje1&gt;LLONG_MAX/zamnozenje2 || zamnozenje1&lt;LLONG_MIN/zamnozenje2)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje2&lt;0 &amp;&amp; (zamnozenje1==LLONG_MIN || -zamnozenje1&gt;LLONG_MAX/(-zamnozenje2))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
         if(zamnozenje4&gt;0 &amp;&amp; (zamnozenje3&gt;LLONG_MAX/zamnozenje4 || zamnozenje3&lt;LLONG_MIN/zamnozenje4)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje4&lt;0 &amp;&amp; (zamnozenje3==LLONG_MIN || -zamnozenje3&gt;LLONG_MAX/(-zamnozenje4))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
         if(zamnozenje6&gt;0 &amp;&amp; (zamnozenje5&gt;LLONG_MAX/zamnozenje6 || zamnozenje5&lt;LLONG_MIN/zamnozenje6)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje6&lt;0 &amp;&amp; (zamnozenje5==LLONG_MIN || -zamnozenje5&gt;LLONG_MAX/(-zamnozenje6))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        if(zasabiranje2&lt;0 &amp;&amp; zasabiranje1&gt;LLONG_MAX+zasabiranje2) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zasabiranje2&gt;0 &amp;&amp; zasabiranje1&lt;LLONG_MIN-zasabiranje2) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        auto a=r1.brojnik*(r2.nazivnik/r)-r2.brojnik*(r1.nazivnik/r);
        auto b=r1.nazivnik*r2.nazivnik/r;
        Razlomak rezultat(a,b);
        return rezultat;}
        friend Razlomak operator*=(const Razlomak r1, const Razlomak r2) {
              long long int a,b;
        auto s=NZD(r1.brojnik, r2.nazivnik);
        auto t=NZD(r2.brojnik, r1.nazivnik);
        auto zamnozenje1=r1.brojnik/s, zamnozenje2=r2.brojnik/t, zamnozenje3=r1.nazivnik/t, zamnozenje4=r2.nazivnik/s;
        if(zamnozenje2&gt;0 &amp;&amp; (zamnozenje1&lt;LLONG_MIN/zamnozenje2 || zamnozenje1&gt;LLONG_MAX/zamnozenje2)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje2&lt;0 &amp;&amp; (zamnozenje1==LLONG_MIN || -zamnozenje1&gt;LLONG_MAX/(-zamnozenje2) || -zamnozenje1&lt;LLONG_MIN/(-zamnozenje2))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        if(zamnozenje4&gt;0 &amp;&amp; (zamnozenje3&lt;LLONG_MIN/zamnozenje4 || zamnozenje3&gt;LLONG_MAX/zamnozenje4)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje4&lt;0 &amp;&amp; (zamnozenje3==LLONG_MIN || -zamnozenje3&gt;LLONG_MAX/(-zamnozenje4) || -zamnozenje3&lt;LLONG_MIN/(-zamnozenje4))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        a=(r1.brojnik/s)*(r2.brojnik/t);
        b=(r1.nazivnik/t)*(r2.nazivnik/s);
        Razlomak rezultat(a,b);
        return rezultat;
        }
        friend Razlomak operator/=(const Razlomak r1, const Razlomak r2) {
              auto r=NZD(r1.nazivnik, r2.nazivnik);
        auto u=NZD(r1.brojnik, r2.brojnik);
        long long int a,b;
        auto zamnozenje1=r1.brojnik/u, zamnozenje2=r2.nazivnik/r, zamnozenje3=r1.nazivnik/r, zamnozenje4=r2.brojnik/u;
        if(zamnozenje2&gt;0 &amp;&amp; (zamnozenje1&lt;LLONG_MIN/zamnozenje2 || zamnozenje1&gt;LLONG_MAX/zamnozenje2)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje2&lt;0 &amp;&amp; (zamnozenje1==LLONG_MIN || -zamnozenje1&gt;LLONG_MAX/(-zamnozenje2) || -zamnozenje1&lt;LLONG_MIN/(-zamnozenje2))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        if(zamnozenje4&gt;0 &amp;&amp; (zamnozenje3&lt;LLONG_MIN/zamnozenje4 || zamnozenje3&gt;LLONG_MAX/zamnozenje4)) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        else if(zamnozenje4&lt;0 &amp;&amp; (zamnozenje3==LLONG_MIN || -zamnozenje3&gt;LLONG_MAX/(-zamnozenje4) || -zamnozenje3&lt;LLONG_MIN/(-zamnozenje4))) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        a=(r1.brojnik/u)*(r2.nazivnik/r);
        b=(r1.nazivnik/r)*(r2.brojnik/u);
        Razlomak rezultat(a,b);
        return rezultat;
        }
    friend Razlomak operator-(const Razlomak r) {
        if(r.DajBrojnik()==LLONG_MIN) throw std::overflow_error("Nemoguce dobiti tacan rezultat");
        return {-r.DajBrojnik(), r.DajNazivnik()};
    }
    friend Razlomak operator+(const Razlomak r) {
        return {r.DajBrojnik(), r.DajNazivnik()};
    }
<a name="4"></a><font color="#FF00FF"><a href="match581-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    friend bool operator&lt;(const Razlomak r1, const Razlomak r2) {
        long double a=(long double)r1.DajBrojnik()/r1.DajNazivnik();
        long double b=(long double)r2.DajBrojnik()/r2.DajNazivnik();
</font>        return a&lt;b;
    }
<a name="5"></a><font color="#FF0000"><a href="match581-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    friend bool operator&gt;(const Razlomak r1, const Razlomak r2) {
        long double a=(long double)r1.DajBrojnik()/r1.DajNazivnik();
        long double b=(long double)r2.DajBrojnik()/r2.DajNazivnik();
</font>        return a&gt;b;
    }
<a name="6"></a><font color="#00FF00"><a href="match581-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    friend bool operator &gt;=(const Razlomak r1, const Razlomak r2) {
        long double a=(long double)r1.DajBrojnik()/r1.DajNazivnik();
        long double b=(long double)r2.DajBrojnik()/r2.DajNazivnik();
</font>        return a&gt;=b;
    }
<a name="7"></a><font color="#0000FF"><a href="match581-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    friend bool operator&lt;=(const Razlomak r1, const Razlomak r2) {
        long double a=(long double)r1.DajBrojnik()/r1.DajNazivnik();
        long double b=(long double)r2.DajBrojnik()/r2.DajNazivnik();
</font>        return a&lt;=b;
    }
    friend bool operator==(const Razlomak r1, const Razlomak r2) {
        long double a=(long double)r1.DajBrojnik()/r1.DajNazivnik();
        long double b=(long double)r2.DajBrojnik()/r2.DajNazivnik();
        return fabs(a-b)&lt;1e-10;
    }
    friend bool operator!=(const Razlomak r1, const Razlomak r2) {
        long double a=(long double)r1.DajBrojnik()/r1.DajNazivnik();
        long double b=(long double)r2.DajBrojnik()/r2.DajNazivnik();
        return fabs(a-b)&gt;1e-10;
    }
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok, Razlomak r) {
        tok&lt;&lt;r.DajBrojnik();
        if(r.DajNazivnik()!=1) tok&lt;&lt;"/"&lt;&lt;r.DajNazivnik();
        return tok;
    }
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;tok, Razlomak &amp;r){
        long long int a, b;
        char znak;
        tok&gt;&gt;std::ws;
        if(!tok) tok.ignore(1000);
        tok&gt;&gt;a;
        if(tok &amp;&amp; tok.peek()=='\n') r=Razlomak(a);
        else if(tok.peek()!='\n'){
            tok&gt;&gt;znak;
            if(znak=='/') {tok&gt;&gt;b;
            if(tok.peek()&lt;13){
            r=Razlomak(a,b);}
            
                else tok.setstate(std::ios::failbit);}
            else tok.setstate(std::ios::failbit);
        } else tok.setstate(std::ios::failbit);
        return tok; 
    }
};

  long long int Razlomak::NZD(long long int p, long long int q) {
      if(p==LLONG_MIN &amp;&amp; q==LLONG_MIN) return LLONG_MIN;
      if(p&lt;0 &amp;&amp; p!=LLONG_MIN) p*=-1;
      if(q&lt;0 &amp;&amp; q!=LLONG_MIN) q*=-1;
      if(p==0) return q;
     auto manji(p);
     if(p&gt;q) manji=q;
     for(auto i=manji; i&gt;=1; i--) {
         if(p%i==0 &amp;&amp; q%i==0) {
             return i;
         }
}
     return 1;
}

int main ()
{
     
	return 0;
}</pre>
</body>
</html>
