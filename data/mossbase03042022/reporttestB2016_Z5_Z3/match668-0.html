<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student2437.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student2437.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 3)
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;limits&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;
#include &lt;sstream&gt;
    const long long int M = std::numeric_limits&lt;long long int&gt;::max();
    const long long int m = std::numeric_limits&lt;long long int&gt;::min();
    
    void PrekoracenjeOduzimanja(long long int a, long long int b){
        if((b &gt; 0 &amp;&amp; a &lt; m - b) || (b &lt; 0 &amp;&amp; a &gt; M - b))
            throw std::overflow_error("Nemoguce dobiti tacan rezultat");
    }
    void PrekoracenjeSabiranja(long long int a, long long int b){
        if((b &gt; 0 &amp;&amp; a &gt; M - b) || (b &lt; 0 &amp;&amp; a &lt; m - b))
            throw std::overflow_error("Nemoguce dobiti tacan rezultat");
    }
    void PrekoracenjeMnozenja(long long int a, long long int b){
        if((b &gt; 0 &amp;&amp; (a &lt; m/b || a &gt; M/b)) || ( b &lt; 0 &amp;&amp; (a == m || -a &gt; M/-b  || -a &lt; m/-b)))
            throw std::overflow_error("Nemoguce dobiti tacan rezultat");
    }
    class Razlomak{
        long long int brojnik;
        long long int nazivnik;
        static int NZD(long long int broj1, long long int broj2){
            if(broj2 == 0) return broj1;
            broj1 = broj1 % broj2;
            return NZD(broj2,broj1);
        }
    public:
        Razlomak(){brojnik = 0, nazivnik = 0;}
        Razlomak(long long int brojnik, long long int nazivnik = 1);
        long long int DajBrojnik()const{ return brojnik; }
        long long int DajNazivnik()const{ return nazivnik; }
        friend Razlomak operator +(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak operator -(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak operator *(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak operator /(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak &amp;operator +=(Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak &amp;operator -=(Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak &amp;operator *=(Razlomak &amp;r1, const Razlomak &amp;r2);
<a name="1"></a><font color="#00FF00"><a href="match668-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        friend Razlomak &amp;operator /=(Razlomak &amp;r1, const Razlomak &amp;r2);
        friend Razlomak &amp;operator ++(Razlomak &amp;r);
        friend Razlomak &amp;operator --(Razlomak &amp;r);
        friend Razlomak operator ++(Razlomak &amp;r, int);
        friend Razlomak operator --(Razlomak &amp;r,int);
</font><a name="2"></a><font color="#0000FF"><a href="match668-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        friend bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2){
            return r1.brojnik == r2.brojnik &amp;&amp; r1.nazivnik == r2.nazivnik;
        }
        friend bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2){
</font>            return r1.brojnik != r2.brojnik || r1.nazivnik != r2.nazivnik;
        }
        friend bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2);
        friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const Razlomak &amp;r);
        friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, Razlomak &amp;r);
        operator long double()const;
        friend Razlomak operator +(const Razlomak &amp;r){
            return {r.brojnik,r.nazivnik};
        }
        friend Razlomak operator -(const Razlomak &amp;r);
    };
    
    Razlomak::Razlomak(long long int brojnik, long long int nazivnik){
        if(nazivnik == 0) throw std::logic_error("Nekorektan razlomak");
        int nzd = NZD(brojnik,nazivnik);
        brojnik /= nzd;
        nazivnik /= nzd;
        if(brojnik &lt; 0 &amp;&amp; nazivnik &lt; 0){
            brojnik *= -1;
            nazivnik *= -1;
            Razlomak::brojnik = brojnik;
            Razlomak::nazivnik = nazivnik;
        }
        else if(brojnik &gt; 0 &amp;&amp; nazivnik &lt; 0){
            brojnik *= -1;
            nazivnik *= -1;
            Razlomak::brojnik = brojnik;
            Razlomak::nazivnik = nazivnik;
        }
        else{
            Razlomak::brojnik = brojnik;
            Razlomak::nazivnik = nazivnik;
        }
    }
    
    Razlomak::operator long double()const{
        return static_cast&lt;long double&gt;(brojnik)/static_cast&lt;long double&gt;(nazivnik);
    }
    
    Razlomak operator -(const Razlomak &amp;r){
        PrekoracenjeOduzimanja(-r.brojnik,-r.nazivnik);
        return { -r.brojnik, -r.nazivnik };
    }
    Razlomak &amp;operator +=(Razlomak &amp;r1, const Razlomak &amp;r2){
<a name="3"></a><font color="#00FFFF"><a href="match668-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        int n = Razlomak::NZD(r1.nazivnik,r2.nazivnik);
      /*  PrekoracenjeMnozenja(r1.brojnik,r2.nazivnik/n);
        PrekoracenjeMnozenja(r2.brojnik,r1.nazivnik/n);
        PrekoracenjeMnozenja(r1.nazivnik,r2.nazivnik/n);
        PrekoracenjeOduzimanja(r1.brojnik* (r2.nazivnik/n),r2.brojnik * (r1.nazivnik/n));*/
        r1.brojnik = r1.brojnik * (r2.nazivnik/n) + r2.brojnik * (r1.nazivnik/n);
        r1.nazivnik = r1.nazivnik * (r2.nazivnik/n);
</font>        Razlomak{r1.brojnik,r1.nazivnik};
        return r1;
    }
    Razlomak &amp;operator -=(Razlomak &amp;r1, const Razlomak &amp;r2){
<a name="0"></a><font color="#FF0000"><a href="match668-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

        int n = Razlomak::NZD(r1.nazivnik,r2.nazivnik);
       /* PrekoracenjeMnozenja(r1.brojnik,r2.nazivnik/n);
        PrekoracenjeMnozenja(r2.brojnik,r1.nazivnik/n);
        PrekoracenjeMnozenja(r1.nazivnik,r2.nazivnik/n);
        PrekoracenjeSabiranja(r1.brojnik* (r2.nazivnik/n),r2.brojnik * (r1.nazivnik/n*/
        r1.brojnik = r1.brojnik * (r2.nazivnik/n) - r2.brojnik * (r1.nazivnik/n);
        r1.nazivnik = r1.nazivnik * (r2.nazivnik/n);
</font>        Razlomak{r1.brojnik,r1.nazivnik};
        return r1;
    }
    Razlomak &amp;operator *=(Razlomak &amp;r1, const Razlomak &amp;r2){
        int s = Razlomak::NZD(r1.brojnik,r2.nazivnik);
        int t = Razlomak::NZD(r2.brojnik,r1.nazivnik);
        /*PrekoracenjeMnozenja(r1.brojnik,s);
        PrekoracenjeMnozenja(r2.brojnik,t);
        PrekoracenjeMnozenja(r1.nazivnik,t);
        PrekoracenjeMnozenja(r2.nazivnik,s);*/
        r1.brojnik = (r1.brojnik * s) / (r2.brojnik * t);
        r1.nazivnik = (r1.nazivnik * t) / (r2.nazivnik * s);
        Razlomak{r1.brojnik,r1.nazivnik};
        return r1;
    }
    Razlomak &amp;operator /=(Razlomak &amp;r1, const Razlomak &amp;r2){
        int r = Razlomak::NZD(r1.nazivnik,r2.nazivnik);
<a name="5"></a><font color="#FF0000"><a href="match668-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        int u = Razlomak::NZD(r2.brojnik,r1.nazivnik);
        /*PrekoracenjeMnozenja(r1.brojnik / u,r2.nazivnik / r);
        PrekoracenjeMnozenja(r1.nazivnik / r,r2.brojnik / u);*/
        r1.brojnik = (r1.brojnik / u) * (r2.nazivnik / r);
        r1.nazivnik = (r1.nazivnik / r) * (r2.brojnik / u);
</font>        Razlomak{r1.brojnik,r1.nazivnik};
        return r1;
    }
    Razlomak &amp;operator ++(Razlomak &amp;r){
        r.brojnik++; r.nazivnik++;
      //  PrekoracenjeSabiranja(r.brojnik,r.nazivnik);
        return r;
    }
    Razlomak &amp;operator --(Razlomak &amp;r){
        r.brojnik--; r.nazivnik--;
        PrekoracenjeOduzimanja(r.brojnik,r.nazivnik);
        return r;
    }
    Razlomak operator ++(Razlomak &amp;r, int){
        Razlomak povratni(r);
        r.brojnik++; r.nazivnik++;
   //     PrekoracenjeSabiranja(r.brojnik,r.nazivnik);
        return povratni;
    }
    Razlomak operator --(Razlomak &amp;r, int){
        Razlomak povratni(r);
        r.brojnik--; r.nazivnik--;
      //  PrekoracenjeOduzimanja(r.brojnik,r.nazivnik);
        return povratni;
    }
    bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2){
        long double x = static_cast&lt;long double&gt; (r1.brojnik)/static_cast&lt;long double&gt;(r1.nazivnik);
        long double y = static_cast&lt;long double&gt;(r2.brojnik)/static_cast&lt;long double&gt;(r2.nazivnik);
        return x &gt; y;
    }
    bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2){
        long double x = static_cast&lt;long double&gt;(r1.brojnik)/static_cast&lt;long double&gt;(r1.nazivnik);
        long double y =static_cast&lt;long double&gt;(r2.brojnik)/static_cast&lt;long double&gt;(r2.nazivnik);
        return x &lt; y;
    }
    bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2){
        double const eps(0.0000000001);
        long double x = static_cast&lt;long double&gt;(r1.brojnik)/static_cast&lt;long double&gt;(r1.nazivnik);
        long double y = static_cast&lt;long double&gt;(r2.brojnik)/static_cast&lt;long double&gt;(r2.nazivnik);
        return x &gt; y || fabs(x - y) &lt; eps;
    }
    bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2){
        double const eps(0.0000000001);
        long double x = static_cast&lt;long double&gt;(r1.brojnik)/static_cast&lt;long double&gt;(r1.nazivnik);
        long double y = static_cast&lt;long double&gt;(r2.brojnik)/static_cast&lt;long double&gt;(r2.nazivnik);
        return x &lt; y || fabs(x - y) &lt; eps;
    }
    
    std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const Razlomak &amp;r){
        if(r.nazivnik == 1) tok &lt;&lt; r.brojnik;
        else if(r.brojnik == 0) tok &lt;&lt; 0;
        else
            tok &lt;&lt; r.brojnik &lt;&lt; "/" &lt;&lt; r.nazivnik;
        
        return tok;
    }
    
    Razlomak operator +(const Razlomak &amp;r1, const Razlomak &amp;r2){
        int n = Razlomak::NZD(r1.DajNazivnik(),r2.DajNazivnik());
       /* PrekoracenjeMnozenja(r1.brojnik,r2.nazivnik/n);
        PrekoracenjeMnozenja(r2.brojnik,r1.nazivnik/n);
        PrekoracenjeMnozenja(r1.nazivnik,r2.nazivnik/n);
        PrekoracenjeSabiranja(r1.brojnik* (r2.nazivnik/n),r2.brojnik * (r1.nazivnik/n));*/
        long long int brojnik{r1.brojnik* (r2.nazivnik/n) + r2.brojnik * (r1.nazivnik/n)};
        long long int nazivnik{r1.nazivnik * (r2.nazivnik/n)};
        return {brojnik,nazivnik};
    }
    Razlomak operator -(const Razlomak &amp;r1, const Razlomak &amp;r2){
        int n = Razlomak::NZD(r1.nazivnik,r2.nazivnik);
       /* PrekoracenjeMnozenja(r1.brojnik,r2.nazivnik/n);
        PrekoracenjeMnozenja(r2.brojnik,r1.nazivnik/n);
        PrekoracenjeMnozenja(r1.nazivnik,r2.nazivnik/n);
        PrekoracenjeSabiranja(r1.brojnik* (r2.nazivnik/n),r2.brojnik * (r1.nazivnik/n));*/
        long long int brojnik{r1.brojnik * (r2.nazivnik/n) - r2.brojnik * (r1.nazivnik/n)};
        long long int nazivnik{r1.nazivnik * (r2.nazivnik/n)};
        return {brojnik,nazivnik};
    }
    Razlomak operator *(const Razlomak &amp;r1, const Razlomak &amp;r2){
        int s = Razlomak::NZD(r1.brojnik,r2.nazivnik);
        int t = Razlomak::NZD(r2.brojnik,r1.nazivnik);
/*      PrekoracenjeMnozenja(r1.brojnik,s);
        PrekoracenjeMnozenja(r2.brojnik,t);
        PrekoracenjeMnozenja(r1.nazivnik,t);
        PrekoracenjeMnozenja(r2.nazivnik,s);*/
        long long int brojnik{(r1.brojnik * s) / (r2.brojnik * t)};
        long long int nazivnik{(r1.nazivnik * t) / (r2.nazivnik * s)};
        return {brojnik,nazivnik};
    }
    Razlomak operator /(const Razlomak &amp;r1, const Razlomak &amp;r2){
        int r = Razlomak::NZD(r1.nazivnik,r2.nazivnik);
        int u = Razlomak::NZD(r2.brojnik,r1.nazivnik);
       /* PrekoracenjeMnozenja(r1.brojnik/u,r2.nazivnik/r);
        PrekoracenjeMnozenja(r1.nazivnik/r,r2.brojnik/u);*/
        long long int brojnik{(r1.brojnik/u) * (r2.nazivnik/r)};
        long long int nazivnik{(r1.nazivnik/r) * (r2.brojnik/u)};
        return {brojnik,nazivnik};
    }
        
        std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, Razlomak &amp;r){
        char znak;
        long long int x;
        long long int y;
        
        tok &gt;&gt; std::ws;
        tok &gt;&gt; x;
        
        if(tok.peek() == EOF || tok.peek() == ' ' || tok.peek() == '\t' || tok.peek() == '\r' || tok.peek() == '\v'|| tok.peek() == '\n'){
            r.brojnik = x;
            r.nazivnik = 1;
            return tok;
        }
        tok &gt;&gt; znak;
        if(znak != '/'){ tok.setstate(std::ios::failbit);
         tok.clear(); 
        }
        tok &gt;&gt; y;
<a name="4"></a><font color="#FF00FF"><a href="match668-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        if(tok.peek() != EOF &amp;&amp; tok.peek() != ' ' &amp;&amp; tok.peek() != '\t' &amp;&amp; tok.peek() != '\r' &amp;&amp; tok.peek() != '\v'&amp;&amp; tok.peek() != '\n'){
            tok.setstate(std::ios::failbit);
</font>        
        }
        if(tok) tok.clear();
        int z = Razlomak::NZD(x,y);
        r.brojnik = x/z; r.nazivnik = y/z;
    
        if(tok) tok.clear();
        
        return tok;
            
    }
int main ()
{   
    try{
        Razlomak r1,r2;
        std::cout &lt;&lt; "Unesite dva razlomka: "&lt;&lt;std::endl;
        std::cin &gt;&gt; r1 &gt;&gt; r2;
        std::cout &lt;&lt; "Zbir zazlomaka r1 i r2 je: r1 + r2 = "&lt;&lt; r1 + r2&lt;&lt;std::endl;
        std::cout &lt;&lt; "Razlika zazlomaka r1 i r2 je: r1 - r2 = "&lt;&lt; r1 - r2&lt;&lt;std::endl;
        r1 += r2;
        r1--;
        Razlomak r3(r1/r2);
        std::cout &lt;&lt; "Razlomak r1 iznosi: "&lt;&lt; r1&lt;&lt;std::endl;
        std::cout &lt;&lt; "Razlomak r3 iznosi: "&lt;&lt; r3&lt;&lt;std::endl;
    }
    catch(std::overflow_error e){
        std::cout &lt;&lt; e.what();
    }
    catch(std::logic_error e){
        std::cout &lt;&lt; e.what();
    }
	return 0;
}</pre>
</body>
</html>
