<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student4128.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student2406.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
#include &lt;sstream&gt;
#define eps 1E-18
#define M LLONG_MAX
#define m LLONG_MIN

using namespace std;

class Razlomak {
    long long int brojnik,nazivnik;
    public:
    Razlomak(long long int b=0,long long int n=1)
    {
        int i=2;
        if(n==0)throw;
        while(i&lt;=b &amp;&amp; i&lt;=n)
        {
            
            if(b%i==0 &amp;&amp; n%i==0)
            {
                b/=i;
                n/=i;
            }
            else 
            i++;
        }
        brojnik=b;
        nazivnik=n;
    }
    Razlomak(initializer_list&lt;long long int&gt;  b_n);
    long long int DajBrojnik() const { return brojnik; };
    long long int DajNazivnik() const { return nazivnik; };
    friend Razlomak operator +(Razlomak r1, const Razlomak &amp;r2)
    {
        return Razlomak(r1.brojnik*r2.nazivnik+r2.brojnik*r1.nazivnik,r1.nazivnik*r2.nazivnik);
    }
    friend Razlomak operator -(Razlomak r1, const Razlomak &amp;r2)
    {
        return Razlomak(r1.brojnik*r2.nazivnik-r2.brojnik*r1.nazivnik,r1.nazivnik*r2.nazivnik);
    }
    friend Razlomak operator *(Razlomak r1, const Razlomak &amp;r2)
    {
        return Razlomak(r1.brojnik*r2.brojnik,r1.nazivnik*r2.nazivnik);
    }
    friend Razlomak operator /(Razlomak r1, const Razlomak &amp;r2)
    {
         return Razlomak(r1.brojnik*r2.nazivnik,r1.nazivnik*r2.brojnik);
    }
    friend Razlomak operator +(const Razlomak &amp;r1)
    {
        return Razlomak(r1);
    }
    friend Razlomak operator -(Razlomak &amp;r1)
    {
<a name="1"></a><font color="#00FF00"><a href="match289-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

        return Razlomak(-r1.brojnik,r1.nazivnik);
    }
    friend Razlomak &amp;operator +=(Razlomak &amp;r1, const Razlomak &amp;r2)
    {
        return r1=r1+r2;
    }
    friend Razlomak &amp;operator -=(Razlomak &amp;r1, const Razlomak &amp;r2)
    {
        return r1=r1-r2;
    }
    friend Razlomak &amp;operator *=(Razlomak &amp;r1, const Razlomak &amp;r2)
    {
        return r1=r1*r2;
    }
    friend Razlomak &amp;operator /=(Razlomak &amp;r1, const Razlomak &amp;r2)
    {
        return r1=r1/r2;
    }
    friend Razlomak &amp;operator ++(Razlomak &amp;r1)
    {
        return r1+=Razlomak(1,r1.nazivnik);
</font>    }
    friend Razlomak &amp;operator --(Razlomak &amp;r1)
     {
        return r1-=Razlomak(1,r1.nazivnik);
    }
    friend Razlomak operator ++(Razlomak &amp;r1, int){
        Razlomak rh=r1;
        ++r1;
        return rh;
    }
    friend Razlomak operator --(Razlomak &amp;r1, int)
    {
        Razlomak rh=r1;
        --r1;
        return rh;
    }
    friend bool operator &lt;(const Razlomak &amp;r1, const Razlomak &amp;r2)
    {
        return r1.brojnik/r1.nazivnik &lt; r2.brojnik/r2.nazivnik;
    }
    friend bool operator &gt;(const Razlomak &amp;r1, const Razlomak &amp;r2)
    {
         return r1.brojnik/r1.nazivnik &gt; r2.brojnik/r2.nazivnik;
    }
    friend bool operator &lt;=(const Razlomak &amp;r1, const Razlomak &amp;r2)
    {
        return !(r1&lt;r2);
    }
    friend bool operator &gt;=(const Razlomak &amp;r1, const Razlomak &amp;r2)
    {
        return !(r1&lt;r2);
    }
    friend bool operator ==(const Razlomak &amp;r1, const Razlomak &amp;r2)
    {
        return !(r1&lt;r2 || r1&gt;r2);
    }
    friend bool operator !=(const Razlomak &amp;r1, const Razlomak &amp;r2)
    {
        return (r1&lt;r2 || r1&gt;r2);
    }
    friend ostream &amp;operator &lt;&lt;(ostream &amp;tok, const Razlomak &amp;r1)
    {
        
        if(r1.brojnik==0) return tok&lt;&lt;"0";
        else if(r1.nazivnik==1) return tok&lt;&lt;r1.brojnik;
        else return tok&lt;&lt;r1.brojnik&lt;&lt;"/"&lt;&lt;r1.nazivnik;
    }
    friend istream &amp;operator &gt;&gt;(istream &amp;tok,Razlomak &amp;r1)
    {
        char znak;
        tok&gt;&gt;std::ws;
        tok&gt;&gt;r1.brojnik;
        if(tok.peek()!= '/') { r1.nazivnik=1; return tok; }
        else {
            tok&gt;&gt;znak&gt;&gt;r1.nazivnik;
        }
        if(tok.peek()!=' ' &amp;&amp; tok.peek()!='\t' &amp;&amp; tok.peek()!='\n' &amp;&amp; tok.peek()!='\v' &amp;&amp; tok.peek()!='\f') tok.setstate(std::ios::failbit);
        r1=Razlomak(r1.brojnik,r1.nazivnik);
       
        return tok;
    }
    explicit operator long double() const { return (double)brojnik/nazivnik; }
    
    
};
<a name="0"></a><font color="#FF0000"><a href="match289-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_24.gif"/></a>

int main()
{
    //AT3 (c9): operator &gt;&gt; (1/3) ...
     //NAPOMENA: najlogicnija izvedba op&gt;&gt; ce proci
     //ove ATove. Dodatne izvedbe su nelogicne i nisu u skladu
     //sa ostaim tipovima...

     //ovdje cu koristiti specijalnu klasu (ne radi se naB
     //da preko stringa simuliram ulaz
     //cisto da se vide viska razmaci

     //NAPOMENA: pod "razmakom" se smatra SVAKI znak koji je BJELINA
     //odnosno ovih 6 znakova u en-US:
     //      \n, |r, \f, \v, \t, ' '
     // i |r je sa backshashom, ali zbog buga pisem |r. Znaci, i \R (samo malo r)
     Razlomak r, q, t;
     std::istringstream is ("10/20"); //ne mora sa \n zavrsiti
     is &gt;&gt; r;
     std::cout &lt;&lt; r &lt;&lt; std::endl;

     is.str ("173"); //samo jedan broj, 173/1
     is.clear(); //mora, radi EOF
     is &gt;&gt; r;
     std::cout &lt;&lt; r &lt;&lt; std::endl;

     is.str ("               173/50"); //ispravno, razmaci prije
     is.clear();
     is &gt;&gt; r;
     std::cout &lt;&lt; r &lt;&lt; std::endl;

     is.str ("               173/50       "); //ispravno, razmaci prije, poslije
     is.clear();
     is &gt;&gt; r;
     std::cout &lt;&lt; r &lt;&lt; std::endl;


     is.str ("173/51\n  ne zanima nas sta je nakon     "); //ispravno
     is.clear();
     is &gt;&gt; r; //sljedece citanje bi bilo neispravno
     std::cout &lt;&lt; r &lt;&lt; std::endl;

     is.str ("17/33e ali je vazno da nakon razlomka ide BJELINA"); //neispravno
     is.clear();
     is &gt;&gt; r;
     if (is.fail()) std::cout &lt;&lt; "OK, neispravno!" &lt;&lt; std::endl;
     else std::cout &lt;&lt; "Nije OK! Ovo nije ispravan unos!" &lt;&lt; std::endl;

     //nije ispravno ni npr. 10b/20, ni 10/ 20 ni a20/5
     //necu sve testirati (barem ne u javnim :troll:)

     is.str ("a17/33"); //neispravno
     is.clear();
     is &gt;&gt; r;
     if (is.fail()) std::cout &lt;&lt; "OK, neispravno!" &lt;&lt; std::endl;
     else std::cout &lt;&lt; "Nije OK! Ovo nije ispravan unos!" &lt;&lt; std::endl;

     std::cout &lt;&lt; "VEOMA VAZNO: " &lt;&lt; std::endl;
     //treba biti MOGUCE unijeti vise razlomaka odjednom! (pazite na std::ws)
     is.str (" 1/3   5/7  4/2    nebitno"); //ispravna prva 3
     is.clear();
     is &gt;&gt; r &gt;&gt; q &gt;&gt; t;
     std::cout &lt;&lt; "r = " &lt;&lt; r &lt;&lt; ", q = " &lt;&lt; q &lt;&lt; ", t = " &lt;&lt; t;
</font>
     //dosta testova :whew:
    return 0;
}</pre>
</body>
</html>
