<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student4290.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z3/student6151.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 3)      1.2 boda
//Autotestovi by Enil Pajic (mail: epajic1@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;
#include &lt;limits&gt;
#include &lt;initializer_list&gt;

#define MAX std::numeric_limits&lt;long long&gt;::max()
#define MIN std::numeric_limits&lt;long long&gt;::min()

class Razlomak {
        long long int brojnik;
        long long int nazivnik;
        static long long int EuklidovAlgoritam (long long int brojnik, long long int nazivnik) {
            if (nazivnik==0)
                return brojnik;
            else     
                return EuklidovAlgoritam(nazivnik,brojnik%nazivnik);
        }
    public :
        Razlomak (long long int brojnik_main=0, long long int nazivnik_main=1) {
            if (nazivnik_main==0)
                throw std::logic_error ("Nekorektan razlomak");
            if (brojnik_main&lt;0 &amp;&amp; nazivnik_main&lt;0) { brojnik_main=-brojnik_main; nazivnik_main=-nazivnik_main; };
            if (brojnik_main&gt;0 &amp;&amp; nazivnik_main&lt;0) { brojnik_main=-brojnik_main; nazivnik_main=-nazivnik_main; };
            brojnik=brojnik_main;
            nazivnik=nazivnik_main;
            auto NZD (EuklidovAlgoritam(brojnik,nazivnik));
            brojnik/=NZD;
            nazivnik/=NZD;
        }
        Razlomak (std::initializer_list&lt;long long int&gt; lista) : brojnik(0), nazivnik(1) {
            auto it (lista.begin());
            brojnik=*it;
            it++;
            if (brojnik&gt;=0 &amp;&amp; it!=lista.end()) nazivnik=*it;
            else if (brojnik&gt;=0 &amp;&amp; it==lista.end()) nazivnik=1;
            if (nazivnik==0)  throw std::logic_error ("Nekorektan razlomak");
            if (brojnik&lt;0 &amp;&amp; nazivnik&lt;0) { brojnik=-brojnik; nazivnik=-nazivnik; };
            if (brojnik&gt;0 &amp;&amp; nazivnik&lt;0) { brojnik=-brojnik; nazivnik=-nazivnik; };
            auto NZD (EuklidovAlgoritam(brojnik,nazivnik));
            brojnik/=NZD;
            nazivnik/=NZD;
        }
        Razlomak (const Razlomak &amp;main_razlomak)  {
            brojnik=main_razlomak.brojnik;
            nazivnik=main_razlomak.nazivnik;
        }
        long long int DajBrojnik () const { return brojnik; }
        long long int DajNazivnik () const { return nazivnik; }
        friend std::ostream&amp; operator &lt;&lt; (std::ostream &amp;tok, const Razlomak &amp;raz1); 
        friend std::istream&amp; operator &gt;&gt; (std::istream &amp;tok, Razlomak &amp;raz1);
        friend bool operator == (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator != (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator &gt;= (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator &gt; (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator &lt;= (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend bool operator &lt; (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak &amp;operator += (Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator + (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator + (const Razlomak &amp;raz1);
        friend Razlomak operator ++ (Razlomak &amp;raz1, int);
        friend Razlomak &amp;operator ++ (Razlomak &amp;raz1);
        friend Razlomak &amp;operator -= (Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator - (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator - (Razlomak &amp;raz1);
        friend Razlomak operator -- (Razlomak &amp;raz1, int);
        friend Razlomak &amp;operator -- (Razlomak &amp;raz1);
        friend Razlomak &amp;operator *= (Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator * (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak &amp;operator /= (Razlomak &amp;prvi, const Razlomak &amp;drugi);
        friend Razlomak operator / (const Razlomak &amp;prvi, const Razlomak &amp;drugi);
        operator long double() const { return (long double)brojnik/nazivnik;}
};
    
<a name="5"></a><font color="#FF0000"><a href="match644-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    std::ostream&amp; operator &lt;&lt; (std::ostream &amp;tok, const Razlomak &amp;raz1) {
        if (raz1.nazivnik==1)
            tok&lt;&lt;raz1.brojnik;
        else if (raz1.brojnik%raz1.nazivnik==0)
</font>            tok&lt;&lt;"1"&lt;&lt;std::endl;
        else 
<a name="4"></a><font color="#FF00FF"><a href="match644-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

            tok&lt;&lt;raz1.brojnik&lt;&lt;"/"&lt;&lt;raz1.nazivnik;
        return tok;
    }
    
    std::istream&amp; operator &gt;&gt; (std::istream &amp;tok, Razlomak &amp;raz1) {
        char je_li_broj(0); 
</font>        tok&gt;&gt;std::ws;
        je_li_broj=tok.peek();
        if (je_li_broj&lt;='9' &amp;&amp; je_li_broj&gt;='0') { 
            tok &gt;&gt; raz1.brojnik;
            tok.clear();
            raz1.nazivnik=1;
            if (tok.peek() == ' ' || tok.peek()=='nul') { tok.clear(); raz1.nazivnik=1; }
            else if (tok.peek() != '/') tok.setstate(std::ios::failbit);
            else  tok.get();
            if (tok.peek()=='nul' || tok.peek()==' ')
                 raz1.nazivnik=1;
            else if (tok.peek()&lt;='9' &amp;&amp; tok.peek()&gt;='0')
                tok&gt;&gt;raz1.nazivnik;
            if (!(tok.peek()==' '))
                tok.setstate(std::ios::failbit);
        }
        else {
            tok.setstate(std::ios::failbit);
        }
        raz1=Razlomak(raz1.brojnik,raz1.nazivnik);
        return tok;
    }
    
    bool operator  == (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        return prvi.brojnik==drugi.brojnik &amp;&amp; prvi.nazivnik==drugi.nazivnik;
    }
    
    inline bool operator != (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        return !(prvi==drugi);
    }
    
    bool operator &gt;= (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        return (((long double)(prvi)) &gt;= ((long double)(drugi)));
    }
    
    bool operator &gt; (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        return (long double)(prvi) &gt; (long double)(drugi);
    }
    
    bool operator &lt;= (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        return (long double)(prvi) &lt;= (long double)(drugi);
    }
    
    bool operator &lt; (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        return (long double)(prvi) &lt; (long double)(drugi);
    }
    
    Razlomak &amp;operator += (Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        if (((long double)(drugi))&gt;=0 &amp;&amp; ((long double)(prvi) &gt; (MAX - (long double)(drugi))))
            throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
        if (((long double)(drugi))&lt;0 &amp;&amp; ((long double)(prvi) &lt; (MIN - (long double)(drugi))))
            throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
<a name="1"></a><font color="#00FF00"><a href="match644-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        long long int r (Razlomak::EuklidovAlgoritam(prvi.nazivnik,drugi.nazivnik));
        long long int gornji = prvi.brojnik*(drugi.nazivnik/r)+drugi.brojnik*(prvi.nazivnik/r);
        long long int donji = prvi.nazivnik*(drugi.nazivnik/r);
</font>        prvi.brojnik=gornji;
        prvi.nazivnik=donji;
        return prvi;
    }
    
    Razlomak operator + (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        Razlomak treci(prvi);
        treci+=drugi;
        treci=Razlomak(treci.brojnik,treci.nazivnik);
        return treci;
    }
    
    Razlomak operator + (const Razlomak &amp;raz1) { 
        return raz1;
    }
    
    Razlomak operator ++ (Razlomak &amp;raz1, int) {
        auto helper(raz1);
        raz1.brojnik++;
        raz1.nazivnik++;
        helper=Razlomak(raz1.brojnik,raz1.nazivnik);
        return helper;
    }

    Razlomak &amp;operator ++ (Razlomak &amp;raz1) {
        raz1.brojnik++; 
        raz1.nazivnik++;
        raz1=Razlomak(raz1.brojnik,raz1.nazivnik);
        return raz1;
    } 
    
    Razlomak &amp;operator -= (Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        if (((long double)(drugi))&lt;0 &amp;&amp; ((long double)(prvi) &gt; (MAX - (long double)(drugi))))
            throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
        if (((long double)(drugi))&gt;=0 &amp;&amp; ((long double)(prvi) &lt; (MIN - (long double)(drugi))))
            throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
<a name="2"></a><font color="#0000FF"><a href="match644-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

        long long int r = Razlomak::EuklidovAlgoritam(prvi.nazivnik,drugi.nazivnik);
        long long int gornji = prvi.brojnik*(drugi.nazivnik/r)-drugi.brojnik*(prvi.nazivnik/r);
        long long int donji = prvi.nazivnik*(drugi.nazivnik/r);
</font>        prvi.brojnik=gornji;
        prvi.nazivnik=donji;
        return prvi;
    }
    
    Razlomak operator - (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        Razlomak treci(prvi);
        treci-=drugi;
        return treci;
    }
    
    Razlomak operator - (Razlomak &amp;raz1) { 
        raz1.brojnik=-raz1.brojnik;
        raz1.nazivnik=-raz1.nazivnik;
        if (raz1.brojnik&lt;0 &amp;&amp; raz1.nazivnik&lt;0) { raz1.brojnik=-raz1.brojnik; raz1.nazivnik=-raz1.nazivnik; };
        if (raz1.brojnik&gt;0 &amp;&amp; raz1.nazivnik&lt;0) { raz1.brojnik=-raz1.brojnik; raz1.nazivnik=-raz1.nazivnik; };
        raz1=Razlomak(raz1.brojnik,raz1.nazivnik);
        return raz1;
    }
    
    Razlomak operator -- (Razlomak &amp;raz1, int) {
        auto helper(raz1);
        raz1.brojnik--;
        raz1.nazivnik--;
        if (raz1.brojnik&lt;0 &amp;&amp; raz1.nazivnik&lt;0) { raz1.brojnik=-raz1.brojnik; raz1.nazivnik=-raz1.nazivnik; };
        if (raz1.brojnik&gt;0 &amp;&amp; raz1.nazivnik&lt;0) { raz1.brojnik=-raz1.brojnik; raz1.nazivnik=-raz1.nazivnik; };
        helper=Razlomak(raz1.brojnik,raz1.nazivnik);
        return helper;
    }
    
    Razlomak &amp;operator -- (Razlomak &amp;raz1) {
        raz1.brojnik--;
        raz1.nazivnik--;
        if (raz1.brojnik&lt;0 &amp;&amp; raz1.nazivnik&lt;0) { raz1.brojnik=-raz1.brojnik; raz1.nazivnik=-raz1.nazivnik; };
        if (raz1.brojnik&gt;0 &amp;&amp; raz1.nazivnik&lt;0) { raz1.brojnik=-raz1.brojnik; raz1.nazivnik=-raz1.nazivnik; };
        raz1=Razlomak(raz1.brojnik,raz1.nazivnik);
        return raz1;
    }
    
    Razlomak &amp;operator *= (Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        if (((long double)(drugi))&gt;0 &amp;&amp; ((long double)(prvi) &lt; (MIN / (long double)(drugi))))
            throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
        else if (((long double)(drugi))&gt;0 &amp;&amp; ((long double)(prvi) &gt; (MAX / (long double)(drugi))))
            throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
        if (((long double)(drugi))&lt;0 &amp;&amp; ((long double)(prvi) == MIN))
            throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
        else if (((long double)(drugi))&lt;0 &amp;&amp; (-((long double)(prvi))) &lt; (MIN / (-(long double)(drugi))))
            throw std::overflow_error ("Nemoguce dobiti tacan rezultat");
<a name="0"></a><font color="#FF0000"><a href="match644-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

        long long int s = Razlomak::EuklidovAlgoritam(prvi.brojnik,drugi.nazivnik);
        long long int t = Razlomak::EuklidovAlgoritam(drugi.brojnik,prvi.nazivnik);
        long long int gornji = (prvi.brojnik/s)*(drugi.brojnik/t); 
        long long int donji = (prvi.nazivnik/t)*(drugi.nazivnik/s);
</font>        prvi.brojnik=gornji;
        prvi.nazivnik=donji;
        return prvi;
    }
    
    Razlomak operator * (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        Razlomak treci(prvi);
        treci*=drugi;
        return treci;
    }
    
    Razlomak &amp;operator /= (Razlomak &amp;prvi, const Razlomak &amp;drugi) {
<a name="3"></a><font color="#00FFFF"><a href="match644-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

        long long int u = Razlomak::EuklidovAlgoritam(prvi.brojnik,drugi.brojnik);
        long long int r = Razlomak::EuklidovAlgoritam(prvi.nazivnik,drugi.nazivnik);
        long long int gornji = (prvi.brojnik/u)*(drugi.nazivnik/r); 
</font>        long int donji = (prvi.nazivnik/r)*(drugi.brojnik/u);
        prvi.brojnik=gornji;
        prvi.nazivnik=donji;
        return prvi;
    }
    
    inline Razlomak operator / (const Razlomak &amp;prvi, const Razlomak &amp;drugi) {
        Razlomak treci(prvi);
        treci/=drugi;
        return treci;
    }

int main () {
    try {
        Razlomak x{5},y{4};
        auto zbir (x+y);
        std::cout&lt;&lt;"         "&lt;&lt;y;
    }
    catch (std::logic_error iz) {
        std::cout&lt;&lt;iz.what(); 
    }
    catch (std::overflow_error iz) {
        std::cout&lt;&lt;iz.what();
    }
	return 0;
}</pre>
</body>
</html>
