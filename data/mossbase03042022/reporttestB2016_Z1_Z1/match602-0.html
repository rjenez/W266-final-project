<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z1/student7665.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z1/student7665.cpp<p></p><pre>
//B 2016/2017, ZadaÄ‡a 1, Zadatak 1

#include&lt;iostream&gt;
#include&lt;vector&gt; 

typedef std::vector&lt;int&gt; vektor;                         //Uz ovako naveden typedef, konstrukcija vektor je dostupna svakoj funkciji i olaksica se ogleda u tome sto nije nuzno svaki put pisati prepoznatljivu konstrukciju za vektor, dakle dovoljno je uporijebiti rijec, u ovom slucaju "vektor" da bi se znalo o kojoj konstrukciji je rijec
 
bool Ispitaj(vektor vektor_modul){                       //funkcija koja ima zadatak da primi vektor koji se sastoji od terarnih cifara odredjenog elementa naseg pocetnog vektora i da ispita da li se cifre u terarnom zapisu pojavljuju ili ne, paran broj puta, odnosno neparan.
     int brojac(0);
    
     for(int i=0; i&lt;vektor_modul.size(); i++){
         for(int j=i+1; j&lt;vektor_modul.size(); j++){
             if(vektor_modul[i]==vektor_modul[j]) brojac++;
             if(vektor_modul[i]==vektor_modul[j]){
             vektor_modul.erase(vektor_modul.begin()+j);
             j--;
             }
         }
         if(brojac==0 || ((brojac+1)%2!=0 &amp;&amp; brojac&gt;1)) return false; 
         brojac=0;
     }
     return true;
}

bool IspitajDaLiSuSviElementiParliIliNeparni(vektor vektor_modul){ 
    int prvibr(1), drugibr(1);                            //ova funkcija ima ulogu da pronadje onaj element koji nema SVE elemente parne ili neparne
    for(int i=0; i&lt;vektor_modul.size(); i++){
        for(int j=i+1; j&lt;vektor_modul.size(); j++){
        if(vektor_modul[i]==vektor_modul[j]) prvibr++;
        if(vektor_modul[i]==vektor_modul[j]) {
            vektor_modul.erase(vektor_modul.begin()+j);
            j--; 
        }
        }
        if(prvibr&gt;=1) break;
    }
    for(int i=1; i&lt;vektor_modul.size(); i++){
        for(int j=i+1; j&lt;vektor_modul.size(); j++){
            if(vektor_modul[i]==vektor_modul[j]) drugibr++;
            if(vektor_modul[i]==vektor_modul[j]){
                vektor_modul.erase(vektor_modul.begin()+j);
                j--;
            }
        }
        
        if(prvibr%2!=0 &amp;&amp; drugibr%2!=0) drugibr=1;
        else return false;
      
    }
    return true;
}

vektor IzdvojiGadne(vektor VEK, bool X){
    vektor OPAKI;
    vektor ODVRATNI;
    vektor vektor_modula;
    
    int n;
    int modul;
    
<a name="0"></a><font color="#FF0000"><a href="match602-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

    for(int i=0; i&lt;VEK.size(); i++){                     //brisanje istih elemenata u pocetnom vektoru
        for(int j=i+1; j&lt;VEK.size(); j++){
            if(VEK.at(i)==VEK.at(j)){
                VEK.erase(VEK.begin()+j);
</font>            }
        }
    }
    
<a name="1"></a><font color="#00FF00"><a href="match602-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

    for(int i=0; i&lt;VEK.size(); i++){
        for(int j=i+1; j&lt;VEK.size(); j++){
            if(VEK.at(i)==VEK.at(j)){
                VEK.erase(VEK.begin()+j);
</font>            }
        }
    }
    
   
    for(int i=0; i&lt;VEK.size(); i++){
        n=VEK.at(i);
        while(n!=0){
            modul= n%3;
            vektor_modula.push_back(modul);
            n= n/3;
        }
       
        
        if(Ispitaj(vektor_modula)==true)
            OPAKI.push_back(VEK.at(i));
        
            
        if(Ispitaj(vektor_modula)==false)
        {
            if(IspitajDaLiSuSviElementiParliIliNeparni(vektor_modula)==true)
            ODVRATNI.push_back(VEK.at(i));
        }
        vektor_modula=vektor(0);
    }
    
    if(X==true)
      return OPAKI;
      
    if(X==false) 
      return ODVRATNI;
}


int main ()
{
    vektor VEKTOR;
    int elementi_VEKTORA;
    
    std::cout&lt;&lt;"Unesite brojeve (0 za prekid unosa): ";
    for(;;){                                               //beskonacna for petlja koja vrsi unos elemenata u vektor VEKTOR dok god je element koji unosimo s tastature nenultog karaktera
        std::cin&gt;&gt;elementi_VEKTORA;
        if(elementi_VEKTORA==0) break;
        VEKTOR.push_back(elementi_VEKTORA);
    }

    auto opaki = IzdvojiGadne(VEKTOR, true);
    auto odvratni = IzdvojiGadne(VEKTOR, false);
   
std::cout&lt;&lt;"Opaki: ";
    for(int x: opaki){                                     //TZV rangovska for petlja koja je prakticna kod ispisa elemenata vektora
<a name="2"></a><font color="#0000FF"><a href="match602-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

        std::cout&lt;&lt;x&lt;&lt;" ";
    }
    std::cout&lt;&lt;std::endl;
    
std::cout&lt;&lt;"Odvratni: ";
    for(int x: odvratni){
</font>        std::cout&lt;&lt;x&lt;&lt;" ";
    }
	return 0;
}</pre>
</body>
</html>
