<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z4/student5842.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z4/student5842.cpp<p></p><pre>
/*B 2016/2017, Zadaća 1, Zadatak 4
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.
	
*/
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
typedef std::vector&lt;std::string&gt; StringVektor;

std::string ObrniFraze(std::string recenica, StringVektor fraze) {
	for(int i(0); i&lt;fraze.size(); i++) {			//petljom idemo kroz vektor stringova, za svaku frazu provjera da li se pojavljuje u recenici
		for(int j(0); j&lt;recenica.length(); j++) {	//petljom idemo kroz recenicu slovo po slovo
			int k(0);								//pomocni brojac k koji sluzi da idemo slovo po slovo kroz frazu u vektoru stringova
			if(fraze[i][k]==recenica[j]) {			//provjera da li se u recenici pojavljuje pocetno slovo fraze, ako ne da petlja nastavi dalje
				while(fraze[i][k]==recenica[j+k]) {  //ukoliko je pocetno slovo isto, provjeravaju se u while petlji i ostala slova fraze
					k++;							//uvećavamo brojac k svaki put u petlji
					if (k==fraze[i].length()) break; //kada brojac bude jednak duzini fraze prekidamo petlju i to je znak da se fraza javlja u recenici
				}
				int n(0);							//pomocni brojac koji će nam sluziti za obrtanje rijeci
				if(k==fraze[i].length()) {			//provjera da li je doslo do breaka u while petlji, ukoliko jeste obrćemo frazu
					 for(int l(j); l&lt;j+k/2; l++) {	//posto fraza u recenici pocinje od j-te pozicije, brojac inicijaliziramo sa j i petlja ide do polovine fraze kako ne bi doslo do duplog obrtanja
					 	int pom(recenica[l]);       //l-ti char smjestamo u pomocnu varijablu(moze biti i tipa char)
					 	recenica[l]=recenica[j+k-1-n]; //posto k ima vrijednost duzine stringa umanjujemo za 1 jer indeksiranje krece od 0, pa posljednji clan ima indeks k-1
					 	recenica[j+k-1-n]=pom;		//na prvo mjesto stavljamo zadnji clan i obratno, na drugo predzadnji itd
					 	n++;		//uvećavamo brojac n kako bi se s kraja fraze priblizavali sredini
					 }
				}
			}
		}
	}
	return recenica;
}
std::string IzmijeniUPigLatin(std::string recenica, StringVektor fraze) {
	for(int i(0); i&lt;fraze.size(); i++) 				//sa ugnijezdenom for petljom prolazimo kroz cijeli vektor fraze, i kroz svaku frazu znak po znak
		for(int j(0); j&lt;fraze[i].length(); j++)     //kako bi provjerili da li ima nekih drugih znakova osim eng. alfabeta, ukoliko da baca se izuzetak
			if(!(fraze[i][j]&gt;='A' &amp;&amp; fraze[i][j]&lt;='Z') &amp;&amp; !(fraze[i][j]&gt;='a' &amp;&amp; fraze[i][j]&lt;='z')) throw std::domain_error ("Nekorektan izbor rijeci");
	if(fraze.size()==0) {	//po tekstu zadatka ako je je vektor fraze prazan svaka rijec u recenici se mijenja po pig latinu
		for(int i(0); i&lt;recenica.length(); i++) { //for petljom idemo kroz citavu recenicu u potrazi za rijecima
			int k(i);  // u pom brojacu k, pamtimo poziciju prvog slova u rijeci
			if((recenica[i]&gt;='A' &amp;&amp; recenica[i]&lt;='Z') || (recenica[i]&gt;='a' &amp;&amp; recenica[i]&lt;='z')) { //provjera da li recenica pocinje slovima
<a name="2"></a><font color="#0000FF"><a href="match726-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

				while((recenica[i]&gt;='A' &amp;&amp; recenica[i]&lt;='Z') || (recenica[i]&gt;='a' &amp;&amp; recenica[i]&lt;='z')) i++; //idemo petljom kroz recenicu dok ne naiđemo na nesto sto nije slovo
				recenica.insert(recenica.begin()+i, recenica[k]); //prvo slovo sa pozicije k, insertujemo na poziciju i (i je na 1 poziciji iza rijeci)
</font><a name="3"></a><font color="#00FFFF"><a href="match726-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

				recenica.erase(recenica.begin()+k); //brisemo prvo slovo rijeci
				recenica.insert(recenica.begin()+i, 'a'); //posto smo koristili erase, i je idalje na 1 poziciji iza rijeci, tu insertujemo 'a'
				recenica.insert(recenica.begin()+i+1, 'y'); // i je sada na pozicij slova 'a', pa 'y' insertujemo na i+1 poziciju
				i+=2; //nakon 3 inserta i 1 erase i povećavamo za 2 kako bi i-ti indeks bio iza rijeci
</font>			}
			if(i&lt;recenica.length()) {  //ako nije kraj recenice idemou potragu za novom rijeci
				while(!(recenica[i]&gt;='A' &amp;&amp; recenica[i]&lt;='Z') &amp;&amp; !(recenica[i]&gt;='a' &amp;&amp; recenica[i]&lt;='z')) { // sada u petlji povećavamo brojac dok
					i++;       // se ne naiđe na slovo
					if(i&gt;=recenica.length()) break; //ako i prekoraci duzinu recenice, dolazi do breaka kako ne bi pristupali izvan stringa
				}  //na kraju while petlje na poziciji i je pocetno slovo neke rijeci (ukoliko nije doslo do breaka)
				i--; //s obzirom da će se brojac inkrementirati u for petlji pa će tada i biti indeks drugog slova, dekrementiramo i
			}
		}
	}
	for(int i(0); i&lt;fraze.size(); i++) { //slicno kao i u obrni fraze uz dodatni uslov da se mijenjaju samo rijeci, a ne i podfraze
		for(int j(0); j&lt;recenica.length(); j++) {
			int k(0);
			bool prekid(false);  //ovdje smo deklarisali logicku varijablu prekid kako bi znali je li doslo do prekida u while-petlji
			if(fraze[i][k]==recenica[j]) {
				while(fraze[i][k]==recenica[j+k]) {
					k++;
					if(k==fraze[i].length()) {prekid=true; break;} //ako se fraza iz vektora javlja u recenici dolazi do prekida
				}  //u sljedecoj liniji koda nalazi se uslov za provjeru da li je doslo do prekida i da li se fraza javlja kao rijec u recenici (a ne kao podfraza), uslov za to je da je rijec omeđena necim sto nije slovo ili da se radi o pocetku ili kraju recenice
				if(prekid &amp;&amp; (j==0 || (!(recenica[j-1]&gt;='A' &amp;&amp; recenica[j-1]&lt;='Z') &amp;&amp; !(recenica[j-1]&gt;='a' &amp;&amp; recenica[j-1]&lt;='z'))) &amp;&amp; (j+k==recenica.length() || (!(recenica[j+k]&gt;='A' &amp;&amp; recenica[j+k]&lt;='Z') &amp;&amp; !(recenica[j+k]&gt;='a' &amp;&amp; recenica[j+k]&lt;='z')))) {
					char pom(recenica[j]); //primjena pig latin pravila slicno kao i kada je vektor fraze prazan, uz malo drugaciji redoslijed
					recenica.erase(recenica.begin()+j); //prvo slovo rijeci na j-toj poziciji mozemo obrisati, jer ga cuvamo u varijabli pom
					recenica.insert(recenica.begin()+j+k-1, pom); //inace bi j+k bio indeks pozicije iza posljednjeg slova, ali zbog erase to je sada j+k-1 i na tu poziciju insertujemo prvo slovo
					recenica.insert(recenica.begin()+j+k, 'a');  //nakon prethodnog inserta sada je j+k pozicija iza posljednjeg slova i tu insertujemo 'a'
					recenica.insert(recenica.begin()+j+k+1, 'y'); //konacno na poziciju iza 'a' insertujemo i 'y'
				}
			}
			
		}
	}
	
<a name="1"></a><font color="#00FF00"><a href="match726-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

	return recenica;
}
int main ()
{
	std::string recenica;
	StringVektor spisak_fraza;
	std::cout&lt;&lt;"Unesite recenicu: ";
	std::getline(std::cin, recenica);
	std::cout&lt;&lt;"Unesite fraze: ";
</font>	std::string fraza;
	for(;;) {								//beskonacna for petlja za unos fraza
		std::getline(std::cin, fraza);		//unosi se fraza
		if(fraza.length()==0) break;		//provjera da li je naprazno unesen enter, ukoliko jeste prekida se besk. petlja
		spisak_fraza.push_back(fraza);		//ukoliko je zaista unesena fraza ona se stavlja u vektor i petlja se ponavlja
	}
	try {				//pošto funkcija IzmijeniUPigLatin baca izuzetak ona se nalazi u try-catch bloku
<a name="0"></a><font color="#FF0000"><a href="match726-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

		std::cout&lt;&lt;"Recenica nakon PigLatin transformacije: "&lt;&lt;IzmijeniUPigLatin(recenica, spisak_fraza)&lt;&lt;std::endl;
	}
	catch (std::domain_error poruka) {
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka.what()&lt;&lt;std::endl;
</font>	}
	std::cout&lt;&lt;"Recenica nakon obrtanja fraza: "&lt;&lt;ObrniFraze(recenica, spisak_fraza); //funkcija ObrniFraze ne baca nikakve izuzetke i nalazi se van
	return 0;										//bloka, kako bi se izvrsila cak iako prva funkcija baci izuzetak
}</pre>
</body>
</html>
