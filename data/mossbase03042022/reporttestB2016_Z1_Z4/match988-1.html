<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z4/student3442.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z4/student4425.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
// 2/19 fail.
// 1 memory error, 1 wrong result 
// wr: new line should be added out of exception msg like std::endl, exception msg should be exact &amp; intact
// me: dunno
bool IsItALetter(char a) {
	if ((a &gt;= 'A' &amp;&amp; a &lt;= 'Z') || (a &gt;= 'a' &amp;&amp; a &lt;= 'z')) return true;
	else return false;
}

std::string ObrniFraze(std::string sentence, std::vector&lt;std::string&gt; phrases) {
	if (sentence.length()==0) return sentence;
	//
	/*bool valid(false);
	for (int i = 0; i &lt; sentence.length(); i++) {
		if (IsItALetter(sentence[i])) {
			valid = true;
			break;
		}
	}
	if (!valid) return sentence;
	*/
	int num_of_phrases(phrases.size()), sentence_len(sentence.size());
	for (int i = 0; i &lt; num_of_phrases; i++) {
		std::string a_phrase(phrases[i]);
		int a_phrase_len(a_phrase.size());
		
		if (a_phrase_len &gt; sentence.size()) continue; //genius...
		
		for (int j = 0; j &lt; sentence_len - a_phrase_len+1; j++) { //+1 (29.3)
			std::string potential_substring(sentence.substr(j, a_phrase_len));
			//std::cout &lt;&lt; potential_substring &lt;&lt; "@@" &lt;&lt; a_phrase &lt;&lt; "@@" &lt;&lt; std::endl; ////
			if (potential_substring == a_phrase) {
				//reverse
				for (int k = 0; k &lt; (a_phrase_len) / 2; k++) {
					char tmp = sentence[j+k];
					sentence[j+k] = sentence[j+a_phrase_len-1-k];
					sentence[j+a_phrase_len-1-k] = tmp;
				}
				//
			}
		}
	}
	return sentence;
}

std::string IzmijeniUPigLatin(std::string sentence, std::vector&lt;std::string&gt; words) {
	if (sentence.length()==0) return sentence;
	//
	bool valid(false);
	for (int i = 0; i &lt; sentence.length(); i++) {
		if(IsItALetter(sentence[i])) {
			valid = true;
			break;
		}
	}
	
	
	bool allwords(false);
	std::vector&lt;std::string&gt; empty;
	
	if (words.size()==0) {
		//sve riječi
		allwords=true;
		int woerter(0);
		//prebroji rijeci
<a name="0"></a><font color="#FF0000"><a href="match988-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

		bool IsSeparator(true);
		for (int i = 0; i &lt; sentence.length(); i++) {
			if (!((sentence[i]&gt;='A' &amp;&amp; sentence[i]&lt;='Z') || (sentence[i]&gt;='a' &amp;&amp; sentence[i]&lt;='z'))) IsSeparator = true;
</font>			else if (IsSeparator) {
				IsSeparator = false;
				int start = i;
<a name="1"></a><font color="#00FF00"><a href="match988-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

				while (((sentence[i]&gt;='A' &amp;&amp; sentence[i]&lt;='Z')||(sentence[i]&gt;='a' &amp;&amp; sentence[i]&lt;='z')) &amp;&amp; i &lt; sentence.length()) i++;
				std::string add_word = sentence.substr(start, i-start);
</font>				//std::cout &lt;&lt; "Word added &gt;&gt;" &lt;&lt; add_word &lt;&lt; "&lt;&lt;" &lt;&lt; std::endl; //////////////////////////////////////////////
				words.resize(woerter+1);
				words[woerter] = add_word;
				woerter++;
				i--;
			}
		}
		
		goto idiuelse;
		
	} else {
		idiuelse: 
		//provjeri uslov za riječi
		for (int i = 0; i &lt; words.size(); i++) {
			std::string s=words[i];
			for (int j = 0; j &lt; words[i].size(); j++) {
				if (!((s[j] &gt;= 'A' &amp;&amp; s[j] &lt;='Z') || (s[j] &gt;= 'a' &amp;&amp; s[j] &lt;='z'))) throw std::domain_error("Nekorektan izbor rijeci\n");
			}
		}
		
		if (!valid) return sentence;
		
		for (int i = 0; i &lt; words.size(); i++) {
			std::string a_word(words[i]);
			int a_word_len(a_word.size());
			
			if (a_word_len &gt; sentence.size()) continue;
			
			for (int j = 0; j &lt; sentence.size()-a_word_len; j++) {
				std::string potential_word(sentence.substr(j, a_word_len));
					std::string space(" "), before(" "), after(" ");
					
					if (j==0) {
						after[0] = sentence[j+a_word_len];
						if (IsItALetter(after[0])) continue; //nije rijec;
					} else {
						before[0] = sentence[j-1];
						after[0] = sentence[j+a_word_len];
						//std::cout &lt;&lt; "before &gt;&gt;" &lt;&lt; before &lt;&lt; "   after &gt;&gt;" &lt;&lt; after &lt;&lt; std::endl;
						if (IsItALetter(after[0]) || IsItALetter(before[0])) continue; //nije rijec
					}
					
					//std::cout &lt;&lt; "&gt;&gt;&gt;&gt;&gt;&gt;&gt;" &lt;&lt; potential_word &lt;&lt; "&lt;&lt;&lt;&lt;&lt;&lt;&lt;"&lt;&lt; a_word &lt;&lt; "!!!" &lt;&lt; sentence.size() &lt;&lt; std::endl;///////////////////////////
				if (potential_word == a_word) {
					//piglatiniziraj riječ
					std::string first_letter("X");
					first_letter[0] = sentence[j];
					std::string tmp = sentence.substr(j+1, a_word_len-1) + first_letter + "ay";
					//std::cout &lt;&lt; "prije:" &lt;&lt; sentence.size() &lt;&lt; std::endl; ///////////////////////////////
					for (int k = 0; k &lt; a_word_len; k++) {
						sentence.erase(sentence.begin()+j);
						//std::cout &lt;&lt; "brisanje " &lt;&lt; k+1 &lt;&lt; " :" &lt;&lt; sentence.size() &lt;&lt; std::endl;
					}
					for (int k = 0; k &lt; tmp.size(); k++) {
						sentence.insert(sentence.begin()+j+k, tmp[k]);
						//std::cout &lt;&lt; "dodavanje " &lt;&lt; k+1 &lt;&lt; " :" &lt;&lt; sentence.size() &lt;&lt; std::endl;
					}
				}
				
				//
			}
		}
		
		//posljednja rijec - 'cause it doesn't fit to the above alg.
		//if (words.size()!=0) {
			int end = sentence.length()-1;
			while (!((sentence[end]&gt;='A' &amp;&amp; sentence[end]&lt;='Z') || (sentence[end]&gt;='a' &amp;&amp; sentence[end]&lt;='z'))) end--;
			int start = end;
			while (((sentence[start]&gt;='A' &amp;&amp; sentence[start]&lt;='Z') || (sentence[start]&gt;='a' &amp;&amp; sentence[start]&lt;='z'))) start--;
			start++;
			std::string forcheck = sentence.substr(start, end-start+1);
			//int last_position = words.size() - 1;
			//std::cout &lt;&lt; forcheck&lt;&lt; words[last_position] &lt;&lt; std::endl; //////////////////////////////
			
			for (int s = 0; s &lt; words.size(); s++) {
				if (forcheck == words[s]) {
					std::string foradd = sentence.substr(start+1, end-start+1) + sentence[start] + "ay";
					for (int k = 0; k &lt; foradd.size()-2; k++) sentence.erase(sentence.begin()+start);
					for (int k = 0; k &lt; foradd.size(); k++) sentence.insert(sentence.begin()+start+k, foradd[k]);
					break;
				}
			}
		//}
	}
<a name="2"></a><font color="#0000FF"><a href="match988-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	if (allwords) words = empty;
	return sentence;
}

int main () {
	
	std::cout &lt;&lt; "Unesite recenicu: ";
	std::string recenica;
	std::getline(std::cin, recenica);
	
	std::cout &lt;&lt; "Unesite fraze: ";
</font>	std::vector&lt;std::string&gt; fraze, empty;
	
	int brojac(0);
	while(1) {
		std::string tmp, empt;
		std::getline(std::cin, tmp);
		if (tmp[0]=='\n' || tmp.size()==0) {
			std::getline(std::cin, tmp);
			if (tmp[0]=='\n' || tmp.size()==0) break;
			else {
				brojac++;
				fraze.resize(brojac);
				fraze[brojac-1]=tmp;
				tmp=empt;
			}
		} else {
			brojac++;
			fraze.resize(brojac);
			fraze[brojac-1]=tmp;
			tmp=empt;
		}
	}
	
	try {
		std::string trans1(IzmijeniUPigLatin(recenica, fraze));
		std::cout &lt;&lt; "Recenica nakon PigLatin transformacije: " &lt;&lt; trans1 &lt;&lt; std::endl;
	} catch(std::domain_error err) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; err.what();
	}
	
	std::string trans2(ObrniFraze(recenica, fraze));
	std::cout &lt;&lt; "Recenica nakon obrtanja fraza: " &lt;&lt; trans2;
	
	return 0;
}</pre>
</body>
</html>
