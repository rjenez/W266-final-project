<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z4/student3867.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z4/student3867.cpp<p></p><pre>
//s:~PROGRAMMERS DON'T SEE WOMEN AS objects.
//s:~THEY CONSIDER EACH TO BE IN A class OF HER OWN.

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;cctype&gt;

std::string ObrniFraze(std::string recenica, std::vector&lt;std::string&gt; frase)
{
	std::string rec{recenica};
	if(frase.size()==0)
		return rec;
	for(int i=0;i&lt;frase.size();i++)
	{
		int count{0};
		bool flag{false};
		int begin_posit,end_posit;
		for(int j=0;j&lt;rec.length();j++)
		{
//izuzetak za "frazu" duzine 1
			if(frase[i].length()==1)
				break;
//provjera pocetka fraze u recenici
			if(flag==false &amp;&amp; rec.at(j)==frase[i].at(count))
			{
				flag=true;
				begin_posit=j;
				count++;
			}
	//provjera nastavka na pocetak u recenici za istu frazu
			else if(flag==true &amp;&amp; rec.at(j)==frase[i].at(count))
			{
				end_posit=j;
				count++;
		//provjera kraza fraze
				if(frase[i].length()==count)
				{
					flag=false;
					count=0;
					int position{0};
			//obrtanje rijeci u recenici koja odgovara frazi
					for(int k=begin_posit;k&lt;=(begin_posit+(end_posit-begin_posit)/2);k++)
					{
						char znak{rec.at(k)};
						rec.at(k)=rec.at(end_posit-position);
					    rec.at(end_posit-position)=znak;
					    position++;
					}
				}
			}
	//provjera pocetka istih slova jedno do drugog, i vracanje na novi pocetak
			else
			{
				if(j&gt;0 &amp;&amp; rec.at(j)==rec.at(j-1) &amp;&amp; flag==true)
				{
					begin_posit=j;
					count=1;
				}
	//nema podudaranja
				else
				{
					count=0;
					flag=false;
				}
			}
		}
	}
	return rec;
}

std::string IzmijeniUPigLatin(std::string recenica, std::vector&lt;std::string&gt; frase)
{
	std::string rec{recenica};
	if(frase.size()==0)
	{
		bool faza{false};
		int begin_save;
		for(int i=0;i&lt;rec.size();i++)
		{
<a name="1"></a><font color="#00FF00"><a href="match389-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

			if(faza==false &amp;&amp; ((rec.at(i)&gt;='A' &amp;&amp; rec.at(i)&lt;='Z') || (rec.at(i)&gt;='a' &amp;&amp; rec.at(i)&lt;='z')))
			{
				begin_save=i;
</font>				faza=true;
			}
<a name="3"></a><font color="#00FFFF"><a href="match389-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			else if(faza==true &amp;&amp; (rec.at(i)&lt;'A' || (rec.at(i)&gt;'Z' &amp;&amp; rec.at(i)&lt;'a') || rec.at(i)&gt;'z'))
</font>			{
				reform:
				int pos{i};
				faza=false;
				int fo;
				char znak{rec.at(begin_save)};
			//pomjeranje svih slova za jedno mjesto unazad(osim prvo naravno)
				for(fo=begin_save;fo&lt;pos-1;fo++)
					rec.at(fo)=rec.at(fo+1);
			//prvo slovo ide na kraj
				rec.at(fo)=znak;
				rec.resize(rec.length()+2);
			//pomjeranje svih karaktera od mjesta izmjene za dva mjesta
				for(int teta=rec.length()-1;teta&gt;=pos+2;teta--)
					rec.at(teta)=rec.at(teta-2);
				rec.at(fo+1)='a';
				rec.at(fo+2)='y';
				i+=2;
			}
<a name="2"></a><font color="#0000FF"><a href="match389-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

			else if(faza==true &amp;&amp; ((rec.at(i)&gt;='A' &amp;&amp; rec.at(i)&lt;='Z') || (rec.at(i)&gt;='a' &amp;&amp; rec.at(i)&lt;='z')))
</font>			{
			//zadnji karakter u recenici
				if(i==rec.size()-1)
					goto reform;
				continue;
			}
			else faza=false;
		}
		return rec;
	}
//test alfabetskog formata fraza
	for(int i=0;i&lt;frase.size();i++)
<a name="0"></a><font color="#FF0000"><a href="match389-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

		for(int j=0;j&lt;frase[i].length();j++)
			if((frase[i].at(j)&lt;'A' || (frase[i].at(j)&gt;'Z' &amp;&amp; frase[i].at(j)&lt;'a') || frase[i].at(j)&gt;'z'))
				throw std::domain_error("Nekorektan izbor rijeci");
</font>	std::vector&lt;std::vector&lt;int&gt;&gt; position(1);
	for(int i=0;i&lt;frase.size();i++)
	{
		int count{0};
		bool morph{false};
		int begin_save;
		for(int j=0;j&lt;rec.length();j++)
		{
//pocetak fraze u recenici
			if(morph==false &amp;&amp; rec.at(j)==frase[i].at(count))
			{
		//izuzetak za "frazu" duzine 1
				if(frase[i].length()==1 &amp;&amp; (j==rec.size()-1 || ((rec.at(j+1)&lt;'A' || (rec.at(j+1)&gt;'Z' &amp;&amp; rec.at(j+1)&lt;'a') || rec.at(j+1)&gt;'z') &amp;&amp; 
				(rec.at(j-1)&lt;'A' || (rec.at(j-1)&gt;'Z' &amp;&amp; rec.at(j-1)&lt;'a') || rec.at(j-1)&gt;'z'))))
				{
					rec.resize(rec.length()+2);
			//pomjeranje svih karaktera od mjesta izmjene za dva mjesta
					for(int teta=rec.length()-1;teta&gt;=j+2;teta--)
						rec.at(teta)=rec.at(teta-2);
					rec.at(j+1)='a';
					rec.at(j+2)='y';
					count=0;
			//povecanje svake koordinate od izmjene za (+2) zbog izmjene
					for(int red=0;red&lt;position.size();red++)
					{
						for(int x=0;x&lt;position[red].size();x++)
							if(position[red][x]&gt;j)
								position[red][x]+=2;
					}
					morph=false;
					continue;
				}
				if(j&gt;0)
				{
					if((rec.at(j-1)&lt;'A' || (rec.at(j-1)&gt;'Z' &amp;&amp; rec.at(j-1)&lt;'a') || rec.at(j-1)&gt;'z'))
					{
						morph=true;
						begin_save=j;
						count++;
					}
				}
				else
				{
					morph=true;
					begin_save=j;
					count++;
				}
			}
	//nastavak na pocetak fraze u recenici
			else if(morph==true &amp;&amp; rec.at(j)==frase[i].at(count))
			{
				count++;
		//kraj fraze i podudaranje
				if(frase[i].length()==count)
				{
					if(j==rec.size()-1)
					{
			//zadnji karakter u recenici
						position[position.size()-1].push_back(begin_save);
						position[position.size()-1].push_back(j);
						position.resize(position.size()+1);
					}
			//prekid rijeci sa nealfabetskim karakterom
					else if((rec.at(j+1)&lt;'A' || (rec.at(j+1)&gt;'Z' &amp;&amp; rec.at(j+1)&lt;'a') || rec.at(j+1)&gt;'z'))
					{
						morph=false;
						count=0;
				//postavljanje u matricu "koordinata" pocetka i kraja fraze u recenici
						position[position.size()-1].push_back(begin_save);
						position[position.size()-1].push_back(j);
						position.resize(position.size()+1);
					}
					else
					{
						count=0;
						morph=false;
					}
				}
			}
			else
			{
	//nema podudaranja
				count=0;
				morph=false;
			}
		}
	}
//brisanje praznih redova matrice u slucaju pogresnog sirenja
	do
		position.resize(position.size()-1);
	while(position[position.size()-1].size()==0);
	int temp,prom;
//sortiranje "koordinata" matrice od manjeg ka vecem

//sortira se da bi se lakse kretalo po recenici i islo redom tokom mijenjanja u pig latin
	for(int i=0;i&lt;position.size()-1;i++)
	{
		int min=i;
		for(int j=i+1;j&lt;position.size();j++)
			if(position[j][0]&lt;position[min][0])
				min=j;
		temp=position[i][0];
		prom=position[i][1];
		position[i][0]=position[min][0];
		position[i][1]=position[min][1];
		position[min][0]=temp;
		position[min][1]=prom;
	}
//promjena u piglatin
	int begin{0};
	do
	{
		char znak{rec.at(position[begin][0])};
		int fo;
//pomjeranje svih slova za jedno mjesto unazad(osim prvo naravno)
		for(fo=position[begin][0];fo&lt;position[begin][1];fo++)
			rec.at(fo)=rec.at(fo+1);
//prvo slovo ide na kraj
		rec.at(fo)=znak;
//prosirenje za "ay"
		rec.resize(rec.length()+2);
//pomjeranje svih karaktera od mjesta izmjene za dva mjesta
		for(int teta=rec.length()-1;teta&gt;=fo+2;teta--)
			rec.at(teta)=rec.at(teta-2);
		rec.at(fo+1)='a';
		rec.at(fo+2)='y';
		begin++;
//povecanje svake koordinate od izmjene za (+2) zbog izmjene
		for(int red=begin;red&lt;position.size();red++)
			for(int x=0;x&lt;position[red].size();x++)
				position[red][x]+=2;
	}while(begin!=position.size());
	return rec;
}

int main()
{
	std::cout&lt;&lt;"Unesite recenicu: ";
	std::string recenica;
	std::getline(std::cin,recenica);
	std::cout&lt;&lt;"Unesite fraze: ";
	std::vector&lt;std::string&gt; fraze;
	std::string novi;
//unos fraza sa zavrsetkom '\n'
	do
	{
		std::getline(std::cin,novi);
		if(novi.length()!=0)
			fraze.push_back(novi);
	}while(novi.length()!=0);
//try za piglatin test nepravilan format	
	try
	{
		std::cout&lt;&lt;"Recenica nakon PigLatin transformacije: ";
		std::string pigey{IzmijeniUPigLatin(recenica,fraze)};
		for(char c:pigey)
			std::cout&lt;&lt;c;
		std::cout&lt;&lt;std::endl;
	}
	catch(std::domain_error alfabet)
	{
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;alfabet.what()&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Recenica nakon obrtanja fraza: ";
	std::string obrnuti{ObrniFraze(recenica,fraze)};
	for(char c:obrnuti)
		std::cout&lt;&lt;c;
	return 0;
}</pre>
</body>
</html>
