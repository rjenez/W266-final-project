<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z2/student6455.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z2/student9887.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match260-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_95.gif"/></a>

/B2017/2018: Zadaća 3, Zadatak 2
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;tuple&gt;
/*Prvo ćete napraviti funkciju “KreirajIndeksPojmova” koja kao 
parametar prima neki objekat tipa “Knjiga”, koji predstavlja tekst
koji se analizira. Funkcija kao rezultat treba vratiti mapu koja predstavlja traženi indeks pojmova.
Ključna polja ove mape su tipa “string”, a pridružene vrijednosti su skupovi čiji su elementi uređene trojke
(tipa “tuple”), čija je prva koordinata tipa “string”, a druga i treća su cijeli brojevi. 
Vrijednosti ključnih polja predstavljaju različite riječi pronađene u analiziranom tekstu, 
dok su odgovarajuće pridružene vrijednosti skupovi čiji elementi opisuju pozicije na kojima
se odgovarajuća riječ nalazi unutar razmatranog teksta. Svaka pozicija opisana je kao uređena trojka,
pri čemu prva koordinata predstavlja oznaku poglavlja, druga koordinata redni broj stranice (uz numeraciju koja počinje od jedinice, a ne od nule)
, dok treća koordinata predstavlja poziciju razmatrane riječi unutar stranice (tj. indeks od kojeg počinje riječ).*/
typedef std::map&lt;std::string ,std::vector&lt;std::string&gt;&gt; Knjiga;
struct PolozajiIRijeci{
    std::vector&lt;std::string&gt; rijeci;
    std::vector&lt;std::vector&lt;int&gt;&gt; indeksi;
};
bool Ponavljanja(std::vector&lt;std::string&gt; s, std::string rijec){
    for(int i=0;i&lt;s.size();i++){
    if(s.at(i)==rijec){
    return true;}}
    return false;
}
PolozajiIRijeci  Vrati_Rijeci_I_Indekse(std::string sadrzaj_stranice){
    
    PolozajiIRijeci rezultat;
    bool razmak=true;
    std::string cuva;
int cuva_indeks(0);
    int i(0);
    int po_redu_rijec(0);
    while(i&lt;sadrzaj_stranice.length()) {
        if(sadrzaj_stranice[i]==' ')
            razmak=true;
        else if(razmak) {
            razmak=false;
        cuva_indeks=i;
                rezultat.indeksi[po_redu_rijec].push_back(i);
            while(sadrzaj_stranice[i]!=' '&amp;&amp; i&lt;sadrzaj_stranice.length()) {
                
                cuva.push_back(sadrzaj_stranice[i]);
                
                i++;
            }
            if(!Ponavljanja(rezultat.rijeci, cuva)){
                rezultat.rijeci.push_back(cuva);
                
            
            int pocetak(0);
            for(int j=i;j&lt;sadrzaj_stranice.length();j++){
                while(cuva_indeks!=-1){
                cuva_indeks=sadrzaj_stranice.find(cuva, pocetak);
                pocetak=cuva_indeks+1;
                if(cuva_indeks!=-1)
                rezultat.indeksi[po_redu_rijec].push_back(cuva_indeks);
            }
}
            po_redu_rijec++;
}
        }
        i++;

    }
    return rezultat;

}
std::map&lt;std::string , std::set&lt;std::tuple&lt;std::string, int, int&gt;&gt;&gt;KreirajIndeksPojmova(Knjiga tekst){
   std::map&lt;std::string , std::set&lt;std::tuple&lt;std::string, int, int&gt;&gt;&gt; rezultat;
   int broj_stranica=tekst.size();
   for(auto it=tekst.begin() ;it!=tekst.end();it++){
       for(int i=0;i&lt;broj_stranica;i++){
          PolozajiIRijeci jedna_stranica;
          jedna_stranica=Vrati_Rijeci_I_Indekse(tekst[it-&gt;first][i]);
          std::cout&lt;&lt;
       }
   }
}
int main ()
{
	return 0;
</font>}
</pre>
</body>
</html>
