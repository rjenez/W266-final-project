<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z4/Z2/student5961.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z4/Z2/student7795.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match13-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B2017/2018: ZadaÄ‡a 4, Zadatak 2
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;tuple&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

struct Kugla {
    double x, y, z, r;
};

class NepreklapajucaKugla {
    using PokNaKuglu = NepreklapajucaKugla*;
    private:
        static PokNaKuglu lastSphere;
        PokNaKuglu previousSphere;
        double x, y, z, r;
        
        /// additional functions and variables
		constexpr static double PI = 4 * atan(1);
		constexpr static double ERROR = std::pow(10, -10);
		
		/// additional control functions
		bool static _equal(const double&amp; x, const double&amp; y) { return std::fabs(x - y) &lt; ERROR; };
        void static checkCenter(const double&amp; _r) { if(_r &lt; 0) throw std::domain_error("Ilegalan poluprecnik");}
        double static _SQR(const double&amp; x) { return x*x; };
        double static _distance(const double&amp; x1, const double&amp; y1, const double&amp; z1, 
                            const double&amp; x2, const double&amp; y2, const double&amp; z2) { return _SQR(x1 - x2) + _SQR(y1 - y2) + _SQR(z1 - z2); }
        /// function to check if sphere details
        double static KugleRastojanje(const Kugla &amp;k1, const Kugla &amp;k2) { return std::sqrt(_distance(k1.x, k1.y, k1.z, k2.x, k2.y, k2.z)); }
        bool static DaLiSuIdenticne(const Kugla &amp;k1, const Kugla &amp;k2) { return _equal(k1.r, k2.r) &amp;&amp; _equal(k1.x, k2.x) &amp;&amp; _equal(k1.y, k2.y) &amp;&amp; _equal(k1.z, k2.z); }
    	bool static CenterIn(const Kugla&amp; k1, const Kugla&amp; k2) { return KugleRastojanje(k1, k2) &lt;= std::fabs(k1.r - k2.r); }
        bool static CenterOut(const Kugla&amp; k1, const Kugla&amp; k2) { return KugleRastojanje(k1, k2) &gt;= std::fabs(k1.r + k2.r); }
        bool static DaLiSeDodirujuIzvana(const Kugla &amp;k1, const Kugla &amp;k2) { return _equal(KugleRastojanje(k1, k2), k1.r + k2.r) &amp;&amp; CenterOut(k1, k2); }
        bool static DaLiSePreklapaju(const Kugla &amp;k1, const Kugla &amp;k2) { return DaLiSeSijeku(k1, k2) || CenterIn(k1, k2) || DaLiSeDodirujuIzvana(k1, k2); }
        bool static DaLiSeSijeku(const Kugla &amp;k1, const Kugla &amp;k2) {
            bool _return(false);
            if(CenterIn(k1, k2)) _return = k1.r + KugleRastojanje(k1, k2) &gt; k2.r - ERROR;
            else if(CenterIn(k2, k1)) _return = k2.r + KugleRastojanje(k1, k2) &gt; k1.r - ERROR;
            else _return = KugleRastojanje(k1, k2) &lt; k1.r + k2.r + ERROR;
            return _return;
        }
        /// check intersection
        void static checkIntersection(const std::tuple&lt;double, double, double&gt;&amp; centar, const double&amp; poluprecnik) {
            return checkIntersection(std::get&lt;0&gt;(centar), std::get&lt;1&gt;(centar), std::get&lt;2&gt;(centar), poluprecnik);
        }
        void static checkIntersection(const double&amp; _x, const double&amp; _y, const double&amp; _z, const double&amp; _r) {
            for(auto it(NepreklapajucaKugla::lastSphere); it != nullptr; it = it-&gt;previousSphere)
                if(DaLiSePreklapaju({_x, _y, _z, _r}, {it-&gt;x, it-&gt;y, it-&gt;z, it-&gt;r})) 
                    throw std::logic_error("Nedozvoljeno preklapanje");
        }
    public:
        void setPointers();
        /// constructors and destructor
        NepreklapajucaKugla(const NepreklapajucaKugla&amp;) = delete;
        NepreklapajucaKugla&amp; operator=(const NepreklapajucaKugla&amp;) = delete;
        
        NepreklapajucaKugla(NepreklapajucaKugla&amp;&amp;) = delete; 
        NepreklapajucaKugla&amp; operator=(NepreklapajucaKugla&amp;&amp;) = delete;
        
        explicit NepreklapajucaKugla(double r = 0);
        NepreklapajucaKugla(double x, double y, double z, double r = 0);
        explicit NepreklapajucaKugla(const std::tuple&lt;double, double, double&gt; &amp;centar, double r = 0);
        ~NepreklapajucaKugla();
        
        /// inspectors
        double DajX() const { return x; };
        double DajY() const { return y; };
        double DajZ() const { return z; };
        std::tuple&lt;double, double, double&gt; DajCentar() const { return std::make_tuple(this-&gt;DajX(), this-&gt;DajY(), this-&gt;DajZ()); };
        double DajPoluprecnik() const { return r; };
        double DajPovrsinu() const { return 4 * PI * _SQR(this-&gt;DajPoluprecnik()); };
        double DajZapreminu() const { return this-&gt;DajPovrsinu() * this-&gt;DajPoluprecnik() / 3.; };
        void Ispisi() const;
        bool DaLiSadrzi(const NepreklapajucaKugla &amp;k) const;
        
        /// mutators
        NepreklapajucaKugla &amp;PostaviX(double x);
        NepreklapajucaKugla &amp;PostaviY(double y);
        NepreklapajucaKugla &amp;PostaviZ(double z);
        NepreklapajucaKugla &amp;PostaviCentar(double x, double y, double z);
        NepreklapajucaKugla &amp;PostaviCentar(const std::tuple&lt;double, double, double&gt; &amp;centar);
        NepreklapajucaKugla &amp;PostaviPoluprecnik(double r);
        void Transliraj(double delta_x, double delta_y, double delta_z);
        
        /// friend functions
        friend double RastojanjeCentara(const NepreklapajucaKugla &amp;k1, const NepreklapajucaKugla &amp;k2); /// check if sphere intersects with rest
};

/// implementing constructors, destructor and list connections
void NepreklapajucaKugla::setPointers() {
    this-&gt;previousSphere = lastSphere;
    lastSphere = this;
}
NepreklapajucaKugla::NepreklapajucaKugla(double r) : x(0), y(0), z(0) {
    checkCenter(r);
    checkIntersection(0, 0, 0, r);
    NepreklapajucaKugla::r = r;
    this-&gt;setPointers();
}
NepreklapajucaKugla::NepreklapajucaKugla(double x, double y, double z, double r) : x(x), y(y), z(z) {
    checkCenter(r);
    checkIntersection(x, y, z, r);
    NepreklapajucaKugla::r = r;
    this-&gt;setPointers();
}
NepreklapajucaKugla::NepreklapajucaKugla(const std::tuple&lt;double, double, double&gt; &amp;centar, double r) : 
    x(std::get&lt;0&gt;(centar)), 
    y(std::get&lt;1&gt;(centar)),
    z(std::get&lt;2&gt;(centar)) {
    checkCenter(r);
    checkIntersection(centar, r);
    NepreklapajucaKugla::r = r;
    this-&gt;setPointers();
}
NepreklapajucaKugla::~NepreklapajucaKugla() {
    NepreklapajucaKugla* it(lastSphere);
    
    if (lastSphere == this) {
        lastSphere = lastSphere-&gt;previousSphere;
        return;
    }
    for (;it != nullptr &amp;&amp; it-&gt;previousSphere != this; it = it-&gt;previousSphere);
    if(it != nullptr) it-&gt;previousSphere = it-&gt;previousSphere-&gt;previousSphere;
}
/// other interface implementations (mutators and inspectors)
NepreklapajucaKugla&amp; NepreklapajucaKugla::PostaviX(double x) { 
    checkIntersection(x, this-&gt;DajY(), this-&gt;DajZ(), this-&gt;DajPoluprecnik());
    NepreklapajucaKugla::x = x; return *this; 
}
NepreklapajucaKugla&amp; NepreklapajucaKugla::PostaviY(double y) { 
    checkIntersection(this-&gt;DajX(), y, this-&gt;DajZ(), this-&gt;DajPoluprecnik());
    NepreklapajucaKugla::y = y; return *this; 
}
NepreklapajucaKugla&amp; NepreklapajucaKugla::PostaviZ(double z) { 
    checkIntersection(this-&gt;DajX(), this-&gt;DajY(), z, this-&gt;DajPoluprecnik());
    NepreklapajucaKugla::z = z; return *this; 
}
NepreklapajucaKugla&amp; NepreklapajucaKugla::PostaviCentar(double x, double y, double z) { 
    checkIntersection(x, y, z, this-&gt;DajPoluprecnik());
    return this-&gt;PostaviX(x).PostaviY(y).PostaviZ(z); 
}
NepreklapajucaKugla&amp; NepreklapajucaKugla::PostaviCentar(const std::tuple&lt;double, double, double&gt; &amp;centar) { 
    checkIntersection(centar, this-&gt;DajPoluprecnik());
    return this-&gt;PostaviX(std::get&lt;0&gt;(centar)).PostaviY(std::get&lt;1&gt;(centar)).PostaviZ(std::get&lt;2&gt;(centar)); 
}
NepreklapajucaKugla&amp; NepreklapajucaKugla::PostaviPoluprecnik(double r) { 
    checkCenter(r); 
    checkIntersection(this-&gt;DajX(), this-&gt;DajY(), this-&gt;DajZ(), r);
    NepreklapajucaKugla::r = r; return *this; 
}
void NepreklapajucaKugla::Ispisi() const { 
    std::cout &lt;&lt; "{(" &lt;&lt; this-&gt;DajX() &lt;&lt; "," &lt;&lt;this-&gt;DajY() &lt;&lt; ","&lt;&lt;this-&gt;DajZ() &lt;&lt; "),"&lt;&lt;this-&gt;DajPoluprecnik() &lt;&lt; "}" &lt;&lt; std::endl; 
}
void NepreklapajucaKugla::Transliraj(double delta_x, double delta_y, double delta_z) {
    checkIntersection(this-&gt;DajX() + delta_x, this-&gt;DajY() + delta_y, this-&gt;DajZ() + delta_z, this-&gt;DajPoluprecnik());
    this-&gt;PostaviX(this-&gt;DajX() + delta_x).PostaviY(this-&gt;DajY() + delta_y).PostaviZ(this-&gt;DajZ() + delta_z);
}
double RastojanjeCentara(const NepreklapajucaKugla &amp;k1, const NepreklapajucaKugla &amp;k2) {
    return std::sqrt(NepreklapajucaKugla::_distance(k1.DajX(), k1.DajY(), k1.DajZ(), k2.DajX(), k2.DajY(), k2.DajZ()));
}
bool NepreklapajucaKugla::DaLiSadrzi(const NepreklapajucaKugla &amp;k) const {
    return NepreklapajucaKugla::_equal(this-&gt;DajPoluprecnik(), k.DajPoluprecnik()) || (RastojanjeCentara(*this, k) &gt; std::fabs(this-&gt;DajPoluprecnik() - k.DajPoluprecnik()));
}

/// initialise pointer last to null
NepreklapajucaKugla* NepreklapajucaKugla::lastSphere = nullptr;

/// main program logic
int main () {
    int n;
    std::cout &lt;&lt; "Unesite broj kugli: "; 
    for(;;) {
        std::cin &gt;&gt; n;
        if(!std::cin || n &lt;= 0) {
            if(!std::cin) { std::cin.clear(); std::cin.ignore(10000, '\n'); }
            std::cout &lt;&lt; "Neispravan broj kugli, unesite ponovo!\n";
            continue;
        }
        break;
    }
    /// read data
    double x, y, z, r;
    std::vector&lt;std::shared_ptr&lt;NepreklapajucaKugla&gt;&gt; _kugle;
    for(int i = 1; i &lt;= n;) {
        std::cout &lt;&lt; "Unesite centar za " &lt;&lt; i &lt;&lt; ". kuglu: ";
        for(;;) {
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
            if(!std::cin) {
                std::cout &lt;&lt; "Neispravan centar, unesite ponovo:\n"; 
                std::cin.clear(); std::cin.ignore(10000, '\n');
                continue;
            } else break;
        }
        std::cout &lt;&lt; "Unesite poluprecnik: ";
        for(;;) {
            std::cin &gt;&gt; r;
            if(!std::cin || r &lt; 0) {
                std::cout &lt;&lt; "Neispravan poluprecnik, unesite ponovo:\n"; 
                if(!std::cin) { std::cin.clear(); std::cin.ignore(10000, '\n'); }
                continue;
            } else break;
        }
		try {
			_kugle.push_back(std::shared_ptr&lt;NepreklapajucaKugla&gt;(new NepreklapajucaKugla(x, y, z, r)));
			++i;
		} catch (std::exception &amp;e) { std::cout &lt;&lt; e.what() &lt;&lt; std::endl; }
    }
    /// sort
    std::sort(_kugle.begin(), _kugle.end(), [](const std::shared_ptr&lt;NepreklapajucaKugla&gt; &amp;_kugla1, const std::shared_ptr&lt;NepreklapajucaKugla&gt; &amp;_kugla2) {
        return _kugla1-&gt;DajPovrsinu() &lt; _kugla2-&gt;DajPovrsinu();
    });
    /// print
    std::cout &lt;&lt; std::endl &lt;&lt; "Kugle nakon obavljenog sortiranja: \n";
    std::for_each(_kugle.begin(), _kugle.end(), [](const std::shared_ptr&lt;NepreklapajucaKugla&gt; &amp;_kugla) { _kugla-&gt;Ispisi(); });
</font>	return 0;
}</pre>
</body>
</html>
