<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student6462.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student4559.c<p></p><pre>
#include &lt;stdio.h&gt;

/* prototipi */
<a name="0"></a><font color="#FF0000"><a href="match150-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

int max(int [100][100], int, int);
int izbaci_kolone(int [100][100], int, int, int);
void delete_column(int [100][100], int, int, int);

int main() {
	int matrix[100][100];
	int height, width;
	int turn; // broj prolaza
	int i, j;
	
	/* UNOS */
	printf("Unesite sirinu i visinu matrice: ");
	scanf("%d%d", &amp;width, &amp;height);
	
	for (i = 0; i &lt; height; i++) {
		printf("Unesite elemente %d. reda: ", i + 1);
		
		for (j = 0; j &lt; width; j++)
			scanf("%d", &amp;matrix[i][j]);
	}
	
	printf("\n");
	
	turn = 1;
	while (width) {
		/* dobivamo novu sirinu matrice iz funkcije */
		width = izbaci_kolone(matrix, height, width, max(matrix, height, width));
		
		/* ako je ona nula, onda je matrica prazna, gotovi sa radom */
		if (!width) {
			printf("Nakon %d. prolaza matrica je prazna!\n", turn);
			break;
		}
		
		/* ako nije prazna, ispisati je */
		printf("Nakon %d. prolaza matrica glasi:\n", turn);
		for (i = 0; i &lt; height; i++) {
			for (j = 0; j &lt; width; j++)
				printf("%5d", matrix[i][j]);
			printf("\n");
		}
		printf("\n");
		
		/* sljedeci prolaz */
		turn++;
	}
	
	return 0;
}

/* max - IMPLEMENTACIJA */
int max(int matrix[100][100], int height, int width) {
	int maxOccurances = -1, maxNumber = -1;
	int tmpCount, len = height * width;
	int i, j;
	
	for (i = 0; i &lt; len; i++) {
		tmpCount = 1;
		
		for (j = i + 1; j &lt; len; j++)
			if (matrix[i / width][i % width] == matrix[j / width][j % width])
				tmpCount++;
				
		if (maxOccurances &lt; tmpCount ||
		   (maxOccurances == tmpCount &amp;&amp; maxNumber &gt; matrix[i / width][i % width])) {
			maxOccurances = tmpCount;
			maxNumber = matrix[i / width][i % width];
		}
	}
	
	return maxNumber;
}
// end max

/* delete_column - IMPLEMENTACIJA */
/* Ova funkcija izbaca kolonu iz matrice po njenom indeksu*/
void delete_column(int matrix[100][100], int height, int width, int column) {
	int i, j;
	
	for (i = 0; i &lt; height; i++)
		for (j = column; j &lt; width - 1; j++)
			matrix[i][j] = matrix[i][j + 1];
}
// end delete_column

/* izbaci_kolone - IMPLEMENTACIJA */
/* Ova funkcija izbaca svaku kolonu koja sadrzi element toBeDeleted */
int izbaci_kolone(int matrix[100][100], int height, int width, int toBeDeleted) {
	int i, j;
	
	for (j = 0; j &lt; width; j++) 
		for (i = 0; i &lt; height; i++)
			if (matrix[i][j] == toBeDeleted) {
				// Izbrisi je
				delete_column(matrix, height, width, j);
				
				// Posto je izbrisana smanji sirinu za jedan
				width--;
				
				// Vrati se i pregledaj ovu kolonu sto je sada zamijenila izbrisanu
				j--;
				
				// ne treba provjeravati dalje ovu kolonu
				break;
			}
	
	// Vrati novu sirinu
	return width;
</font>}</pre>
</body>
</html>
