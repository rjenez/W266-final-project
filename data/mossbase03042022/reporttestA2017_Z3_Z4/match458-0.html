<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student7977.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student7977.c<p></p><pre>
#include &lt;stdio.h&gt;

int max(int matrica[100][100], int visina, int sirina)
{

	int i, j, k, l, brojac, najviseponavljani, najveci;
	int brojacielemenata[100][100]= {{0}}; /*Pravimo matricu brojaca elemenata posmatrane matrice. Tako da i sirina i visina moraju biti isti
	kao kod unesene matrice kako bi svaki element imao vlastiti brojac */

<a name="0"></a><font color="#FF0000"><a href="match458-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_26.gif"/></a>

	for(i=0; i&lt;visina; i++) { /*Vec koristeni algoritam za usporedbu brojeva u matrici*/
		for(j=0; j&lt;sirina; j++) {
			brojac=1;
			for(l=i; l&lt;visina; l++) {
				for(k=0; k&lt;sirina; k++) {
					if(k&gt;j || l!=i) {
						if(matrica[i][j]==matrica[l][k]) {
							brojac++;
							brojacielemenata[l][k]=-5; /*if u 16.toj liniji se odnosi na duplikate, u tom slucaju bi se brojaci razdijelili.
					Zbog toga radi posebnog "tretmana" u nastavku vrsimo dodjelu randomly izabrane vrijednosti radi koristenja u nastavku.*/
						}
					}
				}
			}

			if(brojacielemenata[i][j]!=-5) {
				brojacielemenata[i][j]=brojac; /*Ovdje prvom brojacu koji je "naletio" na broj koji se ponavlja dalje u matrici dodjeljujemo
				pravi brojac kako bi prebrojavanje bilo validno*/
			}
		}
	}

	najviseponavljani=matrica[0][0]; /*Trazenje najveceg brojaca*/
	najveci=brojacielemenata[0][0];
	for(i=0; i&lt;visina; i++) {
		for(j=0; j&lt;sirina; j++) {
</font>			if(najveci==brojacielemenata[i][j]) {
				/* U nastavku osiguravamo da ukoliko imamo vise clanova s jednakim brojem ponavljanja, uzmemo manji od ta dva jer je takva
				postavka zadatka */
				if(najviseponavljani&gt;matrica[i][j]) {
					najveci=brojacielemenata[i][j];
					najviseponavljani=matrica[i][j];
				}
			}
			if(najveci&lt;brojacielemenata[i][j]) {
<a name="3"></a><font color="#00FFFF"><a href="match458-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

				najveci=brojacielemenata[i][j];
				najviseponavljani=matrica[i][j];
			}
		}
	}

	return najviseponavljani;
}

int izbaci_kolone(int matrica[100][100], int visina, int sirina, int br)
</font>{
	int i, j, k, l;
	for(i=0; i&lt;visina; i++) {
<a name="2"></a><font color="#0000FF"><a href="match458-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

		for(j=0; j&lt;sirina; j++) {
			if(matrica[i][j]==br) {
				for(l=i; l&lt;visina; l++) {
					for(k=j; k&lt;sirina-1; k++) {
						matrica[l][k]=matrica[l][k+1];
</font>					}
				}
				i=0;
				j--;
				sirina--; /*Ranije smo koristili slicne algoritme za izbacivanje kolona*/
			}
		}
	}
	return sirina; /* Na kraju funkcija treba da vrati sirinu  */
}

int main()
{

	int sirina, visina, i, j, nProlaza, matrica[100][100];

	printf("Unesite sirinu i visinu matrice: ");
	scanf("%d %d", &amp;sirina, &amp;visina);

	for (i=0; i&lt;visina; i++) {
<a name="1"></a><font color="#00FF00"><a href="match458-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_16.gif"/></a>

		printf("Unesite elemente %d. reda: ", i+1);
		for(j=0; j&lt;sirina; j++) {
			scanf("%d", &amp;matrica[i][j]);
		}
	}
	nProlaza=0;
	while(sirina!=0) {
		sirina=izbaci_kolone(matrica, visina, sirina, max(matrica,visina,sirina));
		nProlaza++;

		if(sirina==0)
			printf("\nNakon %d. prolaza matrica je prazna!", nProlaza);
		else {
			printf("\nNakon %d. prolaza matrica glasi:\n", nProlaza);

			for(i=0; i&lt;visina; i++) {
				for(j=0; j&lt;sirina; j++) {
</font>					printf("%5d", matrica[i][j]);
				}

				printf("\n");
			}
		}
	}
	return 0;
}
</pre>
</body>
</html>
