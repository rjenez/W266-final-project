<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student1132.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student1366.c<p></p><pre>
#include &lt;stdio.h&gt;
<a name="0"></a><font color="#FF0000"><a href="match157-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_53.gif"/></a>

int max(int matrica[100][100], int visina, int sirina)
{
	int brojaci[100][100]= {{0}};
	int i, j, k, l, brojac, najfrekventniji, najveciBrojac;
	// Pravimo novu matricu sastavljenu od brojaca, koja ce imati iste parametre duzine i visine kao i pocetna matrica. Svaki element matrice ima vlastiti brojac na istoj [i][j] adresi u matrici brojaca.
	// Algoritam za uporedjivanje dva broja u matrici
	for (i=0; i&lt;visina; i++) {
		for (j=0; j&lt;sirina; j++) {
			brojac=1;
			for (k=i; k&lt;visina; k++) {
				for (l=0; l&lt;sirina; l++) {
					if (k!=i || l&gt;j) {
						if (matrica[i][j]==matrica[k][l]) {
							brojac++;
							brojaci[k][l]=-1; // Ne zelimo da imamo vise brojaca za jedan isti broj, tako da brojac svakog duplog clana postavljamo na -1 da znamo da je on duplikat.
						}
					}
				}
			}
			if (brojaci[i][j]!=-1) {
				brojaci[i][j]=brojac; // Ovdje iskoristimo cinjenicu da su brojaci duplikata -1, i samo originalnom brojacu proslijedjujemo vrijednost broja jednakih clanova
			}
		}
	}
	// Algoritam za trazenje max elementa u matrici (trazimo max vrijednost brojaca)
	najfrekventniji=matrica[0][0];
	najveciBrojac=brojaci[0][0];
	for (i=0; i&lt;visina; i++) {
		for (j=0; j&lt;sirina; j++) {
			if (brojaci[i][j]==najveciBrojac) {
				if (matrica[i][j]&lt;najfrekventniji) {
					najveciBrojac=brojaci[i][j]; // U slucaju da se vise clanova ponavljaju isti broj puta, po postavci zadatka, biramo najmanji
					najfrekventniji=matrica[i][j];
				}
			}
			if (brojaci[i][j]&gt;najveciBrojac) {
				najveciBrojac=brojaci[i][j]; 
				najfrekventniji=matrica[i][j];
			}
		}
	}
	return najfrekventniji;
}

int izbaci_kolone(int matrica[100][100], int visina, int sirina, int N)
</font>{
	int i, j, k, l;
	// Algoritam za izbacivanje kolone iz matrice
	for (i=0; i&lt;visina; i++) {
<a name="1"></a><font color="#00FF00"><a href="match157-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_19.gif"/></a>

		for (j=0; j&lt;sirina; j++) {
			if (matrica[i][j]==N) {
				for (k=i; k&lt;visina; k++) {
					for (l=j; l&lt;sirina-1; l++) {
						matrica[k][l]=matrica[k][l+1];
					}
				}
				sirina--;
				i=0;
				j--;
			}
		}
	}
	return sirina;
}
int main()
{
	int matrica[100][100], sirina, visina, i, j, brojacProlaza;
	printf("Unesite sirinu i visinu matrice: ");
	scanf("%d %d", &amp;sirina, &amp;visina);
	for (i=0; i&lt;visina; i++) {
</font><a name="2"></a><font color="#0000FF"><a href="match157-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_15.gif"/></a>

		printf("Unesite elemente %d. reda: ", i+1);
		for (j=0; j&lt;sirina; j++) {
			scanf("%d", &amp;matrica[i][j]);
		}
	}
	brojacProlaza=0;
	while (sirina!=0) {
		sirina=izbaci_kolone(matrica, visina, sirina, max(matrica, visina, sirina));
		brojacProlaza++;
		if (sirina==0)
			printf("\nNakon %d. prolaza matrica je prazna!", brojacProlaza);
		else {
			printf("\nNakon %d. prolaza matrica glasi: \n", brojacProlaza);
			for (i=0; i&lt;visina; i++) {
				for (j=0; j&lt;sirina; j++) {
</font>					printf("%5d", matrica[i][j]);
				}
				printf("\n");
			}
		}
	}

	return 0;
}
</pre>
</body>
</html>
