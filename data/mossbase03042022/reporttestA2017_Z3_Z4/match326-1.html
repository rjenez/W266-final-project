<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student7485.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student1313.c<p></p><pre>
#include &lt;stdio.h&gt;
Funkcija vraća član matrice koji se najviše puta ponavlja. 
Ako se više članova ponavljaju jednak (najveći) broj puta, funkcija treba vratiti najmanji od tih članova.
Zatim napisati funkciju izbaci_kolone koja prima matricu (kao iznad) i jedan broj N, 
a zatim iz matrice izbacuje sve kolone u kojima se javlja član N. 

<a name="0"></a><font color="#FF0000"><a href="match326-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_39.gif"/></a>

int max(int mat[100][100], int visina, int sirina)
{
	int i, j, id, jd, max_clan, testni_clan, brojac1=0, brojac2;
	
/*	if (visina==0 || sirina==0)
		return 0;*/
		
	max_clan=mat[0][0];
		
	for(i=0; i&lt;visina; i++)
	{
		for(j=0; j&lt;sirina; j++)
		{
			brojac2=0;
			testni_clan=mat[i][j];
			/*ponovni prolazak krzo clanove matrice zbog trazenja maksimuma*/
			for(id=0; id&lt;visina; id++)
			{
				for(jd=0; jd&lt;sirina; jd++)
				{
					if (mat[id][jd]==testni_clan)
						brojac2++;
				}
			}
			if (brojac2&gt;brojac1)
			{
				max_clan=testni_clan;
				brojac1=brojac2;
			}	
			else if (brojac2==brojac1 &amp;&amp; testni_clan&lt;max_clan)
			{
				max_clan=testni_clan;
				brojac1=brojac2;
			}	
		}
	}
	return max_clan;
}

int izbaci_kolone(int mat[100][100], int visina, int sirina, int n)
{
	int i, j, id, jd, brojac=0, vracaj, stara_sirina;
	
	stara_sirina=sirina;
	for(i=0; i&lt;visina; i++)
	{
		for(j=0; j&lt;sirina; j++)
		{
			if (mat[i][j]==n)
</font>			{
				/*pomjeranje kolona*/
				for(id=0; id&lt;visina; id++)
				{
<a name="1"></a><font color="#00FF00"><a href="match326-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_35.gif"/></a>

					for(jd=j; jd&lt;sirina-1; jd++)
					{
						mat[id][jd]=mat[id][jd+1];
					}
				}
				sirina--;
				j--;
				brojac++;
			}
		}
	}
	vracaj=stara_sirina-brojac;
	return vracaj;
}

int main() {
	int i,j,visina,sirina,mat[100][100],vraceni_max,brojac=0,nova_sirina,salji_sirinu;
	
	printf("Unesite sirinu i visinu matrice: ");
	scanf("%d %d",&amp;sirina,&amp;visina);
	
	for(i=0; i&lt;visina; i++)
	{
		printf("Unesite elemente %d. reda: ",i+1);
		for(j=0; j&lt;sirina; j++)
			scanf("%d",&amp;mat[i][j]);
	}
	printf("\n");
	salji_sirinu=sirina;
	while(1)
	{
		vraceni_max=max(mat,visina,salji_sirinu);
		nova_sirina=izbaci_kolone(mat,visina,salji_sirinu,vraceni_max);
		salji_sirinu=nova_sirina;
		brojac++;
		if (nova_sirina==0)
		{
			printf("Nakon %d. prolaza matrica je prazna!",brojac);
			break;
		}	
		else
			{
				printf("Nakon %d. prolaza matrica glasi:\n",brojac);
				for(i=0; i&lt;visina; i++)
				{
					for(j=0; j&lt;nova_sirina; j++)
						printf("%5d",mat[i][j]);
</font>					printf("\n");	
				}
			}
	}
	
	return 0;
}
</pre>
</body>
</html>
