<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student4305.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student6748.c<p></p><pre>
#include &lt;stdio.h&gt;

/* Vraca clan matrice koji se najvise puta ponavlja, ukoliko ih se vise ponavlja
isti (najveci) broj puta onda se vraca manji od njih */

<a name="1"></a><font color="#00FF00"><a href="match273-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_35.gif"/></a>

int max (int matrica[100][100], int visina, int sirina)
{
	int i, j, k, n;

	/* Inicijalizacija za max_clan se mora uraditi zbog poredjenja u else if */

	int tr_clan, tr_br_ponavljanja, max_clan = matrica[0][0];
	int max_br_ponavljanja = 0;

	/* Za svaki clan matrice mora se po jednom proci kroz matricu */
	for (i=0 ; i&lt;visina ; i++) {
		for (j=0 ; j&lt;sirina ; j++) {
			/* Ove dvije petlje nam sluze da se uzme svaki clan matrice,
			   ali trebaju nam i jos dvije da za taj uzeti clan prodjemo kroz matricu */
			tr_clan = matrica[i][j];
			tr_br_ponavljanja = 0;
			for (k=0 ; k&lt;visina ; k++) {
				for (n=0 ; n&lt;sirina ; n++) {
					if (matrica[k][n] == tr_clan)
						tr_br_ponavljanja++;
				}
			}
			if (tr_br_ponavljanja &gt; max_br_ponavljanja) {
				max_br_ponavljanja = tr_br_ponavljanja;
				max_clan = tr_clan;
			} else if (tr_br_ponavljanja == max_br_ponavljanja) {
				/* Trebamo zapamtiti onaj clan koji je manji */
				if (tr_clan &lt; max_clan)
					max_clan = tr_clan;
				/* U suprotnom nista ne diramo, jer nema smisla pisati if (max_clan &lt; tr_clan) max_clan = max_clan */

			}
		}
	}

	return max_clan;
}

int izbaci_kolone (int matrica[100][100], int visina, int sirina, int N)
</font>{

	/* Prolazimo kroz matricu, ali ovaj put po kolonama */

	int i, j, k, n;

	for (i=0 ; i&lt;sirina ; i++) {
<a name="0"></a><font color="#FF0000"><a href="match273-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_58.gif"/></a>

		for (j=0 ; j&lt;visina ; j++) {

			/* Ako je element == N, potrebno je izbaciti kolonu */
			if (matrica[j][i] == N) {

				/* Opet je potrebna dvostruka for petlja, koja prolazi po kolonama, i izbaca kolonu koja sadrzi N */
				for (k=i ; k&lt;sirina-1 ; k++) {
					for (n=0 ; n&lt;visina ; n++) {
						matrica[n][k] = matrica[n][k+1];
					}
				}
				sirina--;
				i--;
			}
		}
	}
	return sirina;
}

int main()
{
	int mat[100][100];
	int i, j, sirina, visina, max_pon_element;
	int br_prolaza;
	printf ("Unesite sirinu i visinu matrice: ");
	scanf ("%d %d", &amp;sirina, &amp;visina);

	for (i = 0; i &lt; 100; i++)
		for (j = 0; j &lt; 100; j++)
			mat[i][j] = 0;

	for (i=0 ; i&lt;visina ; i++) {
		printf ("Unesite elemente %d. reda: ", i+1);
		for (j=0 ; j&lt;sirina ; j++) {
			scanf("%d", &amp;mat[i][j]);
		}
	}

	br_prolaza = 0;
	max_pon_element = max(mat, visina, sirina);
	sirina = izbaci_kolone(mat, visina, sirina, max_pon_element);
	while(sirina &gt; 0) {
		printf("\nNakon %d. prolaza matrica glasi:\n", br_prolaza+1);
		for (i = 0; i &lt; visina; i++) {
			for (j = 0; j &lt; sirina; j++) {
				printf("%5d", mat[i][j]);
			}
			printf("\n");
		}
		max_pon_element = max(mat, visina, sirina);
		sirina = izbaci_kolone(mat, visina, sirina, max_pon_element);
		br_prolaza++;
	}
	printf("\nNakon %d. prolaza matrica je prazna!", br_prolaza+1);
</font>
	return 0;
}
</pre>
</body>
</html>
