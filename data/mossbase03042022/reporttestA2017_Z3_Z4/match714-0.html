<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student6522.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z4/student6522.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int max(int matrica[100][100], int visina, int sirina){
	int i,j,clanovimatrice[10000]={0},k=0,maksi=0,temp,brojac=1,maxbrojac=1,maxbroj;
	for(i=0; i&lt;visina; i++){
		for(j=0; j&lt;sirina; j++){
			clanovimatrice[k]=matrica[i][j];
			k++;
		}
	} /*Nakon sto smo unijeli elemente matrice u jedan niz(da bismo lakse posmatrali), sada cemo taj niz sortirati, tako da na prvom mjestu bude maksimalan broj */
<a name="2"></a><font color="#0000FF"><a href="match714-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

	for(i=0; i&lt;(k-1); i++){
		maksi=i;
		for(j=i+1; j&lt;k; j++){
			if(clanovimatrice[maksi]&lt;clanovimatrice[j])
			maksi=j;
</font>		}
		if(maksi!=i){
			temp=clanovimatrice[i];
			clanovimatrice[i]=clanovimatrice[maksi];
			clanovimatrice[maksi]=temp;
		}
	} /*Postavimo da je prvi clan maksimalan i pamtimo njegovu vrijednost u varijabli maxbroj.U petlji postavljamo uslov da se brojac povecava, sve dok je trenutni jednak
	prethodnom. Kada to nije slucaj, onda maksbrojac pamti dotadasnju vrijednost brojaca,jer se brojac mora postaviti na 1 */
	maxbroj=clanovimatrice[0];
	for(i=1; i&lt;=k; i++){
		if(clanovimatrice[i]==clanovimatrice[i-1]) {
		brojac++;
		if((brojac&gt;maxbrojac) &amp;&amp; (clanovimatrice[i]&lt;maxbroj)){
			maxbrojac=brojac;
			maxbroj=clanovimatrice[i];
		}
		}
		else {
			if(brojac&gt;=maxbrojac){
				maxbrojac=brojac;
				maxbroj=clanovimatrice[i-1];
				brojac=1;
		}
		}
    }
    return maxbroj;
}
int izbaci_kolone(int matrica[100][100], int visina, int sirina, int N){
<a name="1"></a><font color="#00FF00"><a href="match714-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

	int i,j,k,t,izbacena=-1;
	for(i=0; i&lt;visina; i++){
		for(j=0; j&lt;sirina; j++){
			if(matrica[i][j]==N) {
</font>			izbacena=j;
			break;
			}
		}
		if(izbacena==-1) continue;
		else {
	for(k=izbacena; k&lt;sirina-1; k++){
		for(t=i; t&lt;visina; t++){
			matrica[t][k]=matrica[t][k+1];
			}
		}
		sirina--;
		izbacena=-1;
		}
	}
	return sirina;
}

int main() {
	int A[100][100], visina, sirina, i,j,a;
	printf("Unesite sirinu i visinu matrice: ");
	scanf("%d%d", &amp;sirina, &amp;visina);
	for(i=0; i&lt;visina; i++){
		a=i+1;
		printf("Unesite elemente %d. reda: ", a);
<a name="0"></a><font color="#FF0000"><a href="match714-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_17.gif"/></a>

		for(j=0; j&lt;sirina; j++){
			scanf("%d", &amp;A[i][j]);
		}
	}
	int kolona = sirina;
	int prolaz=1;
	int N;
	while(kolona &gt;0){
		 N=max(A,visina,kolona);
		 kolona=izbaci_kolone(A,visina,kolona,N);
		 if(kolona==0) {
		 	printf("\nNakon %d. prolaza matrica je prazna!", prolaz);
		 	break;
		 }
		 	printf("\nNakon %d. prolaza matrica glasi:\n", prolaz);
		 	for(i=0; i&lt;visina; i++){
		 	for(j=0; j&lt;kolona; j++){
		 		printf("%5d", A[i][j]);
</font>		 	} 
		 	printf("\n");
		 	}
		 prolaz++;
	}	 
	return 0;
}
</pre>
</body>
</html>
