<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student1202.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student1202.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define E 0.001

enum TipOblika {
    TACKA, KRUZNICA, PRAVOUGAONIK, TROUGAO
};
struct Tacka {
	float x,y;
};
struct Kruznica {
	struct Tacka centar;
	float radijus;
};
struct Pravougaonik {
	struct Tacka donji_lijevi;
	float sirina, visina;
};
struct Trougao {
	struct Tacka prvi, drugi, treci;
};
struct Duz {
	struct Tacka A, B;
	float ugao;
};
float udaljenost(struct Tacka a, struct Tacka b)
{
	return sqrt(pow(a.x-b.x, 2) + pow(a.y-b.y, 2));
}
float _udaljenost(float x, float y, struct Tacka b)
{
	return sqrt(pow(x-b.x, 2) + pow(y-b.y, 2));
}
<a name="0"></a><font color="#FF0000"><a href="match932-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

int pripada_pravougaoniku(struct Tacka t, struct Pravougaonik p)
{
	return t.x &gt;= p.donji_lijevi.x &amp;&amp; t.x &lt;= p.donji_lijevi.x + p.sirina &amp;&amp; t.y &gt;= p.donji_lijevi.y &amp;&amp; t.y &lt;= p.donji_lijevi.y + p.visina;
</font>}
#define PI atan2(0,-1)
//Kreira duz izmedju tacaka A i B
struct Duz duz(struct Tacka A, struct Tacka B)
{
	struct Duz d;
	d.A = A;
	d.B = B;
	d.ugao = atan2(B.y-A.y, B.x-A.x);
	if (d.ugao &lt; 0) d.ugao += 2*PI;
	return d;
}
//Vraca udaljenost izmedju tacke i duzi
float udaljenost_td(struct Tacka t, struct Duz d)
{
	float k = (d.A.y-d.B.y)/(d.A.x-d.B.x);
	if (fabs(d.A.x - d.B.x) &lt; E) return fabs(t.x - d.A.x);
	return fabs(t.y -k * t.x - d.A.y + k * d.A.x) / sqrt(1 + k*k);
}
//Vraca da li je ugao a izmedju uglova b i c
int u_intervalu(float a, float b, float c)
{
	float m = fmin(b, c), M = fmax(b, c);
	if (M - m &gt; PI) return a &gt;= M || a &lt;= m;
	else return a &gt;= m &amp;&amp; a &lt;= M;
}
struct Tacka unesi_tacku()
{
	struct Tacka t;
	printf("koordinate x,y: ");
	scanf("%f,%f", &amp;t.x, &amp;t.y);
	return t;
}
#define _A tr.prvi
#define _B tr.drugi
#define _C tr.treci
int pripada(struct Tacka t, struct Trougao tr)
{
	struct Tacka a, b;
	struct Duz AB = duz(_A, _B), AC = duz(_A, _C), BC = duz(_B, _C),
	           BA = duz(_B, _A), AT = duz(_A, t), BT = duz(_B, t);
	int l = 0;
	//Ako je trougao tacka, mora biti identican sa tackom t
	if (udaljenost(_A, _B) &lt; E &amp;&amp; udaljenost(_A, _C) &lt; E &amp;&amp; udaljenost(_B, _C) &lt; E)
		return udaljenost(t, _A) &lt; E &amp;&amp; udaljenost(t, _B) &lt; E &amp;&amp; udaljenost(t, _C) &lt; E;
	if (udaljenost(_A, _B) &lt; E) {
		a = _A;
		b = _C;
		l = 1;
	}
	if (udaljenost(_A, _C) &lt; E) {
		a = _A;
		b = _B;
		l = 1;
	}
	if (udaljenost(_C, _B) &lt; E) {
		a = _B;
		b = _C;
		l = 1;
	}
	//Ako su dva vrha identicna, provjerava da li tacka lezi na duzi odredjenoj njima i trecim vrhom
	if (l) {
		struct Duz v1 = duz(a, t), v2 = duz(a, b);
		return fabs(v1.ugao - v2.ugao) &lt; E;
	}
	return udaljenost(t, _A) &lt; E || udaljenost(t, _B) &lt; E || udaljenost(t, _C) &lt; E || (u_intervalu(AT.ugao, AB.ugao, AC.ugao) &amp;&amp; u_intervalu(BT.ugao, BA.ugao, BC.ugao));
}
#undef _A
#undef _B
#undef _C
#define pp radijus
#define cx centar.x
#define cy centar.y
#define dlx donji_lijevi.x
#define dly donji_lijevi.y
#define _A tr1.prvi
#define _B tr1.drugi
#define _C tr1.treci
int obuhvata(void *oblik1, enum TipOblika to1, void *oblik2, enum TipOblika to2)
{
	struct Tacka t1, t2;
	struct Kruznica k1, k2;
	struct Pravougaonik p1, p2;
	struct Trougao tr1, tr2;
	float dx, dy, d;
	switch (to2) {
	case TACKA:
		t2 = *((struct Tacka*) oblik2);
	case KRUZNICA:
		k2 = *((struct Kruznica*) oblik2);
	case PRAVOUGAONIK:
		p2 = *((struct Pravougaonik*) oblik2);
	case TROUGAO:
		tr2 = *((struct Trougao*) oblik2);
	}
	switch(to1) {
	case TACKA:
		t1 = *((struct Tacka*) oblik1);
		switch(to2) {
		case TACKA:
			return fabs(t2.x - t1.x) &lt; E &amp;&amp; fabs(t2.y - t1.y) &lt; E;
		case KRUZNICA:
			return k2.pp &lt; E &amp;&amp; fabs(k2.cx - t1.x) &lt; E &amp;&amp; fabs(k2.cy - t1.y) &lt; E;
		case PRAVOUGAONIK:
			return p2.sirina &lt; E &amp;&amp; p2.visina &lt; E &amp;&amp; fabs(p2.dlx - t1.x) &lt; E &amp;&amp; fabs(p2.dly - t1.y) &lt; E;
		case TROUGAO:
			return fabs(tr2.prvi.x - t1.x) &lt; E &amp;&amp; fabs(tr2.drugi.x - t1.x) &lt; E &amp;&amp; fabs(tr2.treci.x - t1.x) &lt; E
			       &amp;&amp; fabs(tr2.prvi.y - t1.y) &lt; E &amp;&amp; fabs(tr2.drugi.y - t1.y) &lt; E &amp;&amp; fabs(tr2.treci.y - t1.y) &lt; E;
		}
	case KRUZNICA:
		k1 = *((struct Kruznica*) oblik1);
		switch (to2) {
		case TACKA:
			return udaljenost(t2, k1.centar) &lt;= k1.pp;
		case KRUZNICA:
			dx = k2.cx - k1.cx;
			dy = k2.cy - k1.cy;
			d = udaljenost(k2.centar, k1.centar);
			return k1.pp &gt;= k2.pp &amp;&amp; (d &lt; E || sqrt(pow(dx + dx/d * k2.pp, 2) + pow(dy + dy/d * k2.pp, 2)) &lt;= k1.pp);
		case PRAVOUGAONIK:
			return udaljenost(p2.donji_lijevi, k1.centar) &lt;= k1.pp &amp;&amp; _udaljenost(p2.dlx + p2.sirina, p2.dly, k1.centar) &lt;= k1.pp
			       &amp;&amp; _udaljenost(p2.dlx + p2.sirina, p2.dly + p2.visina, k1.centar) &lt;= k1.pp &amp;&amp; _udaljenost(p2.dlx, p2.dly + p2.visina, k1.centar) &lt;= k1.pp;
		case TROUGAO:
			return udaljenost(tr2.prvi, k1.centar) &lt;= k1.pp &amp;&amp; udaljenost(tr2.drugi, k1.centar) &lt;= k1.pp &amp;&amp; udaljenost(tr2.treci, k1.centar) &lt;= k1.pp;
		}
	case PRAVOUGAONIK:
		p1 = *((struct Pravougaonik*) oblik1);
		switch (to2) {
		case TACKA:
			return t2.x &gt;= p1.dlx &amp;&amp; t2.x &lt;= p1.dlx + p1.sirina &amp;&amp; t2.y &gt;= p1.dly &amp;&amp; t2.y &lt;= p1.dly + p1.visina;
		case KRUZNICA:
			return k2.cx - k2.pp &gt;= p1.dlx &amp;&amp; k2.cx + k2.pp &lt;= p1.dlx + p1.sirina &amp;&amp; k2.cy - k2.pp &gt;= p1.dly &amp;&amp; k2.cy + k2.pp &lt;= p1.dly + p1.visina;
		case PRAVOUGAONIK:
			return p2.dlx &gt;= p1.dlx &amp;&amp; p2.dlx + p2.sirina &lt;= p1.dlx + p1.sirina &amp;&amp; p2.dly &gt;= p1.dly &amp;&amp; p2.dly + p2.visina &lt;= p1.dly + p1.visina;
		case TROUGAO:
			return pripada_pravougaoniku(tr2.prvi, p1) &amp;&amp; pripada_pravougaoniku(tr2.drugi, p1) &amp;&amp; pripada_pravougaoniku(tr2.treci, p1);
		}
	case TROUGAO:
		tr1 = *((struct Trougao*) oblik1);
		switch (to2) {
		case TACKA:
			return pripada(t2, tr1);
		case KRUZNICA: {
			struct Duz AB = duz(_A, _B), AC = duz(_A, _C), BC = duz(_B, _C);
			return pripada(k2.centar, tr1) &amp;&amp; udaljenost_td(k2.centar, AB) &gt;= k2.pp &amp;&amp; udaljenost_td(k2.centar, AC) &gt;= k2.pp &amp;&amp; udaljenost_td(k2.centar, BC) &gt;= k2.pp;
		}
		case PRAVOUGAONIK: {
			struct Tacka B, C, D;
			B.x = C.x = p2.dlx + p2.sirina;
			D.x = p2.dlx;
			C.y = D.y = p2.dly + p2.visina;
			B.y = p2.dly;
			return pripada(p2.donji_lijevi, tr1) &amp;&amp; pripada(B, tr1) &amp;&amp; pripada(C, tr1) &amp;&amp; pripada(D, tr1);
		}
		case TROUGAO:
			return pripada(tr2.prvi, tr1) &amp;&amp; pripada(tr2.drugi, tr1) &amp;&amp; pripada(tr2.treci, tr1);
		}
	}
	return 0;
}
#undef pp
#undef cx
#undef cy
#undef dlx
#undef dly

int main()
{
	int tip, n, i = 0, j;
	void *oblici[50];
	enum TipOblika tipovi[50];
	struct Tacka t;
	struct Kruznica k;
	struct Pravougaonik p;
	struct Trougao tr;
	printf("Unesite broj oblika: ");
	scanf("%d", &amp;n);
	do {
		printf("Odaberite tip %d. oblika (1 - tacka, 2 - kruznica, 3 - pravougaonik, 4 - trougao): ", i+1);
		scanf("%d", &amp;tip);
		if (tip == 1) {
			printf("Unesite tacku: ");
			t = unesi_tacku();
			oblici[i] = &amp;t;
			tipovi[i] = TACKA;
		} else if(tip == 2) {
			printf("Unesite centar kruznice: ");
			k.centar = unesi_tacku();
			printf("Unesite poluprecnik kruznice: ");
			scanf("%f", &amp;k.radijus);
			oblici[i] = &amp;k;
			tipovi[i] = KRUZNICA;
		} else if (tip == 3) {
			printf("Unesite donji lijevi ugao: ");
			p.donji_lijevi = unesi_tacku();
			printf("Unesite sirinu: ");
			scanf("%f", &amp;p.sirina);
			printf("Unesite visinu: ");
			scanf("%f", &amp;p.visina);
			oblici[i] = &amp;p;
			tipovi[i] = PRAVOUGAONIK;
		} else if (tip == 4) {
			printf("Unesite prvi vrh: ");
			tr.prvi = unesi_tacku();
			printf("Unesite drugi vrh: ");
			tr.drugi = unesi_tacku();
			printf("Unesite treci vrh: ");
			tr.treci = unesi_tacku();
			oblici[i] = &amp;tr;
			tipovi[i] = TROUGAO;
		} else {
			printf("Nepoznat tip oblika %d!\n", tip);
			continue;
		}
		i++;
	} while (i &lt; 50 &amp;&amp; i &lt; n);
	for (i = 0; i &lt; n; i++)
		for (j = 0; j &lt; n; j++)
<a name="1"></a><font color="#00FF00"><a href="match932-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

			if (i != j &amp;&amp; obuhvata(oblici[i], tipovi[i], oblici[j], tipovi[j]))
				printf("\nOblik %d obuhvata oblik %d.", i+1, j+1);
</font>	return 0;
}</pre>
</body>
</html>
