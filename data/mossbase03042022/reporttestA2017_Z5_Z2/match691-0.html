<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student2922.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student2922.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define epsilon 0.001

/* Strukture osnovnih elemenata*/
struct Tacka {
	float x,y;
};
struct Kruznica {
	struct Tacka centar;
	float radijus;
};
struct Pravougaonik {
	struct Tacka dole_lijevo;
	float sirina;
	float visina;
};
struct Trougao {
	struct Tacka prvi_vrh;
	struct Tacka drugi_vrh;
	struct Tacka treci_vrh;
};

/* Funkcije za unos */
struct Tacka unos_tacke ()
{
<a name="0"></a><font color="#FF0000"><a href="match691-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

	struct Tacka t;
	printf ("koordinate x,y: ");
	scanf ("%f,%f", &amp;t.x, &amp;t.y);
	return t;
}
struct Kruznica unos_kruznice()
{
	struct Kruznica k;
	printf ("Unesite centar kruznice: ");
	k.centar = unos_tacke();
	printf ("Unesite poluprecnik kruznice: ");
	scanf("%f", &amp;k.radijus);
	return k;
}
struct Pravougaonik unos_pravougaonika()
{
	struct Pravougaonik p;
	printf("Unesite donji lijevi ugao: ");
	p.dole_lijevo=unos_tacke();
	printf("Unesite sirinu: ");
	scanf("%f",&amp;p.sirina);
	printf("Unesite visinu: ");
	scanf("%f",&amp;p.visina);
	return p;
}
struct Trougao unos_trougla()
{
	struct Trougao tr;
	printf("Unesite prvi vrh: ");
	tr.prvi_vrh=unos_tacke();
	printf("Unesite drugi vrh: ");
	tr.drugi_vrh=unos_tacke();
	printf("Unesite treci vrh: ");
	tr.treci_vrh=unos_tacke();
	return tr;
</font>}
/* Funkcija za udaljenost izmedju dvije tacke koristeci koordinate tih tacaka*/
float udaljenost(float x1,float y1,float x2,float y2)
{
	return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
}
/*Funkcija koja racuna povrsinu trougla datog preko koordinata vrhova*/
float povrsina(float x1, float y1, float x2, float y2, float x3, float y3)
{
	return (fabs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))/2.;
}
/*Funkcija koja racuna diskriminantu kvadratne jednacine koja se dobije rjesavanje sistema jednacina prave i kruznice u ravni*/
float diskriminanta(float x1,float y1,float x2,float y2,float xc,float yc,float r)
{
	return (2.*(((y2-y1)/(x2-x1))*((y1-x1*((y2-y1)/(x2-x1)))-yc)-xc))*(2.*(((y2-y1)/(x2-x1))*((y1-x1*((y2-y1)/(x2-x1)))-yc)-xc))-4.*(1+((y2-y1)/(x2-x1))*((y2-y1)/(x2-x1)))*(((y1-x1*((y2-y1)/(x2-x1)))-yc)*((y1-x1*((y2-y1)/(x2-x1)))-yc)+xc*xc-r*r);
}
/*pobrojni tip "TipOblika" */
enum TipOblika { TACKA, KRUZNICA, PRAVOUGAONIK, TROUGAO };

/* funckija za provjeru da li jedan element obuhvata drugi */
int obuhvata(void* oblik1, enum TipOblika to1, void* oblik2, enum TipOblika to2)
{
	struct Tacka* t1 = (struct Tacka*) oblik1;
	struct Tacka* t2 = (struct Tacka*) oblik2;
	struct Kruznica* k1 = (struct Kruznica*) oblik1;
	struct Kruznica* k2 = (struct Kruznica*) oblik2;
	struct Pravougaonik* p1=(struct Pravougaonik*) oblik1;
	struct Pravougaonik* p2 = (struct Pravougaonik*) oblik2;
	struct Trougao *tr1=(struct Trougao*) oblik1;
	struct Trougao* tr2 = (struct Trougao*) oblik2;

	/*Tacka obuhvata tacku ako se poklapaju*/
	if(to1==TACKA &amp;&amp; to2==TACKA &amp;&amp; fabs(t1-&gt;x-t2-&gt;x)&lt;epsilon &amp;&amp; fabs(t1-&gt;y-t2-&gt;y)&lt;epsilon) return 1;
	/*Tacka obuhvata kruznicu ako je kruznica poluprecnika 0, a centar kruznice se poklapa s tackom*/
	else if(to1==TACKA &amp;&amp; to2==KRUZNICA &amp;&amp; fabs(t1-&gt;x-k2-&gt;centar.x)&lt;epsilon &amp;&amp; fabs(t1-&gt;y-k2-&gt;centar.y)&lt;epsilon &amp;&amp; k2-&gt;radijus&lt;epsilon &amp;&amp; k2-&gt;radijus&gt;-epsilon) return 1;
	/*Tacka obuhvata pravougaonik ako se tacka poklapa s donjim lijevim uglom pravougaonika a dimenzije pravougaonika su nula*/
	else if(to1==TACKA &amp;&amp; to2==PRAVOUGAONIK &amp;&amp; fabs(t1-&gt;x-p2-&gt;dole_lijevo.x)&lt;epsilon &amp;&amp; fabs(t1-&gt;y-p2-&gt;dole_lijevo.y)&lt;epsilon &amp;&amp; p2-&gt;sirina&lt;epsilon &amp;&amp; p2-&gt;sirina&gt;-epsilon &amp;&amp; p2-&gt;visina&lt;epsilon &amp;&amp; p2-&gt;visina&gt;-epsilon) return 1;
	/*Tacka obuhvata trougao ako se koordinate svih vrhova trougla poklapaju s koordinatama tacke*/
	else if(to1==TACKA &amp;&amp; to2==TROUGAO &amp;&amp; fabs(t1-&gt;x-tr2-&gt;prvi_vrh.x)&lt;epsilon &amp;&amp; fabs(t1-&gt;y-tr2-&gt;prvi_vrh.y)&lt;epsilon &amp;&amp; fabs(t1-&gt;x-tr2-&gt;drugi_vrh.x)&lt;epsilon &amp;&amp; fabs(t1-&gt;y-tr2-&gt;drugi_vrh.y)&lt;epsilon &amp;&amp; fabs(t1-&gt;x-tr2-&gt;treci_vrh.x)&lt;epsilon &amp;&amp; fabs(t1-&gt;y-tr2-&gt;treci_vrh.y)&lt;epsilon) return 1;
	/*Kruznica obuhvata tacku ako je udaljenost tacke od centra kruznice manja ili jednaka poluprecniku kruznice*/
	else if(to1==KRUZNICA &amp;&amp; to2==TACKA &amp;&amp; (k1-&gt;radijus-udaljenost(k1-&gt;centar.x,k1-&gt;centar.y,t2-&gt;x,t2-&gt;y))&gt;-epsilon) return 1;
	/*Kruznica obuhvata kruznicu ako je poluprecnik kruznice 1 veci ili jednak od zbira poluprecnika kruznice 2 i udaljenosti izmedju centara*/
	else if(to1==KRUZNICA &amp;&amp; to2==KRUZNICA &amp;&amp; (k1-&gt;radijus-(k2-&gt;radijus+udaljenost(k1-&gt;centar.x,k1-&gt;centar.y,k2-&gt;centar.x,k2-&gt;centar.y)))&gt;-epsilon) return 1;
	/*Kruznica obuhvata pravougaonik ako je svaki vrh pravougaonika unutar kruznice, a da li je vrh unutar kruznice provjeravamo kao u slucaju kruznica-tacka*/
	else if(to1==KRUZNICA &amp;&amp; to2==PRAVOUGAONIK &amp;&amp; (k1-&gt;radijus-udaljenost(k1-&gt;centar.x,k1-&gt;centar.y,p2-&gt;dole_lijevo.x,p2-&gt;dole_lijevo.y))&gt;-epsilon &amp;&amp; (k1-&gt;radijus-udaljenost(k1-&gt;centar.x,k1-&gt;centar.y,p2-&gt;dole_lijevo.x+p2-&gt;sirina,p2-&gt;dole_lijevo.y))&gt;-epsilon &amp;&amp; (k1-&gt;radijus-udaljenost(k1-&gt;centar.x,k1-&gt;centar.y,p2-&gt;dole_lijevo.x+p2-&gt;sirina,p2-&gt;dole_lijevo.y+p2-&gt;visina))&gt;-epsilon &amp;&amp; (k1-&gt;radijus-udaljenost(k1-&gt;centar.x,k1-&gt;centar.y,p2-&gt;dole_lijevo.x,p2-&gt;dole_lijevo.y+p2-&gt;visina))&gt;-epsilon) return 1;
	/*Kruznica obuhvata trougao ako je svaki vrh trougala unutar kruznice, a to provjeravamo kao u slucaju kruznica-tacka*/
	else if(to1==KRUZNICA &amp;&amp; to2==TROUGAO &amp;&amp; (k1-&gt;radijus-udaljenost(k1-&gt;centar.x,k1-&gt;centar.y,tr2-&gt;prvi_vrh.x,tr2-&gt;prvi_vrh.y))&gt;-epsilon &amp;&amp; (k1-&gt;radijus-udaljenost(k1-&gt;centar.x,k1-&gt;centar.y,tr2-&gt;drugi_vrh.x,tr2-&gt;drugi_vrh.y))&gt;-epsilon &amp;&amp; (k1-&gt;radijus-udaljenost(k1-&gt;centar.x,k1-&gt;centar.y,tr2-&gt;treci_vrh.x,tr2-&gt;treci_vrh.y))&gt;-epsilon) return 1;
	/*Pravougaonik obuhvata tacku ako je x koordinata tacke izmedju donjeg lijevog ugla i donjeg desnog ugla; Na isti nacin funkcionise i za y koordinatu tacke*/
	else if(to1==PRAVOUGAONIK &amp;&amp; to2==TACKA &amp;&amp; (t2-&gt;x-p1-&gt;dole_lijevo.x)&gt;-epsilon &amp;&amp; (p1-&gt;dole_lijevo.x+p1-&gt;sirina-t2-&gt;x)&gt;-epsilon &amp;&amp; (t2-&gt;y-p1-&gt;dole_lijevo.y)&gt;-epsilon &amp;&amp; (p1-&gt;dole_lijevo.y+p1-&gt;visina-t2-&gt;y)&gt;-epsilon) return 1;
	/*Pravougaonik obuhvata kruznicu ako su tacke : "najniza, najvisa, najljevlja, najdesnija" unutar pravougaonika; Da li je tacka unutar pravougaonika provjeravamo kao u slucaju pravougaonik-tacka*/
	else if(to1==PRAVOUGAONIK &amp;&amp; to2==KRUZNICA &amp;&amp; (p1-&gt;dole_lijevo.y+p1-&gt;visina-(k2-&gt;centar.y+k2-&gt;radijus))&gt;-epsilon &amp;&amp; (p1-&gt;dole_lijevo.x+p1-&gt;sirina-(k2-&gt;centar.x+k2-&gt;radijus))&gt;-epsilon &amp;&amp; ((k2-&gt;centar.x-k2-&gt;radijus)-p1-&gt;dole_lijevo.x)&gt;-epsilon &amp;&amp; ((k2-&gt;centar.y-k2-&gt;radijus)-p1-&gt;dole_lijevo.y)&gt;-epsilon) return 1;
	/*Pravougaonik obuhvata pravougaonik ako su cetiri vrha pravougaonika 2 unutar pravougaonika 1; Vrhove provjeravamo kao u slucaju pravougaonik-tacka*/
	else if(to1==PRAVOUGAONIK &amp;&amp; to2==PRAVOUGAONIK &amp;&amp; (p2-&gt;dole_lijevo.x-p1-&gt;dole_lijevo.x)&gt;-epsilon &amp;&amp; ((p1-&gt;dole_lijevo.x+p1-&gt;sirina)-(p2-&gt;dole_lijevo.x-p2-&gt;sirina))&gt;-epsilon &amp;&amp; (p2-&gt;dole_lijevo.y-p1-&gt;dole_lijevo.y)&gt;-epsilon &amp;&amp; ((p1-&gt;dole_lijevo.y+p1-&gt;visina)-(p2-&gt;dole_lijevo.y-p2-&gt;visina))&gt;-epsilon) return 1;
	/*Pravougaonik obuhvata trougao ako su sva tri vrha trougla unutar pravougaonika;*/
	else if(to1==PRAVOUGAONIK &amp;&amp; to2==TROUGAO &amp;&amp; ((tr2-&gt;prvi_vrh.x-p1-&gt;dole_lijevo.x)&gt;-epsilon &amp;&amp; ((p1-&gt;dole_lijevo.x+p1-&gt;sirina)-tr2-&gt;prvi_vrh.x)&gt;-epsilon &amp;&amp; (tr2-&gt;prvi_vrh.y-p1-&gt;dole_lijevo.y)&gt;-epsilon &amp;&amp; ((p1-&gt;dole_lijevo.y+p1-&gt;visina)-tr2-&gt;prvi_vrh.y)&gt;-epsilon) &amp;&amp; ((tr2-&gt;drugi_vrh.x-p1-&gt;dole_lijevo.x)&gt;-epsilon &amp;&amp; ((p1-&gt;dole_lijevo.x+p1-&gt;sirina)-tr2-&gt;drugi_vrh.x)&gt;-epsilon &amp;&amp; (tr2-&gt;drugi_vrh.y-p1-&gt;dole_lijevo.y)&gt;-epsilon &amp;&amp; ((p1-&gt;dole_lijevo.y+p1-&gt;visina)-tr2-&gt;drugi_vrh.y)&gt;-epsilon) &amp;&amp; ((tr2-&gt;treci_vrh.x-p1-&gt;dole_lijevo.x)&gt;-epsilon &amp;&amp; ((p1-&gt;dole_lijevo.x+p1-&gt;sirina)-tr2-&gt;treci_vrh.x)&gt;-epsilon &amp;&amp; (tr2-&gt;treci_vrh.y-p1-&gt;dole_lijevo.y)&gt;-epsilon &amp;&amp; ((p1-&gt;dole_lijevo.y+p1-&gt;visina)-tr2-&gt;treci_vrh.y)&gt;-epsilon)) return 1;
	/*Trougao obuhvata tacku ako je povrsina trougla jednaka zbriru povrsina trouglova koje formiramo tackama (tacka2 i 2 od tri vrha trougla)*/
	else if(to1==TROUGAO &amp;&amp; to2==TACKA &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,t2-&gt;x,t2-&gt;y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,t2-&gt;x,t2-&gt;y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(t2-&gt;x,t2-&gt;y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon) return 1;
	/*Trougao obuhvata pravougaonik ako su sva cetiri vrha pravougaonika unutar trougla*/
	else if(to1==TROUGAO &amp;&amp; to2==PRAVOUGAONIK &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,p2-&gt;dole_lijevo.x,p2-&gt;dole_lijevo.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,p2-&gt;dole_lijevo.x,p2-&gt;dole_lijevo.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(p2-&gt;dole_lijevo.x,p2-&gt;dole_lijevo.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,p2-&gt;dole_lijevo.x+p2-&gt;sirina,p2-&gt;dole_lijevo.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,p2-&gt;dole_lijevo.x+p2-&gt;sirina,p2-&gt;dole_lijevo.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(p2-&gt;dole_lijevo.x+p2-&gt;sirina,p2-&gt;dole_lijevo.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,p2-&gt;dole_lijevo.x,p2-&gt;dole_lijevo.y+p2-&gt;visina)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,p2-&gt;dole_lijevo.x,p2-&gt;dole_lijevo.y+p2-&gt;visina,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(p2-&gt;dole_lijevo.x,p2-&gt;dole_lijevo.y+p2-&gt;visina,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,p2-&gt;dole_lijevo.x+p2-&gt;sirina,p2-&gt;dole_lijevo.y+p2-&gt;visina)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,p2-&gt;dole_lijevo.x+p2-&gt;sirina,p2-&gt;dole_lijevo.y+p2-&gt;visina,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(p2-&gt;dole_lijevo.x+p2-&gt;sirina,p2-&gt;dole_lijevo.y+p2-&gt;visina,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon) return 1;
	/*Trougao obuhvata kruznicu ako su cetiri "bitne" tacke kruznice prethodno navedene unutar trougla, s tim sto jos nijedna stranica trougla ne smije sjeci kruznicu, to provjeracamo uslovom zajednicikih tacaka prave na kojoj lezi stranica trougla i kruznice*/
	else if(to1==TROUGAO &amp;&amp; to2==KRUZNICA &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,k2-&gt;centar.x,k2-&gt;centar.y-k2-&gt;radijus)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,k2-&gt;centar.x,k2-&gt;centar.y-k2-&gt;radijus,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(k2-&gt;centar.x,k2-&gt;centar.y-k2-&gt;radijus,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,k2-&gt;centar.x,k2-&gt;centar.y+k2-&gt;radijus)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,k2-&gt;centar.x,k2-&gt;centar.y+k2-&gt;radijus,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(k2-&gt;centar.x,k2-&gt;centar.y+k2-&gt;radijus,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,k2-&gt;centar.x+k2-&gt;radijus,k2-&gt;centar.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,k2-&gt;centar.x+k2-&gt;radijus,k2-&gt;centar.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(k2-&gt;centar.x+k2-&gt;radijus,k2-&gt;centar.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,k2-&gt;centar.x-k2-&gt;radijus,k2-&gt;centar.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,k2-&gt;centar.x-k2-&gt;radijus,k2-&gt;centar.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(k2-&gt;centar.x-k2-&gt;radijus,k2-&gt;centar.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon &amp;&amp; diskriminanta(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,k2-&gt;centar.x,k2-&gt;centar.y,k2-&gt;radijus)&lt;epsilon &amp;&amp;  diskriminanta(tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y,k2-&gt;centar.x,k2-&gt;centar.y,k2-&gt;radijus)&lt;epsilon &amp;&amp;  diskriminanta(tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y,tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,k2-&gt;centar.x,k2-&gt;centar.y,k2-&gt;radijus)&lt;epsilon) return 1;
	/*Trougao obuhvata trougao ako su svi vrhovi trougla 2 unutar trougla 1*/
	else if(to1==TROUGAO &amp;&amp; to2==TROUGAO &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr2-&gt;prvi_vrh.x,tr2-&gt;prvi_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr2-&gt;prvi_vrh.x,tr2-&gt;prvi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr2-&gt;prvi_vrh.x,tr2-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr2-&gt;drugi_vrh.x,tr2-&gt;drugi_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr2-&gt;drugi_vrh.x,tr2-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr2-&gt;drugi_vrh.x,tr2-&gt;drugi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon &amp;&amp; fabs(povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr2-&gt;treci_vrh.x,tr2-&gt;treci_vrh.y)-povrsina(tr1-&gt;prvi_vrh.x,tr1-&gt;prvi_vrh.y,tr2-&gt;treci_vrh.x,tr2-&gt;treci_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y)-povrsina(tr2-&gt;treci_vrh.x,tr2-&gt;treci_vrh.y,tr1-&gt;drugi_vrh.x,tr1-&gt;drugi_vrh.y,tr1-&gt;treci_vrh.x,tr1-&gt;treci_vrh.y))&lt;epsilon) return 1;
	/*U svim ostalim slucajevima, oblik1 ne obuhvata oblik2*/
	else return 0;
}
int main()
{
	int i=0,j=0,n=0;
	int niz[50]= {0};
	struct Tacka t[50];
	struct Kruznica k[50];
	struct Pravougaonik p[50];
	struct Trougao tr[50];
	printf("Unesite broj oblika: ");
	do {
		scanf("%d",&amp;n);
	} while(n&gt;50 || n&lt;0);
	for(i=0; i&lt;n; i++) {
		printf("Odaberite tip %d. oblika (1 - tacka, 2 - kruznica, 3 - pravougaonik, 4 - trougao): ",i+1);
		scanf("%d",&amp;j);
		if(j&gt;4 || j&lt;1) {
			printf("Nepoznat tip oblika %d!\n",j);
			i--; /*Smanjujemo brojac da bi ponovo mogli koristiti isti broj jer je ovo bio prazan hod*/
			continue;
			/* Unosimo odgovarajuce elemente pozivajuci funkcije*/
		} else if (j==1) {
			niz[i]=0;
			printf("Unesite tacku: ");
			t[i]=unos_tacke();
		} else if(j==2) {
			niz[i]=1;
			k[i]=unos_kruznice();
		} else if(j==3) {
			niz[i]=2;
			p[i]=unos_pravougaonika();
		} else if(j==4) {
			niz[i]=3;
			tr[i]=unos_trougla();
		}
	}
	for(i=0; i&lt;n; i++) {
		if(niz[i]==0) {
			for(j=0; j&lt;n; j++) {
				if(j==i) continue;
				else {
					/* U tipu enum, odgovarajuci oblici imaju odgovarajuce brojeve krenuvis od 0 pa do 3*/
					if(niz[j]==0) {
						if(obuhvata(&amp;t[i],0,&amp;t[j],0)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==1) {
						if(obuhvata(&amp;t[i],0,&amp;k[j],1)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==2) {
						if(obuhvata(&amp;t[i],0,&amp;p[j],2)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==3) {
						if(obuhvata(&amp;t[i],0,&amp;tr[j],3)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					}
				}
			}
		} else if(niz[i]==1) {
			for(j=0; j&lt;n; j++) {
				if(j==i) continue;
				else {
					if(niz[j]==0) {
						if(obuhvata(&amp;k[i],1,&amp;t[j],0)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==1) {
						if(obuhvata(&amp;k[i],1,&amp;k[j],1)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==2) {
						if(obuhvata(&amp;k[i],1,&amp;p[j],2)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==3) {
						if(obuhvata(&amp;k[i],1,&amp;tr[j],3)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					}
				}
			}
		} else if(niz[i]==2) {
			for(j=0; j&lt;n; j++) {
				if(j==i) continue;
				else {
					if(niz[j]==0) {
						if(obuhvata(&amp;p[i],2,&amp;t[j],0)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==1) {
						if(obuhvata(&amp;p[i],2,&amp;k[j],1)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==2) {
						if(obuhvata(&amp;p[i],2,&amp;p[j],2)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==3) {
						if(obuhvata(&amp;p[i],2,&amp;tr[j],3)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					}
				}
			}
		} else if(niz[i]==3) {
			for(j=0; j&lt;n; j++) {
				if(j==i) continue;
				else {
					if(niz[j]==0) {
						if(obuhvata(&amp;tr[i],3,&amp;t[j],0)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==1) {
						if(obuhvata(&amp;tr[i],3,&amp;k[j],1)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==2) {
						if(obuhvata(&amp;tr[i],3,&amp;p[j],2)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					} else if(niz[j]==3) {
						if(obuhvata(&amp;tr[i],3,&amp;tr[j],3)) printf("\nOblik %d obuhvata oblik %d.",i+1,j+1);
					}
				}
			}
		}
	}
	return 0;
}
</pre>
</body>
</html>
