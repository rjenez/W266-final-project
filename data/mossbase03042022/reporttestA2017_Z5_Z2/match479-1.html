<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student7249.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student4559.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define EPSILON 0.001

enum TipOblika {
	TACKA,
	KRUZNICA,
	PRAVOUGAONIK,
	TROUGAO
};

struct Tacka {
	double x, y;
};

struct Kruznica {
	struct Tacka centar;
	double radijus;
};

struct Pravougaonik {
	struct Tacka dolje_lijevo;
	double visina, sirina;
};

struct Trougao {
	struct Tacka tacka1, tacka2, tacka3;
};

union shapeGroup {
	struct Tacka point;
	struct Kruznica circle;
	struct Pravougaonik rect;
	struct Trougao triangle;
};

struct Oblik {
	enum TipOblika shapeType;
	
	union shapeGroup shape;
};

struct Tacka unos_tacke() {
	struct Tacka tmp;
	
	printf("koordinate x,y: ");
	scanf("%lf,%lf", &amp;tmp.x, &amp;tmp.y);
	
	return tmp;
}

double distance(struct Tacka, struct Tacka);
int isInPoint(struct Tacka*, void*, enum TipOblika);
int isInCircle(struct Kruznica*, void*, enum TipOblika);
int isInRect(struct Pravougaonik*, void*, enum TipOblika);
int isInTriangle(struct Trougao*, void*, enum TipOblika);
int obuhvata(void*, enum TipOblika, void*, enum TipOblika);

int main() {
	struct Oblik shapes[50];
	int n, type;
	int i, j;
	
	printf("Unesite broj oblika: ");
	scanf("%d", &amp;n);
	
	for (i = 0; i &lt; n; i++) {
		printf("Odaberite tip %d. oblika (1 - tacka, 2 - kruznica, 3 - pravougaonik, 4 - trougao): ", i + 1);
		scanf("%d", &amp;type);
		
		if (type &lt; 1 || type &gt; 4) {
			printf("Nepoznat tip oblika %d!\n", type);
			i--;
			continue;
		}
		
<a name="1"></a><font color="#00FF00"><a href="match479-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if (type == 1) {
			shapes[i].shapeType = TACKA;
			
			printf("Unesite tacku: ");
			shapes[i].shape.point = unos_tacke();
		}
		else if (type == 2) {
			shapes[i].shapeType = KRUZNICA;
			
			printf("Unesite centar kruznice: ");
</font>			shapes[i].shape.circle.centar = unos_tacke();
			printf("Unesite poluprecnik kruznice: ");
			scanf("%lf", &amp;shapes[i].shape.circle.radijus);
		}
		else if (type == 3) {
			shapes[i].shapeType = PRAVOUGAONIK;
			
			printf("Unesite donji lijevi ugao: ");
			shapes[i].shape.rect.dolje_lijevo = unos_tacke();
			printf("Unesite sirinu: ");
			scanf("%lf", &amp;shapes[i].shape.rect.sirina);
			printf("Unesite visinu: ");
			scanf("%lf", &amp;shapes[i].shape.rect.visina);
		}
		else {
			shapes[i].shapeType = TROUGAO;
			
			printf("Unesite prvi vrh: ");
			shapes[i].shape.triangle.tacka1 = unos_tacke();
			printf("Unesite drugi vrh: ");
			shapes[i].shape.triangle.tacka2 = unos_tacke();
			printf("Unesite treci vrh: ");
			shapes[i].shape.triangle.tacka3 = unos_tacke();
		}
	}
	
	printf("\n");
	
	for (i = 0; i &lt; n; i++)
		for (j = 0; j &lt; n; j++)
<a name="3"></a><font color="#00FFFF"><a href="match479-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			if (i != j &amp;&amp; obuhvata(&amp;shapes[i].shape, shapes[i].shapeType,
								   &amp;shapes[j].shape, shapes[j].shapeType))
</font>				printf("Oblik %d obuhvata oblik %d.\n", i + 1, j + 1);
	
	return 0;
}

int obuhvata(void* shape1, enum TipOblika shape1Type,
			 void* shape2, enum TipOblika shape2Type) {
	switch(shape1Type) {
		case TACKA:
			return isInPoint((struct Tacka*)(shape1), shape2, shape2Type);
		case KRUZNICA:
			return isInCircle((struct Kruznica*)(shape1), shape2, shape2Type);
		case PRAVOUGAONIK:
			return isInRect((struct Pravougaonik*)(shape1), shape2, shape2Type);
		case TROUGAO:
			return isInTriangle((struct Trougao*)(shape1), shape2, shape2Type);
	}
	
	return -1;
}

double distance(struct Tacka p1, struct Tacka p2) {
<a name="2"></a><font color="#0000FF"><a href="match479-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
</font>}

int isInPoint(struct Tacka* point, void* shape, enum TipOblika shapeType) {
	if (shapeType == TACKA)
		return fabs(point-&gt;x - ((struct Tacka*)(shape))-&gt;x) &lt; EPSILON &amp;&amp;
			   fabs(point-&gt;y - ((struct Tacka*)(shape))-&gt;y) &lt; EPSILON;
			   
	if (shapeType == KRUZNICA)
		return fabs(((struct Kruznica*)(shape))-&gt;radijus) &lt; EPSILON &amp;&amp;
			   isInPoint(point, &amp;(((struct Kruznica*)(shape))-&gt;centar), TACKA);
			   
	if (shapeType == PRAVOUGAONIK)
		return fabs(((struct Pravougaonik*)(shape))-&gt;sirina) &lt; EPSILON &amp;&amp;
			   fabs(((struct Pravougaonik*)(shape))-&gt;visina) &lt; EPSILON &amp;&amp;
			   isInPoint(point, &amp;(((struct Pravougaonik*)(shape))-&gt;dolje_lijevo), TACKA);
			   
	if (shapeType == TROUGAO)
		return isInPoint(point, &amp;(((struct Trougao*)(shape))-&gt;tacka1), TACKA) &amp;&amp;
			   isInPoint(point, &amp;(((struct Trougao*)(shape))-&gt;tacka2), TACKA) &amp;&amp;
			   isInPoint(point, &amp;(((struct Trougao*)(shape))-&gt;tacka3), TACKA);
			   
	return -1;
}

int isInCircle(struct Kruznica* circle, void* shape, enum TipOblika shapeType) {
	/* Ova tacka sluzi za pomoc ukoliko je oblik koji se treba nalaziti unutra pravougaonik */
	struct Tacka gore_desno;
	switch (shapeType) {
		case TACKA:
			return distance(circle-&gt;centar, *(struct Tacka*)(shape)) &lt;= circle-&gt;radijus;
			
		case KRUZNICA:
			return (distance(circle-&gt;centar, ((struct Kruznica*)(shape))-&gt;centar)) +
				   (((struct Kruznica*)(shape))-&gt;radijus) &lt;= circle-&gt;radijus;
				   
		case PRAVOUGAONIK:
			gore_desno.x = ((struct Pravougaonik*)(shape))-&gt;dolje_lijevo.x +
						   ((struct Pravougaonik*)(shape))-&gt;sirina;
			gore_desno.y = ((struct Pravougaonik*)(shape))-&gt;dolje_lijevo.y +
						   ((struct Pravougaonik*)(shape))-&gt;visina;
			return distance(circle-&gt;centar, gore_desno) &lt;= circle-&gt;radijus &amp;&amp;
				   distance(circle-&gt;centar, ((struct Pravougaonik*)(shape))-&gt;dolje_lijevo) &lt;= circle-&gt;radijus;
		
		case TROUGAO:
			return distance(circle-&gt;centar, ((struct Trougao*)(shape))-&gt;tacka1) &lt;= circle-&gt;radijus &amp;&amp;
				   distance(circle-&gt;centar, ((struct Trougao*)(shape))-&gt;tacka2) &lt;= circle-&gt;radijus &amp;&amp;
				   distance(circle-&gt;centar, ((struct Trougao*)(shape))-&gt;tacka3) &lt;= circle-&gt;radijus;
	}
	
	return -1;
}

int isInRect(struct Pravougaonik* rect, void* shape, enum TipOblika shapeType) {
	if (shapeType == TACKA)
		return ((struct Tacka*)(shape))-&gt;x &lt;= rect-&gt;dolje_lijevo.x + rect-&gt;sirina &amp;&amp;
			   ((struct Tacka*)(shape))-&gt;x &gt;= rect-&gt;dolje_lijevo.x &amp;&amp;
			   ((struct Tacka*)(shape))-&gt;y &lt;= rect-&gt;dolje_lijevo.y + rect-&gt;visina &amp;&amp;
			   ((struct Tacka*)(shape))-&gt;y &gt;= rect-&gt;dolje_lijevo.y;
	
	if (shapeType == KRUZNICA) {
		struct Kruznica *k = (struct Kruznica*)(shape);
		return (k-&gt;centar.x + k-&gt;radijus &lt;= rect-&gt;dolje_lijevo.x + rect-&gt;sirina) &amp;&amp;
			   (k-&gt;centar.x - k-&gt;radijus &gt;= rect-&gt;dolje_lijevo.x) &amp;&amp;
			   (k-&gt;centar.y + k-&gt;radijus &lt;= rect-&gt;dolje_lijevo.y + rect-&gt;visina) &amp;&amp;
			   (k-&gt;centar.y - k-&gt;radijus &gt;= rect-&gt;dolje_lijevo.y);
	}
	
	if (shapeType == PRAVOUGAONIK) {
		struct Pravougaonik *p = (struct Pravougaonik*)(shape);
		return (p-&gt;dolje_lijevo.x + p-&gt;sirina &lt;= rect-&gt;dolje_lijevo.x + rect-&gt;sirina) &amp;&amp;
			   (p-&gt;dolje_lijevo.x &gt;= rect-&gt;dolje_lijevo.x) &amp;&amp;
			   (p-&gt;dolje_lijevo.y + p-&gt;visina &lt;= rect-&gt;dolje_lijevo.y + rect-&gt;visina) &amp;&amp;
			   (p-&gt;dolje_lijevo.y &gt;= rect-&gt;dolje_lijevo.y);
	}
	
	if (shapeType == TROUGAO) {
		struct Trougao *t = (struct Trougao*)(shape);
		
		return isInRect(rect, &amp;(t-&gt;tacka1), TACKA) &amp;&amp;
			   isInRect(rect, &amp;(t-&gt;tacka2), TACKA) &amp;&amp;
			   isInRect(rect, &amp;(t-&gt;tacka3), TACKA);
	}
	
	return -1;
}

int isInTriangle(struct Trougao* triangle, void* shape, enum TipOblika shapeType) {
<a name="0"></a><font color="#FF0000"><a href="match479-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	if (fabs(triangle-&gt;tacka1.x - triangle-&gt;tacka2.x) &lt; EPSILON &amp;&amp;
		fabs(triangle-&gt;tacka2.x - triangle-&gt;tacka3.x) &lt; EPSILON &amp;&amp;
		fabs(triangle-&gt;tacka1.y - triangle-&gt;tacka2.y) &lt; EPSILON &amp;&amp;
</font>		fabs(triangle-&gt;tacka2.y - triangle-&gt;tacka3.y) &lt; EPSILON)
		return isInPoint(&amp;(triangle-&gt;tacka1), shape, shapeType);
	
	if (shapeType == TACKA) {
		struct Tacka *t = (struct Tacka*)(shape);
		
		/* Mozemo definirati vektore preko strukture tacka
		   Algoritam opisan na: http://blackpawn.com/texts/pointinpoly */
		struct Tacka v0, v1, vt;
		double dot00, dot01, dot0t, dot11, dot1t;
		double u, v;
		
		v0.x = triangle-&gt;tacka3.x - triangle-&gt;tacka1.x;
		v0.y = triangle-&gt;tacka3.y - triangle-&gt;tacka1.y;
		
		v1.x = triangle-&gt;tacka2.x - triangle-&gt;tacka1.x;
		v1.y = triangle-&gt;tacka2.y - triangle-&gt;tacka1.y;
		
		vt.x = t-&gt;x - triangle-&gt;tacka1.x;
		vt.y = t-&gt;y - triangle-&gt;tacka1.y;
		
		/* Racunanje skalarnog proizvoda izmedju svih vektora */
		dot00 = v0.x * v0.x + v0.y * v0.y;
		dot01 = v0.x * v1.x + v0.y * v1.y;
		dot0t = v0.x * vt.x + v0.y * vt.y;
		dot11 = v1.x * v1.x + v1.y * v1.y;
		dot1t = v1.x * vt.x + v1.y * vt.y;
		
		/* Racunanje koordinata tacke u bazi vectora [C-A] i [B-A] */
		u = (dot11 * dot0t - dot01 * dot1t) / (dot00 * dot11 - dot01 * dot01);
		v = (dot00 * dot1t - dot01 * dot0t) / (dot00 * dot11 - dot01 * dot01);
		
		return (u &gt;= 0) &amp;&amp; (v &gt;= 0) &amp;&amp; (u + v &lt;= 1 + EPSILON);
	}
	
	if (shapeType == KRUZNICA) {
		struct Kruznica *k = (struct Kruznica*)(shape);
		
		struct Tacka v12, v13, v23;
		struct Tacka vp1, vp2;
		
		double dot12p, dot13p, dot23p;
		double v12sq, v13sq, v23sq;
		double vp1sq, vp2sq;
		
		v12.x = triangle-&gt;tacka2.x - triangle-&gt;tacka1.x;
		v12.y = triangle-&gt;tacka2.y - triangle-&gt;tacka1.y;
		
		v13.x = triangle-&gt;tacka3.x - triangle-&gt;tacka1.x;
		v13.y = triangle-&gt;tacka3.y - triangle-&gt;tacka1.y;
		
		v23.x = triangle-&gt;tacka3.x - triangle-&gt;tacka2.x;
		v23.y = triangle-&gt;tacka3.y - triangle-&gt;tacka2.y;
		
		vp1.x = -triangle-&gt;tacka1.x + k-&gt;centar.x;
		vp1.y = -triangle-&gt;tacka1.y + k-&gt;centar.y;
		
		vp2.x = -triangle-&gt;tacka2.x + k-&gt;centar.x;
		vp2.y = -triangle-&gt;tacka2.y + k-&gt;centar.y;
		
		dot12p = v12.x * vp1.x + v12.y * vp1.y;
		dot13p = v13.x * vp1.x + v13.y * vp1.y;
		dot23p = v23.x * vp2.x + v23.y * vp2.y;
		
		v12sq = v12.x * v12.x + v12.y * v12.y;
		v13sq = v13.x * v13.x + v13.y * v13.y;
		v23sq = v23.x * v23.x + v23.y * v23.y;
		
		vp1sq = vp1.x * vp1.x + vp1.y * vp1.y;
		vp2sq = vp2.x * vp2.x + vp2.y * vp2.y;
		
		/*printf("%5f %5f %5f\n", vp1sq - dot12p * dot12p / v12sq - (k-&gt;radijus) * (k-&gt;radijus),
							 vp1sq - dot13p * dot13p / v13sq,
							 vp2sq - dot23p * dot23p / v23sq);*/
		
		return isInTriangle(triangle, &amp;(k-&gt;centar), TACKA) &amp;&amp;
			   vp1sq - dot12p * dot12p / v12sq - (k-&gt;radijus) * (k-&gt;radijus) &gt; EPSILON &amp;&amp;
			   vp1sq - dot13p * dot13p / v13sq - (k-&gt;radijus) * (k-&gt;radijus) &gt; EPSILON &amp;&amp;
			   vp2sq - dot23p * dot23p / v23sq - (k-&gt;radijus) * (k-&gt;radijus) &gt; EPSILON;
	}
	
	if (shapeType == PRAVOUGAONIK) {
		struct Pravougaonik *p = (struct Pravougaonik*)(shape);
		struct Tacka gore_lijevo, dolje_desno, gore_desno;
		
		gore_lijevo.x = p-&gt;dolje_lijevo.x;
		gore_lijevo.y = p-&gt;dolje_lijevo.y + p-&gt;visina;
		
		dolje_desno.x = p-&gt;dolje_lijevo.x + p-&gt;sirina;
		dolje_desno.y = p-&gt;dolje_lijevo.y;
		
		gore_desno.x = p-&gt;dolje_lijevo.x + p-&gt;sirina;
		gore_desno.y = p-&gt;dolje_lijevo.y + p-&gt;visina;
		
		return isInTriangle(triangle, &amp;(p-&gt;dolje_lijevo), TACKA) &amp;&amp;
			   isInTriangle(triangle, &amp;gore_lijevo, TACKA) &amp;&amp;
			   isInTriangle(triangle, &amp;dolje_desno, TACKA) &amp;&amp;
			   isInTriangle(triangle, &amp;gore_desno, TACKA);
	}
	
	if (shapeType == TROUGAO) {
		struct Trougao *t = (struct Trougao*)(shape);
		
		return isInTriangle(triangle, &amp;(t-&gt;tacka1), TACKA) &amp;&amp;
			   isInTriangle(triangle, &amp;(t-&gt;tacka2), TACKA) &amp;&amp;
			   isInTriangle(triangle, &amp;(t-&gt;tacka3), TACKA);
	}
	return -1;
}</pre>
</body>
</html>
