<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student2922.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student5381.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#define EPS 0.001
enum TipOblika {TACKA,KRUZNICA,PRAVOUGAONIK,TROUGAO};
struct Tacka {
	float x;
	float y;
};
struct Kruznica {
	struct Tacka centar;
	float radijus;
};
struct Pravougaonik {
	struct Tacka donji_lijevi;
	float sirina,visina;
};
struct Trougao {
	struct Tacka prvi_vrh,drugi_vrh,treci_vrh;
};
struct Tacka unesi_tacku()
{
<a name="0"></a><font color="#FF0000"><a href="match504-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	struct Tacka t;
	printf ("koordinate x,y: ");
	scanf ("%f,%f", &amp;t.x, &amp;t.y);
	return t;
}
struct Kruznica unesi_kruznicu ()
{
	struct Kruznica k;
	printf ("Unesite centar kruznice: ");
	k.centar=unesi_tacku();
	printf ("Unesite poluprecnik kruznice: ");
	scanf ("%f",&amp;k.radijus);
	return k;
}
struct Pravougaonik unesi_pravougaonik()
{
	struct Pravougaonik p;
	printf ("Unesite donji lijevi ugao: ");
	p.donji_lijevi=unesi_tacku();
	printf ("Unesite sirinu: ");
	scanf ("%f",&amp;p.sirina);
	printf ("Unesite visinu: ");
	scanf ("%f",&amp;p.visina);
	return p;
}
struct Trougao unesi_trougao ()
{
	struct Trougao tr;
	printf ("Unesite prvi vrh: ");
	tr.prvi_vrh=unesi_tacku();
	printf ("Unesite drugi vrh: ");
	tr.drugi_vrh=unesi_tacku();
	printf ("Unesite treci vrh: ");
	tr.treci_vrh=unesi_tacku();
	return tr;
</font>}
float udaljenost (struct Tacka t1,struct Tacka t2)
{
	return sqrt (((t1.x-t2.x)*(t1.x-t2.x)) + ((t1.y-t2.y)*(t1.y-t2.y)));
}
float povrsina (struct Tacka t1,struct Tacka t2,struct Tacka t3)
{
	float pov;
	pov=(t1.x*(t2.y-t3.y)+t2.x*(t3.y-t1.y)+t3.x*(t1.y-t2.y))/2;
	if (pov&lt;0)
		pov=-pov;
	return pov;
}
int tacka_u_kruznici (struct Kruznica* k, struct Tacka t)
{
	if (udaljenost(k-&gt;centar,t)&lt;=k-&gt;radijus)
		return 1;
	return 0;
}
int tacka_u_pravougaoniku (struct Pravougaonik* p,struct Tacka t)
{
	/*Funkcija prima pravougaonik, i formira uz pomoc visine i sirine i jedne tacke, i one ostale tri*/
	/*Provjeravamo da li se neka tacka,nalazi unutar pravougaonika omedjenog sa ove cetiri tacke*/
	struct Tacka tp;
	tp.x=p-&gt;donji_lijevi.x+p-&gt;sirina;
	tp.y=p-&gt;donji_lijevi.y+p-&gt;visina;
	if (t.x&gt;=p-&gt;donji_lijevi.x &amp;&amp; t.x&lt;=tp.x &amp;&amp; t.y&gt;=p-&gt;donji_lijevi.y &amp;&amp; t.y&lt;=tp.y)
		return 1;
	return 0;

}
int tacka_u_trouglu (struct Trougao* tr,struct Tacka t)
{
	/*Formiramo tri trougla,od kojih svaki sadrzi neku tacku za koju zelimo da provjerimo je li u trouglu*/
	/*Racunamo povrsine trouglova koji sadrze ovu tacku,i dva tjemena trougla,uvijek razlicita*/
	/*Ako je zbir tih povrsina jednak povrsini trougla,tacka je u trouglu*/
	float A1,A2,A3,Au,At;
	A1=povrsina(tr-&gt;prvi_vrh,tr-&gt;drugi_vrh,t);
	A2=povrsina(tr-&gt;prvi_vrh,tr-&gt;treci_vrh,t);
	A3=povrsina(tr-&gt;drugi_vrh,tr-&gt;treci_vrh,t);
	Au=A1+A2+A3;
	At=povrsina(tr-&gt;prvi_vrh,tr-&gt;drugi_vrh,tr-&gt;treci_vrh);
	if (abs(At-Au)&lt;EPS)
		return 1;
	return 0;

}
int tangenta_na_kruznicu (struct Tacka t1,struct Tacka t2,struct Kruznica k)
{
	/*Da bismo znali da se kruznica sigurno nalazi u trouglu, niti jedna prava formirana od svaka dva tjemena trougla, ne smije dodirivati kruznicu u vise od jedne tacke*/
	/*Iz uslova dodira,mozemo znati kakav ce biti polozaj kruznice u trouglu*/
	float r=k.radijus;
	float p=k.centar.x,q=k.centar.y;
	float m,n;
	float v;
	/*Za slucaj da je neka tangenta vertikalna,imamo posebni uslov,da ne bismo dosli u situaciju da dijelimo s nulom*/
	if (abs(t1.x-t2.x)&lt;=EPS) {
		v=t1.x;
		if (v&lt;k.centar.x) {
			if (k.centar.x-v&gt;k.radijus)
				return 1;
			return 0;
		} else {
			if (v-k.centar.x&gt;k.radijus)
				return 1;
			return 0;
		}
	}
	m=(t1.y-t2.y)/(t1.x-t2.x);
	n=t1.y-m*t1.x;
	if (r*r*(m*m+1)-(-(m*p)+q-n)*(-(m*p)+q-n)&lt;=0)
		return 1;
	return 0;
}

int  obuhvata (void* oblik1, enum TipOblika to1, void* oblik2, enum TipOblika to2)
{
	struct Tacka* t1;
	struct Tacka* t2;
	struct Kruznica* k1;
	struct Kruznica* k2;
	struct Pravougaonik* p1;
	struct Pravougaonik* p2;
	struct Trougao* tr1;
	struct Trougao* tr2;
	if (to1==TACKA)
		t1=(struct Tacka*)oblik1;
	else if (to1==KRUZNICA)
		k1=(struct Kruznica*)oblik1;
	else if (to1==PRAVOUGAONIK)
		p1=(struct Pravougaonik*)oblik1;
	else if (to1==TROUGAO)
		tr1=(struct Trougao*)oblik1;
	if (to2==TACKA)
		t2=(struct Tacka*)oblik2;
	else if (to2==KRUZNICA)
		k2=(struct Kruznica*)oblik2;
	else if (to2==PRAVOUGAONIK)
		p2=(struct Pravougaonik*)oblik2;
	else if (to2==TROUGAO)
		tr2=(struct Trougao*)oblik2;
	if (to1==KRUZNICA) {
		if (to2==PRAVOUGAONIK) {
			/*Formiramo sva 4 tjemena pravougonika,i ako se oni nalaze u kruznici,znaci da je i pravougaonik u njoj*/
			struct Tacka pr1,pr2,pr3;
			pr1.x=p2-&gt;donji_lijevi.x;
			pr1.y=p2-&gt;donji_lijevi.y+p2-&gt;visina;
			pr2.x=p2-&gt;donji_lijevi.x+p2-&gt;sirina;
			pr2.y=p2-&gt;donji_lijevi.y;
			pr3.x=p2-&gt;donji_lijevi.x+p2-&gt;sirina;
			pr3.y=p2-&gt;donji_lijevi.y+p2-&gt;visina;
			if (tacka_u_kruznici(k1,pr1) &amp;&amp; tacka_u_kruznici(k1,pr2) &amp;&amp; tacka_u_kruznici(k1,pr3) &amp;&amp; tacka_u_kruznici(k1,p2-&gt;donji_lijevi))
				return 1;
			return 0;
		} else if (to2==TACKA) {
			if (tacka_u_kruznici(k1,*t2))
				return 1;
			return 0;
		} else if (to2==TROUGAO) {
			if (tacka_u_kruznici(k1,tr2-&gt;prvi_vrh) &amp;&amp; tacka_u_kruznici(k1,tr2-&gt;drugi_vrh) &amp;&amp; tacka_u_kruznici(k1,tr2-&gt;treci_vrh))
				return 1;
			return 0;
		} else if (to2==KRUZNICA) {
			if (tacka_u_kruznici(k1,k2-&gt;centar) &amp;&amp; k2-&gt;radijus&lt;=k1-&gt;radijus-udaljenost(k1-&gt;centar,k2-&gt;centar))
				return 1;
			return 0;
		}
	} else if (to1==TROUGAO) {
		if (to2==TACKA) {
			if (tacka_u_trouglu(tr1,*t2))
				return 1;
			return 0;
		} else if (to2==PRAVOUGAONIK) {
			/*Na isti nacin,formiramo sva tjemna pravougaonika i koristimo pomocnu funckiju*/
			struct Tacka pr1,pr2,pr3;
			pr1.x=p2-&gt;donji_lijevi.x;
			pr1.y=p2-&gt;donji_lijevi.y+p2-&gt;visina;
			pr2.x=p2-&gt;donji_lijevi.x+p2-&gt;sirina;
			pr2.y=p2-&gt;donji_lijevi.y;
			pr3.x=p2-&gt;donji_lijevi.x+p2-&gt;sirina;
			pr3.y=p2-&gt;donji_lijevi.y+p2-&gt;visina;
			if (tacka_u_trouglu(tr1,pr1) &amp;&amp; tacka_u_trouglu(tr1,pr2) &amp;&amp; tacka_u_trouglu(tr1,pr3) &amp;&amp; tacka_u_trouglu(tr1,p2-&gt;donji_lijevi))
				return 1;
			return 0;
		} else if (to2==KRUZNICA) {
			if (tacka_u_trouglu(tr1,k2-&gt;centar) &amp;&amp; tangenta_na_kruznicu(tr1-&gt;prvi_vrh,tr1-&gt;drugi_vrh,*k2) &amp;&amp;
			tangenta_na_kruznicu(tr1-&gt;prvi_vrh,tr1-&gt;treci_vrh,*k2) &amp;&amp; tangenta_na_kruznicu(tr1-&gt;drugi_vrh,tr1-&gt;treci_vrh,*k2))
				return 1;
			return 0;
		} else if (to2==TROUGAO) {
			if (tacka_u_trouglu(tr1,tr2-&gt;prvi_vrh) &amp;&amp; tacka_u_trouglu(tr1,tr2-&gt;drugi_vrh) &amp;&amp; tacka_u_trouglu(tr1,tr2-&gt;drugi_vrh))
				return 1;
			return 0;
		}
	}
	if (to1==PRAVOUGAONIK) {
		if (to2==TACKA) {
			if (tacka_u_pravougaoniku(p1,*t2))
				return 1;
			return 0;
		} else if (to2==TROUGAO) {
			if (tacka_u_pravougaoniku(p1,tr2-&gt;prvi_vrh) &amp;&amp; tacka_u_pravougaoniku(p1,tr2-&gt;drugi_vrh)
			&amp;&amp; tacka_u_pravougaoniku(p1,tr2-&gt;treci_vrh))
				return 1;
			return 0;
		} else if (to2==KRUZNICA) {
			struct Tacka tk1,tk2,tk3,tk4;
			tk1.x=k2-&gt;centar.x;
			tk1.y=k2-&gt;centar.y+k2-&gt;radijus;
			tk2.x=k2-&gt;centar.x;
			tk2.y=k2-&gt;centar.y-k2-&gt;radijus;
			tk3.x=k2-&gt;centar.x+k2-&gt;radijus;
			tk3.y=k2-&gt;centar.y;
			tk4.x=k2-&gt;centar.x-k2-&gt;radijus;
			tk4.y=k2-&gt;centar.y;
			if (tacka_u_pravougaoniku(p1,k2-&gt;centar) &amp;&amp; tacka_u_pravougaoniku(p1,tk1) &amp;&amp; tacka_u_pravougaoniku(p1,tk2)
			&amp;&amp; tacka_u_pravougaoniku(p1,tk3) &amp;&amp; tacka_u_pravougaoniku(p1,tk4))
				return 1;
			return 0;
		} else if (to2==PRAVOUGAONIK) {
			struct Tacka pp1,pp2,pp3;
			pp1.x=p2-&gt;donji_lijevi.x;
			pp1.y=p2-&gt;donji_lijevi.y+p2-&gt;visina;
			pp2.x=p2-&gt;donji_lijevi.x+p2-&gt;sirina;
			pp2.y=p2-&gt;donji_lijevi.y;
			pp3.x=p2-&gt;donji_lijevi.x+p2-&gt;sirina;
			pp3.y=p2-&gt;donji_lijevi.y+p2-&gt;visina;
			if (tacka_u_pravougaoniku(p1,pp1) &amp;&amp; tacka_u_pravougaoniku(p1,pp2) &amp;&amp; tacka_u_pravougaoniku(p1,pp3)
			&amp;&amp; tacka_u_pravougaoniku(p1,p2-&gt;donji_lijevi))
				return 1;
			return 0;
		}
	} else if (to1==TACKA) {
		if (to2==TACKA) {
			if (abs(t1-&gt;x-t2-&gt;x)&lt;=EPS &amp;&amp; abs(t1-&gt;y-t2-&gt;y)&lt;=EPS)
				return 1;
			return 0;
		} else if (to2==KRUZNICA) {
<a name="1"></a><font color="#00FF00"><a href="match504-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

			if (k2-&gt;radijus&lt;EPS &amp;&amp; abs(t1-&gt;x-k2-&gt;centar.x)&lt;=EPS &amp;&amp; abs(t1-&gt;y-k2-&gt;centar.y)&lt;=EPS)
</font><a name="1"></a><font color="#00FF00"><a href="match504-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

				return 1;
</font>			return 0;
		} else if (to2==TROUGAO) {
			if (abs(tr2-&gt;prvi_vrh.x-tr2-&gt;drugi_vrh.x)&lt;=EPS &amp;&amp; abs(tr2-&gt;prvi_vrh.y-tr2-&gt;drugi_vrh.y)&lt;=EPS
			&amp;&amp; abs(tr2-&gt;prvi_vrh.x-tr2-&gt;treci_vrh.x)&lt;=EPS &amp;&amp; abs(tr2-&gt;prvi_vrh.y-tr2-&gt;treci_vrh.y)&lt;=EPS &amp;&amp;
			abs(tr2-&gt;prvi_vrh.x-t1-&gt;x)&lt;=EPS &amp;&amp; abs(tr2-&gt;prvi_vrh.y-t1-&gt;y)&lt;=EPS)
				return 1;
			return 0;
		} else if (to2==PRAVOUGAONIK) {
			if (p2-&gt;visina&lt;EPS &amp;&amp; p2-&gt;sirina&lt;EPS &amp;&amp; abs(p2-&gt;donji_lijevi.x-t1-&gt;x)&lt;=EPS &amp;&amp; abs(p2-&gt;donji_lijevi.y-t1-&gt;y)&lt;=EPS)
				return 1;
			return 0;
		}
	}
	return 2;
}


int main()
{
	int broj_oblika,i,tip_oblika,j;
	struct Tacka tacke[50];
	struct Trougao niz_trouglova[50];
	struct Pravougaonik niz_pravougaonika[50];
	struct Kruznica niz_kruznica[50];
	int brojac_t=0,brojac_tr=0,brojac_p=0,brojac_k=0,br=0,niz[50],brojac_t1=0,brojac_p1=0,brojac_tr1=0,brojac_k1=0;
	struct Tacka* t;
	struct Trougao* tr;
	struct Kruznica* k;
	struct Pravougaonik* p;
	struct Tacka* t1;
	struct Trougao* tr1;
	struct Kruznica* k1;
	struct Pravougaonik* p1;
	printf ("Unesite broj oblika: ");
	scanf ("%d",&amp;broj_oblika);
	for (i=0; i&lt;broj_oblika; i++) {
		printf ("Odaberite tip %d. oblika (1 - tacka, 2 - kruznica, 3 - pravougaonik, 4 - trougao): ",i+1);
		scanf ("%d",&amp;tip_oblika);

		if (tip_oblika==1) {
			printf ("Unesite tacku: ");
			tacke[brojac_t]=unesi_tacku();
			brojac_t++;
			niz[br]=1;
		} else if (tip_oblika==2) {
			niz_kruznica[brojac_k]=unesi_kruznicu();
			brojac_k++;
			niz[br]=2;
		} else if (tip_oblika==3) {
			niz_pravougaonika[brojac_p]=unesi_pravougaonik();
			brojac_p++;
			niz[br]=3;
		} else if (tip_oblika==4) {
			niz_trouglova[brojac_tr]=unesi_trougao();
			brojac_tr++;
			niz[br]=4;
		} else {
			printf("Nepoznat tip oblika %d!\n",tip_oblika);
			i--;
			br--;
		}
		br++;
	}
	printf ("\n");
	brojac_tr=0;
	brojac_p=0;
	brojac_t=0;
	brojac_k=0;
	/*Nakon sto smo smjestili sve oblike u razlicite nizove,prolazimo dvostrukom petljom i uporedjujemo ih*/
	/*Uz pomoc brojaca,uvijek smo u opsegu tih nizova,i sprijeceno je ponavljanje tj.uporedjivanje istih oblika*/
	for (i=0; i&lt;broj_oblika; i++) {
		if (niz[i]==1) {
			t1=&amp;tacke[brojac_t1];
			brojac_t1++;
			for (j=0; j&lt;broj_oblika; j++) {

				if (niz[j]==1) {
					t=&amp;tacke[brojac_t];
					brojac_t++;
					if (obuhvata(t1,TACKA,t,TACKA) &amp;&amp; j!=i)
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==2) {
					k=&amp;niz_kruznica[brojac_k];
					brojac_k++;
					if (obuhvata(t1,TACKA,k,KRUZNICA) )
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==3) {
					p=&amp;niz_pravougaonika[brojac_p];
					brojac_p++;
					if (obuhvata(t1,TACKA,p,PRAVOUGAONIK))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==4) {
					tr=&amp;niz_trouglova[brojac_tr];
					brojac_tr++;
					if (obuhvata(t1,TACKA,tr,TROUGAO))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				}
			}
		} else if (niz[i]==2) {
			k1=&amp;niz_kruznica[brojac_k1];
			brojac_k1++;
			for (j=0; j&lt;broj_oblika; j++) {
				if (niz[j]==1) {
					t=&amp;tacke[brojac_t];
					brojac_t++;
					if (obuhvata(k1,KRUZNICA,t,TACKA))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==3) {
					p=&amp;niz_pravougaonika[brojac_p];
					brojac_p++;
					if (obuhvata(k1,KRUZNICA,p,PRAVOUGAONIK))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==2) {
					k=&amp;niz_kruznica[brojac_k];
					brojac_k++;
					if (obuhvata(k1,KRUZNICA,k,KRUZNICA) &amp;&amp; j!=i)
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==4) {
					tr=&amp;niz_trouglova[brojac_tr];
					brojac_tr++;
					if (obuhvata(k1,KRUZNICA,tr,TROUGAO))
						printf ("Oblik %d obuhvata oblike %d.\n",i+1,j+1);

				}
			}
		} else if (niz[i]==3) {
			p1=&amp;niz_pravougaonika[brojac_p1];
			brojac_p1++;
			for (j=0; j&lt;broj_oblika; j++) {
				if (niz[j]==1) {
					t=&amp;tacke[brojac_t];
					brojac_t++;
					if (obuhvata(p1,PRAVOUGAONIK,t,TACKA))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==2) {
					k=&amp;niz_kruznica[brojac_k];
					brojac_k++;
					if (obuhvata(p1,PRAVOUGAONIK,k,KRUZNICA))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==3) {
					p=&amp;niz_pravougaonika[brojac_p];
					brojac_p++;
					if (obuhvata(p1,PRAVOUGAONIK,p,PRAVOUGAONIK) &amp;&amp; j!=i)
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==4) {
					tr=&amp;niz_trouglova[brojac_tr];
					brojac_tr++;
					if (obuhvata(p1,PRAVOUGAONIK,tr,TROUGAO))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				}
			}
		} else if (niz[i]==4) {
			tr1=&amp;niz_trouglova[brojac_tr1];
			brojac_tr1++;
			for (j=0; j&lt;broj_oblika; j++) {
				if (niz[j]==1) {
					t=&amp;tacke[brojac_t];
					brojac_t++;
					if (obuhvata(tr1,TROUGAO,t,TACKA))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==2) {
					k=&amp;niz_kruznica[brojac_k];
					brojac_k++;
					if (obuhvata(tr1,TROUGAO,k,KRUZNICA))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==3) {
					p=&amp;niz_pravougaonika[brojac_p];
					brojac_p++;
					if (obuhvata(tr1,TROUGAO,p,PRAVOUGAONIK))
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				} else if (niz[j]==4) {
					tr=&amp;niz_trouglova[brojac_tr];
					brojac_tr++;
					if (obuhvata(tr1,TROUGAO,tr,TROUGAO) &amp;&amp; j!=i)
						printf ("Oblik %d obuhvata oblik %d.\n",i+1,j+1);
				}
			}
		}
		brojac_tr=0;
		brojac_p=0;
		brojac_k=0;
		brojac_t=0;
	}
	return 0;
}
</pre>
</body>
</html>
