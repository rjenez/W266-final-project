<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student1202.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z2/student6748.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define eps 0.001

/* operator -&gt; ima istu funkciju kao dereferenciranje tj * na pok pa onda pristup sa operatorom ., dakle -&gt; mijenja *. */
/*PROVJERITI NAKON AT OVO &lt;= i eps*/

struct Tacka {
<a name="1"></a><font color="#00FF00"><a href="match948-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	float x, y;
};

struct Kruznica {
	struct Tacka centar;
	float poluprecnik;
};

struct Pravougaonik {
	struct Tacka dole_lijevo;
	float sirina, visina;
};

struct Trougao {
	struct Tacka vrh1, vrh2, vrh3;
</font>};

enum TipOblika { TACKA, KRUZNICA, PRAVOUGAONIK, TROUGAO };

int tacka_u_trouglu(struct Trougao tr, struct Tacka tk)
{
	/*koristi se metod zasnovan na baricentričnim koordinatama*/
	double a, b, A;

	a = tr.vrh1.y * tr.vrh3.x - tr.vrh1.x * tr.vrh3.y + (tr.vrh3.y - tr.vrh1.y) * tk.x + (tr.vrh1.x - tr.vrh3.x) * tk.y;
	b = tr.vrh1.x * tr.vrh2.y - tr.vrh1.y * tr.vrh2.x + (tr.vrh1.y - tr.vrh2.y) * tk.x + (tr.vrh2.x - tr.vrh1.x) * tk.y;


	if ((a &lt; 0) != (b &lt; 0))         /*ili a &lt; 0 &amp;&amp; b &gt;= 0 || a &gt;= 0 &amp;&amp; b &lt; */
		return 0;

	A = -1 * tr.vrh2.y * tr.vrh3.x + tr.vrh1.y * (tr.vrh3.x - tr.vrh2.x) + tr.vrh1.x * (tr.vrh2.y - tr.vrh3.y) + tr.vrh2.x * tr.vrh3.y;

	if (A &lt; 0.0) {
		a = -a;
		b = -b;
		A = - A;
	}

	return (a &gt; 0 || fabs(a - eps) &gt; 0)  &amp;&amp; (b &gt; 0 || fabs(b - eps) &gt; 0) &amp;&amp; (a + b &lt; A || fabs(a + b - A) &lt; eps);
}

int obuhvata(void *oblik1, enum TipOblika to1, void *oblik2, enum TipOblika to2)
{
	float d1, d2, d3, d4;
	struct Tacka *tk1, *tk2;
	struct Kruznica *k1, *k2;
	struct Pravougaonik *p1, *p2;
	struct Trougao *tr1, *tr2;
	int uslov1, uslov2, uslov3, uslov4;
	/*OVO JE DODANO ZBOG PRILAGODJAVANJA ZADATKA STRUKTURI, PRVOBITNO SAM RADILA STRUKTURU KAO NA TUTORIJALU(CUVALA DVIJE TACKE)*/
	struct Tacka gore_desno;


	if (to1 == TACKA &amp;&amp; to2 == TACKA) {
		/*pretvaranje u tacku tj u pkazivac na tacku*/
		tk1 = (struct Tacka*) oblik1;
		/*slucajevi 1. tacka-tacka, 2. tacka-kruznica, 3. tacka-pravougaonik, 4. tacka-trougao*/
		/*ovdje se samo moze porediti tacka sa tackom, ne moze nikako tacka obuhvatiti pravougaonik(osim ako ne bude da su obje tacke u pravougaoniku iste?)*/
		tk2 = (struct Tacka*) oblik2;
		if (fabs(tk1-&gt;x - tk2-&gt;x) &lt; eps &amp;&amp; fabs(tk1-&gt;y - tk2-&gt;y) &lt; eps)
			return 1;
	} else if (to1 == KRUZNICA) {
		k1 = (struct Kruznica*) oblik1;
		/*kruznica-slucajevi: 1. kruznica-tacka, 2. kruznica - kruznica, 3. kruznica-pravougaonik, 4. kruznica-trougao*/
		if (to2 == TACKA) {
			tk2 = (struct Tacka*) oblik2;
			/*udaljenost tacke kao oblika 2 od centra kruznice manja je od poluprecnika kruznice, tada obuhvata*/
			/*asocijativnost za -&gt; i . je left-to-right tj prvo se izvrsava onaj sa lijeve strane*/
			d1 = sqrt((tk2-&gt;x - k1-&gt;centar.x) * (tk2-&gt;x - k1-&gt;centar.x) + (tk2-&gt;y - k1-&gt;centar.y) * (tk2-&gt;y - k1-&gt;centar.y));
			if (d1 &lt; k1-&gt;poluprecnik || fabs(d1 - k1-&gt;poluprecnik) &lt; eps)
				return 1;
		} else if (to2 == KRUZNICA) {
			/*nadjemo provjerimo da li je poluprecnik velike kruznice veci od d + r2 gdje je d udaljenost izmedju 2 centra*/
			k2 = (struct Kruznica*) oblik2;
			d1 = sqrt((k2-&gt;centar.x - k1-&gt;centar.x) * (k2-&gt;centar.x - k1-&gt;centar.x) + (k2-&gt;centar.y - k1-&gt;centar.y) * (k2-&gt;centar.y - k1-&gt;centar.y));
			/*ako je k1 manja kruznica, nema sanse da k2 bude unutar nje pa zato imamo prvi dio uslova*/
			if ((k1-&gt;poluprecnik &gt; k2-&gt;poluprecnik || fabs(k1-&gt;poluprecnik - k2-&gt;poluprecnik) &lt; eps) &amp;&amp;
			        k1-&gt;poluprecnik &gt; d1 + k2-&gt;poluprecnik || fabs(k1-&gt;poluprecnik - (d1 + k2-&gt;poluprecnik)) &lt; eps)
				return 1;
		} else if (to2 == PRAVOUGAONIK) {
			/*ako su obje(kao i one pored njih) tacke kojima je definisan pravougaonik unutar kruznice*/
			p2 = (struct Pravougaonik*) oblik2;
			/*d1 je distanca izmedju centra i prve tacke, a d2 izmedju centra i druge tacke*/
			/*-----------------------provjeriti kako se zovu tacke u pravougaoniku za onu strukturu definisanu na serveru kako pise u zadatku-----------------------------*/
			/*OVO JE DODANO ZBOG PRILAGODJAVANJA ZADATKA STRUKTURI, PRVOBITNO SAM RADILA STRUKTURU KAO NA TUTORIJALU(CUVALA DVIJE TACKE)*/
			gore_desno = (struct Tacka) {
				p2-&gt;dole_lijevo.x + p2-&gt;sirina, p2-&gt;dole_lijevo.y + p2-&gt;visina
			};

			d1 = sqrt((k1-&gt;centar.x - p2-&gt;dole_lijevo.x) * (k1-&gt;centar.x - p2-&gt;dole_lijevo.x) + (k1-&gt;centar.y - p2-&gt;dole_lijevo.y) * (k1-&gt;centar.y - p2-&gt;dole_lijevo.y));
			d2 = sqrt((k1-&gt;centar.x - gore_desno.x) * (k1-&gt;centar.x - gore_desno.x) + (k1-&gt;centar.y - gore_desno.y) * (k1-&gt;centar.y - gore_desno.y));
			/*za tacku gore lijevo*/
			d3 = sqrt((k1-&gt;centar.x - p2-&gt;dole_lijevo.x) * (k1-&gt;centar.x - p2-&gt;dole_lijevo.x) + (k1-&gt;centar.y - gore_desno.x) * (k1-&gt;centar.y - gore_desno.x));
			d4 = sqrt((k1-&gt;centar.x - gore_desno.x) * (k1-&gt;centar.x - gore_desno.x) + (k1-&gt;centar.y - p2-&gt;dole_lijevo.y) * (k1-&gt;centar.y - p2-&gt;dole_lijevo.y));

			if ((k1-&gt;poluprecnik &gt; d1 || fabs(k1-&gt;poluprecnik - d1) &lt; eps) &amp;&amp;
			        (k1-&gt;poluprecnik &gt; d2 || fabs(k1-&gt;poluprecnik - d2) &lt; eps) &amp;&amp;
			        (k1-&gt;poluprecnik &gt; d3 || fabs(k1-&gt;poluprecnik - d3) &lt; eps) &amp;&amp;
			        (k1-&gt;poluprecnik &gt; d4 || fabs(k1-&gt;poluprecnik - d4) &lt; eps))
				return 1;

		} else if (to2 == TROUGAO) {
			/*ako su sve tri tacke trougla u kruznici*/
			tr2 = (struct Trougao*) oblik2;
			d1 = sqrt((k1-&gt;centar.x - tr2-&gt;vrh1.x) * (k1-&gt;centar.x - tr2-&gt;vrh1.x) + (k1-&gt;centar.y - tr2-&gt;vrh1.y) * (k1-&gt;centar.y - tr2-&gt;vrh1.y));
			d2 = sqrt((k1-&gt;centar.x - tr2-&gt;vrh2.x) * (k1-&gt;centar.x - tr2-&gt;vrh2.x) + (k1-&gt;centar.y - tr2-&gt;vrh2.y) * (k1-&gt;centar.y - tr2-&gt;vrh2.y));
			d3 = sqrt((k1-&gt;centar.x - tr2-&gt;vrh3.x) * (k1-&gt;centar.x - tr2-&gt;vrh3.x) + (k1-&gt;centar.y - tr2-&gt;vrh3.y) * (k1-&gt;centar.y - tr2-&gt;vrh3.y));

			if ((k1-&gt;poluprecnik &gt; d1 || fabs(k1-&gt;poluprecnik - d1) &lt; eps) &amp;&amp;
			        (k1-&gt;poluprecnik &gt; d2 || fabs(k1-&gt;poluprecnik - d2) &lt; eps) &amp;&amp;
			        (k1-&gt;poluprecnik &gt; d3 || fabs(k1-&gt;poluprecnik - d3) &lt; eps))
				return 1;
		}
	} else if (to1 == PRAVOUGAONIK) {
		p1 = (struct Pravougaonik*) oblik1;
		gore_desno = (struct Tacka) {
			p1-&gt;dole_lijevo.x + p1-&gt;sirina, p1-&gt;dole_lijevo.y + p1-&gt;visina
		};

		if (to2 == TACKA) {
			tk2 = (struct Tacka*) oblik2;

			uslov1 = (gore_desno.x &gt; tk2-&gt;x || fabs(gore_desno.x - tk2-&gt;x) &lt; eps) &amp;&amp; (gore_desno.y &gt; tk2-&gt;y || fabs(gore_desno.y - tk2-&gt;y) &lt; eps)
			         &amp;&amp; (p1-&gt;dole_lijevo.x &lt; tk2-&gt;x || fabs(p1-&gt;dole_lijevo.x - tk2-&gt;x) &lt; eps) &amp;&amp; (p1-&gt;dole_lijevo.y &lt; tk2-&gt;y || fabs(p1-&gt;dole_lijevo.y - tk2-&gt;y) &lt; eps);

			if (uslov1)
				return 1;
		} else if (to2 == KRUZNICA) {
			k2 = (struct Kruznica*) oblik2;
			/*provjeravamo centar kruznice plus poluprecnik u pravcu x i pravcu y*/
			d1 = k2-&gt;centar.x + k2-&gt;poluprecnik; /*ovo je po x osi*/
			d2 = k2-&gt;centar.x - k2-&gt;poluprecnik;
			d3 = k2-&gt;centar.y + k2-&gt;poluprecnik; /*po y osi*/
			d4 = k2-&gt;centar.y - k2-&gt;poluprecnik;
			if ((gore_desno.x &gt; d1 || fabs(gore_desno.x - d1) &lt; eps) &amp;&amp; (gore_desno.y &gt; d3 || fabs(gore_desno.y - d3) &lt; eps) &amp;&amp;
			        (p1-&gt;dole_lijevo.x &lt; d2 || fabs(p1-&gt;dole_lijevo.x - d2) &lt; eps) &amp;&amp; (p1-&gt;dole_lijevo.y &lt; d4 || fabs(p1-&gt;dole_lijevo.y - d4) &lt; eps))
				return 1;

		} else if (to2 == PRAVOUGAONIK) {
			p2 = (struct Pravougaonik*) oblik2;
			/*ako su obje tacke kojima je definisan pravougaonik 2 u pravougaoniku 1*/
			/*tacka gore desno iz p2*/
			/*DODANO ZBOG RAZLICITIH STRUKTURA KAO STO JE RANIJE NAPOMENUTO*/
			struct Tacka gd_p2 = { p2-&gt;dole_lijevo.x + p2-&gt;sirina, p2-&gt;dole_lijevo.y + p2-&gt; visina };

			uslov1 = (gore_desno.x &gt; gd_p2.x || fabs(gore_desno.x - gd_p2.x) &lt; eps) &amp;&amp;
			         (gore_desno.y &gt; gd_p2.y || fabs(gore_desno.y - gd_p2.y) &lt; eps) &amp;&amp;
			         (p1-&gt;dole_lijevo.x &lt; p2-&gt;dole_lijevo.x || fabs(p1-&gt;dole_lijevo.x - p2-&gt;dole_lijevo.x) &lt; eps) &amp;&amp;
			         (p1-&gt;dole_lijevo.y &lt; p2-&gt;dole_lijevo.y || fabs(p1-&gt;dole_lijevo.y - p2-&gt;dole_lijevo.y) &lt; eps);
			if (uslov1)
				return 1;
		} else if (to2 == TROUGAO) {
			tr2 = (struct Trougao*) oblik2;
			/*sve tri tacke pravougaonika u trouglu*/
			/*vrh1*/
			uslov1 = (tr2-&gt;vrh1.x &lt; gore_desno.x || fabs(tr2-&gt;vrh1.x - gore_desno.x) &lt; eps) &amp;&amp; (tr2-&gt;vrh1.y &lt; gore_desno.y ||
			         fabs(tr2-&gt;vrh1.y - gore_desno.y)) &amp;&amp; (tr2-&gt;vrh1.x &gt; p1-&gt;dole_lijevo.x || fabs(tr2-&gt;vrh1.x - p1-&gt;dole_lijevo.x) &lt; eps)
			         &amp;&amp; (tr2-&gt;vrh1.y &gt; p1-&gt;dole_lijevo.y || fabs(tr2-&gt;vrh1.y - p1-&gt;dole_lijevo.y));
			/*vrh2*/
			uslov2 = (tr2-&gt;vrh2.x &lt; gore_desno.x || fabs(tr2-&gt;vrh2.x - gore_desno.x) &lt; eps) &amp;&amp; (tr2-&gt;vrh2.y &lt; gore_desno.y ||
			         fabs(tr2-&gt;vrh2.y - gore_desno.y)) &amp;&amp; (tr2-&gt;vrh2.x &gt; p1-&gt;dole_lijevo.x || fabs(tr2-&gt;vrh2.x - p1-&gt;dole_lijevo.x) &lt; eps)
			         &amp;&amp; (tr2-&gt;vrh2.y &gt; p1-&gt;dole_lijevo.y || fabs(tr2-&gt;vrh2.y - p1-&gt;dole_lijevo.y));
			/*vrh3*/
			uslov3 = (tr2-&gt;vrh3.x &lt; gore_desno.x || fabs(tr2-&gt;vrh3.x - gore_desno.x) &lt; eps) &amp;&amp; (tr2-&gt;vrh3.y &lt; gore_desno.y ||
			         fabs(tr2-&gt;vrh3.y - gore_desno.y)) &amp;&amp; (tr2-&gt;vrh3.x &gt; p1-&gt;dole_lijevo.x || fabs(tr2-&gt;vrh3.x - p1-&gt;dole_lijevo.x) &lt; eps)
			         &amp;&amp; (tr2-&gt;vrh3.y &gt; p1-&gt;dole_lijevo.y || fabs(tr2-&gt;vrh3.y - p1-&gt;dole_lijevo.y));

			if (uslov1 &amp;&amp; uslov2 &amp;&amp; uslov3)
				return 1;
		}
	} else if (to1 == TROUGAO) {
		tr1 = (struct Trougao*) oblik1;

		if (to2 == TACKA) {
			tk2 = (struct Tacka*) oblik2;
			if (tacka_u_trouglu(*tr1, *tk2)) /*šaljemo vrijednost a ne adresu*/
				return 1;
		} else if (to2 == KRUZNICA) {
			k2 = (struct Kruznica*) oblik2;
			/*nije implementirano*/
			return 0;
		} else if (to2 == PRAVOUGAONIK) {
			/*Ako su sve tacke pravougaonika u trouglu*/
			p2 = (struct Pravougaonik*) oblik2;
			/*DODANO ZBOG RAZLICITIH STRUKTURA KAO STO JE RANIJE NAPOMENUTO*/
			struct Tacka gd_p2 = { p2-&gt;dole_lijevo.x + p2-&gt;sirina, p2-&gt;dole_lijevo.y + p2-&gt; visina };

			uslov1 = tacka_u_trouglu(*tr1, gd_p2);
			uslov2 = tacka_u_trouglu(*tr1, p2-&gt;dole_lijevo);

			struct Tacka dole_desno =  { p2-&gt;dole_lijevo.x, gd_p2.y };
			struct Tacka gore_lijevo = { gd_p2.x, p2-&gt;dole_lijevo.y };
			uslov3 = tacka_u_trouglu(*tr1, gore_lijevo);
			uslov4 = tacka_u_trouglu(*tr1, dole_desno);

			if (uslov1 &amp;&amp; uslov2 &amp;&amp; uslov3 &amp;&amp; uslov4)
				return 1;
		} else if (to2 == TROUGAO) {
			tr2 = (struct Trougao*) oblik2;
			/*ako su sve tacke trougla 2 u trouglu 1*/
			uslov1 = tacka_u_trouglu(*tr1, tr2-&gt;vrh1);
			uslov2 = tacka_u_trouglu(*tr1, tr2-&gt;vrh2);
			uslov3 = tacka_u_trouglu(*tr1, tr2-&gt;vrh3);

			if (uslov1 &amp;&amp; uslov2 &amp;&amp; uslov3)
				return 1;
		}
	}

	return 0;
}

int main()
{
	void *oblici[50];
	enum TipOblika tipovi[50];
	int i, j, br_oblika, tip;
	float sirina, visina;

	struct Tacka tacke[50];
	struct Kruznica kruznice[50];
	struct Pravougaonik pravougaonici[50];
	struct Trougao trouglovi[50];
	int br_tk = 0, br_k = 0, br_p = 0, br_tr = 0;


	printf("Unesite broj oblika: ");
	scanf("%d", &amp;br_oblika);

	for (i = 0; i &lt; br_oblika; i++) {
		printf("Odaberite tip %d. oblika (1 - tacka, 2 - kruznica, 3 - pravougaonik, 4 - trougao): ", i + 1);
		scanf("%d", &amp;tip);

		if (tip == 1) {
			/*unos tacke*/
			printf("Unesite tacku: koordinate x,y: ");
			scanf("%f,%f", &amp;tacke[br_tk].x, &amp;tacke[br_tk].y);
			oblici[i] = &amp;tacke[br_tk];
			tipovi[i] = TACKA;

			br_tk++;
		} else if (tip == 2) {
			/*unos kruznice*/
			printf("Unesite centar kruznice: koordinate x,y: ");
			scanf("%f,%f", &amp;kruznice[br_k].centar.x, &amp;kruznice[br_k].centar.y);
			printf("Unesite poluprecnik kruznice: ");
			scanf("%f", &amp;kruznice[br_k].poluprecnik);
			oblici[i] = &amp;kruznice[br_k];
			tipovi[i] = KRUZNICA;

			br_k++;
		} else if (tip == 3) {
			/*pravougaonik*/
			printf("Unesite donji lijevi ugao: koordinate x,y: ");
			scanf("%f,%f", &amp;pravougaonici[br_p].dole_lijevo.x, &amp;pravougaonici[br_p].dole_lijevo.y);
			printf("Unesite sirinu: ");
			scanf("%f", &amp;pravougaonici[br_p].sirina);
			printf("Unesite visinu: ");
			scanf("%f", &amp;pravougaonici[br_p].visina);

			oblici[i] = &amp;pravougaonici[br_p];
			tipovi[i] = PRAVOUGAONIK;

			br_p++;
		} else if (tip == 4) {
			/*trougao*/
			printf("Unesite prvi vrh: koordinate x,y: ");
			scanf("%f,%f", &amp;trouglovi[br_tr].vrh1.x, &amp;trouglovi[br_tr].vrh1.y);
			printf("Unesite drugi vrh: koordinate x,y: ");
			scanf("%f,%f", &amp;trouglovi[br_tr].vrh2.x, &amp;trouglovi[br_tr].vrh2.y);
			printf("Unesite treci vrh: koordinate x,y: ");
			scanf("%f,%f", &amp;trouglovi[br_tr].vrh3.x, &amp;trouglovi[br_tr].vrh3.y);

			oblici[i] = &amp;trouglovi[br_tr];
			tipovi[i] = TROUGAO;

			br_tr++;
		} else {
			/*pogresan tip*/
			printf("Nepoznat tip oblika %d!\n", tip);
			i--; /*i++ na kraju petlje nas vrati na isto*/
		}

	}

<a name="0"></a><font color="#FF0000"><a href="match948-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	for (i = 0; i &lt; br_oblika; i++) {
		for (j = 0; j &lt; br_oblika; j++) {
			if (i != j &amp;&amp; obuhvata(oblici[i], tipovi[i], oblici[j], tipovi[j]))
				printf("\nOblik %d obuhvata oblik %d.", i+1, j+1);
</font>		}
	}

	return 0;
}
</pre>
</body>
</html>
