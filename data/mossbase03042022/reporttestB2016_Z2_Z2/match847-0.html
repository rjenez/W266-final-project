<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z2/student2922.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z2/student2922.cpp<p></p><pre>
// B 16/17, ZadaÄ‡a 2, Zadatak 2
//	Autotestovi by Enil Pajic (epajic1@etf.unsa.ba | @eon : etf.ba)
//	NAPOMENA: i javni ATo-vi su dio postavke!	
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;deque&gt;
#include&lt;stdexcept&gt;
#include&lt;type_traits&gt;
#include&lt;iomanip&gt;
<a name="0"></a><font color="#FF0000"><a href="match847-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

using namespace std;

enum class SmjerKretanja{
    NaprijedNazad, NazadNaprijed, GoreDolje, DoljeGore, LijevoDesno, DesnoLijevo
};

    //GENERICKA FUNKCIJA KOJA IZVLACI RAVAN BROJEVA IZ KONTEJNERA kont 
    //NJOJ PROSLIJEDITI GRANICE PO KOJIM CE VRTITI FOR PETLJE
    //IDEJA JE DA RADI NA OSNOVU TIH GRANICA KOJE OVISE O SMJERU KRETANJA

template &lt;typename Kontejner&gt; auto IzvuciRavan (Kontejner kont, SmjerKretanja smjer)
-&gt; typename remove_reference&lt;decltype(kont.at(0))&gt;::type {
</font>    typedef typename remove_reference&lt;decltype(kont.at(0))&gt;::type Potkontejner;
    typedef typename remove_reference&lt;decltype(kont.at(0).at(0))&gt;::type PotPotkontejner;
    //Pocetne skraceno napisane vrijednosti maximuma proslijedjenog kontejnera
    int kPoc(kont.size()), iPoc(kont.at(0).size()), jPoc(kont.at(0).at(0).size());
    Potkontejner ploha;
    //SAD DEFAULT VRIJEDNOSTI NA KOJE CE SE VRACATI kPoc, jPoc i iPoc
   
 
    for (int k{0}; kPoc != k; k++){
        //Formiranje pomocnog potpotkontejnera koji ce zapravo biti nekakav 1D niz neceg
        PotPotkontejner red_plohe;
        for(int i{0} ; iPoc != i; i++ ){
            for( int j{0}; jPoc != j; j++   ){
                //SAD SE PUNJENJE GRANA PO TOME DA LI TRAZIMO GLAVNU ILI SPOR DIJAG
                //TJ DA LI NAS kont KVADAR GLEDAMO SPRIJEDA ILI SAZADA
                //USLOVI ZA ELEMENTE DOBIVENI PREKO JEDNACINA RAVNI U 3D PROSTORU
                if((int)smjer==0 &amp;&amp; i==j){
                    red_plohe.push_back(kont.at(k).at(i).at(j));
                } else if ((int)smjer==1 &amp;&amp; i+j+1==jPoc){
                    red_plohe.push_back(kont.at(k).at(i).at(j));
                } else if ((int)smjer==2 &amp;&amp; k+j+1==kPoc){
                    red_plohe.push_back(kont.at(k).at(i).at(j));
                } else if ((int)smjer==3 &amp;&amp; 2*j==jPoc+2*k){
                    red_plohe.push_back(kont.at(k).at(i).at(j));
                } else if ((int)smjer==4 &amp;&amp; k+i+1==kPoc){
                    red_plohe.push_back(kont.at(k).at(i).at(j));
                } else if ((int)smjer==5 &amp;&amp; k==i){
                    red_plohe.push_back(kont.at(k).at(i).at(j));
                }
                
            }
            
           
        }
        //SAD RED FORMIRAN KRETANJEM KROZ i-j RAVAN PUSH BACKAMO U PLOHU
         ploha.push_back(red_plohe);
        
    }
    return ploha;
}

template &lt;typename Kontejner&gt;
//Vraca reverz po kolonama proslijedjene joj 2d matrice 
auto ReverzMatrica(Kontejner matrica) -&gt; typename remove_reference&lt;decltype(matrica)&gt;::type{
   typedef typename remove_reference&lt;decltype(matrica)&gt;::type Matrica;
    Matrica pomocna{matrica};
    int horizontalna{ pomocna.at(0).size()};

    for(int i{0}; i&lt;matrica.size(); i++) for(int j{0}; j&lt;horizontalna; j++) pomocna.at(i).at(j)=matrica.at(i).at(matrica.at(0).size()-1-j);
    return pomocna;
}

template &lt;typename Kontejner&gt;
auto TransponovanaMatrica(Kontejner matrica)-&gt; typename remove_reference&lt;decltype(matrica)&gt;::type{
    typedef typename remove_reference&lt;decltype(matrica)&gt;::type Matrica;
    typedef typename remove_reference&lt;decltype(matrica.at(0))&gt;::type red;
    Matrica t(matrica.at(0).size(), red(matrica.size()));
    int horizontalna{ t.at(0).size() }, vertikanla { t.size() };
    for(int i{vertikanla-1}; i&gt;=0; i--) for (int j{horizontalna-1}; j&gt;=0; j--) t.at(i).at(j)=matrica.at(j).at(i);
    return ReverzMatrica(t);
}

template &lt;typename Kontejner&gt;
//Vraca reverznu matricu po redovima
auto InverzMatrica(Kontejner matrica)-&gt; typename remove_reference&lt;decltype(matrica)&gt;::type{
    typedef typename remove_reference&lt;decltype(matrica)&gt;::type Matrica;
    Matrica pomocna{matrica};
    int vertiklana{ pomocna.size() };
    for(int i{0}; i&lt;vertiklana; i++){
        for(int j{0}; j&lt;matrica.at(0).size(); j++) pomocna.at(i).at(j)=matrica.at(matrica.size()-1-i).at(j);
    }
    return pomocna;
}

template&lt;typename TriDKontejner&gt; auto IzdvojiDijagonale3D( TriDKontejner kont, SmjerKretanja smjer )
-&gt; typename remove_reference&lt;decltype(kont.at(0))&gt;::type {
    typedef typename remove_reference&lt;decltype(kont.at(0))&gt;::type Potkontejner;
    typedef typename remove_reference&lt;decltype(kont.at(0).at(0))&gt;::type PotPotkontejner;
    
    Potkontejner ploha;
    
    //k JE INDEKS ZA PLOHE (NIVO 1)
    //i JE INDEKS ZA REDOVE UNUTAR PLOHA (NIVO 2)
    //j JE INDEKS ZA KOLONE UNUTAR REDOVA UNUTAR PLOHA (NIVO 3)
    //Za brojeve redova unutar ploha
    for(int k{0}; k&lt;kont.size(); k++ ) if (kont.at(k).size()!=kont.at(0).size()) throw domain_error("Plohe nemaju isti broj redova");
    //Za brojeve elemenata u pojedinacnim redovima pojedinacnih ploha
    for( int k{0}; k&lt;kont.size(); k++ ) 
<a name="2"></a><font color="#0000FF"><a href="match847-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

        for ( int i{0}; i&lt;kont.at(0).size(); i++ ) 
            if(kont.at(0).at(0).size() != kont.at(k).at(i).size()) 
                throw domain_error("Redovi nemaju isti broj elemenata");
</font>    
    //FUNKCIJI IzvuciRavan PROSLIJEDJUJEMO KONTEJNER I DONJU I GORNJU GRANICU INDEKSA
    //PO KOJOJ CE DA VRATI PLOHU BROJEVA, NO PAZIMO I NA TO DA LI SE RADI O GLAVNOJ ILI SPOREDNOJ
    ploha=IzvuciRavan(kont,smjer);
    if((int)smjer==2 || (int)smjer==3 || (int)smjer==4 || (int)smjer==5){
        ploha=TransponovanaMatrica(ploha);
        if((int)smjer==3) ploha=InverzMatrica(ReverzMatrica(ploha));
    if((int)smjer==5 ) ploha=InverzMatrica(ploha);
    
    }
    if((int)smjer==1){
        Potkontejner pomocna{ploha};
        int vertikalna { pomocna.size() };
        for(int i{0}; i&lt;vertikalna; i++){
            for(int j{0}; j&lt;pomocna.at(0).size(); j++){
                pomocna.at(i).at(j)=ploha.at( ploha.size()-1-i ).at(j);
            }
        }
        return pomocna;
    } 
    if((int)smjer==3 || (int)smjer == 5){
        Potkontejner pomocna{ploha};
        for(int i{0}; i&lt;pomocna.size(); i++){
            for(int j{0}; j&lt;pomocna.at(0).size(); j++){
                pomocna.at(i).at(j)=ploha.at(i).at( ploha.at(0).size()-1-j );
            } 
        }
        return pomocna;
    }
    
    return ploha;
}


int main (){
    cout &lt;&lt;"Unesite dimenzije (x y z): ";
    int x,y,z;
<a name="3"></a><font color="#00FFFF"><a href="match847-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
    if(x&lt;0 || y&lt;0 || z&lt;0){
        cout&lt;&lt;"Neispravne dimenzije kontejnera!";
        return 0;
</font>    }
<a name="1"></a><font color="#00FF00"><a href="match847-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    vector&lt;deque&lt;deque&lt;int&gt;&gt;&gt; kvadar(x,deque&lt;deque&lt;int&gt;&gt;(y, deque&lt;int&gt;(z)));
    
    
    cout&lt;&lt;"Unesite elemente kontejnera: ";
</font>    for(int k{0}; k&lt;x; k++){
        
        for(int i{0}; i&lt;y; i++){
            
<a name="4"></a><font color="#FF00FF"><a href="match847-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

            for(int j{0}; j&lt;z; j++){
                int broj;
                cin&gt;&gt;broj;
                kvadar.at(k).at(i).at(j)=broj;
            }
            
        }
        
    }
    cout &lt;&lt;endl&lt;&lt; "Unesite smjer kretanja [0 - 5]: ";
</font>    SmjerKretanja smjer;
    int broj_smjera_u_enum;
    cin&gt;&gt;broj_smjera_u_enum;
    smjer = SmjerKretanja(broj_smjera_u_enum);
    if(broj_smjera_u_enum&lt;0 ||broj_smjera_u_enum&gt;5){
        cout&lt;&lt;"Smjer kretanja nije ispravan!"&lt;&lt;endl;
        return 0;
    }
    //Sad formiramo plohu u mainu pozivom funkcije
    try{
    deque&lt;deque&lt;int&gt;&gt; plohaMain { IzdvojiDijagonale3D(kvadar, smjer) };
    switch((int)smjer){
        case 0:cout&lt;&lt;"NaprijedNazad: "; break;
        case 1:cout&lt;&lt;"NazadNaprijed: "; break;
        case 2:cout&lt;&lt;"GoreDolje: "; break;
        case 3:cout&lt;&lt;"DoljeGore: "; break;
        case 4:cout&lt;&lt;"LijevoDesno: "; break;
        case 5:cout&lt;&lt;"DesnoLijevo: "; break;
    }
        cout&lt;&lt;endl;
        for(auto red : plohaMain){
	    for(auto x : red) {
	         cout&lt;&lt;setw(4)&lt;&lt;x;
	    }
	    cout&lt;&lt;endl;
	    }
    }catch(domain_error e){
        cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
        return 0;
    }
	
	return 0;
}</pre>
</body>
</html>
