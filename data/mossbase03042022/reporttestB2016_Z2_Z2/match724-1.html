<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z2/student7001.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z2/student6999.cpp<p></p><pre>
// B 16/17, Zadaća 2, Zadatak 2
//	Autotestovi by Enil Pajic (epajic1@etf.unsa.ba | @eon : etf.ba)
//	NAPOMENA: i javni ATo-vi su dio postavke
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
enum class SmjerKretanja {NaprijedNazad=0, NazadNaprijed=1, GoreDolje=2, DoljeGore=3, LijevoDesno=4, DesnoLijevo=5};
//definisanje smjera kretanja

<a name="0"></a><font color="#FF0000"><a href="match724-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

template &lt;typename lopata&gt;
auto IzdvojiDijagonale3D(lopata D, SmjerKretanja smjer) -&gt; typename std::remove_reference&lt;decltype(D.at(0))&gt;::type {
    typename std::remove_reference&lt;decltype(D.at(0))&gt;::type izlaz(D.size()); //napravljen izlaz
</font>    switch(smjer){
        // NIJE PODRŽANO INDEKSIRANJE, KORISTITI .at(); !!!
        case SmjerKretanja::NaprijedNazad:{
            //glavna dijagonala D[0] u prvu vrstu izlaza, glavnu od D[1] u drugu... itd...;
            izlaz.resize(D.size()); //treba onoliko vrsta izlaza koliko ima matrica ulaza.
            for(int i=0;i&lt;D.size();i++){
                //ide po matricama.
                for(int j=0;j&lt;D.at(i).size();j++){
                    //ide po vrstama matrica.
                    for(int k=0;k&lt;D.at(i).at(j).size();k++){
                        //ide po kolonama matrica.
                        if(j==k) izlaz.at(i).push_back(D.at(i).at(j).at(k));
                        //šutaj glavnu dijagonalu i-te matrice u i-ti red izlaza.
                    }
                }
            }
          break;  
        }
        case SmjerKretanja::NazadNaprijed:{
        //sporedna dijagonala D[0] u prvu vrstu izlaza, sporednu od D[1] u drugu... itd...;
            izlaz.resize(D.size()); //treba onoliko vrsta izlaza koliko ima matrica ulaza.
            for(int i=0;i&lt;D.size();i++){
                //ide po matricama.
                for(int j=0;j&lt;D.at(i).size();j++){
                    //ide po vrstama matrica.
                    for(int k=D.at(i).at(j).size()-1;k&gt;=0;k--){
                        //ide po kolonama matrica.
                        if(k+j == D.at(i).at(j).size()-1) izlaz.at(i).push_back(D.at(i).at(j).at(k));
                        //šutaj glavnu dijagonalu i-te matrice u i-ti red izlaza.
                    }
                }
            }typename std::remove_reference&lt;decltype(D.at(0))&gt;::type izlaz1(D.size());
            int k=0;
            for(int i=izlaz.size()-1;i&gt;=0;i--){
                izlaz1.at(k++)=izlaz.at(i);
            }
            for(int i=0;i&lt;izlaz.size();i++){
                izlaz.at(i)=izlaz1.at(i);
            }
          break;    
        }
        case SmjerKretanja::DesnoLijevo:{
            int velicina = D.at(0).at(0).size()-1;// velicina prve vrste (-1 prvi legalan index)
            for(int i=0;i&lt;D.at(0).at(0).size();i++){ // ide po prvoj vrsti 
            izlaz.resize(izlaz.size()+1);
                for(int j=0;j&lt;D.size();j++){ 
                    int k=0;// ide po broju matrica
                    izlaz.at(i).push_back(D.at(j).at(j).at(velicina-k));
                    k++;
                }
                velicina--;
            }
          break;    
        }
        case SmjerKretanja::LijevoDesno:{
//          int velicina = D.at(0).at(0).size()-1;// velicina prve vrste (-1 prvi legalan index)
            for(int i=0;i&lt;D.at(0).at(0).size();i++){ // ide po prvoj vrsti 
            izlaz.resize(izlaz.size()+1);
            int k=0;
                for(int j=D.size()-1;j&gt;=0;j--){ 
                    // ide po broju matrica odzada
                    izlaz.at(i).push_back(D.at(j).at(k).at(i));
                 k++;
                }
//                velicina--;
            } 
          break;
        }
        case SmjerKretanja::GoreDolje:{
            for(int i=0;i&lt;D.at(0).size();i++){
                int k=0;
                izlaz.resize(izlaz.size()+1);
                for(int j=D.size()-1;j&gt;=0;j--){
                    izlaz.at(i).push_back(D.at(j).at(i).at(k++));
                }
            }
          break;    
        }
        case SmjerKretanja::DoljeGore:{
           for(int i=D.at(0).size()-1;i&gt;=0;i--){
               izlaz.resize(izlaz.size()+1);
               int k=D.at(0).at(0).size()-1;
               for(int j=D.size()-1;j&gt;=0;j--){
                   izlaz.at(i).push_back(D.at(j).at(i).at(k--));
               }
           }
           
           typename std::remove_reference&lt;decltype(D.at(0))&gt;::type izlaz1(D.size());
            int k=0;
            izlaz1.resize(izlaz.size());
            for(int i=izlaz.size()-1;i&gt;=0;i--){
                izlaz1.at(k++)=izlaz.at(i);
            }
            for(int i=0;i&lt;izlaz.size();i++){
                izlaz.at(i)=izlaz1.at(i);
            }
          break;    
        }
        default : return izlaz;
        ;
        
    }
    return izlaz;    
}
typedef std::deque&lt;std::vector&lt;short int&gt;&gt; matrica;
int main (){
    try{
std::cout&lt;&lt;"Unesite dimenzije (x y z): ";
int x,y,z;
std::cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
if(x&lt;0 || y&lt;0 || z&lt;0) throw std::range_error("Neispravne dimenzije kontejnera!");
std::deque&lt;matrica&gt; kont(x,matrica(y,std::vector&lt;short int&gt;(z)));
std::cout&lt;&lt;"Unesite elemente kontejnera: "&lt;&lt;std::endl;
for(int i=0;i&lt;kont.size();i++){
    for(int j=0;j&lt;kont.at(i).size();j++){
        for(int k=0;k&lt;kont.at(i).at(j).size();k++){
<a name="3"></a><font color="#00FFFF"><a href="match724-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

            std::cin&gt;&gt;kont.at(i).at(j).at(k);
        }
    }
}
std::cout&lt;&lt;"Unesite smjer kretanja [0 - 5]: "; 
int smjer;
std::cin&gt;&gt;smjer;
</font>try{
<a name="1"></a><font color="#00FF00"><a href="match724-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

matrica izlaz = IzdvojiDijagonale3D(kont,(SmjerKretanja)(smjer));
switch(smjer){
    case 0:{std::cout&lt;&lt;"NaprijedNazad: "&lt;&lt;std::endl;break;}
    case 1:{std::cout&lt;&lt;"NazadNaprijed: "&lt;&lt;std::endl;break;}
</font>    case 2:{std::cout&lt;&lt;"GoreDolje: "&lt;&lt;std::endl;break;}
    case 3:{std::cout&lt;&lt;"DoljeGore: "&lt;&lt;std::endl;break;}
<a name="4"></a><font color="#FF00FF"><a href="match724-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

    case 4:{std::cout&lt;&lt;"LijevoDesno: "&lt;&lt;std::endl;break;}
    case 5:{std::cout&lt;&lt;"DesnoLijevo: "&lt;&lt;std::endl;break;}
    default : throw std::domain_error("Smjer kretanja nije ispravan!\n");
</font>}
for(int i=0;i&lt;izlaz.size();i++){
    if(!izlaz.at(i).size()) continue;
    for(int j=0; j&lt;izlaz.at(i).size();j++){
<a name="2"></a><font color="#0000FF"><a href="match724-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

        std::cout&lt;&lt;std::setw(4)&lt;&lt;izlaz.at(i).at(j);
    }
    std::cout&lt;&lt;std::endl;
}
}catch(std::domain_error &amp;ex){std::cout&lt;&lt;ex.what();}}catch(std::range_error &amp;ex){std::cout&lt;&lt;ex.what();}
</font>    return 0;
}</pre>
</body>
</html>
