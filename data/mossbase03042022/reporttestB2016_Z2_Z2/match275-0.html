<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z2/student6776.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z2/student6776.cpp<p></p><pre>
// B 16/17, ZadaÄ‡a 2, Zadatak 2
//	Autotestovi by Enil Pajic (epajic1@etf.unsa.ba | @eon : etf.ba)
//	NAPOMENA: i javni ATo-vi su dio postavke!	

#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;deque&gt;
#include &lt;type_traits&gt;
#include &lt;stdexcept&gt;

typedef std::vector&lt;int&gt; Vektor;
typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;
typedef std::vector&lt;std::vector&lt;std::vector&lt;int&gt;&gt;&gt; Mat3D;

enum class SmjerKretanja{
    NaprijedNazad, NazadNaprijed, GoreDolje, DoljeGore, LijevoDesno, DesnoLijevo
};

Matrica KreirajMatricu(int br_red, int br_kol){
    if(br_red==0 || br_kol==0) return(Matrica(br_red, Vektor(br_kol)));
    return Matrica(br_red, Vektor(br_kol));
}
Mat3D Kreiraj3DMatricu(int br_ploha, int br_red, int br_kol){
    return Mat3D(br_ploha, Matrica(br_red, Vektor(br_kol)));
}
Mat3D UnesiMatricu(int br_ploha, int br_red, int br_kol){
    Mat3D mat=Kreiraj3DMatricu(br_ploha,br_red,br_kol);
    for(int k=0;k&lt;br_ploha;k++){
        for(int j=0;j&lt;br_red;j++){
            for(int i=0;i&lt;br_kol;i++){
                std::cin&gt;&gt;mat[k][j][i];
            }
        }
    }    
    return mat;
}

//Glavna funkcija
template&lt;typename NekiTip&gt;
auto IzdvojiDijagonale3D(NekiTip mat, SmjerKretanja smjer)-&gt; typename std::remove_reference&lt;decltype(mat.at(0))&gt;::type {
    typename std::remove_reference&lt;decltype(mat.at(0))&gt;::type DvoDim;
    int br_ploha=mat.size();
    int br_red=mat[0].size();
    int br_kol=mat[0][0].size();
    if(br_ploha==0 || br_red==0 || br_kol==0){
        return DvoDim;
    }
    for(int k=0;k&lt;br_ploha;k++){
<a name="4"></a><font color="#FF00FF"><a href="match275-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

        for(int i=0;i&lt;br_red;i++){
            for(int j=0;j&lt;br_kol;j++){
                if(mat.at(k).at(i).size()!=br_kol){
                    throw std::domain_error("Redovi nemaju isti broj elemenata");
</font>                }
            }
        }
    }
    for(int k=0;k&lt;br_ploha;k++){
        if(mat.at(k).size()!=br_red){
                throw std::domain_error("Plohe nemaju isti broj redova");
        }
    }

    if((int)smjer==0){       
<a name="0"></a><font color="#FF0000"><a href="match275-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        for(int k=0;k&lt;br_ploha;k++){
            typename std::remove_reference&lt;decltype(mat.at(0).at(0))&gt;::type pom;
            for(int i=0;i&lt;br_red;i++){
                for(int j=0;j&lt;br_kol;j++){
                    if(i==j){ 
</font>                        
                        pom.push_back(mat.at(k).at(i).at(j));}
                }
            }
            DvoDim.push_back(pom);
        }
        return DvoDim;
    }
    if((int)smjer==1){       
        for(int k=0;k&lt;br_ploha;k++){
<a name="1"></a><font color="#00FF00"><a href="match275-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

            typename std::remove_reference&lt;decltype(mat.at(0).at(0))&gt;::type pom;
            for(int i=0;i&lt;br_red;i++){
                for(int j=0;j&lt;br_kol;j++){
                    if(i+j==br_kol-1){ 
</font>                        pom.push_back(mat.at(br_ploha-k-1).at(i).at(j));}
                }
            }
            DvoDim.push_back(pom);
        }
        return DvoDim;
    }
    if((int)smjer==2){
        for(int i=0;i&lt;br_red;i++){
<a name="2"></a><font color="#0000FF"><a href="match275-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

            typename std::remove_reference&lt;decltype(mat.at(0).at(0))&gt;::type pom;
            for(int j=0;j&lt;br_kol;j++){
                for(int k=0;k&lt;br_ploha;k++){
                    if(j==k){
</font>                        pom.push_back(mat.at(br_ploha-k-1).at(i).at(j));}
                }
            }
            DvoDim.push_back(pom);
        }
        return DvoDim;
    }
    if((int)smjer==3){
        for(int i=0;i&lt;br_red;i++){
<a name="3"></a><font color="#00FFFF"><a href="match275-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

           typename std::remove_reference&lt;decltype(mat.at(0).at(0))&gt;::type pom;
            for(int j=0;j&lt;br_kol;j++){
                for(int k=0;k&lt;br_ploha;k++){
                    if(j==k){
</font>                        pom.push_back(mat.at(br_ploha-k-1).at(br_red-i-1).at(br_kol-j-1));}
                }
            }
            DvoDim.push_back(pom);
        }
        return DvoDim;
    }    
    if((int)smjer==4){       
        for(int j=0;j&lt;br_kol;j++){
            typename std::remove_reference&lt;decltype(mat.at(0).at(0))&gt;::type pom;
            for(int i=0;i&lt;br_red;i++){
                for(int k=0;k&lt;br_ploha;k++){
                    if(i==k){
                        
                        pom.push_back(mat.at(br_ploha-k-1).at(i).at(j));}
                }
            }
            DvoDim.push_back(pom);
        }
        return DvoDim;
    }
    if((int)smjer==5){       
        for(int j=0;j&lt;br_kol;j++){
            typename std::remove_reference&lt;decltype(mat.at(0).at(0))&gt;::type pom;
            for(int i=0;i&lt;br_red;i++){
                for(int k=0;k&lt;br_ploha;k++){
                    if(i==k){
                        pom.push_back(mat.at(k).at(i).at(br_kol-j-1));}
                }
            }
            DvoDim.push_back(pom);
        }
        return DvoDim;
    }
    return DvoDim;
}

void IspisiMatricu(Matrica m){
<a name="5"></a><font color="#FF0000"><a href="match275-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

    for(int i=0;i&lt;m.size();i++){
        for(int j=0;j&lt;m[0].size();j++){
            std::cout&lt;&lt;std::setw(4)&lt;&lt;std::right&lt;&lt;m[i][j];
</font>        }
        std::cout&lt;&lt;std::endl;
    }
}
int main (){
    std::cout&lt;&lt;"Unesite dimenzije (x y z): ";
    int br_ploha, br_red, br_kol;
    std::cin&gt;&gt;br_ploha&gt;&gt;br_red&gt;&gt;br_kol;
    if(br_ploha&lt;0 || br_red&lt;0 || br_kol&lt;0){std::cout&lt;&lt;"Neispravne dimenzije kontejnera!"; return 0;}
    
    Mat3D mat=Kreiraj3DMatricu(br_ploha,br_red,br_kol);
    
    std::cout&lt;&lt;"Unesite elemente kontejnera: ";
    mat=UnesiMatricu(br_ploha,br_red,br_kol);
    Matrica rezultat=KreirajMatricu(0,0);
    std::cout&lt;&lt;"\nUnesite smjer kretanja [0 - 5]: ";
        int n;
    std::cin&gt;&gt;n;
    if(n&lt;0 || n&gt;5) {
        std::cout&lt;&lt;"Smjer kretanja nije ispravan!"&lt;&lt;std::endl;
        return 0;
    }
    const char *smjerovi[6]={"NaprijedNazad", "NazadNaprijed", "GoreDolje", "DoljeGore", "LijevoDesno", "DesnoLijevo"};
    std::cout&lt;&lt;smjerovi[n]&lt;&lt;": "&lt;&lt;std::endl;
try{
    std::cout&lt;&lt;std::endl;
    rezultat=(IzdvojiDijagonale3D(mat,SmjerKretanja(n)));
    IspisiMatricu(rezultat);
}catch(std::domain_error izuzetak){
    std::cout&lt;&lt;izuzetak.what();
}
	return 0;
}</pre>
</body>
</html>
