<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z6/student7125.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z6/student7125.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match13-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_96.gif"/></a>

/B2016/2017: Zadaća 3, Zadatak 6
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;stdexcept&gt;
#include &lt;memory&gt;
struct Dijete {
    std::string ime;
    std::shared_ptr&lt;Dijete&gt; sljedeci;
};

std::vector&lt;std::set&lt;std::string&gt;&gt; Razvrstavanje(std::vector&lt;std::string&gt; ulaz, int br);
std::shared_ptr&lt;Dijete&gt; KreirajPovezanuListu(std::vector&lt;std::string&gt; &amp;unos);
void UnistiListu(Dijete *pocetak);
bool jestotreba(char &amp;p);
int prebroj(std::string unos);
int main ()
{
    try {
        std::cout&lt;&lt;"Unesite broj djece: ";
        int n;
        std::cin&gt;&gt;n;
        std::cout&lt;&lt;"Unesite imena djece: ";
        std::vector&lt;std::string&gt; imena(n);
        std::cin.ignore(10000, '\n');
        for(int i(0); i &lt; n; i++)
            std::getline(std::cin,imena[i]);

        std::cout&lt;&lt;std::endl&lt;&lt;"Unesite broj timova: ";
        std::cin&gt;&gt;n;

        auto timovi(Razvrstavanje(imena,n));
        for(int i(0); i &lt; n; i++) {
            std::cout&lt;&lt;"Tim "&lt;&lt;i+1&lt;&lt;": ";
            for(auto it(timovi[i].begin()); it != timovi[i].end(); it++) {
                auto it2(timovi[i].end());
                if(it != --it2)
                    std::cout&lt;&lt;*it&lt;&lt;", ";
                else std::cout&lt;&lt;*it;
            }
            std::cout&lt;&lt;std::endl;
        }
    } catch(std::logic_error error) {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;error.what();
    }

    return 0;
}

std::vector&lt;std::set&lt;std::string&gt;&gt; Razvrstavanje(std::vector&lt;std::string&gt; ulaz, int br)
{
    if(br &lt; 1 || br &gt; ulaz.size()) throw std::logic_error("Razvrstavanje nemoguce");
    
    //kreairaj povezanu listu
    auto djeca(KreirajPovezanuListu(ulaz));
    
    //kreiraj timove
    std::vector&lt;std::set&lt;std::string&gt;&gt; tim(br);
    //dodatne varijable da ne racuna duzinu prvih i ostalih timova te koliko prvih timova će imati jednog igrača više svaki put u petlji
    int i(0),duz1(ulaz.size()/br+1),duz2(ulaz.size()/br),rbrtima(ulaz.size()%br);

    //inicijalizuj 3 pametna pokazivala, poc će uvjek pokazivat na pocetak, it će se kretati kroz povezanu listu, it2 onaj koji treba obrisat, it3 onaj koji se nalazi prije it2
    std::shared_ptr&lt;Dijete&gt; it(djeca), it2(djeca),poc(djeca),it3(djeca);
    //kada lista bude prazna poc će pokazivati na nullptr
    while(poc != nullptr) {
        tim.resize(i+1);
        //unosi prvih nekoliko timova
        if(tim.size() &lt;= rbrtima)
            while(tim[i].size() &lt; duz1) {
            //↑↑↑↑↑↑ dok je velicina tima manja od predviđene velicine
            
                //porebna bool varijable da ne bi vise puta istu osobu pokusavali brisati 
                bool jednom(true);
                //dodatne varijable, q predstvlja duzinu imena djeteta koje se izbacuje iz kruga
                int p(0),q(prebroj(it-&gt;ime));
                
                //U slucaju da nema vise djece odmah prekini petlju
                if(poc-&gt;sljedeci == nullptr) {
                    poc = nullptr;
                    break;
                }
                //pot
                //ubaci dijete u tim
                tim[i].insert((it2 = it)-&gt;ime);
                
                //eci-peci-pec
                while(p &lt; q) {
                    p++;
                    //prebacuj na slj. dijete 
                    it = it-&gt;sljedeci;
                    //ako treba brisati prvo dijete dovoljno je samo pomjeriti pocetak i na slj dijete i obrisati ga ali samo jednom
                    if(it2 == poc &amp;&amp; jednom) {
                    
                        poc = it2-&gt;sljedeci;
                        it2 = nullptr;
                        jednom = false;
                    }
                    //ako treba neko drugo dijete obrisat osim prvog
                    else if(jednom) {
                        it3 = poc;//postavi pokazivac na pocetak
                        //vrti petlji dok it3 ne bude pokazivao na elemenat "iza" it2
                        while(it3-&gt;sljedeci != it2)
                            it3 = it3-&gt;sljedeci;;
                        //neka prethodni element pokazuje na onaj ispred onog kojeg treba obrisati    
                        it3-&gt;sljedeci = it2-&gt;sljedeci;
                        //rijesi se objekta koji nam ne treba
                        it2 = nullptr;
                        jednom = false;
                    }
                    //ako je it nullptr znaci da smo dosli do kraja, idi na pocetak
                    if(it == nullptr)
                        it = poc;
                }
            }
        else {
            //dok je velicina tima manja od predviđene velicine
            while(tim[i].size() &lt; duz2) {
        //sve ispod ponaša se potpuno isto kao i kod unosa prvih nekoliko timova(osim broja članova tima) (mogla se funkcija napraviti za ovo al nemam živaca popravljat eventalne bugove)
                bool jednom(true);
                int p(0),q(prebroj(it-&gt;ime));
                tim[i].insert((it2 = it)-&gt;ime);
                if(poc-&gt;sljedeci == nullptr) {
                    poc = nullptr;
                    break;
                }
                while(p &lt; q) {
                    p++;
                    it = it-&gt;sljedeci;
                    if(it2 == poc &amp;&amp; jednom) {
                        poc = it2-&gt;sljedeci;
                        it2 = nullptr;
                        jednom = false;
                    } else if(jednom) {
                        it3 = poc;
                        while(it3-&gt;sljedeci != it2)
                            it3 = it3-&gt;sljedeci;;
                        it3-&gt;sljedeci = it2-&gt;sljedeci;
                        it2 = nullptr;
                        jednom = false;
                    }

                    if(it == nullptr) {
                        it = poc;
                    }
                }
            }
        }
        //pređi na slj. tim
        i++;
    }

    return tim;
}

bool jestotreba(char &amp;p)
{
    //ako je karakter p ono što nam treba vrati true
    if ((p &gt;= 'a' &amp;&amp; p &lt;= 'z') ||(p&gt;= '0' &amp;&amp; p &lt;= '9') ||(p&gt;= 'A' &amp;&amp; p&lt;= 'Z'))
        return true;
    return false;
}
int prebroj(std::string unos)
{
    int br(0);
    
    for(int i(0); i &lt; unos.length(); i++)
        if(jestotreba(unos[i])) //ako jeststotreba vrati true onda povecaj brojac za 1
            br++;
    return br;
}
//modifikovani KreirajPovezanuListu sa tutorijala 8, prima vektor stringova umjesto znaka za prekidanje
std::shared_ptr&lt;Dijete&gt; KreirajPovezanuListu(std::vector&lt;std::string&gt; &amp;unos)
{
    //inicijaliziraj pametne pokazivače
    std::shared_ptr&lt;Dijete&gt; pocetak(nullptr),prethodni;
    //petlja se ponavlja onoliko puta koliku listu treba napraviti
    for(int i(0); i &lt; unos.size(); i++) {
        //kreairaj dinamički objekat
        auto nov = std::make_shared&lt;Dijete&gt;();
        //dodijeli atribute
        nov-&gt;ime = unos[i];
        nov-&gt;sljedeci = nullptr;
        //povezuj listu
        if(!pocetak) pocetak = nov;
</font>        else prethodni-&gt;sljedeci = nov;
        prethodni = nov;
    }

    return pocetak;
}
</pre>
</body>
</html>
