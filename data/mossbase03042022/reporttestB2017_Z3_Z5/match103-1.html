<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student3867.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student3329.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;new&gt;

<a name="0"></a><font color="#FF0000"><a href="match103-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum class Boje { Pik, Tref, Herc, Karo };

static const char *BojeString [] { "Pik", "Tref", "Herc", "Karo" };
static const char *KarteString [] { "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A" };

const std::map &lt; std::string, short &gt; StrBoje = { { "Pik", 0 }, { "Tref", 1 }, { "Herc", 2 }, { "Karo", 3 } };
const std::map &lt; std::string, short &gt; karte = { { "2", 0 }, { "3", 1 }, { "4", 2 }, { "5", 3 }, { "6", 4 }, { "7", 5 }, { "8", 6 }, { "9", 7 }, 
                                                { "10", 8 }, { "J", 9 }, { "Q", 10 }, { "K", 11 }, { "A", 12 } };

struct Karta 
{ 
    Boje boja; 
    std::string broj; 
};

struct Cvor 
{ 
    Karta karta; 
    Cvor *sljedeci; 
};

namespace ab
{
    bool besmisleno ( Cvor *it )
    {
    /*** vraca 'true' ako se vrijednosti iz parametra 'it' ne nalaze u predefinisanim vrijednostima koje oznacavaju karte ***/
        if ( karte.find ( it -&gt; karta.broj ) == karte.end () ) // provjera za broj
            return true;
       
        for ( const std::pair &lt; std::string, short &gt; &amp;boja : StrBoje ) // provjera za znak
            if ( it -&gt; karta.boja == static_cast &lt; Boje &gt; ( boja.second ) )
                return false;
       
        return true;
    }
    
    unsigned size ( Cvor *first )
    {
    /*** vraca velicinu liste***/
        if ( first == nullptr ) // prazan spil
            return 0;
        
        unsigned vel { 0 };
        Cvor *slider { first };
        do
        {
            vel++;
            if ( vel &gt; 52 ) // prelazak validne velicine za spil
                break;
            slider = slider -&gt; sljedeci;
        }while ( slider != first and slider != nullptr ); // i ciklicne i linearne liste
        
        return vel;
    }
    
    void CardValidation ( Cvor *first )
    {
    /*** testiranje na izuzetke definisane za tip 'Spil' ***/
        if ( first == nullptr )
            return;
    
        if ( size ( first ) &gt; 52 or besmisleno ( first ) ) // provjerava takodjer prvi element, jer ne provjerava zajedno sa ostalim el. u petlji ispod 
            throw std::logic_error ( "Neispravna lista!" );

        Cvor *slider { first }, *aftbeg { first -&gt; sljedeci };
        do // provjera da li su elementi sortirani po postavci zadatka i da li odgovaraju predefinisanim vrijednostima za karte
        {          
            if ( ( static_cast &lt; int &gt; ( slider -&gt; karta.boja ) &gt; static_cast &lt; int &gt; ( aftbeg -&gt; karta.boja ) and
                karte.at ( slider -&gt; karta.broj ) &gt; karte.at ( aftbeg -&gt; karta.broj ) ) or 
                besmisleno ( aftbeg ) )
                    throw std::logic_error ( "Neispravna lista!" );      
            
            aftbeg = aftbeg -&gt; sljedeci;
            slider = slider -&gt; sljedeci;
        }while ( aftbeg != first );
    }
    
    void StackValidation ( std::stack &lt; std::pair &lt; std::string, std::string &gt; &gt; stek, int n )
    {
    /*** testiranje na izuzetke definisane za neki tip reda ***/
        if ( n &lt; 0 or n &gt; 52 )
            throw std::domain_error ( "Broj n je besmislen!" );
        if ( n &gt; stek.size () )
            throw std::range_error ( "Nedovoljno karata u steku!" );
        // provjera da li se vrijednosti reda nalaze u predefinisanim vrijednostima za karte        
        while ( !stek.empty () )
        {
            std::pair &lt; std::string, std::string &gt; card = stek.top ();
            stek.pop ();
            if ( karte.find ( card.second ) == karte.end () or
                StrBoje.find ( card.first ) == StrBoje.end () )
                    throw std::logic_error ( "Neispravne karte!" );
        }
    }
    
    Cvor *last_el ( Cvor *first )
    {
    /*** vraca adresu "posljednjeg" elementa u listi ***/
        if ( first == nullptr ) // prazan spil
            return nullptr;
            
        Cvor *slider { first }, *pre { first };
        do
        {
            if ( slider != first )
                pre = pre -&gt; sljedeci;
            slider = slider -&gt; sljedeci;
        }while ( slider != first );
    
        return pre;
    }
    
    Cvor *find ( Cvor *first, const std::pair &lt; Boje, std::string &gt; &amp;el )
    {        
    /*** vraca element koji se nalazi prije elemente iz liste koji je jednak parametru 'el' ***/
        if ( first == nullptr ) // prazna lista
            return nullptr;
            
        Cvor *slider { first };
        do
        {
            if ( slider -&gt; karta.boja == el.first and slider -&gt; karta.broj == el.second )
                return last_el ( slider );

            slider = slider -&gt; sljedeci;
        }while ( slider != first );            
        
        return nullptr; // parametar 'el' se ne podudara niti sa jednim elementom iz liste
    }
    
    Cvor *insert ( Cvor *first, const std::pair &lt; Boje, std::string &gt; &amp;el )
    {
        if ( first == nullptr )
        {
            first = new Cvor { { el.first, el.second }, nullptr };
            return first -&gt; sljedeci = first;
        }
        
        Cvor *exist { find ( first, el ) }, *pre { nullptr };
        if ( !exist ) // da li vec postoji element u listi
        {
            Cvor *slider { first };
            while ( static_cast &lt; int &gt; ( slider -&gt; karta.boja ) &lt; static_cast &lt; int &gt; ( el.first ) )
                slider = slider -&gt; sljedeci;
                
            while ( karte.at ( slider -&gt; karta.broj ) &lt; karte.at ( el.second ) )
                slider = slider -&gt; sljedeci;
                
            pre = last_el ( slider );    
                
            Cvor *novi = new Cvor { { el.first, el.second }, slider };
            pre -&gt; sljedeci = novi;
        }
        
        return pre -&gt; sljedeci; // vraca se pokazivac na novouneseni element
    }
    
    Cvor *erase ( Cvor *it )
    {
        if ( it == nullptr )
            return nullptr;
        
        if ( it -&gt; sljedeci == it ) // brisanje elementa koji je jedini clan liste, nakon ovoga lista je prazna
        {
            delete it;
            return it = nullptr;
        }
        
        Cvor *pre { last_el ( it ) };
        
        pre -&gt; sljedeci = it -&gt; sljedeci;
        delete it;
        
        return pre; // vraca pokazivac na prethodni element obrisanog elementa
    }
}

void IspisiSpil ( Cvor *first )
{
/*** ispis kontejnera 'Spil' u formatu zadanom u postavci zadatka ***/
    Cvor *slider { first }, *pre { ab::last_el ( first ) };
    
    std::cout &lt;&lt; "U spilu trenutno ima " &lt;&lt; ab::size ( first ) &lt;&lt; " karata, i to:";
    for ( const char *boja : BojeString )
    {
        std::cout &lt;&lt; std::endl &lt;&lt; boja &lt;&lt; ":";
        if ( first == nullptr or static_cast &lt; std::string &gt; ( boja ) != BojeString [ static_cast &lt; int &gt; ( slider -&gt; karta.boja ) ] )
            continue; // prazna lista ili se ne poklapa znak
            
        do
        {
            std::cout &lt;&lt; " " &lt;&lt; slider -&gt; karta.broj;
            
            pre = pre -&gt; sljedeci;
            slider = slider -&gt; sljedeci;
        }while ( karte.at ( slider -&gt; karta.broj ) &gt; karte.at ( pre -&gt; karta.broj ) );
    }
    
}

Cvor *KreirajSpil ( void )
{
/*** vraca pokazivac na prvi 'element' liste ***/
    Cvor *prvi { nullptr }, *last;
    
    for ( int i = 0; i &lt; 4; i++ )
        for ( const char *broj : KarteString )
        {
            Cvor *novi = new Cvor { { static_cast &lt; Boje &gt; ( i ), static_cast &lt; std::string &gt; ( broj ) }, nullptr };
            ( !prvi ) ? ( prvi = novi ) : ( last -&gt; sljedeci = novi );
            last = novi;
        }        

    return last -&gt; sljedeci = prvi;
}

void UnistiSpil ( Cvor *first )
{
/*** brisanje svih elemenata liste ***/
    if ( first == nullptr ) // ne treba nista brisati, lista prazna
        return;
        
    Cvor *slider { first }, *last { ab::last_el ( first ) };
    last -&gt; sljedeci = nullptr;
    while ( slider != nullptr )
    {
        Cvor *brisi { slider };
        slider = slider -&gt; sljedeci;
        delete brisi;
    }
}

void IzbaciKarte ( Cvor *&amp;spil, std::multimap &lt; Boje, std::string &gt; &amp;izb )
{    
    ab::CardValidation ( spil );
    
    Cvor *del { nullptr };
    for ( typename std::multimap &lt; Boje, std::string &gt;::iterator card = izb.begin (); card != izb.end(); card++ )
    {
        del = ab::find ( spil, *card );
        if ( !del )
        {
            card = izb.erase ( card );
            
            ab::erase ( del -&gt; sljedeci );
        }
    }
}

std::stack &lt; std::pair &lt; std::string, std::string &gt; &gt; IzbaciKarteRazbrajanjem ( Cvor *&amp;first, const short &amp;r, const int &amp;b )
{
    if ( r &lt; 1 or r &gt; 52 or b &lt; 1 )
        throw std::logic_error ( "Neispravni elementi za izbacivanje!" );
    ab::CardValidation ( first );
    
    Cvor *slider { first };
    
    std::stack &lt; std::pair &lt; std::string, std::string &gt; &gt; stek;
    int i { 0 }, count { 0 };
    while ( slider != nullptr and i != b )
    {
        if ( ++count == r )
        {
            stek.emplace ( BojeString [ static_cast &lt; int &gt; ( slider -&gt; karta.boja ) ], slider -&gt; karta.broj );
            
            slider = ab::erase ( slider );
            
            if ( slider == nullptr )
                break;

            count = 0;
            i++;
        }

        slider = slider -&gt; sljedeci;
    }    

    return stek;
}

void VratiPosljednihNKarata ( Cvor *&amp;first, std::stack &lt; std::pair &lt; std::string, std::string &gt; &gt; &amp;stek, int n )
{
    ab::StackValidation ( stek, n );
    ab::CardValidation ( first );
    
    std::pair &lt; std::string, std::string &gt; par;
    int i { 0 };
    while ( i++ != n )
    {
        par = stek.top ();
        stek.pop ();
        
        ab::insert ( first, std::make_pair ( static_cast &lt; Boje &gt; ( StrBoje.at ( par.first ) ), par.second ) );
    }
}

int main ( void ) 
{
    short raz;
    std::cout &lt;&lt; "Unesite korak razbrajanja: ";
    std::cin &gt;&gt; raz;
    
    int izb;
    std::cout &lt;&lt; "Unesite broj karata koje zelite izbaciti: ";
    std::cin &gt;&gt; izb;
    
    Cvor *spil { nullptr };
    try
    {
        spil = KreirajSpil ();
        std::stack &lt; std::pair &lt; std::string, std::string &gt; &gt; obrisane { IzbaciKarteRazbrajanjem ( spil, raz, izb ) };
        
        IspisiSpil ( spil );
        
        std::cout &lt;&lt; "\nUnesite broj karata koje zelite vratiti u spil: ";
        std::cin &gt;&gt; izb;
        VratiPosljednihNKarata ( spil, obrisane, izb );
        
        IspisiSpil ( spil ); 
        UnistiSpil ( spil );
    }
    catch ( const std::exception &amp;exc ) { std::cout &lt;&lt; "Izuzetak: " &lt;&lt; exc.what (); UnistiSpil ( spil ); }
</font>    return 0;
}</pre>
</body>
</html>
