<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student2941.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student8864.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 5
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;

enum class Boje
{
    Pik, Tref, Herc, Karo
};

struct Karta {
    Boje boja;
    std::string vrijednost;
};

struct Cvor {
    Karta karta;
    Cvor* sljedeci;
};

Cvor* kraj_liste (Cvor* pocetak)
{
    if(pocetak == nullptr) return pocetak;
    Cvor* prethodni(nullptr);
    Cvor* trenutni(pocetak);
    do {
        prethodni = trenutni;
        trenutni=trenutni-&gt;sljedeci;
    } while (trenutni!=pocetak);

    return prethodni;
}

int velicina_liste (Cvor* pocetak)
{
    int lista_vel(0);
    Cvor* i(pocetak);
    do {
        lista_vel++;
        i=i-&gt;sljedeci;
    } while (i!=pocetak);

    return lista_vel;
}

void Ispisi_Listu(Cvor* p)
{
    const std::string boje[4] = {"Pik", "Tref", "Herc", "Karo"};
    for(int j=0; j&lt;4; j++) {
        std::cout &lt;&lt; boje[j] &lt;&lt;": ";
        Cvor* i(p);
        do {
            if(int(i-&gt;karta.boja) == j) std::cout &lt;&lt; i-&gt;karta.vrijednost &lt;&lt; " ";
            i=i-&gt;sljedeci;
        } while (i!=p);
        std::cout &lt;&lt; std::endl;
    }
}

Cvor* KreirajSpil()
{
    const std::string vrijednosti[13]= {"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"};
    Cvor *pocetak(nullptr), *prethodni(nullptr);
<a name="0"></a><font color="#FF0000"><a href="match680-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

    for(int i=0; i&lt;4; i++) {
        for(int j=0; j&lt;13; j++) {
            Cvor* novi(new Cvor {{Boje(i), vrijednosti[j]}, nullptr});
            if(pocetak == nullptr) pocetak=novi;
            else prethodni-&gt;sljedeci = novi;
            prethodni = novi;
        }
    }
    prethodni-&gt;sljedeci = pocetak;

    return pocetak;
}

void ValidacijaSpila(Cvor* pocetak)
</font>{

    const std::string vrijednosti[13]= {"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"};
    Cvor* prethodni(kraj_liste(pocetak));
    Cvor* trenutni(pocetak);
    do {
        if(int(trenutni-&gt;karta.boja) &lt;0 || int(trenutni-&gt;karta.boja) &gt;3 || std::find(vrijednosti, vrijednosti+13, trenutni-&gt;karta.vrijednost)==vrijednosti+13)
            throw std::logic_error ("Neispravna lista!");
        
        int i(std::find(vrijednosti, vrijednosti+13, prethodni-&gt;karta.vrijednost)-vrijednosti);
        int j(std::find(vrijednosti, vrijednosti+13, trenutni-&gt;karta.vrijednost)-vrijednosti);
        
        if(trenutni != pocetak &amp;&amp; trenutni != kraj_liste(pocetak)) {
            if(!(((trenutni-&gt;karta.boja == prethodni-&gt;karta.boja &amp;&amp; i&lt;j ) || (trenutni-&gt;karta.boja &gt; prethodni-&gt;karta.boja)))) throw std::logic_error("Neispravna lista!");
        } else if(trenutni == kraj_liste(pocetak)) {
            if(!((trenutni-&gt;karta.boja == prethodni-&gt;karta.boja &amp;&amp; i&lt;j ) || (trenutni-&gt;karta.boja &gt; prethodni-&gt;karta.boja))) throw std::logic_error("Neispravna lista!");
        }
 
        prethodni = trenutni;
        trenutni=trenutni-&gt;sljedeci;
    } while (trenutni!=pocetak);
}

void IzbaciKarte (Cvor* &amp;pocetak, std::multimap &lt;Boje, std::string&gt; &amp;za_izbaciti)
{

    try {
        ValidacijaSpila(pocetak);
    }
    catch (...) {
        throw;
    }
    
    auto it(za_izbaciti.begin());
    while (it != za_izbaciti.end()) {
        Cvor* prethodni(kraj_liste(pocetak));
        Cvor* trenutni(pocetak);
        do {

            if(trenutni-&gt;karta.boja == it-&gt;first &amp;&amp; trenutni-&gt;karta.vrijednost == it-&gt;second) {
                auto tmp(trenutni);
                if(trenutni == pocetak) {
                    pocetak = trenutni-&gt;sljedeci;
                } else prethodni-&gt;sljedeci = trenutni-&gt;sljedeci;
                delete tmp;
                break;
            }
            if(prethodni == nullptr) prethodni=pocetak;
            else prethodni = trenutni;
            trenutni=trenutni-&gt;sljedeci;
        } while (trenutni!=pocetak);
        if(trenutni != pocetak) it=za_izbaciti.erase(it);
        else it++;
        if(pocetak-&gt;sljedeci == pocetak) pocetak=nullptr;
    }

}

<a name="2"></a><font color="#0000FF"><a href="match680-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

std::stack&lt;std::pair&lt;std::string, std::string&gt;&gt;
        IzbaciKarteRazbrajanjem(Cvor* &amp;pocetak, const short int &amp;r, const int &amp;b)
 {
    
    if(r &lt; 1 || r &gt; 52 || b &lt; 1) throw std::logic_error ("Neispravni elementi za izbacivanje!");
</font>    
    try {
        ValidacijaSpila(pocetak);
    }
    catch (...) {
        throw;
    }
    
    const std::string boje[4] = {"Pik", "Tref", "Herc", "Karo"};
    int br_izbacenih(0);
    Cvor* prethodni(kraj_liste(pocetak)); 
    Cvor* trenutni(pocetak);
    std::stack&lt;std::pair&lt;std::string, std::string&gt;&gt; izbacene_karte;
    do { 
        int r_tmp(0);
        for(r_tmp=0; r_tmp&lt;r-1; r_tmp++) {
            prethodni=trenutni;
            trenutni=trenutni-&gt;sljedeci;
        }
        if(trenutni == pocetak) pocetak = trenutni-&gt;sljedeci; //azuriranje pocetka
        auto tmp(trenutni);
        if(trenutni == pocetak) {
            pocetak=trenutni-&gt;sljedeci;
        } else prethodni-&gt;sljedeci = trenutni-&gt;sljedeci; 
    
        br_izbacenih++;
        izbacene_karte.push(make_pair(boje[int(trenutni-&gt;karta.boja)], trenutni-&gt;karta.vrijednost));

        prethodni = trenutni;
        trenutni=trenutni-&gt;sljedeci; 
        delete tmp;
    } while (br_izbacenih!=b);

    if(pocetak-&gt;sljedeci == pocetak) pocetak=nullptr; //ako je ostala prazna lista

    return izbacene_karte; 
}

<a name="1"></a><font color="#00FF00"><a href="match680-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

void VratiPosljednjihNKarata(Cvor* &amp;pocetak, std::stack&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;izbacene_karte, int n)
{
    if(n&lt;0) throw std::domain_error ("Broj n je besmislen!");
    if(n&gt;izbacene_karte.size()) throw std::range_error ("Nedovoljno karata u steku!");
</font>
    try {
        ValidacijaSpila(pocetak);
    }
    catch (...) {
        throw;
    }

    const std::string boje[4] = {"Pik", "Tref", "Herc", "Karo"};
    const std::string vrijednosti[13]= {"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"};
    int vraceno(0);
    while (vraceno != n) {

        int i(std::find(boje, boje+4, izbacene_karte.top().first)-boje);
        //indeks u nizu boja - int od enum vrijednosti

        Cvor* novi(new Cvor {{Boje(i), izbacene_karte.top().second}, nullptr});
        //alokacija novog elementa tipa cvor koji se treba ubaciti
        
        bool u_spilu(false); 
        if(pocetak==nullptr) {
            pocetak=novi; 
            pocetak-&gt;sljedeci = pocetak;
        } else {
            Cvor* trenutni(pocetak);
            Cvor* prethodni(kraj_liste(pocetak));
            int k(std::find(vrijednosti, vrijednosti+13, novi-&gt;karta.vrijednost)-vrijednosti);
            int x(0);
            do {
                x++;
                int j(std::find(vrijednosti, vrijednosti+13, trenutni-&gt;karta.vrijednost)-vrijednosti);
                if((novi-&gt;karta.boja == trenutni-&gt;karta.boja &amp;&amp; k &lt; j) || (novi-&gt;karta.boja &lt; trenutni-&gt;karta.boja &amp;&amp; k&lt;j))
                    break;
                if(novi-&gt;karta.boja == trenutni-&gt;karta.boja &amp;&amp; k == j){
                    u_spilu=true;
                }
                prethodni=trenutni;
                trenutni=trenutni-&gt;sljedeci;
            } while(trenutni != pocetak); //pronalazenje mjesta na koje se treba ubaciti
            if(!u_spilu){ //ubacuje ako nije vec u spilu
            if(x==1) pocetak=novi;
            prethodni-&gt;sljedeci = novi;
            novi-&gt;sljedeci = trenutni;
            }
            else delete novi; //ako je vec u spilu ignorira
            
        }
        
        vraceno++;
        izbacene_karte.pop(); //prelazak na sljedeci element stacka
    }
}

void UnistiSpil(Cvor* &amp;pocetak)
{
    auto i(pocetak);
    do {
        auto tmp(i);
        i=i-&gt;sljedeci;
        delete tmp;
    } while (i!=pocetak);

    pocetak=nullptr;
}



int main ()
{
    
    auto p(KreirajSpil());
    try { 
        std::cout &lt;&lt; "Unesite korak razbrajanja: ";
        int r;
        std::cin &gt;&gt; r; 
        std::cout &lt;&lt; "Unesite broj karata koje zelite izbaciti: ";
        int b;
        std::cin &gt;&gt; b;

        auto izbacene_karte(IzbaciKarteRazbrajanjem(p, r, b));
        std::cout &lt;&lt; "U spilu trenutno ima " &lt;&lt; velicina_liste(p) &lt;&lt; " karata, i to:" &lt;&lt; std::endl;
        Ispisi_Listu(p);

        std::cout &lt;&lt; "Unesite broj karata koje zelite vratiti u spil: ";
        int n;
        std::cin &gt;&gt; n;
        
        VratiPosljednjihNKarata(p, izbacene_karte, n);
        std::cout &lt;&lt; "U spilu trenutno ima " &lt;&lt; velicina_liste(p) &lt;&lt;" karata, i to:" &lt;&lt; std::endl;
        Ispisi_Listu(p);
 
        UnistiSpil(p);
    } catch(std::domain_error izuzetak) {
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
        UnistiSpil(p);
    } catch(std::logic_error izuzetak) {
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
        UnistiSpil(p);
    } catch(std::range_error izuzetak) {
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
        UnistiSpil(p);
    }
    return 0;
}
</pre>
</body>
</html>
