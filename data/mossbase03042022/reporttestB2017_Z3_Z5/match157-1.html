<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student3807.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student9993.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match157-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B2017/2018: ZadaÄ‡a 3, Zadatak 1
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;

bool moja_funkcija(std::pair&lt;double, double&gt; a, std::pair&lt;double, double&gt; b){
    return (a.first&lt;b.first);
}

std::function&lt;double(double)&gt; LinearnaInterpolacija(   //prva verzija
    std::vector&lt;std::pair&lt;double, double&gt;&gt; v){
        return [v] (double x){ 
            double povratni; int vel=v.size(); int marker;
            if(x==v.at(vel-1).first) return v.at(vel-1).second;
            if(x&lt;v[0].first || x&gt;v[vel-1].first) { throw std::range_error ("Argument izvan opsega");} 
            //vektor samo od x-eva
            std::vector&lt;double&gt; iksevi;
            for(int i(0); i&lt;v.size(); i++){  //pravimo vektor samo od x iz uredjenih parova
                iksevi.push_back(v[i].first);
            }
            for(int i(0); i&lt;iksevi.size(); i++){
                for(int j(i+1); j&lt;iksevi.size(); j++){
                    if(iksevi[i]==iksevi[j]) { throw std::domain_error ("Neispravni cvorovi"); break;}
                }
            }
        
            std::vector&lt;double&gt;::iterator pos=std::lower_bound(iksevi.begin(), iksevi.end(), x)-1; //par-koji sadrzi donju granicu od x
            for(int i(0); i&lt;v.size(); i++){
                if(*pos==v[i].first) {
                    marker=i;
                    break; //trazimo korespondirajuci uredjen par
                }
            }
            povratni=v[marker].second+((v[marker+1].second-v[marker].second)/(v[marker+1].first-v[marker].first))*(x-v[marker].first);
            return povratni;};}

    
           

std::function&lt;double(double)&gt; LinearnaInterpolacija(  //druga verzija
    std::function&lt;double(double)&gt; f, double xmin, double xmax, double dx){
        return[xmin, xmax, dx, f] (double x){
        if(xmin&gt;xmax || dx&lt;=0) { throw std::domain_error ("Nekorektni parametri");}    
        if(x&lt;xmin || x&gt;xmax) { throw std::range_error ("Argument izvan opsega");}
        std::vector&lt;std::pair&lt;double, double&gt;&gt; cvorovi(0); int brojac(0);
        std::pair&lt;double, double&gt; tekuci_par;
        for(int i(0);; i++){
            std::pair&lt;double, double&gt; tekuci_par;
            if((xmin+i*dx)==xmax){
                tekuci_par.first=xmax;
                tekuci_par.second=f(xmax);
                cvorovi.push_back(tekuci_par);
                break;
            }
            tekuci_par.first=xmin+i*dx;
            tekuci_par.second=f(tekuci_par.first);
            cvorovi.push_back(tekuci_par);
        }
        //sad imamo vektor parova sa datim korakom... moramo sortirati
        std::sort(cvorovi.begin(), cvorovi.end(), moja_funkcija);
        std::vector&lt;double&gt; iksevi2;
            for(int i(0); i&lt;cvorovi.size(); i++){  //pravimo vektor samo od x iz uredjenih parova
                iksevi2.push_back(cvorovi[i].first);
            }
        int marker2; double povratni2;
        std::vector&lt;double&gt;::iterator pos=std::lower_bound(iksevi2.begin(), iksevi2.end(), x)-1; //par-koji sadrzi donju granicu od x
            for(int i(0); i&lt;cvorovi.size(); i++){
                if(*pos==cvorovi[i].first) {
                    marker2=i;
                    break; //trazimo korespondirajuci uredjen par
                }
            }
            povratni2=cvorovi[marker2].second+((cvorovi[marker2+1].second-cvorovi[marker2].second)/(cvorovi[marker2+1].first-cvorovi[marker2].first))*(x-cvorovi[marker2].first);
            return povratni2;};}

double fun(double x){
    return x*x+std::sin(x);
}

int main (){
    int choice; int br_cv;
    std::cout&lt;&lt;"Odaberite opciju (1 - unos cvorova, 2 - aproksimacija): ";
    std::cin&gt;&gt;choice;
    if(choice==1) {
        try{
        std::cout&lt;&lt;"Unesite broj cvorova: ";
        std::cin&gt;&gt;br_cv;
        std::vector&lt;std::pair&lt;double, double&gt;&gt; vek(br_cv);
        std::cout&lt;&lt;"Unesite cvorove kao parove x y: ";
        for(int i(0); i&lt;br_cv; i++){
            std::cin&gt;&gt;vek.at(i).first&gt;&gt;vek.at(i).second;
        }
        //sortiranje po velicini x-koordinata
        std::sort(vek.begin(), vek.end(), moja_funkcija);
        
        auto fx(LinearnaInterpolacija(vek));
        double arg;
        try{
        do{
            std::cout&lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
            std::cin&gt;&gt;arg;
            if(!(std::cin)) return 0;
            std::cout&lt;&lt;"f("&lt;&lt;arg&lt;&lt;") = "&lt;&lt;fx(arg)&lt;&lt;std::endl;
        }while(std::cin);
        }catch(std::range_error izuzetak2){                                               // izvan opsega
            std::cout&lt;&lt;izuzetak2.what()&lt;&lt;std::endl;
        }
    }catch(std::domain_error izuzetak){                                                  //iste x koordinate
                std::cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
            }
        return 0;
    }
    
      else if(choice==2){
          
          std::cout&lt;&lt;"Unesite krajeve intervala i korak: ";
          double min; double max; double step;
          std::cin&gt;&gt;min&gt;&gt;max&gt;&gt;step;
          
          auto fx2(LinearnaInterpolacija(fun, min, max, step));
          do{
              try{
                double arg2;
              std::cout&lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
              std::cin&gt;&gt;arg2;
          
              if(!(std::cin)) return 0;
              std::cout&lt;&lt;"f("&lt;&lt;arg2&lt;&lt;") = "&lt;&lt;fun(arg2)&lt;&lt;" fapprox("&lt;&lt;arg2&lt;&lt;") = "&lt;&lt;fx2(arg2)&lt;&lt;std::endl;
              }catch(std::range_error izuzetak2){                                               // izvan opsega
            std::cout&lt;&lt;izuzetak2.what()&lt;&lt;std::endl;
        } 
          }while(std::cin);
          return 0;
</font>      }
return 0;
}</pre>
</body>
</html>
