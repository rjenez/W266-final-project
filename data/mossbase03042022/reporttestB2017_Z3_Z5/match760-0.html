<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student5244.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student5244.cpp<p></p><pre>
/B2017/2018: Zadaća 3, Zadatak 5
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;utility&gt;
#include &lt;new&gt;

enum class Boje
{
    Pik, Tref, Herc, Karo
};

std::vector&lt;std::string&gt; NazivKarata {"2","3","4","5","6","7","8","9","10","J","Q","K","A"};

struct Karta {
    Boje boja;
    std::string vrijednost;
};

struct Cvor {
    Karta karta;
    Cvor* sljedeci;
};

Cvor* KreirajSpil()
{
    Cvor *pocetak (nullptr), *pomocni;
    for (int i = 0; i &lt; NazivKarata.size(); i++) {
        Cvor* temp = new Cvor;
        temp-&gt;karta.boja = Boje::Pik;
        temp-&gt;karta.vrijednost = NazivKarata.at(i);
        temp-&gt;sljedeci = nullptr;
        if(pocetak == nullptr) pocetak = temp;
        else pomocni-&gt;sljedeci = temp;
        pomocni = temp;
    }
    for (int i = 0; i &lt; NazivKarata.size(); i++) {
        Cvor *temp = new Cvor;
        temp-&gt;karta.boja = Boje::Tref;
        temp-&gt;karta.vrijednost = NazivKarata.at(i);
        temp-&gt;sljedeci = nullptr;
        pomocni-&gt;sljedeci = temp;
        pomocni = temp;
    }
    for (int i = 0; i &lt; NazivKarata.size(); i++) {
        Cvor *temp = new Cvor;
        temp-&gt;karta.boja = Boje::Herc;
        temp-&gt;karta.vrijednost = NazivKarata.at(i);
        temp-&gt;sljedeci = nullptr;
        pomocni-&gt;sljedeci = temp;
        pomocni = temp;
    }
    for (int i = 0; i &lt; NazivKarata.size(); i++) {
        Cvor *temp = new Cvor;
        temp-&gt;karta.boja = Boje::Karo;
        temp-&gt;karta.vrijednost = NazivKarata.at(i);
        if(i == NazivKarata.size() - 1) temp-&gt;sljedeci = pocetak;
        else temp-&gt;sljedeci = nullptr;
        pomocni-&gt;sljedeci = temp;
        pomocni = temp;
    }
    return pocetak;
}

void Izuzeci(Cvor *pocetakspila)
{
    int brojac = 0;
    for(auto kretanje = pocetakspila; kretanje-&gt;sljedeci != pocetakspila; kretanje = kretanje-&gt;sljedeci) {
        brojac++;
        bool smislen = false;
        for(int i = 0; i &lt; NazivKarata.size(); i++) {
            if(kretanje-&gt;karta.vrijednost == NazivKarata.at(i)) smislen = true;
        }
        if(smislen == false) throw std::logic_error("Neispravna lista!");

        if(brojac &gt; 52) throw std::logic_error("Neispravna lista!");
        Boje boja;
        for(auto kretanje = pocetakspila; kretanje-&gt;sljedeci != pocetakspila; kretanje = kretanje-&gt;sljedeci) {
            boja = kretanje-&gt;karta.boja;
            while(kretanje-&gt;karta.boja == boja &amp;&amp; kretanje-&gt;sljedeci != pocetakspila) {
                auto pomocnakarta = kretanje;
                kretanje = kretanje-&gt;sljedeci;
                if(kretanje-&gt;karta.boja != boja) break;
                auto nazivpomocna = std::find(NazivKarata.begin(), NazivKarata.end(), pomocnakarta-&gt;karta.vrijednost);
                auto nazivkretanje = std::find(NazivKarata.begin(), NazivKarata.end(), kretanje-&gt;karta.vrijednost);
                if(nazivpomocna &gt;= nazivkretanje) throw std::logic_error("Neispravna lista!");
            }
            if(boja == Boje::Karo &amp;&amp; kretanje-&gt;sljedeci != pocetakspila) throw std::logic_error("Neispravna lista!");
            for(auto kretanje2 = kretanje; kretanje2 != pocetakspila; kretanje2 = kretanje2-&gt;sljedeci) {
                if(boja == Boje::Pik) {
                    if(kretanje2-&gt;karta.boja == Boje::Pik) throw std::logic_error("Neispravna lista!");
                } else if(boja == Boje::Tref) {
                    if(kretanje2-&gt;karta.boja == Boje::Tref || kretanje2-&gt;karta.boja == Boje::Pik) throw std::logic_error("Neispravna lista!");
                } else if(boja == Boje::Herc) {
                    if(kretanje2-&gt;karta.boja == Boje::Pik || kretanje2-&gt;karta.boja == Boje::Tref || kretanje2-&gt;karta.boja == Boje::Herc) throw std::logic_error("Neispravna lista!");
                }
            }
            if(kretanje-&gt;sljedeci == pocetakspila) break;
        }
    }
}

void IzbaciKarte(Cvor *&amp;pocetakspila, std::multimap&lt;Boje, std::string&gt; &amp;m)
{
    Izuzeci(pocetakspila);
    auto novi = pocetakspila;
    auto kraj = pocetakspila;
    while(kraj-&gt;sljedeci != pocetakspila) kraj = kraj -&gt; sljedeci;

    for(auto it = m.begin(); it != m.end();) { // pomjera se ručno ako se karta ne obriše ili pomoću erase ako se obriše
        bool obrisana(false);
        if((*it).first == novi-&gt;karta.boja &amp;&amp; (*it).second == novi-&gt;karta.vrijednost) {
            obrisana = true;
            pocetakspila = pocetakspila-&gt;sljedeci;
            kraj-&gt;sljedeci = pocetakspila;
            if(pocetakspila == pocetakspila-&gt;sljedeci) pocetakspila = nullptr;
            delete novi;
            it = m.erase(it); // pomjera it za jedno mjesto
            novi = pocetakspila; 
        }
        if(obrisana == false) {
            for(auto kretanje = pocetakspila-&gt;sljedeci; kretanje != pocetakspila; kretanje = kretanje-&gt;sljedeci) {
                if((*it).first == kretanje-&gt;karta.boja &amp;&amp; (*it).second == kretanje-&gt;karta.vrijednost) {
                    obrisana = true;
                    auto prethodnik = pocetakspila;
                    while(prethodnik-&gt;sljedeci != kretanje) prethodnik = prethodnik-&gt;sljedeci;
                    prethodnik-&gt;sljedeci = kretanje-&gt;sljedeci;
                    delete kretanje;
                    it = m.erase(it); // pomjera it za jedno mjesto
                    break;
                }
            }
        }
        if(obrisana == false) it++; // ako it nije pomjeren tj ako se nijedna karta nije obrisala, pomjeri
    }
}


std::stack&lt;std::pair&lt;std::string, std::string&gt;&gt;IzbaciKarteRazbrajanjem(Cvor* &amp;pocetakspila, const short int &amp;r, const int &amp;b)
{
    if (r &lt; 1 || r &gt; 52 || b &lt; 1) throw std::logic_error("Neispravni elementi za izbacivanje!");
    Izuzeci(pocetakspila);
    auto kraj = pocetakspila;
    auto novi = pocetakspila;
    auto kretanje = pocetakspila;
    while(kraj-&gt;sljedeci != pocetakspila) kraj = kraj-&gt;sljedeci;
    std::stack&lt;std::pair&lt;std::string, std::string&gt;&gt; stek;
    int broj_izbacenih = 0;
    while(broj_izbacenih != b &amp;&amp; pocetakspila != nullptr) {
        int korak(0);
        while(korak &lt; r - 1) {
            kretanje = kretanje-&gt;sljedeci;
            korak++;
        }
        std::pair&lt;std::string, std::string&gt;element_steka;
        if(kretanje-&gt;karta.boja == Boje::Pik) element_steka.first = "Pik";
        else if(kretanje-&gt;karta.boja == Boje::Tref) element_steka.first = "Tref";
        else if(kretanje-&gt;karta.boja == Boje::Herc) element_steka.first = "Herc";
        else element_steka.first = "Karo";
        element_steka.second = kretanje-&gt;karta.vrijednost;
        stek.push(element_steka);
        if (kretanje == pocetakspila ) {
            if(pocetakspila == pocetakspila-&gt;sljedeci) {
                delete pocetakspila;
                pocetakspila = nullptr;
            }
            else {
                pocetakspila = pocetakspila-&gt;sljedeci;
                kraj-&gt;sljedeci = pocetakspila;
                delete novi;
                novi = pocetakspila;
                kretanje = pocetakspila;
                broj_izbacenih++;
            }
        }
        else {
            auto prethodnik = pocetakspila;
            while (prethodnik-&gt;sljedeci != kretanje) prethodnik = prethodnik-&gt;sljedeci;
            if(kretanje-&gt;sljedeci == pocetakspila) kraj = prethodnik;
            prethodnik-&gt;sljedeci = kretanje-&gt;sljedeci;
            kretanje-&gt;sljedeci = nullptr;
            delete kretanje;
            broj_izbacenih++;
            kretanje = prethodnik-&gt;sljedeci;                
        }
    }
    return stek;
}


void NeispravneKarte(const std::stack&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;stek)
{
    auto pomocni = stek;
    while( !pomocni.empty()) {
        std::pair&lt;std::string, std::string&gt; p = pomocni.top();
        if (p.first != "Pik" &amp;&amp; p.first != "Tref" &amp;&amp; p.first != "Herc" &amp;&amp; p.first != "Karo") throw std::logic_error("Neispravne karte!");
        bool smislen = false;
        for( int i = 0; i &lt; NazivKarata.size(); i++) {
            if( NazivKarata.at(i) == p.second) smislen = true;
        }
        if ( smislen == false) throw std::logic_error("Neispravne karte!");
        pomocni.pop();
    }
}

std::string IspisiBoju(Boje b) {
    if(b == Boje::Pik) return "Pik ";
    else if(b == Boje::Tref) return "Tref ";
    else if(b == Boje::Herc) return "Herc ";
    else return "Karo ";
}

<a name="0"></a><font color="#FF0000"><a href="match760-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

void VratiPosljednjihNKarata(Cvor* &amp;pocetakspila, std::stack&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;stek, int n)
{
    if (n  &lt; 0) throw std::domain_error("Broj n je besmislen!");
    if (n &gt; stek.size()) throw std::range_error("Nedovoljno karata u steku!");
</font>    NeispravneKarte(stek);
    std::pair&lt;std::string, std::string&gt; p;
    for( int i = 0; i &lt; n; i++) {
        p = stek.top();
        stek.pop();
        std::pair&lt;Boje, std::string&gt; pomocni;
        try {
            Cvor* novakarta = new Cvor;
            if(p.first == "Pik")  novakarta-&gt;karta.boja = Boje::Pik;
            else if(p.first == "Tref")  novakarta-&gt;karta.boja = Boje::Tref;
            else if(p.first == "Karo") novakarta-&gt;karta.boja = Boje::Karo;
            else novakarta-&gt;karta.boja = Boje::Herc;
            for( int j = 0; j &lt; NazivKarata.size(); j++) {
                if ( p.second == NazivKarata.at(j)) novakarta-&gt;karta.vrijednost = NazivKarata.at(j);
            }
            //ako se u spilu vec nalazi karta novakarta, ignorisati je, ne ubacivati nazad;
            bool ubacena(false);
            if(pocetakspila != nullptr) {
                auto kraj = pocetakspila;
                while(kraj-&gt;sljedeci != pocetakspila) kraj = kraj-&gt;sljedeci;
                if(kraj-&gt;karta.boja == novakarta-&gt;karta.boja &amp;&amp; kraj-&gt;karta.vrijednost == novakarta-&gt;karta.vrijednost){
                    delete novakarta;
                    continue;
                } 
                for(auto kretanje = pocetakspila; kretanje-&gt;sljedeci != pocetakspila; kretanje = kretanje-&gt;sljedeci) {
                    if (kretanje-&gt;karta.boja ==  novakarta-&gt;karta.boja &amp;&amp; kretanje-&gt;karta.vrijednost == novakarta-&gt;karta.vrijednost){
                        delete novakarta;
                        continue;
                    }
                }
                //posto petlja ispod nece ici do kraja spila potrebno je posebno provjeriti zadnju kartu
                for(auto kretanje = pocetakspila;  kretanje-&gt;sljedeci != pocetakspila; kretanje = kretanje-&gt;sljedeci) {
                    ubacena = false;
                    if( novakarta-&gt;karta.boja &gt; kretanje-&gt;karta.boja) continue;
                    else if(kretanje-&gt;sljedeci != pocetakspila &amp;&amp; novakarta-&gt;karta.boja == kretanje-&gt;karta.boja) {
                        auto novakartait = std::find(NazivKarata.begin(), NazivKarata.end(), novakarta-&gt;karta.vrijednost);
                        //ubacena = false;
                        auto kretanjekrozboje(kretanje);
                        int kruzenje(0);
                        for(kretanjekrozboje = kretanje; kretanjekrozboje-&gt;karta.boja == kretanje-&gt;karta.boja; kretanjekrozboje = kretanjekrozboje-&gt;sljedeci) { // ova petlja će biti beskonačna ako se u špilu nalaze karte samo jedne boje pa se trebamo zaštiti od toga
                            if(kretanjekrozboje == kretanje) kruzenje++;
                            if(kruzenje &gt; 1) break; // ako je kruzenje naislo na pocetnu kartu vise od jednom, petlja se izvrsila vec jednom citava i ne treba ponovo
                            auto kretanjekrozbojeit = std::find(NazivKarata.begin(), NazivKarata.end(), kretanjekrozboje-&gt;karta.vrijednost);
                            if ( novakartait &gt; kretanjekrozbojeit ) continue;
                            // kada dođemo ispod ovog ifa kretanje kroz boje pokazuje na kartu koja treba biti nakon one što se ubacuje, pa trebamo naći prethodnika radi uvezivanja
                            auto prethodnik(pocetakspila);
                            while(prethodnik-&gt;sljedeci != kretanjekrozboje) prethodnik = prethodnik-&gt;sljedeci;
                            //ubacivanje karte
                            if(prethodnik-&gt;karta.boja &gt; novakarta-&gt;karta.boja) pocetakspila = novakarta; // ako je boja karte koja dolazi prije karte koja se ubacuje veca od nje same, znaci da se karta ubacuje na pocetak
                            novakarta-&gt;sljedeci = kretanjekrozboje;
                            prethodnik-&gt;sljedeci = novakarta;
                            ubacena = true;
                            break;
                        }
                        if(ubacena == false) {
                            //ubacvanje karte
                            // ponovo tražimo prethodnu kartu
                            auto prethodnik(pocetakspila);
                            while(prethodnik-&gt;sljedeci != kretanjekrozboje) prethodnik = prethodnik-&gt;sljedeci;
                            if(prethodnik-&gt;karta.boja &gt; novakarta-&gt;karta.boja) pocetakspila = novakarta;
                            novakarta-&gt;sljedeci = kretanjekrozboje;
                            prethodnik-&gt;sljedeci = novakarta;
                            ubacena = true;
                            break;
                        }
                    } 
                    if(ubacena) break;
                    else if(kretanje-&gt;sljedeci == pocetakspila || novakarta-&gt;karta.boja &lt; kretanje-&gt;karta.boja) {
                        //ubaci
                        // ponovo tražimo prethodnu kartu
                        auto prethodnik(pocetakspila);
                        while(prethodnik-&gt;sljedeci != kretanje) prethodnik = prethodnik-&gt;sljedeci; 
                        if(prethodnik-&gt;karta.boja &gt; novakarta-&gt;karta.boja) pocetakspila = novakarta;
                        novakarta-&gt;sljedeci = kretanje;
                        prethodnik-&gt;sljedeci = novakarta;
                        ubacena = true;
                        break;
                    }
                }
            }
            if(ubacena == false) {
                if(pocetakspila == nullptr) { // ako u spilu nije bila nijedna karta nasa karta je pocetak 
                    pocetakspila = novakarta;
                    pocetakspila-&gt;sljedeci = pocetakspila;
                }
                else if(pocetakspila == pocetakspila-&gt;sljedeci) { // ako je u spilu bila samo jedna karta petlja se nikad nije pokrenula i trebamo vidjeti gdje tu kartu ubacujemo
                    pocetakspila-&gt;sljedeci = novakarta;
                    novakarta-&gt;sljedeci = pocetakspila;
                    // dvije karte koje ce biti u spilu svakako ce biti medjusobno povezane, samo jos treba provjeriti gdje treba da bude pocetak
                    if(novakarta-&gt;karta.boja &lt; pocetakspila-&gt;karta.boja) pocetakspila = novakarta; // ako se ubacuje npr pik a u spilu smo imali samo karo, pik treba postati pocetak spila
                    else if(novakarta-&gt;karta.boja == pocetakspila-&gt;karta.boja) { // ako su karte iste boje porede im se pozicije
                        auto novakartait = std::find(NazivKarata.begin(), NazivKarata.end(), novakarta-&gt;karta.vrijednost);
                        auto prisutnakartait = std::find(NazivKarata.begin(), NazivKarata.end(), pocetakspila-&gt;karta.vrijednost);
                        if(novakartait &lt; prisutnakartait) pocetakspila = novakarta;
                        // iteratori ne mogu biti jednaki a ako je nova veca onda pocetak treba ostati gdje je bio
                    }
                    // na kraju, ako je boja nove karte veca od boje karte koja je vec bila tu pocetak treba ostati gdje je bio (na onoj koja je vec bila tu)
                }
            }
        }
        catch(...) {
            throw;
        }
    }
}
int BrojKarataUSpilu(Cvor* pocetak){
    int broj(1);
    if(pocetak == nullptr) return 0;
    else if(pocetak-&gt;sljedeci == pocetak) return 1;
    for( auto kretanje = pocetak; kretanje-&gt;sljedeci != pocetak; kretanje = kretanje-&gt;sljedeci){
        broj++;
    }
    return broj;
   
}

void UnistiSpil(Cvor* pocetakspila)
{
    if (pocetakspila == nullptr) return;
    auto pomocni = pocetakspila;
    while(pocetakspila-&gt;sljedeci != pomocni) {
        while ( pomocni-&gt;sljedeci != pocetakspila) {
            pomocni = pomocni -&gt; sljedeci;
        }
        pomocni-&gt;sljedeci = pocetakspila-&gt;sljedeci;
        pocetakspila-&gt;sljedeci = nullptr;
        delete pocetakspila;
        pocetakspila = pomocni -&gt; sljedeci;
    }
    pocetakspila-&gt;sljedeci = nullptr;
    pomocni-&gt;sljedeci = nullptr;
    if(pocetakspila == pomocni) {
        delete pocetakspila;
        pocetakspila = nullptr;
        pomocni = nullptr;
    }
    delete pocetakspila;
    delete pomocni;
}

int main ()
{
    Cvor *pocetak = nullptr;
    try {
        pocetak = KreirajSpil();
        auto pok = pocetak;
        short int r;
        std::cout&lt;&lt;"Unesite korak razbrajanja: ";
        std::cin&gt;&gt;r;
        int b;
<a name="1"></a><font color="#00FF00"><a href="match760-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

        std::cout&lt;&lt;"Unesite broj karata koje zelite izbaciti: ";
        std::cin&gt;&gt;b;
        std::stack&lt;std::pair&lt;std::string, std::string&gt;&gt;stek;
</font>        stek = IzbaciKarteRazbrajanjem(pocetak,r,b);
        std::cout&lt;&lt;"U spilu trenutno ima "&lt;&lt;BrojKarataUSpilu(pocetak)&lt;&lt;" karata, i to:"&lt;&lt;std::endl;
        std::cout &lt;&lt; "Pik: ";
        for(pok = pocetak; pok != nullptr &amp;&amp; pok-&gt;sljedeci != pocetak; pok = pok-&gt;sljedeci) {
            if(pok-&gt;karta.boja == Boje::Pik) std::cout &lt;&lt; pok-&gt;karta.vrijednost &lt;&lt; " ";
        }
        if(pok != nullptr &amp;&amp; pok-&gt;karta.boja == Boje::Pik) std::cout &lt;&lt; pok-&gt;karta.vrijednost;
        std::cout &lt;&lt; std::endl &lt;&lt; "Tref: ";
        for(pok = pocetak; pok != nullptr &amp;&amp; pok-&gt;sljedeci != pocetak; pok = pok-&gt;sljedeci) {
            if(pok-&gt;karta.boja == Boje::Tref) std::cout &lt;&lt; pok-&gt;karta.vrijednost &lt;&lt; " ";
        }
        if(pok != nullptr &amp;&amp; pok-&gt;karta.boja == Boje::Tref) std::cout &lt;&lt; pok-&gt;karta.vrijednost;
        std::cout &lt;&lt; std::endl &lt;&lt; "Herc: ";
        for(pok = pocetak; pok != nullptr &amp;&amp; pok-&gt;sljedeci != pocetak; pok = pok-&gt;sljedeci) {
            if(pok-&gt;karta.boja == Boje::Herc) std::cout &lt;&lt; pok-&gt;karta.vrijednost &lt;&lt; " ";
        }
        if(pok != nullptr &amp;&amp; pok-&gt;karta.boja == Boje::Herc) std::cout &lt;&lt; pok-&gt;karta.vrijednost;
        std::cout &lt;&lt; std::endl &lt;&lt; "Karo: ";
        for(pok = pocetak; pok != nullptr &amp;&amp; pok-&gt;sljedeci != pocetak; pok = pok-&gt;sljedeci) {
            if(pok-&gt;karta.boja == Boje::Karo) std::cout &lt;&lt; pok-&gt;karta.vrijednost &lt;&lt; " ";
        }
        if(pok != nullptr &amp;&amp; pok-&gt;karta.boja == Boje::Karo) std::cout &lt;&lt; pok-&gt;karta.vrijednost;
        
        int n;
        std::cout&lt;&lt;std::endl;
<a name="2"></a><font color="#0000FF"><a href="match760-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

        std::cout&lt;&lt;"Unesite broj karata koje zelite vratiti u spil: ";
        std::cin&gt;&gt;n;
        VratiPosljednjihNKarata(pocetak,stek,n);
        std::cout&lt;&lt;"U spilu trenutno ima "&lt;&lt;BrojKarataUSpilu(pocetak)&lt;&lt;" karata, i to:"&lt;&lt;std::endl;
</font>        pok = pocetak;
        
        std::cout&lt;&lt;"Pik: ";
        for(pok = pocetak; pok!= nullptr &amp;&amp; pok-&gt;sljedeci != pocetak; pok = pok-&gt;sljedeci){
            if(pok-&gt;karta.boja == Boje::Pik) std::cout&lt;&lt; pok-&gt;karta.vrijednost&lt;&lt;" ";
        }
        if(pok != nullptr &amp;&amp; pok-&gt;karta.boja == Boje::Pik) std::cout&lt;&lt; pok-&gt;karta.vrijednost&lt;&lt;" ";
        std::cout&lt;&lt;std::endl&lt;&lt;"Tref: ";
        for(pok = pocetak; pok != nullptr &amp;&amp; pok-&gt;sljedeci != pocetak; pok = pok-&gt;sljedeci){
            if(pok-&gt;karta.boja == Boje::Tref) std::cout&lt;&lt;pok-&gt;karta.vrijednost&lt;&lt;" ";
        }
        if(pok != nullptr &amp;&amp; pok-&gt;karta.boja == Boje::Tref) std::cout&lt;&lt;pok-&gt;karta.vrijednost&lt;&lt;" ";
        std::cout&lt;&lt;std::endl&lt;&lt;"Herc: ";
        for(pok = pocetak; pok != nullptr &amp;&amp; pok-&gt;sljedeci != pocetak; pok = pok-&gt;sljedeci){
            if(pok-&gt;karta.boja == Boje::Herc) std::cout&lt;&lt;pok-&gt;karta.vrijednost&lt;&lt;" ";
        }
        if(pok != nullptr &amp;&amp; pok-&gt;karta.boja == Boje::Herc) std::cout&lt;&lt;pok-&gt;karta.vrijednost&lt;&lt;" ";
        std::cout&lt;&lt;std::endl&lt;&lt;"Karo: ";
        for(pok = pocetak; pok != nullptr &amp;&amp; pok-&gt;sljedeci != pocetak; pok = pok-&gt;sljedeci){
            if(pok-&gt;karta.boja == Boje::Karo) std::cout&lt;&lt;pok-&gt;karta.vrijednost&lt;&lt;" ";
        }
<a name="3"></a><font color="#00FFFF"><a href="match760-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

        if(pok != nullptr &amp;&amp; pok-&gt;karta.boja == Boje::Karo) std::cout&lt;&lt;pok-&gt;karta.vrijednost&lt;&lt;" ";
        
    }catch(std::domain_error e){
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
    }
    catch(std::range_error e){
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
</font>    }
    catch(std::logic_error e) {
        std::cout &lt;&lt;"Izuzetak: "&lt;&lt;e.what();
    }
    
    UnistiSpil(pocetak);
    
    return 0;
}
</pre>
</body>
</html>
