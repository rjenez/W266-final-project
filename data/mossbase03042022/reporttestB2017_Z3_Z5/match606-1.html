<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student1093.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student1066.cpp<p></p><pre>
/B2017/2018: Zadaća 3, Zadatak 5// Kopirao sam kod iz zadatka 4 u zadatak 5, također sam vrsio dosta copy-paste u programu jer nisam imao vremena sve fino ispisivati
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;stdexcept&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;stack&gt;

enum class Boje
{
    Pik,Tref, Herc, Karo
};

typedef std::stack&lt;std::pair&lt;Boje, std::string&gt;&gt; StekKarata;

struct Karta {
    Boje boja;
    std::string vrijednost;
};

struct Cvor {
    Karta karta;
    Cvor *sljedeci;
};

Boje BojaKarte (int boja)
{
    if (boja==0)
        return Boje::Pik;
    else if (boja==1)
        return Boje::Tref;
    else if (boja==2)
        return Boje::Herc;
    return Boje::Karo;
}

std::string BrojKarte (int broj)
{
    if (broj==1)
        return "A";
    else if (broj&gt;=2 &amp;&amp; broj&lt;=10)
        return std::to_string(broj);
    else if (broj==11)
        return "J";
    else if (broj==12)
        return "Q";
    return "K";
}

Cvor *KreirajSpil ()
{
    Cvor *pocetak(nullptr),*prethodni;
    int boja(0),karte;     // karta je trnuetni broj/slovo karte u spilu (11=J, 12=Q, 13=K, 1=A)
    for (int j = 0; j&lt;52; j=j+13) {    // Ova petlja ce se izvrsiti 4 puta za svaku boju respektivvno
        karte=2;
        for (int i = j; i&lt;13+j; i++) {
            if (i==(12+j)) karte=1;      // Ovom naredbom postavljam Asa na zadnje mjesto u listi
            Karta karta({BojaKarte(boja),BrojKarte(karte)});
            Cvor *novi (new Cvor {karta,nullptr}); // Postavljam prvi član na trenutnu boju  // Postavljam drugi član na trenutni broj/slovo karte
            if (!pocetak) pocetak=novi;
            else prethodni-&gt;sljedeci=novi;
            prethodni=novi;
            karte++;
        }
        if (j==39) prethodni-&gt;sljedeci = pocetak;  // povezujem kraj i pocetak
        boja++;   // boja moze biti 0,1,2,3
    }
    return pocetak;
}

Cvor *ZadnjiCvor (Cvor *pocetak)
{
    if (pocetak==pocetak-&gt;sljedeci) return pocetak;
    Cvor *drugi(pocetak-&gt;sljedeci);
    while (1) {
        if (pocetak==drugi-&gt;sljedeci) break;
        drugi=drugi-&gt;sljedeci;
    }
    return drugi;
}

int DuzinaSpila (Cvor *pocetak)
{
    if (!pocetak) return 0;
    int broj_karata(0);
    for (Cvor *p=pocetak; ; p=p-&gt;sljedeci) {
        if (p==ZadnjiCvor(pocetak)) {
            broj_karata++;
            break;
        }
        broj_karata++;
    }
    return broj_karata;
}

void UnistiSpil (Cvor *pocetak)
{
    for (Cvor *p=pocetak-&gt;sljedeci; p!=pocetak; ) {   // postavim da p pokazuje na sljedeci cvor pa na kraju brisem taj cvor
        Cvor *pomoc(p-&gt;sljedeci);
        delete p;
        p=pomoc;
    }
    delete pocetak;
}

void SortirajSpil(Cvor *&amp;pocetak)
{  // Ovdje sam koristio ideju da prvo pretvorim clanove spila koji nisu po redu ASCII tabele da budu po redu ASCII tabele
    int i(0);
    Cvor *pomoc1;
    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci) {
        if (p-&gt;karta.vrijednost=="A") { p-&gt;karta.vrijednost="F"; pomoc1=p; }
        else if (p-&gt;karta.vrijednost=="K") p-&gt;karta.vrijednost="E";
        else if (p-&gt;karta.vrijednost=="Q") p-&gt;karta.vrijednost="D";
        else if (p-&gt;karta.vrijednost=="J") p-&gt;karta.vrijednost="C";
        else if (p-&gt;karta.vrijednost=="10") p-&gt;karta.vrijednost="B";
        i++;
    } // Posto su sada sigurno clanovi spila od 2 do Asa poredani po velicini od najmanjeg to najveced po Ascii tabeli onda ih mogu sortirati
    i=0;
    Karta pomoc;
    pomoc=pomoc1-&gt;karta;
    pomoc1-&gt;karta=ZadnjiCvor(pocetak)-&gt;karta;
    ZadnjiCvor(pocetak)-&gt;karta=pomoc;

    for (Cvor *p=pocetak; p-&gt;sljedeci != pocetak; p=p-&gt;sljedeci){
        for (Cvor *selekcija = p-&gt;sljedeci; selekcija-&gt;sljedeci!=pocetak; selekcija=selekcija-&gt;sljedeci){
            if (p-&gt;karta.vrijednost &gt; selekcija-&gt;karta.vrijednost){
                Karta temp(p-&gt;karta);
                p-&gt;karta=selekcija-&gt;karta;
                selekcija-&gt;karta=temp;
            }
        }
    }
    i=0;
    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci) {   // Sada vracam nazad nazive clanova spila na prvobitnu vrijednost
        if(p-&gt;karta.vrijednost=="F") p-&gt;karta.vrijednost="A";
        else if (p-&gt;karta.vrijednost=="E") p-&gt;karta.vrijednost="K";
        else if (p-&gt;karta.vrijednost=="D") p-&gt;karta.vrijednost="Q";
        else if (p-&gt;karta.vrijednost=="C") p-&gt;karta.vrijednost="J";
        else if (p-&gt;karta.vrijednost=="B") p-&gt;karta.vrijednost="10";
        i++;
    }
    /*
    std::cout&lt;&lt;"Nakon sortiranja"&lt;&lt;std::endl;
    i=0;
    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci){
        std::cout&lt;&lt;"Boja: "&lt;&lt;int(p-&gt;karta.boja)&lt;&lt;" vrijednost: "&lt;&lt;p-&gt;karta.vrijednost&lt;&lt;std::endl;
        i++;
    }*/
} // Sortira spil

void IzuzetakZaSpil (Cvor *pocetak) // Baca izuzetak u slucaju da spil na neki nacin ne valja
{
    if (DuzinaSpila(pocetak)&gt;52) throw std::logic_error ("Neispravna lista!");
    int i (0);
    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci) {
        if (p-&gt;karta.boja !=Boje::Pik &amp;&amp; p-&gt;karta.boja !=Boje::Tref &amp;&amp; p-&gt;karta.boja!=Boje::Herc &amp;&amp; p-&gt;karta.boja!=Boje::Karo)  // U slucaju da neka od Boja nija kako treba
            throw std::logic_error ("Neispravna lista!");
        if (!((p-&gt;karta.vrijednost&gt;="2" &amp;&amp; p-&gt;karta.vrijednost&lt;="9") || p-&gt;karta.vrijednost=="10" || p-&gt;karta.vrijednost=="J" || p-&gt;karta.vrijednost=="Q" || p-&gt;karta.vrijednost=="K" || p-&gt;karta.vrijednost=="A")) // u slucaju da ima element spila koji nije kako treba
            throw std::logic_error ("Neispravna lista!");
            i++;
    }
}

void IzbaciKarte (Cvor *&amp;pocetak, std::multimap&lt;Boje,std::string&gt; &amp;multimapa)
{
    IzuzetakZaSpil(pocetak);  // provjerava da li je spil sortiran
    std::multimap&lt;Boje,std::string&gt;::iterator it_mape(multimapa.begin());
    Cvor *prethodni=ZadnjiCvor(pocetak);
    int i(0);
    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak)+1; p=p-&gt;sljedeci) {
        while (it_mape!=multimapa.end()) {
            if (p-&gt;karta.boja==(*it_mape).first &amp;&amp; p-&gt;karta.vrijednost==it_mape-&gt;second) {  // brise element ukoliko je element mape isti kao i element spila
                std::pair&lt;Boje, std::string&gt; uljez {p-&gt;karta.boja,p-&gt;karta.vrijednost};    // uljez je element koji treba brisati

                if (p==pocetak) pocetak=prethodni; // u slucaju da se izbaci prva karta
                prethodni-&gt;sljedeci=p-&gt;sljedeci; // prethodni postaje sljedeci a trenutni p se brise i p postaje prethodni
                delete p;
                p=prethodni;

                it_mape=multimapa.begin();
                while (it_mape!=multimapa.end()) {  // while petlja koja brise sve elemente iz mape koji su uljezi
                    if (it_mape-&gt;first==uljez.first &amp;&amp; it_mape-&gt;second==uljez.second) {
                        it_mape=multimapa.erase(it_mape);   // brise element koji je uljez i uzima iterator na sebe koji poljae erase
                        break;

                    }
                    it_mape++;
                }
                break;
            }
            it_mape++;
        }
        it_mape=multimapa.begin();
        prethodni=p;
        i++;
    }
}

int Distanca (Cvor *pocetak, Cvor *kraj)
{
    int x(1);
    while (pocetak!=kraj) {
        x++;
        pocetak=pocetak-&gt;sljedeci;
    }
    return x;
}

StekKarata IzbaciKarteRazbrajanjem (Cvor *&amp;pocetak,const short int &amp;korak, const int &amp;izbaci)
{
    //IzuzetakZaSpil(spil);
    if (korak&lt;=0 || korak&gt;52 || izbaci&lt;1){ 
        UnistiSpil(pocetak);
        throw std::logic_error ("Neispravni elementi za izbacivanje!");
    }
    int broj_izbacenih(0);
    StekKarata izbacene;
    Cvor *prethodni=ZadnjiCvor(pocetak);
    for (Cvor *p=pocetak; ; p=p-&gt;sljedeci) {
        int distanca(Distanca(p,ZadnjiCvor(pocetak)));    // Distanca sluzi ako je korak dosao do onog mjesta u spilu kada se sve vraca nazad na pocetak
        if (distanca&lt;korak) {
            p=pocetak;
            // novi_korak je korak kada ostane visak na kraju liste pa se vratimo na pocetak
            int novi_korak(korak-distanca-1);
            if (novi_korak&gt;=DuzinaSpila(pocetak)) novi_korak=(novi_korak%DuzinaSpila(pocetak)); // u slucaju da je novi korak veci od velicine liste onda on trena biti ostatak pri djeljunju samog sebe sa trenutno velicinom liste

            for (int i = 0; i&lt;novi_korak; p=p-&gt;sljedeci){
                if (i==(novi_korak-1)) prethodni = p;
                i++;
            }

            if (DuzinaSpila(pocetak)==1) {  // ukoliko je ostala zadnja karta u spilu ubacujem tu kartu u red i postavljam velicinu spila na nulu
                izbacene.push({pocetak-&gt;karta.boja,pocetak-&gt;karta.vrijednost});
                std::cout&lt;&lt;"1 je";
                break;
            }
            
            izbacene.push({p-&gt;karta.boja,p-&gt;karta.vrijednost});  // ubacujem u red kartu
            
            bool b(false);
            if (p==pocetak) { b=true; pocetak=prethodni; } // u slucaju da se izbaci prva karta
            prethodni-&gt;sljedeci=p-&gt;sljedeci; // prethodni postaje sljedeci a trenutni p se brise i p postaje prethodni
            delete p;
            p=prethodni;
             if (b &amp;&amp; pocetak!=ZadnjiCvor(pocetak)) pocetak=prethodni-&gt;sljedeci;
            broj_izbacenih++;
            prethodni=p;
            if (broj_izbacenih==izbaci) break;
            continue;
        }

        for (int i = 0; i&lt;(korak-1); p=p-&gt;sljedeci) {
            if (i==(korak-2)) prethodni=p;
            i++;
        } // ekvivalent funkcije advance
        if (DuzinaSpila(pocetak)==1) {pocetak-&gt;karta.vrijednost=""; pocetak=nullptr; break; } 

        izbacene.push({p-&gt;karta.boja,p-&gt;karta.vrijednost});
        bool a(false);
        if (p==pocetak){ a=true; pocetak=prethodni;} // u slucaju da se izbaci prva karta
        prethodni-&gt;sljedeci=p-&gt;sljedeci; // prethodni postaje sljedeci a trenutni p se brise i p postaje prethodni
        delete p;
        p=prethodni;
        if (a &amp;&amp; pocetak!=ZadnjiCvor(pocetak)) pocetak=prethodni-&gt;sljedeci;
        broj_izbacenih++;
        prethodni=p;
        if (broj_izbacenih==izbaci)
             break;
    }
    return izbacene;
}

void IzuzetakZaStek (StekKarata stek)
{
    while (!stek.empty()){
        if (stek.top().first!=Boje::Pik &amp;&amp; stek.top().first!=Boje::Tref &amp;&amp; stek.top().first!=Boje::Herc &amp;&amp; stek.top().first!=Boje::Karo)
        throw std::logic_error ("Neispravne karte!");
        if (!((stek.top().second&gt;="2" &amp;&amp; stek.top().second&lt;="9") || stek.top().second=="10" || stek.top().second=="J" || stek.top().second=="Q" || stek.top().second=="K" || stek.top().second=="A"))
            throw std::logic_error ("Neispravne karte!");
            stek.pop();
        }
} // Baca izutezak u slucaju da red karata ima kartu koja ne valja

bool NemaJeUListi (Cvor *pocetak, std::pair&lt;Boje, std::string&gt; karta)
{
    int i(0);
    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci){
        if (p-&gt;karta.boja==karta.first &amp;&amp; p-&gt;karta.vrijednost==karta.second) return false;
        i++;
    }
        return true;
} // Funkcija koja provjerava da li se neka karta nalazi u spilu

void VratiPosljednjihNKarata (Cvor *&amp;pocetak, StekKarata &amp;stek, int n)
{
    if (n&lt;0) {
        UnistiSpil(pocetak);
        throw std::domain_error ("Broj n je besmislen!");
    }
    else if (n&gt;stek.size()){
    UnistiSpil(pocetak);
     throw std::range_error ("Nedovoljno karata u steku!");
    }
    IzuzetakZaStek(stek);
    //IzuzetakZaSpil(spil);
    if (n==0) return; // u slucaju da ne treba vratiti ni jednu karti samo prekini funkciju

    int i(0);
    Cvor *p(pocetak),*prethodni(ZadnjiCvor(pocetak));
    while (i&lt;n) {
        while (NemaJeUListi(pocetak,stek.top())) {
            Karta karta ({stek.top().first,stek.top().second});
            Cvor *novi(new Cvor {karta,nullptr});
           // Cvor* pomoc(p);
            
            prethodni-&gt;sljedeci=novi;
            novi-&gt;sljedeci=p;
            prethodni=p;
            p=p-&gt;sljedeci;
        }
        i++;
        stek.pop();  // brisi element sa pocetka reda
    }
    /*
    i=0;
    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci){
        std::cout&lt;&lt;"Boja: "&lt;&lt;int(p-&gt;karta.boja)&lt;&lt;" vrijednost: "&lt;&lt;p-&gt;karta.vrijednost&lt;&lt;std::endl;
        i++;
    }*/
    //std::cout&lt;&lt;std::endl;
    SortirajSpil(pocetak); // sortira spil
}

void IspisiSpil (Cvor *pocetak)
{
    std::cout&lt;&lt;"U spilu trenutno ima "&lt;&lt;DuzinaSpila(pocetak)&lt;&lt;" karata, i to:\n";
    std::cout&lt;&lt;"Pik: ";
    int i(0);
<a name="1"></a><font color="#00FF00"><a href="match606-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci) {
        if (p-&gt;karta.boja==Boje::Pik) std::cout&lt;&lt;p-&gt;karta.vrijednost&lt;&lt;" ";
</font>        i++;
    }

    std::cout&lt;&lt;"\nTref: ";
    i=0;
<a name="2"></a><font color="#0000FF"><a href="match606-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci) {
        if (p-&gt;karta.boja==Boje::Tref) std::cout&lt;&lt;p-&gt;karta.vrijednost&lt;&lt;" ";
</font>        i++;
    }

    std::cout&lt;&lt;"\nHerc: ";
    i=0;
<a name="3"></a><font color="#00FFFF"><a href="match606-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci) {
        if (p-&gt;karta.boja==Boje::Herc) std::cout&lt;&lt;p-&gt;karta.vrijednost&lt;&lt;" ";
</font>        i++;
    }
    i=0;
    std::cout&lt;&lt;"\nKaro: ";
<a name="4"></a><font color="#FF00FF"><a href="match606-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    for (Cvor *p=pocetak; i&lt;DuzinaSpila(pocetak); p=p-&gt;sljedeci) {
        if (p-&gt;karta.boja==Boje::Karo) std::cout&lt;&lt;p-&gt;karta.vrijednost&lt;&lt;" ";
</font>        i++;
    }
} // Ispisuje spil

int main ()
{
    try {
            short int korak;
            std::cout&lt;&lt;"Unesite korak razbrajanja: ";
            std::cin&gt;&gt;korak;
            std::cout&lt;&lt;"Unesite broj karata koje zelite izbaciti: ";
            int n;
            std::cin&gt;&gt;n;
            Cvor *spil(KreirajSpil());
            auto stek(IzbaciKarteRazbrajanjem(spil,korak,n));
            IspisiSpil(spil);
            std::cout&lt;&lt;"\nUnesite broj karata koje zelite vratiti u spil: ";
            int k;
            std::cin&gt;&gt;k;
            VratiPosljednjihNKarata(spil,stek,k);
            IspisiSpil(spil);
            UnistiSpil(spil);
    } catch (std::domain_error izuzetak) {
<a name="0"></a><font color="#FF0000"><a href="match606-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
    } catch (std::logic_error izuzetak) {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
    } catch (std::range_error izuzetak) {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
</font>    }

    return 0;
}
</pre>
</body>
</html>
