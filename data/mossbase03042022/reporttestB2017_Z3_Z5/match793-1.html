<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student9325.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z5/student8257.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 5
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;stack&gt;
#include &lt;iterator&gt;

using std::pair;
using std::vector;
using std::string;
using std::multimap;
using std::stack;

enum class Boje {Pik, Tref , Herc , Karo};

vector&lt;string&gt; nazivi {"Pik","Tref","Herc","Karo"};
<a name="1"></a><font color="#00FF00"><a href="match793-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

vector&lt;string&gt; v {"2","3","4","5","6","7","8","9","10","J","Q","K","A"};

struct Karta {
  Boje boja;
</font>  string vrijednost;
};

struct Cvor {
  Karta karta;
  Cvor* sljedeci;
};

void IspisiKarte(Cvor *prviCvor);

void IspisiStek(stack&lt;pair&lt;string,string&gt;&gt; stek) {
    while(!stek.empty()) {
        auto karta = stek.top();
        std::cout&lt;&lt;karta.first&lt;&lt;"-"&lt;&lt;karta.second&lt;&lt;" ";
        stek.pop();
    }
}

int brojKarata(Cvor *prviCvor) {
    if(prviCvor==nullptr) return 0;
    int broj=1;
    auto p = prviCvor;
    while(true) {
        p=p-&gt;sljedeci;
        if(p==prviCvor) break;
        broj++;
    }
    return broj;
}

bool postojiUSpilu(Cvor *prviCvor , pair&lt;Boje,string&gt; karta) {
    auto p = prviCvor;
    for(int i=0;i&lt;brojKarata(prviCvor);i++) {
        if((p-&gt;karta).boja == karta.first &amp;&amp; (p-&gt;karta).vrijednost == karta.second) 
            return true;
        p=p-&gt;sljedeci;
    }
    return false;
}


Cvor *KreirajSpil() {
    Cvor *pocetak = nullptr , *prethodni;
        for(int i=0;i&lt;nazivi.size();i++) {
            for(int j=0;j&lt;v.size();j++) {
<a name="0"></a><font color="#FF0000"><a href="match793-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

                Cvor* novi = new Cvor{Karta{Boje(i),v.at(j)},nullptr};
                if(pocetak==nullptr) pocetak = novi;      // Samo za pocetni cvor
                else prethodni-&gt;sljedeci = novi;        // veza izmedju dva cvora
                prethodni = novi;
            }
        }
        prethodni-&gt;sljedeci = pocetak;       // Zadnji element pokazuje na pocetak (kruzna lista)
        return pocetak;
}

void IspravnostSpila(Cvor *prviCvor) {
</font>    if(prviCvor == nullptr) return;
    int brKarata = 0;
    auto prethodna = prviCvor;
    auto p = prviCvor;
    for(int i=0;i&lt;brojKarata(prviCvor);i++) {
        p=p-&gt;sljedeci;
        brKarata++;
        // Ako su podaci liste besmisleni (Program ce dozvoliti samo da vrijednost karte bude besmislena)
        if(std::count(v.begin(),v.end(),(p-&gt;karta).vrijednost)==0)
            throw std::logic_error("Neispravna lista!");
        if(brKarata&gt;52) throw std::logic_error("Neispravna lista!"); 
        if(int((prethodna-&gt;karta).boja) &gt; int((p-&gt;karta).boja) || 
<a name="3"></a><font color="#00FFFF"><a href="match793-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

            ((std::find(v.begin(),v.end(),(prethodna-&gt;karta).vrijednost)) &gt; std::find(v.begin(),v.end(),(p-&gt;karta).vrijednost) &amp;&amp; int((prethodna-&gt;karta).boja)==int((p-&gt;karta).boja))) 
</font>            throw std::logic_error("Neispravna list3!");
    }
        
}

void IzbaciKarte(Cvor *&amp;prviCvor, multimap&lt;Boje,string&gt; &amp;m) {
    IspravnostSpila(prviCvor);
    auto prethodna = prviCvor;
    auto p = prviCvor;              // Pokazivac sa kojim cemo se kretati kroz listu
    while(true) {
        p = p-&gt;sljedeci;
        bool postoji = false;
        auto it = m.begin();     // Za svaku kartu u listi, pretrazujem mapu
        while(it!=m.end()) {
            if(it-&gt;first == (p-&gt;karta).boja &amp;&amp; it-&gt;second == (p-&gt;karta).vrijednost){                // Ako postoji karta iz liste u mapi , izbrisi je u mapi
                it = m.erase(it);
                postoji = true;
            }
            else it++;
        }
        if(postoji) {   // Ako karta postoji u multimapi, treba je izbaciti iz liste
            if(p == p-&gt;sljedeci) {                   // Ako brisem zadnju preostalu kartu iz liste 
                delete p;
                prviCvor = nullptr;
                break;                              // izadji iz petlje kad se isprazni lista
            }
            else {                              
                prethodna-&gt;sljedeci = p-&gt;sljedeci;      // preusmjeri prethodnu kartu na sljedecu poslije trenutne
                delete p;                               // izbrisi trenutnu kartu
                if(p==prviCvor)
                    prviCvor = prethodna-&gt;sljedeci;    // Ako smo izbrisali prvu kartu u listi , iduca karta u listi postaje druga
                p = prethodna-&gt;sljedeci;            // prebaci pokazivac sa izbrisane karte na sljedecu u listi
            }
        }
        else {              // Ako ne treba brisati kartu
            if(p==p-&gt;sljedeci) // Ako zadnju preostalu kartu ne treba brisati , izadji iz petlje
                break;
            prethodna = p;    // Azuriraj prethodnu kartu da pokazuje na trenutnu
        }
    }
}

stack&lt;pair&lt;string,string&gt;&gt; IzbaciKarteRazbrajanjem(Cvor *&amp;prviCvor, const short &amp;r , const int &amp;b) {
    if(r&lt;1 || r&gt;52 || b&lt;1) throw std::logic_error("Neispravni elementi za izbacivanje!");
    //if(prviCvor==nullptr) return;
    IspravnostSpila(prviCvor);
    stack&lt;pair&lt;string,string&gt;&gt; stek;
    // KRUZNO IZBACIVANJE KARATA 
    auto p = prviCvor , prethodna = prviCvor;
    int brojac=0;
    while(brojac&lt;b) {
        int korak=0;
        if(p == p-&gt;sljedeci ) { // Ako se isprazni spil
            stek.push({ nazivi.at(int((p-&gt;karta).boja)) , (p-&gt;karta).vrijednost});
            delete p;
            prviCvor = nullptr;
            break; 
        }
        while(korak&lt;r-1) {           // r-1 zbog brisanja
            prethodna = p;
            p=p-&gt;sljedeci;
            korak++;
        }
        stek.push({ nazivi.at(int((p-&gt;karta).boja)) , (p-&gt;karta).vrijednost});
        if(p!=prviCvor) {                                   // Ako ne brisem prvi cvor
            prethodna-&gt;sljedeci = p-&gt;sljedeci;
            delete p;
            p = prethodna-&gt;sljedeci;
        }
        else if(p==prviCvor) {                              // Ako brisem prvi cvor
            auto zadnja = prviCvor;
            for(int i=0;i&lt;brojKarata(prviCvor)-1;i++) zadnja = zadnja-&gt;sljedeci;
            prviCvor = p-&gt;sljedeci;
            delete p;
            p = prviCvor;
            zadnja-&gt;sljedeci = p;
            IspravnostSpila(prviCvor);
        }
        brojac++;
    }
    return stek;
}

<a name="2"></a><font color="#0000FF"><a href="match793-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

void VratiPosljednjihNKarata(Cvor *&amp;prviCvor, stack&lt;pair&lt;string,string&gt;&gt; &amp;stek, int n) {
    //Provjera ispravnosti spila i reda
    
    if(n&lt;0) throw std::domain_error("Broj n je besmislen!");
    if(n&gt;stek.size()) throw std::range_error("Nedovoljno karata u steku!");
</font>    if(prviCvor==nullptr) return;
    IspravnostSpila(prviCvor);

    // VRACANJE "n" KARATA IZ steka u spil
    int brojac=0;
    int duzinaSteka = stek.size();
    for(int i=0;i&lt;duzinaSteka;i++) {
        pair&lt;string,string&gt; par = stek.top();
        if(std::count(nazivi.begin(),nazivi.end(),par.first)==0 || std::count(v.begin(),v.end(),par.second)==0)
            throw std::logic_error("Neispravne karte!");
        
        int indeks = std::find(nazivi.begin(),nazivi.end(),par.first)-nazivi.begin();  // indeks naziva trenutne karte
        
        pair&lt;Boje,string&gt; karta = {Boje(indeks),par.second};                             //TRENUTNA KARTA KOJU ISPITUJEM
        if(!postojiUSpilu(prviCvor,karta) &amp;&amp; brojac&lt;n) {             // Ako karta iz steka ne postoji u spilu , vrati je u spil.
            auto p = prviCvor;
            auto prethodni = prviCvor;
            int j=0;
            // TRAZENJE PRAVOG MJESTA ZA UMETANJE KARTE
            while(j&lt;brojKarata(prviCvor) &amp;&amp; int((p-&gt;karta).boja) &lt; indeks) {
                prethodni = p;
                p=p-&gt;sljedeci;
                j++;
            }
            while(j&lt;brojKarata(prviCvor) &amp;&amp; (std::find(v.begin(),v.end(),par.second) &gt; std::find(v.begin(),v.end(),(p-&gt;karta).vrijednost) &amp;&amp; int((p-&gt;karta).boja)==indeks)) {
                prethodni = p;
                p=p-&gt;sljedeci;
                j++;
            }
            if(p!=prviCvor) {
                Cvor* novi = new Cvor{{karta.first,karta.second},nullptr};      // Kreiraj novi cvor i uvezi ga u listu
                prethodni-&gt;sljedeci = novi;
                novi-&gt;sljedeci = p;
            }
            else if(p==prviCvor) {
                auto zadnja = prviCvor; for(int i=0;i&lt;brojKarata(prviCvor)-1;i++) zadnja = zadnja-&gt;sljedeci;  // Ako moram da ubacim na mjesto prvog cvora,moram zadnji cvor povezati sa novim prvim
                Cvor* novi = new Cvor{{karta.first,karta.second},nullptr};
                if(int(karta.first) &lt;= int((p-&gt;karta).boja))            // Ovo rjesava slucaj kad se ubacuje karta izmedju zadnje i prve, a pri tom ta karta je veca od prve
                    prviCvor = novi;
                if(zadnja!=nullptr)                 // Ako postoji makar jedna karta (tj. ako spil nije prazan)
                    zadnja-&gt;sljedeci = novi;
                novi-&gt;sljedeci = p;
            }
            brojac++;
        }
        stek.pop();
    }
} 

void UnistiSpil(Cvor *prviCvor) {
    if(prviCvor == nullptr) return;
    int duzinaListe = brojKarata(prviCvor);
    auto iduci = prviCvor, p = prviCvor;
    for(int i=0;i&lt;duzinaListe;i++) {
        iduci = p-&gt;sljedeci;
        delete p;
        p=iduci;
    }
    prviCvor = nullptr;
}

void IspisiKarte(Cvor *prviCvor) {
    auto it = prviCvor;
    int indeksNaziva = 0;
    int brojac=0;
    auto duzinaListe = brojKarata(prviCvor);
    while(indeksNaziva&lt;4) {
        std::cout&lt;&lt;nazivi.at(indeksNaziva)&lt;&lt;": ";
        while(brojac&lt;duzinaListe &amp;&amp; nazivi.at(int((it-&gt;karta).boja)) == nazivi.at(indeksNaziva)) {
            std::cout&lt;&lt;(it-&gt;karta).vrijednost&lt;&lt;" ";
            it = it-&gt;sljedeci;
            brojac++;
        }
        indeksNaziva++;
        std::cout&lt;&lt;std::endl;
    }
}

int main ()
{
    try {
        auto spil = KreirajSpil();
        //IspisiKarte(spil);
        std::cout&lt;&lt;"Unesite korak razbrajanja: ";
        short int r;
        std::cin&gt;&gt;r;
        std::cout&lt;&lt;"Unesite broj karata koje zelite izbaciti: ";
        int b;
        std::cin&gt;&gt;b;
        try {
            auto izbaceneKarte = IzbaciKarteRazbrajanjem(spil,r,b);
            std::cout&lt;&lt;"U spilu trenutno ima "&lt;&lt;brojKarata(spil)&lt;&lt;" karata, i to:\n";
            IspisiKarte(spil);
            std::cout&lt;&lt;"Unesite broj karata koje zelite vratiti u spil: ";
            int n;
            std::cin&gt;&gt;n;
            VratiPosljednjihNKarata(spil,izbaceneKarte,n);
            std::cout&lt;&lt;"U spilu trenutno ima "&lt;&lt;brojKarata(spil)&lt;&lt;" karata, i to:\n";
            IspisiKarte(spil);
        }
        catch(...) {
            UnistiSpil(spil);
            throw;
        }
        UnistiSpil(spil);
        return 0;
    }
    catch(std::logic_error e1) {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e1.what();
    }
    catch(std::range_error e2) {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e2.what();
    }
}
</pre>
</body>
</html>
