<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student9163.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student9163.cpp<p></p><pre>
/*B 2016/2017, ZadaÄ‡a 1, Zadatak 2

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica;

int BrojKolona(Matrica m)
{
	return m[0].size();
}
int BrojRedova(Matrica m)
{
	return m.size();
}


bool daLiJeMatricaGrbava(Matrica M)
{
<a name="6"></a><font color="#00FF00"><a href="match441-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	for(int i=0; i&lt;BrojRedova(M); i++) {
		if(M[i].size() != M[0].size()) {
			return true;
</font>		}
	}
	return false;
}


std::vector&lt;double&gt; izvrniVektor(std::vector&lt;double&gt; v)
{
	std::vector&lt;double&gt;pomocni;

	for(int i=v.size()-1; i&gt;=0; i--) {
		pomocni.push_back(v[i]);
	}

	return pomocni;
}


Matrica Transponuj(Matrica m)
{
	Matrica t(BrojKolona(m));

	for(int j=0; j&lt;BrojKolona(m); j++) {
		for(int i=0; i&lt;BrojRedova(m); i++) {
			t[j].push_back(m[i][j]);
		}
	}
	return t;
}

Matrica h(Matrica m)
{
	Matrica pomocna;
	for(int i=0; i&lt;BrojRedova(m); i++) {
		pomocna.push_back(izvrniVektor(m[i]));
	}
	return pomocna;
}
Matrica v(Matrica m)
{
	return Transponuj(h(Transponuj(m)));
}

Matrica hv(Matrica m)
{
	return h(v(m));
}
Matrica KreirajMatricu(int br_redova, int br_kolona)
{
	return Matrica(br_redova, std::vector&lt;double&gt;(br_kolona));
}

Matrica OgledaloMatrica(Matrica M)
{
	if(M.size()==0) return M;
	if(daLiJeMatricaGrbava(M)) {
		throw std::domain_error("Matrica nije korektna");
	}
	if(M.empty()) return M;
	if(M[0].empty()) return Matrica(KreirajMatricu(3*M.size(), 3*M[0].size()));
	Matrica OM(3*BrojRedova(M),std::vector&lt;double&gt;(3*BrojKolona(M)) );
	Matrica HV=hv(M);
	Matrica H=h(M);
	Matrica V=v(M);
//RED PRVI
<a name="4"></a><font color="#FF00FF"><a href="match441-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

	for(int i=0; i&lt;BrojRedova(M); i++) {
		for(int j=0; j&lt;BrojKolona(M); j++) {
			OM[i][j]=HV[i][j];
</font>		}
	}
	for(int i=0; i&lt;BrojRedova(M); i++) {
		for(int j=BrojKolona(M); j&lt;2*BrojKolona(M); j++) {
			OM[i][j]=V[i][j-BrojKolona(M)];
		}
	}
	for(int i=0; i&lt;BrojRedova(M); i++) {
<a name="7"></a><font color="#0000FF"><a href="match441-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		for(int j=2*BrojKolona(M); j&lt;3*BrojKolona(M); j++) {
			OM[i][j]=HV[i][j-2*BrojKolona(M)];
</font>		}
	}
//RED DRUGI
<a name="0"></a><font color="#FF0000"><a href="match441-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

	for(int i=BrojRedova(M); i&lt;2*BrojRedova(M); i++) {
		for(int j=0; j&lt;BrojKolona(M); j++) {
			OM[i][j]=H[i-BrojRedova(M)][j];
</font>		}
	}
	for(int i=BrojRedova(M); i&lt;2*BrojRedova(M); i++) {
<a name="3"></a><font color="#00FFFF"><a href="match441-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

		for(int j=BrojKolona(M); j&lt;2*BrojKolona(M); j++) {
			OM[i][j]=M[i-BrojRedova(M)][j-BrojKolona(M)];
		}
	}
	for(int i=BrojRedova(M); i&lt;2*BrojRedova(M); i++) {
</font><a name="5"></a><font color="#FF0000"><a href="match441-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

		for(int j=2*BrojKolona(M); j&lt;3*BrojKolona(M); j++) {
			OM[i][j]=H[i-BrojRedova(M)][j-2*BrojKolona(M)];
</font>		}
	}
//RED TRECI
<a name="2"></a><font color="#0000FF"><a href="match441-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

	for(int i=2*BrojRedova(M); i&lt;3*BrojRedova(M); i++) {
		for(int j=0; j&lt;BrojKolona(M); j++) {
			OM[i][j]=HV[i-2*BrojRedova(M)][j];
</font>		}
	}
	for(int i=2*BrojRedova(M); i&lt;3*BrojRedova(M); i++) {
		for(int j=BrojKolona(M); j&lt;2*BrojKolona(M); j++) {
			OM[i][j]=V[i-2*BrojRedova(M)][j-BrojKolona(M)];
		}
	}
	for(int i=2*BrojRedova(M); i&lt;3*BrojRedova(M); i++) {
		for(int j=2*BrojKolona(M); j&lt;3*BrojKolona(M); j++) {
			OM[i][j]=HV[i-2*BrojRedova(M)][j-2*BrojKolona(M)];
		}
	}


	return OM;
}



void IspisiMatricu(Matrica m)
{
<a name="1"></a><font color="#00FF00"><a href="match441-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

	for(int i = 0; i &lt; BrojRedova(m); i++) {
		for(int j = 0; j &lt; BrojKolona(m); j++)
			std::cout &lt;&lt; std::setw(4) &lt;&lt; m[i][j];
		std::cout &lt;&lt; std::endl;
</font><a name="8"></a><font color="#00FFFF"><a href="match441-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	}
}

Matrica UnesiMatricu(int br_redova, int br_kolona)
{
	auto m(KreirajMatricu(br_redova, br_kolona));
	for(int i = 0; i &lt; br_redova; i++)
		for(int j = 0; j &lt; br_kolona; j++) {
</font>			std::cin &gt;&gt; m[i][j];
		}
	return m;
}

int main ()
{
	int m, n;
	try {
	std::cout&lt;&lt;"Unesite dimenzije matrice (m n): ";
		std::cin&gt;&gt;m&gt;&gt;n;
		if(m&lt;0 || n&lt;0) throw std::domain_error("Dimenzije matrice moraju biti nenegativne!");
      
		std::cout&lt;&lt;"Unesite elemente matrice:"&lt;&lt;std::endl;
		Matrica M=UnesiMatricu(m,n);
		Matrica H = OgledaloMatrica(M);
		std::cout&lt;&lt;"Rezultantna matrica:"&lt;&lt;std::endl;
		 if(m==0 || n==0) return 0;
		IspisiMatricu(H);
	} catch(std::domain_error e) {
		std::cout&lt;&lt;e.what()&lt;&lt;std::endl;
	}

	return 0;
}</pre>
</body>
</html>
