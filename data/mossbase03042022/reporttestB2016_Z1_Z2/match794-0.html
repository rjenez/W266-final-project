<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student4628.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student4628.cpp<p></p><pre>
//B 2016/2017, ZadaÄ‡a 1, Zadatak 2

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

using std::cout;
using std::cin;
using std::endl;
typedef std::vector&lt;double&gt; Vektor;
typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica ;

Matrica UnesiMatricu (int br_redova, int br_kolona)
{
	Matrica a (br_redova, Vektor(br_kolona));
	for(int i = 0; i &lt; br_redova; i++) {
		for(int j = 0; j &lt; br_kolona; j++)
			cin &gt;&gt; a.at(i).at(j);
	}
	return a;
}

Matrica HorizontalnoOgledalo (Matrica a)
{
	if(a.size() == 0 || a[0].size() == 0)
		return Matrica (0, Vektor(0));

	Matrica d;
	for(int i = 0; i &lt; a.size(); i++) {
		Vektor c;
		for(int j = a.at(i).size() - 1; j &gt;= 0; j--)
			c.push_back(a.at(i).at(j));         // u novi vektor c unosim elemente redova matrice od posljednjeg ka prvom
		d.push_back(c);                         // redove "slazem" u novu matricu d
	}
	return d;
}

Matrica VertikalnoOgledalo (Matrica b)
{
	if(b.size() == 0 || b[0].size() == 0)
		return Matrica (0, Vektor(0));
	Matrica c;
	for(int i = b.size() - 1; i &gt;= 0; i--)
		c.push_back(b.at(i));                   // u novu matricu ubacujem redove matrice poslane kao parametar f-je u obrnutom redoslijedu

	return c;
}

Matrica OgledaloMatrica (Matrica D)
{
	for(int i = 0; i &lt; D.size(); i++) {
		if(i != D.size() - 1)
			if(D[i].size() != D[i+1].size())                       // ukoliko nije jednak broj elemenata svakog reda matrica je grbava
				throw std::domain_error("Matrica nije korektna"); // bacamo izuzetak
	}
	
	Matrica M;
	Matrica h = std::move(HorizontalnoOgledalo(D));
	Matrica v = std::move(VertikalnoOgledalo(D));
	Matrica hv = std::move(HorizontalnoOgledalo(D));
	hv = std::move(VertikalnoOgledalo(hv));

	//u pomocni vektro ubacujem elemente i-tog reda matrica, a zatim elemente tog vektora ubacujem u ogledalo matricu
	for(int i = 0; i &lt; D.size(); i++) {
		Vektor pomocni;

<a name="0"></a><font color="#FF0000"><a href="match794-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

		for(int j = 0; j &lt; D[i].size(); j++)
			pomocni.push_back(hv.at(i).at(j));

		for(int j = 0; j &lt; D[i].size(); j++)
			pomocni.push_back(v.at(i).at(j));

		for(int j = 0; j &lt; D[i].size(); j++)
			pomocni.push_back(hv.at(i).at(j));

		M.push_back(pomocni);
</font>	}

	for(int i = 0; i &lt; D.size(); i++) {
		Vektor pomocni;

<a name="1"></a><font color="#00FF00"><a href="match794-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

		for(int j = 0; j &lt; D[i].size(); j++)
			pomocni.push_back(h.at(i).at(j));

		for(int j = 0; j &lt; D[i].size(); j++)
			pomocni.push_back(D.at(i).at(j));

		for(int j = 0; j &lt; D[i].size(); j++)
			pomocni.push_back(h.at(i).at(j));

		M.push_back(pomocni);
</font>	}

	for(int i = 0; i &lt; D.size(); i++) {
		Vektor pomocni;

<a name="2"></a><font color="#0000FF"><a href="match794-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

		for(int j = 0; j &lt; D[i].size(); j++)
			pomocni.push_back(hv.at(i).at(j));

		for(int j = 0; j &lt; D[i].size(); j++)
			pomocni.push_back(v.at(i).at(j));

		for(int j = 0; j &lt; D[i].size(); j++)
			pomocni.push_back(hv.at(i).at(j));

		M.push_back(pomocni);
</font>
	}

	return M;
}

int main ()
{
	try {
		int n, m;
		cout &lt;&lt; "Unesite dimenzije matrice (m n): ";
		cin &gt;&gt; m &gt;&gt; n;
		if( m &lt; 0 || n &lt; 0 ) {
			cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!";
			return 1;
		}

		cout &lt;&lt; "Unesite elemente matrice: ";
		auto D (UnesiMatricu(m, n));

		cout &lt;&lt; endl &lt;&lt;"Rezultantna matrica: " &lt;&lt; endl;

		auto A = std::move(OgledaloMatrica(D));
		for(int i = 0; i &lt; 3*m; i++) {
			for(int j = 0; j &lt; 3*n; j++)
				cout &lt;&lt; std::setw(4) &lt;&lt; A.at(i).at(j);
			cout &lt;&lt; endl;
		}

	} catch (std::domain_error izuzetak) {
		cout &lt;&lt; izuzetak.what() &lt;&lt; endl;  // hvatanje izetka i ispisivanje odgovarajuce poruke
	}

	return 0;
}</pre>
</body>
</html>
