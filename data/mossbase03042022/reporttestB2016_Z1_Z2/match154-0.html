<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student1915.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student1915.cpp<p></p><pre>
/*B 2016/2017, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match154-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_93.gif"/></a>

typedef std::vector&lt;std::vector&lt;double&gt;&gt;Matrica;

Matrica KreirajMatricu(int br_redova,int br_kolona){
	return Matrica(br_redova,std::vector&lt;double&gt;(br_kolona));
}
Matrica UnesiMatricu(int br_redova,int br_kolona){
	auto m(KreirajMatricu(br_redova,br_kolona));
	for(int i=0;i&lt;br_redova;i++) {
		for(int j=0;j&lt;br_kolona;j++){
			std::cin&gt;&gt;m[i][j];
		}
	}
	return m;
}
int BrojRedova(Matrica m){
	return m.size();
}
int BrojKolona(Matrica m){
	return m[0].size();
}
Matrica km(Matrica m){
	Matrica km=KreirajMatricu(BrojRedova(m),BrojKolona(m));
	int l=0;
	for(int i=BrojRedova(m)-1;i&gt;=0;i--){
		int s=0;
		for(int j=BrojKolona(m)-1;j&gt;=0;j--){
			km[l][s]=m[i][j];
			s++;
		}
		l++;
	}
	return km;
}
Matrica vm(Matrica m){
	Matrica vm=KreirajMatricu(BrojRedova(m),BrojKolona(m));
	
	for(int i=BrojRedova(m)-1;i&gt;=0;i--){
		for(int j=0;j&lt;BrojKolona(m);j++){
			vm[BrojRedova(m)-1-i][j]=m[i][j];
		}
	}
	return vm;
}
Matrica hm(Matrica m){
	Matrica hm=KreirajMatricu(BrojRedova(m),BrojKolona(m));
	
	for(int i=0;i&lt;BrojRedova(m);i++){
		for(int j=BrojKolona(m)-1;j&gt;=0;j--){
			hm[i][BrojKolona(m)-1-j]=m[i][j];
		}
	}
	return hm;
}




Matrica OgledaloMatrica(Matrica m){
	if(BrojRedova(m)==0 || BrojKolona(m)==0){
		Matrica povratna;
		povratna.resize(3*BrojRedova(m));
		for(int i(0); i&lt;povratna.size(); i++)
			povratna[i].resize(3*BrojKolona(m));
		return povratna;
	}
	Matrica _h = hm(m), _k = km(m), _v(vm(m)), povratna;
	povratna.resize(3*BrojRedova(m));
	for(int i = 0; i&lt;povratna.size(); i++){
		povratna[i].resize(3*BrojKolona(m));
	}
	
	
	for(int i(0); i&lt;povratna.size(); i++){
		int k = 0;
		if(2*BrojRedova(m) &lt;= i &amp;&amp; i&lt;3*BrojRedova(m))
			k = 2*BrojRedova(m);
		for(int j(0); j&lt;povratna[0].size(); j++){
			if((0 &lt;= i &amp;&amp; i &lt; BrojRedova(m)) || (2*BrojRedova(m) &lt;= i &amp;&amp; i&lt;3*BrojRedova(m))){
				if(0 &lt;= j &amp;&amp; j &lt; BrojKolona(m)){
					povratna[i][j] = _k[i - k][j];
				}else if(BrojKolona(m) &lt;= j &amp;&amp; j &lt; 2*BrojKolona(m)){
					povratna[i][j] = _v[i - k][j-BrojKolona(m)];
				}else{
					povratna[i][j] = _k[i - k][j-2*BrojKolona(m)];
				}
			}else if(BrojRedova(m) &lt;= i &amp;&amp; i &lt; 2*BrojRedova(m)){
				if(0 &lt;= j &amp;&amp; j &lt; BrojKolona(m))
					povratna[i][j]=_h[i-BrojRedova(m)][j];
				else if(BrojKolona(m) &lt;= j &amp;&amp; j &lt; 2*BrojKolona(m))
					povratna[i][j] = m[i-BrojRedova(m)][j-BrojKolona(m)];
				else
					povratna[i][j] = _h[i-BrojRedova(m)][j-2*BrojKolona(m)];
			}
			
			
		}
	}


return povratna;	
}

int main ()
{
	int m,n;
	std::cout&lt;&lt;"Unesite dimenzije matrice (m n): ";
	std::cin&gt;&gt;m&gt;&gt;n;
	
	if(m&lt;0 || n&lt;0){
		std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!"&lt;&lt;std::endl;
		return 0;
	}
	
	std::cout&lt;&lt;"Unesite elemente matrice: "&lt;&lt;std::endl;

     auto mat(UnesiMatricu(m,n));
     Matrica matr;
     matr=OgledaloMatrica(mat);
     
     std::cout&lt;&lt;"Rezultantna matrica:"&lt;&lt;std::endl;
     for(int i=0;i&lt;matr.size();i++){
</font>     	for(int j=0;j&lt;matr[0].size();j++){
     		std::cout&lt;&lt;std::setw(4)&lt;&lt;matr[i][j];
     	}
     	std::cout&lt;&lt;std::endl;
     }
	
	return 0;
}</pre>
</body>
</html>
