<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student1828.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student1828.cpp<p></p><pre>
/*B 2016/2017, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.
	
*/
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica;

Matrica OgledaloMatrica (Matrica XxX){
	if (XxX.size()==0){
		return XxX;
	}
	for (int i=0;i&lt;XxX.size();i++){
	     if (XxX[0].size()!=XxX[i].size()){
	    	throw std::domain_error("Matrica nije korektna");
	    }
		
		
	}
	Matrica Horizontalno(XxX.size(),std::vector&lt;double&gt;(0));
	Matrica Vertikalno;
	Matrica HorVertikalno(XxX.size(),std::vector&lt;double&gt;(0));
	for (int i=0;i&lt;XxX.size();i++){             //horizontalna matricha
	    for (int j=0;j&lt;XxX[i].size();j++){
	    	Horizontalno[i].push_back(XxX[i] [XxX[i].size()-1-j]);
		                }
                     	}
	   for (int i=XxX.size()-1;i&gt;=0;i--){     //vertikalna matricha
	    Vertikalno.push_back(XxX[i]);
	   	                }
	   	for (int i=0;i&lt;Vertikalno.size();i++){      //Horvertikalna matricha samo okrene vertikalnu kao horizontalnu
	   		for (int j=0;j&lt;Vertikalno[i].size();j++){
	   			HorVertikalno[i].push_back(Vertikalno[i] [XxX[i].size()-1-j] );
	   		            }
	   	                }
	   	Matrica Nedobognikom(XxX.size()*3,std::vector&lt;double&gt;(XxX[0].size()*3));
<a name="1"></a><font color="#00FF00"><a href="match490-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

	          for (int i=0;i&lt;Nedobognikom.size();i++){
	          	for (int j=0;j&lt;Nedobognikom[i].size();j++){

                            if (i&lt;HorVertikalno.size() &amp;&amp; j&lt;HorVertikalno[i].size()) {
                            Nedobognikom[i][j]=HorVertikalno[i][j];	}
                           else  if ((i&lt;XxX.size())  &amp;&amp; (j&gt;=XxX[i].size()) &amp;&amp; (j&lt;XxX[i].size()*2)){
</font>	          		     	Nedobognikom[i][j]=Vertikalno[i][j-Vertikalno[i].size()];
	          		    }  else  if ( i&lt;XxX.size()  &amp;&amp; j&gt;=XxX[i].size()*2 ){
	          		     	Nedobognikom[i][j]=HorVertikalno[i][j-XxX[i].size()*2];
<a name="4"></a><font color="#FF00FF"><a href="match490-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

	          		    }  else  if ( i&gt;=XxX.size() &amp;&amp; i&lt;XxX.size()*2 &amp;&amp; j&lt;XxX[0].size()) {
	          		 	     Nedobognikom[i][j]=Horizontalno[i-XxX.size()][j];
	          		   } else if (i&gt;=XxX.size()*2 &amp;&amp; i&lt;XxX.size()*3 &amp;&amp; j&gt;=0 &amp;&amp; j&lt;HorVertikalno[0].size()) {
</font>	          		       Nedobognikom[i][j]=HorVertikalno[i-XxX.size()*2][j];
<a name="3"></a><font color="#00FFFF"><a href="match490-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

	          		   } else if (i&gt;=XxX.size() &amp;&amp; i&lt;XxX.size()*2 &amp;&amp; j&gt;=XxX[0].size() &amp;&amp; j&lt;XxX[0].size()*2){
	          		   Nedobognikom[i][j]=XxX[i-XxX.size()][j-XxX[0].size()];}
	          		   else if (i&gt;=XxX.size() &amp;&amp; i&lt;XxX.size()*2 &amp;&amp; j&gt;=XxX[0].size()  &amp;&amp; j&lt;XxX[0].size()*3){
</font><a name="0"></a><font color="#FF0000"><a href="match490-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

	          		   	Nedobognikom[i][j]=Horizontalno[i-XxX.size()][j-XxX[0].size()*2];
	          		   } else if (i&gt;=XxX.size()*2 &amp;&amp; i&lt;XxX.size()*3 &amp;&amp; j&gt;=XxX[0].size() &amp;&amp; j&lt;XxX[0].size()*2){
</font>	          		   	Nedobognikom[i][j]=Vertikalno[i-XxX.size()*2][j-XxX[0].size()];
	          		   } else if (i&gt;=XxX.size()*2 &amp;&amp; i&lt;XxX.size()*3 &amp;&amp; j&gt;=XxX[0].size()*2 &amp;&amp; j&lt;XxX[0].size()*3){
<a name="5"></a><font color="#FF0000"><a href="match490-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

	          		   	Nedobognikom[i][j]=HorVertikalno[i-XxX.size()*2][j-XxX[0].size()*2];
</font>	          		   }
	          		   else Nedobognikom [i][j]=0;

	          	        }
	                    }

	return Nedobognikom;

}

int main ()
{

	int Redovi,Kolone;
	std::cout&lt;&lt;"Unesite dimenzije matrice (m n): ";
<a name="2"></a><font color="#0000FF"><a href="match490-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

	std::cin&gt;&gt;Redovi &gt;&gt;Kolone;
	if (Redovi&lt;0 || Kolone&lt;0){std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";
	return 0; }
	Matrica Matricazapoziv(Redovi,std::vector&lt;double&gt;(Kolone));
	std::cout&lt;&lt;"Unesite elemente matrice: ";
        for (int i=0;i&lt;Redovi;i++){
</font>        	for (int j=0;j&lt;Kolone;j++){
        		std::cin&gt;&gt;Matricazapoziv[i][j];
        	}
        }
        std::cout&lt;&lt;std::endl;
        std::cout&lt;&lt;"Rezultantna matrica: ";
        std::cout&lt;&lt;std::endl;
        Matrica KrajMatrica(Redovi,std::vector&lt;double&gt;(Kolone));
        try {                       
        KrajMatrica=OgledaloMatrica(Matricazapoziv);
        for (int i=0;i&lt;Redovi*3;i++){
        	for (int j=0;j&lt;Kolone*3;j++){
        		std::cout&lt;&lt;std::setw(4)&lt;&lt;KrajMatrica[i][j];
        	}
        	std::cout&lt;&lt;std::endl;
        }}
        catch(const char Greska []){
        	std::cout&lt;&lt;Greska;
        }
	return 0;
}</pre>
</body>
</html>
