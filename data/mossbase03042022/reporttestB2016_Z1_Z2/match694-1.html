<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student6874.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student3943.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
using namespace std;
typedef vector&lt;vector&lt;double&gt;&gt; matrica;
// funkcija kreira matricu
matrica Kreirajmatricu(int brojredova,int brojkolona)
{
return matrica(brojredova,vector&lt;double&gt;(brojkolona));
}
// funkcija vraca broj redova matrice
int Brojredova(matrica m)
{
return m.size();
}
// funkcija vraca broj kolona matrice
int Brojkolona(matrica m)
{
return m[0].size();
}
//funckija ispisuje matricu
void Ispisimatricu(matrica m)
{
for(int i=0;i&lt;Brojredova(m);i++){
for(int j=0;j&lt;Brojkolona(m);j++)
cout&lt;&lt;setw(4)&lt;&lt;m[i][j];
cout&lt;&lt;endl;
}}
//funcija omogucava unosenje matrice
matrica Unesimatricu(int brojredova,int brojkolona)
{
matrica m(Kreirajmatricu(brojredova,brojkolona));
cout&lt;&lt;"Unesite elemente matrice: "&lt;&lt;endl;
for(int i=0;i&lt;brojredova;i++)
for(int j=0;j&lt;brojkolona;j++)
{
cin&gt;&gt;m[i][j];
}
return m;
}
//funkcija vrsi provjeru grbave matrice
void Provjerigrbavu(matrica m)
{
for(int i=0;i&lt;Brojredova(m)-1;i++)
{if(m[i].size()!=m[i+1].size())
throw std::domain_error( "Matrica nije korektna" );
}
}







//funcija vrsi vertikalno pomjeranje
matrica Vertikalnopomjeranje(matrica m,int brojredova,int brojkolona)
{ 
	matrica vertikalnamatrica(Kreirajmatricu(brojredova,brojkolona));
	for(int i=0;i&lt;brojredova;i++)
{
for(int j=0;j&lt;brojkolona;j++)
 vertikalnamatrica[i][j]=m[brojredova-i-1][j];


}
return vertikalnamatrica;
}
//funkcija vrsi horizontalno pomjeranje
matrica Horizontalnopomjeranje(matrica m,int brojredova,int brojkolona)
{
matrica horizontalnamatrica(Kreirajmatricu(brojredova,brojkolona));
	for(int i=0;i&lt;brojredova;i++)
{
for(int j=0;j&lt;brojkolona;j++)
 horizontalnamatrica[i][j]=m[i][brojkolona-j-1];


}
return horizontalnamatrica;
}
// finalna matrica
matrica Finalnamatrica(matrica horizontalnamatrica,matrica vertikalnamatrica,matrica horizontalnovertikalnamatrica,matrica finalnamatrica,matrica m,int brojredova,int brojkolona)
{
//ubaci hv gore lijevo
for(int i=0;i&lt;brojredova;i++)
<a name="1"></a><font color="#00FF00"><a href="match694-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

for(int j=0;j&lt;brojkolona;j++)
finalnamatrica[i][j]=horizontalnovertikalnamatrica[i][j];
//ubaci gore v
for(int i=0;i&lt;brojredova;i++)
for(int j=0;j&lt;brojkolona;j++)
finalnamatrica[i][brojkolona+j]=vertikalnamatrica[i][j];
//ubaci gore desno hv
for(int i=0;i&lt;brojredova;i++)
for(int j=0;j&lt;brojkolona;j++)
finalnamatrica[i][2*brojkolona+j]=horizontalnovertikalnamatrica[i][j];
</font><a name="0"></a><font color="#FF0000"><a href="match694-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_12.gif"/></a>

//ubaci lijevo h
for(int i=0;i&lt;brojredova;i++)
for(int j=0;j&lt;brojkolona;j++)
finalnamatrica[brojredova+i][j]=horizontalnamatrica[i][j];
//ubaci u sredinu m
for(int i=0;i&lt;brojredova;i++)
for(int j=0;j&lt;brojkolona;j++)
finalnamatrica[brojredova+i][brojkolona+j]=m[i][j];
//ubaci desno h
for(int i=0;i&lt;brojredova;i++)
for(int j=0;j&lt;brojkolona;j++)
finalnamatrica[brojredova+i][2*brojkolona+j]=horizontalnamatrica[i][j];
</font>//ubaci dole lijevo hv
for(int i=0;i&lt;brojredova;i++)
for(int j=0;j&lt;brojkolona;j++)
<a name="2"></a><font color="#0000FF"><a href="match694-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

finalnamatrica[2*brojredova+i][j]=horizontalnovertikalnamatrica[i][j];
//ubaci dole v
for(int i=0;i&lt;brojredova;i++)
for(int j=0;j&lt;brojkolona;j++)
</font><a name="3"></a><font color="#00FFFF"><a href="match694-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

finalnamatrica[2*brojredova+i][brojkolona+j]=vertikalnamatrica[i][j];
//ubaci dole desno hv
for(int i=0;i&lt;brojredova;i++)
for(int j=0;j&lt;brojkolona;j++)
</font>finalnamatrica[2*brojredova+i][2*brojkolona+j]=horizontalnovertikalnamatrica[i][j];

return finalnamatrica;

}
matrica OgledaloMatrica(matrica m)
{
try{

Provjerigrbavu(m);
int brojredova(m.size());
int brojkolona(0);
if(brojredova&gt;0)
brojkolona=m[0].size();
matrica horizontalnamatrica(Horizontalnopomjeranje(m,brojredova,brojkolona));
matrica vertikalnamatrica(Vertikalnopomjeranje(m,brojredova,brojkolona));
matrica horizontalnovertikalnamatrica(Horizontalnopomjeranje(m,brojredova,brojkolona));
 horizontalnovertikalnamatrica=Vertikalnopomjeranje(horizontalnovertikalnamatrica,brojredova,brojkolona);
//kreiranje finalne matrice
matrica finalnamatrica(Kreirajmatricu(3*brojredova,3*brojkolona));
finalnamatrica=Finalnamatrica(horizontalnamatrica,vertikalnamatrica,horizontalnovertikalnamatrica,finalnamatrica,m,brojredova,brojkolona);
return finalnamatrica;
}
catch(const std::domain_error e)
{
cout &lt;&lt; e.what() &lt;&lt; '\n';
matrica praznaMatrica;
return praznaMatrica;
}
}

int main ()
{
	int brojredova,brojkolona;
	cout&lt;&lt;"Unesite dimenzije matrice (m n): ";
	cin&gt;&gt;brojredova;
    cin&gt;&gt;brojkolona;
    if ((brojredova&lt;0) or (brojkolona&lt;0))
    {
    cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!";
    return 0;
    }
	

    matrica m=Unesimatricu(brojredova,brojkolona);
	auto ogledalomatrica=OgledaloMatrica(m);
	cout&lt;&lt;"Rezultantna matrica: "&lt;&lt;endl;
	Ispisimatricu(ogledalomatrica);

	
	
	return 0;
}</pre>
</body>
</html>
