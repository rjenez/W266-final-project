<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student8199.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student5673.cpp<p></p><pre>
/*B 2016/2017, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;

<a name="0"></a><font color="#FF0000"><a href="match193-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;

typedef vector&lt;vector&lt;double&gt;&gt; Matrica;

//Obrtanje matrica oko osa
Matrica hflip (Matrica mat) {
	int m(mat.size());
	int n(mat[0].size());
	
	Matrica h(m, vector&lt;double&gt;(n));
	
	for (int  i = 0; i &lt; m; i++) {
		for (int j = 0; j &lt; n; j++) {
			h[i][j] = mat[i][n - 1 - j];
		}
	}
	
	return h;
}

Matrica vflip (Matrica mat) {
	int m(mat.size());
	int n(mat[0].size());

	Matrica v(m, vector&lt;double&gt;(n));

	for (int  i = 0; i &lt; m; i++) {
		for (int j = 0; j &lt; n; j++) {
			v[i][j] = mat[m - i - 1][j];
		}
	}

	return v;
}

Matrica hvflip(Matrica mat) {
	Matrica hv(vflip(mat));
	hv = hflip(hv);
	
	return hv;
}

//Pravljenje velike matrice i ubacivanje manjih u specificirana mjesta
Matrica OgledaloMatrica (Matrica mat) {
	if (mat.size() == 0) return mat;
	
	int m(mat.size() * 3);
	int n(mat[0].size() * 3);
	
	Matrica h(hflip(mat));
	Matrica v(vflip(mat));
	Matrica hv(hvflip(mat));
	
	Matrica ogledalo (m, vector&lt;double&gt;(n));
	
	//Postavljanje manjih matrica u vecu matricu
	for (int i = 0; i &lt; mat.size(); i++) {
		for (int j = 0; j &lt; mat[i].size(); j ++) {
			//Upis matrica obrnute po horizontali i vertikali
			ogledalo[i][j] = hv[i][j];
			ogledalo[i + 2 * mat.size()][j] = hv[i][j];
			ogledalo[i][j + 2 * mat[i].size()] = hv[i][j];
			ogledalo[i + 2 * mat.size()][j + 2 * mat[i].size()] = hv[i][j];
			//Upis matrica obrnutih samo po vertikali
			ogledalo[i][j + mat[i].size()] = v[i][j];
			ogledalo[i + 2 * mat.size()][j + mat[i].size()] = v[i][j];
			//Upis matrica obrnutih samo po horizontali
			ogledalo[i + mat.size()][j] = h[i][j];
			ogledalo[i + mat.size()][j + 2 * mat[i].size()] = h[i][j];
			//Upis obicne matrice u sredinu
			ogledalo[i + mat.size()][j + mat[i].size()] = mat[i][j];
		}
	}
	
	return ogledalo;
	
}

int main ()
{
	int m, n;
	try {
		cout &lt;&lt; "Unesite dimenzije matrice (m n): ";
		cin &gt;&gt; m &gt;&gt; n;
		if (m &lt; 0 || n &lt; 0) throw domain_error("Dimenzije matrice moraju biti nenegativne!");
		
		
		Matrica mat(m, vector&lt;double&gt;(n));
		cout &lt;&lt; "Unesite elemente matrice:" &lt;&lt; endl;
		for (int  i = 0; i &lt; m; i++) {
			for (int j = 0; j &lt; n; j++) {
				cin &gt;&gt; mat[i][j];
			}
		}
		
		Matrica ogledalo(OgledaloMatrica(mat));
		
		int mo(ogledalo.size());
		int no(ogledalo[0].size());
		
		cout &lt;&lt; "Rezultantna matrica:" &lt;&lt; endl;
		for (int i = 0; i &lt; mo; i++) {
			for (int j = 0; j &lt; no; j++) {
				cout &lt;&lt; setw(4) &lt;&lt; ogledalo[i][j];
			}
			cout &lt;&lt; endl;
		}
		
		return 0;
	}
	catch (domain_error izuzetak) {
		cout &lt;&lt; izuzetak.what();
</font>		return 0;
	}
}</pre>
</body>
</html>
