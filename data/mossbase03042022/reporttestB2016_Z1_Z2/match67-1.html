<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student4526.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student2486.cpp<p></p><pre>
/*B 2016/2017, ZadaÄ‡a 1, Zadatak 2

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.


*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
<a name="0"></a><font color="#FF0000"><a href="match67-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using std::cout;
using std::cin;
using std::vector;
using std::domain_error;
using std::endl;
using std::setw;
int brojkolonamatrice(vector&lt;vector&lt;double&gt;&gt; m)
{ return((!m.size()) ? 0 : m.at(0).size());


}//funkcija za brojanje kolona matrice da bi skratili kod
vector &lt;vector&lt;double&gt; &gt; HorizontalnoOgledalo(vector&lt;vector&lt;double&gt;&gt; m1)
{
	vector &lt;vector&lt;double&gt; &gt; nekamatrica;
	int velicina=m1.size();

	nekamatrica.resize(velicina);


	
  for(int i=0;i&lt;m1.size();i++){
		for(int j=m1[i].size()-1;j&gt;=0; j--) {
			nekamatrica [i].push_back(m1.at(i).at(j));

		}}
	return nekamatrica;
}//Horizontalno ogledalo - krecem od prvog reda, ali zadnje kolone i premjestam elemente u novu matricu koju nakon premjestenih elemenata vracam iz fje
//Vertikalno ogledalo- zamjena redova pomocu for petlje
vector&lt;vector&lt;double&gt; &gt; VertikalnoOgledalo(vector&lt;vector&lt;double&gt;&gt; m1)
{
	vector&lt;vector&lt;double&gt;&gt; nekamatrica;


	for(int i=m1.size()-1;i&gt;=0;i--){
	
			nekamatrica.push_back(m1.at(i));
		}
	

	return nekamatrica;
}
  //kombinovano ogledalo dobivamo pozivom funkcije horizontalno ogledalo na vec promjenjenu matricu u vertikalno
vector &lt;vector&lt;double&gt; &gt; KombinovanoOgledalo(vector&lt;vector&lt;double&gt; &gt; m1)
{
return HorizontalnoOgledalo(VertikalnoOgledalo(m1));
}

vector &lt;vector&lt;double&gt; &gt; OgledaloMatrica(vector&lt;vector&lt;double&gt; &gt; matrica){
if(matrica.size()==0) return matrica;//ako je matrica prazna samo vrati praznu
for (int i=0;i&lt;matrica.size();i++){
	if(i!=matrica.size()-1 &amp;&amp; matrica[i].size()!=matrica[i+1].size()){
		throw domain_error("Matrica nije korektna"); 
	}
}//slucaj grbave matrice baca izuzetak

vector&lt;vector&lt;double&gt; &gt; hv;
	vector&lt;vector&lt;double&gt; &gt; v;
	vector&lt;vector&lt;double&gt; &gt; h;
	vector&lt;vector&lt;double&gt; &gt; ogledalomatrica;
	int duzina=matrica.size();
	ogledalomatrica.resize(3*duzina);
//ova matrica ce biti dimenzija 3*mx3*n
	hv=KombinovanoOgledalo(matrica);
	v=VertikalnoOgledalo(matrica);
	h=HorizontalnoOgledalo(matrica);
   
	for(int i=0; i&lt;hv.size(); i++) {
		for(int j=0; j&lt;hv[i].size(); j++) {
			ogledalomatrica[i].push_back(hv[i][j]);
		}
	}
	for(int i=0; i&lt;v.size(); i++) {
		for(int j=0; j&lt;v[i].size(); j++) {
			ogledalomatrica[i].push_back(v[i][j]);
		}
	}
	for(int i=0; i&lt;hv.size(); i++) {
		for(int j=0; j&lt;hv[i].size(); j++) {
			ogledalomatrica[i].push_back(hv[i][j]);
		}
	}
	int a=hv.size()+h.size();
	for(int i=h.size(); i&lt;a; i++) {
		for(int j=0; j&lt;h[i-h.size()].size(); j++) {
			ogledalomatrica[i].push_back(h[i-h.size()][j]);
		}
	}
	
	for(int i=matrica.size(); i&lt;a; i++) {
		for(int j=0; j&lt;matrica[i-hv.size()].size(); j++) {
			ogledalomatrica[i].push_back(matrica[i-hv.size()][j]);
		}
	}
	for(int i=hv.size(); i&lt;a; i++) {
		for(int j=0; j&lt;h[i-hv.size()].size(); j++) {
			ogledalomatrica[i].push_back(h[i-hv.size()][j]);
		}
	}
	int b=a+hv.size();
	for(int i=a; i&lt;b; i++) {
	for(int j=0; j&lt;hv[i-a].size(); j++) {
			ogledalomatrica[i].push_back(hv[i-a][j]);
		}}
		for(int i=a; i&lt;b; i++) {
	for(int j=0; j&lt;v[i-a].size(); j++) {
			ogledalomatrica[i].push_back(v[i-a][j]);
		}}
			for(int i=a; i&lt;b; i++) {
	for(int j=0; j&lt;hv[i-a].size(); j++) {
			ogledalomatrica[i].push_back(hv[i-a][j]);
		}}
		return ogledalomatrica;}
		
	



	int main () {
	try{
int n(0),m(0);

cout&lt;&lt;"Unesite dimenzije matrice (m n): ";
cin&gt;&gt;n;
cin&gt;&gt;m;
if(m&lt;0 || n&lt;0){cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne! "&lt;&lt;endl; return 0;}//m i nula ne smiju biti manji od nula
vector&lt;vector&lt;double&gt; &gt; matrica(n, vector &lt;double&gt; (m));
matrica.resize(n);
//ispis elemenata
cout&lt;&lt;"Unesite elemente matrice: "&lt;&lt;endl;
for(int i=0;i&lt;n;i++){
	for(int j=0;j&lt;m;j++){
		cin&gt;&gt;matrica[i][j];

	}
}
vector &lt;vector&lt;double&gt; &gt; matrica2;
matrica2=OgledaloMatrica(matrica);
cout&lt;&lt;"Rezultantna matrica: "&lt;&lt;endl;
for(int i=0;i&lt;3*n;i++){
	for(int j=0;j&lt;3*m;j++){
	cout&lt;&lt;setw(4)&lt;&lt;matrica2[i][j];
}cout&lt;&lt;endl;}}
	catch(domain_error izuzetak){
		cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
</font>	}


		return 0;
	}</pre>
</body>
</html>
