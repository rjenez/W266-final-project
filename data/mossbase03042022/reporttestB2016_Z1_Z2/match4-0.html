<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student2949.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student2949.cpp<p></p><pre>
//B 2016/2017, ZadaÄ‡a 1, Zadatak 2
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;stdexcept&gt;
#include&lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match4-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica;

Matrica KreirajMatricu(int brojredova, int brojkolona)              //funkcija koja na osnovu redova i kolona koje prima kao parametar vraca praznu matricu s tolikim brojem redova i kolona
{
    return Matrica(brojredova, std::vector&lt;double&gt;(brojkolona));
}


Matrica OgledaloMatrica(Matrica MATRICA)
{

    for(int i=0; i&lt;MATRICA.size(); i++) {
        for(int j=0; j&lt;MATRICA.at(i).size(); j++) {
            if(MATRICA.at(0).size()!=MATRICA.at(i).size())
                throw std::domain_error("Matrica nije korektna");
        }
    }

    int n;
    int m(MATRICA.size());
    if(m==0) n=0;
    else
        n=MATRICA[0].size();

    auto Horizontalna(KreirajMatricu(m,n));
    auto Veritkalna(KreirajMatricu(m,n));
    auto Kombinovana(KreirajMatricu(m,n));
    auto Ogledalo(KreirajMatricu(3*m,3*n));

    if(m==1 &amp;&amp; n==1) {
        for(int i=0; i&lt;Ogledalo.size(); i++) {
            for(int j=0; j&lt;Ogledalo.at(i).size(); j++) {
                Ogledalo.at(i).at(j)=MATRICA.at(0).at(0);
            }
        }
        return Ogledalo;
    }

    for(int i=0, k=0; i&lt;MATRICA.size(), k&lt;Horizontalna.size(); i++, k++) {                  //dvostruka petlja u ovom dijelu koda, paralelno radi s pocetnom matricom i prethodno kreiranom praznom horizontalnom matricom, tako da na odgovarajuca mjesta horizontalne matrice(sto se moze vidjeli iz uvjeta u petljama) stavlja odgovarajuce elemente polazne matrice
        for(int j=MATRICA.at(i).size()-1, e=0; j&gt;=0, e&lt;Horizontalna.at(k).size(); j--, e++) {
            Horizontalna.at(k).at(e)=MATRICA.at(i).at(j);
        }
    }

    for(int i=MATRICA.size()-1, k=0; i&gt;=0, k&lt;Veritkalna.size(); i--, k++) {                //analogno kao u prethodnoj petlji, s tim da baratamo sad s vertikalnom petljom i shodno tome drugacijim uslovima po kojima se ponasa petlja
        for(int j=0, e=0; j&lt;MATRICA.at(i).size(), e&lt;Veritkalna.at(k).size(); j++, e++ ) {
            Veritkalna.at(k).at(e)=MATRICA.at(i).at(j);
        }
    }

    for(int i=MATRICA.size()-1, k=0; i&gt;=0, k&lt;Kombinovana.size(); i--, k++) {
        for(int j=MATRICA.at(i).size()-1, e=0; j&gt;=0, e&lt;Kombinovana.at(k).size(); j--, e++) {
            Kombinovana.at(k).at(e)=MATRICA.at(i).at(j);
        }
    }

    for(int i=0, k=0; i&lt;int(int(Ogledalo.size())/m), k&lt;Kombinovana.size(); i++, k++) {
        for(int j=0, e=0; j&lt;int(int(Ogledalo.at(i).size())/n), e&lt;Kombinovana.at(k).size(); j++, e++ ) {
            Ogledalo.at(i).at(j)=Kombinovana.at(k).at(e);
        }
        std::cout&lt;&lt;std::endl;
    }

    for(int i=0, k=0; i&lt;int(int(Ogledalo.size())/m), k&lt;Veritkalna.size(); i++, k++) {
        for(int j=n, e=0; j&lt;int(int(Ogledalo.at(i).size())/n)+n, e&lt;Veritkalna.at(k).size(); j++, e++) {
            Ogledalo.at(i).at(j)=Veritkalna.at(k).at(e);
        }
    }

    for(int i=0, k=0; i&lt;int(int(Ogledalo.size())/m), k&lt;Kombinovana.size(); i++, k++) {
        for(int j=n+n, e=0; j&lt;Ogledalo.at(i).size(), e&lt;Kombinovana.at(k).size(); j++, e++) {
            Ogledalo.at(i).at(j)=Kombinovana.at(k).at(e);
        }
    }

    for(int i=m, k=0; i&lt;int(int(Ogledalo.size())/m)+m, k&lt;Horizontalna.size(); i++, k++) {
        for(int j=0, e=0; j&lt;int(int(Ogledalo.at(i).size())/n), e&lt;Horizontalna.at(k).size(); j++, e++) {
            Ogledalo.at(i).at(j)=Horizontalna.at(k).at(e);
        }
    }

    for(int i=m, k=0; i&lt;int(int(Ogledalo.size())/m)+m, k&lt;MATRICA.size(); i++, k++) {
        for(int j=n, e=0; j&lt;int(int(Ogledalo.at(i).size())/n)+n, e&lt;MATRICA.at(k).size(); j++, e++) {
            Ogledalo.at(i).at(j)=MATRICA.at(k).at(e);
        }
    }

    for(int i=m, k=0; i&lt;int(int(Ogledalo.size())/m)+m, k&lt;Horizontalna.size(); i++, k++) {
        for(int j=n+n, e=0; j&lt;Ogledalo.at(i).size(), e&lt;Horizontalna.at(k).size(); j++, e++) {
            Ogledalo.at(i).at(j)=Horizontalna.at(k).at(e);
        }
    }

    for(int i=m+m, k=0; i&lt;Ogledalo.size(), k&lt;Kombinovana.size(); i++, k++ ) {
        for(int j=0, e=0; j&lt;int(int(Ogledalo.at(i).size())/n), e&lt;Kombinovana.at(k).size(); j++, e++) {
            Ogledalo.at(i).at(j)=Kombinovana.at(k).at(e);
        }
    }

    for(int i=m+m, k=0; i&lt;Ogledalo.size(), k&lt;Veritkalna.size(); i++, k++) {
        for(int j=n, e=0; j&lt;int(int(Ogledalo.at(i).size())/n)+n, e&lt;Veritkalna.at(k).size(); j++, e++) {
            Ogledalo.at(i).at(j)=Veritkalna.at(k).at(e);
        }
    }

    for(int i=m+m, k=0; i&lt;Ogledalo.size(), k&lt;Kombinovana.size(); i++, k++) {
        for(int j=n+n, e=0; j&lt;Ogledalo.at(i).size(), e&lt;Kombinovana.at(k).size(); j++, e++) {
            Ogledalo.at(i).at(j)=Kombinovana.at(k).at(e);
        }
    }
    return Ogledalo;

}


int main ()
{
    try {
        int m, n;
        double elementiM;
        do {
            std::cout&lt;&lt;"Unesite dimenzije matrice (m n): ";
            std::cin&gt;&gt;m&gt;&gt;n;
            if(m&lt;0 || n&lt;0) {
                std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";
                break;
            }


            std::cout&lt;&lt;"Unesite elemente matrice: ";
            auto M(KreirajMatricu(m, n));

            for(int i=0; i&lt;M.size(); i++) {
                for(int j=0; j&lt;M.at(i).size(); j++) {
                    std::cin&gt;&gt;elementiM;
                    M.at(i).at(j)=elementiM;
                }
            }
            std::cout&lt;&lt;std::endl;
            auto KrajnjaMatrica(OgledaloMatrica(M));

            std::cout&lt;&lt;"Rezultantna matrica: "&lt;&lt;std::endl;
            for(int i=0; i&lt;KrajnjaMatrica.size(); i++) {
                for(int j=0; j&lt;KrajnjaMatrica.at(i).size(); j++) {
                    std::cout&lt;&lt;std::setw(4)&lt;&lt;KrajnjaMatrica.at(i).at(j);
                }
                std::cout&lt;&lt;std::endl;
            }

        } while(m&lt;0 || n&lt;0);
    } catch(std::domain_error izuzetak) {
        std::cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
</font>    }

    return 0;
}</pre>
</body>
</html>
