<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student9163.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student2736.cpp<p></p><pre>
/*B 2016/2017, Zadaća 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.
	
*/
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica;

// Kreira matricu sa zadanim brojem redova i kolona
Matrica KreirajMatricu(int br_redova, int br_kolona) 
{

	return Matrica(br_redova, std::vector&lt;double&gt;(br_kolona));
}

Matrica KreirajMatricu_mat(int br_redova, int br_kolona) 
{
	return Matrica(3*br_redova, std::vector&lt;double&gt;(3*br_kolona));
}


// Vraća broj redova zadane matrice
int BrojRedova(Matrica m) 
{
	return m.size();
}

// Vraća broj kolona zadane matrice
int BrojKolona(Matrica m) 
{
    
<a name="8"></a><font color="#00FFFF"><a href="match441-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

	return m[0].size();
}

// Unosi sa tastature matricu sa zadanim brojem redova i kolona i
// vraća je kao rezultat
Matrica UnesiMatricu(int br_redova, int br_kolona) 
{
	auto m(KreirajMatricu(br_redova, br_kolona));

 	for(int i = 0; i &lt; br_redova; i++)
 	{
 		for(int j = 0; j &lt; br_kolona; j++) 
</font> 		{
 			std::cin &gt;&gt; m[i][j];
 		}
 	}	
 	return m;
}

// Ispisuje zadanu matricu
void IspisiMatricu(Matrica m) 
{
	std::cout&lt;&lt;"Rezultantna matrica: "&lt;&lt;std::endl;
	
<a name="1"></a><font color="#00FF00"><a href="match441-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

 	for(int i = 0; i &lt; BrojRedova(m); i++) 
 	{
 		for(int j = 0; j &lt; BrojKolona(m); j++)
 			std::cout &lt;&lt;std::setw(4)&lt;&lt; m[i][j];
 		std::cout &lt;&lt; std::endl;
</font> 	}
}

Matrica OgledaloMatrica(Matrica m)
{
    
    if(BrojRedova(m)==0 || BrojKolona(m)==0)
        return m;
    
        
<a name="6"></a><font color="#00FF00"><a href="match441-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    for(int i=0;i&lt;BrojRedova(m);i++)
    {
        if(m[i].size()!=m[0].size())
            throw std::domain_error("Matrica nije korektna");
</font>    }
	auto mat(KreirajMatricu(BrojRedova(m),BrojKolona(m)));
	
	if( BrojKolona(m)==0)
	  {
	      mat.resize(3*BrojRedova(m));
	      return mat;
	  }
	mat.resize(3*BrojRedova(m)); // 10 redova
    for(int i = 0; i &lt; 3*BrojRedova(m); i++) mat[i].resize(3*BrojKolona(m));

	for(int i=0;i&lt;3*BrojRedova(m);i+=BrojRedova(m))
	{
	    if(i==0)
        {
<a name="4"></a><font color="#FF00FF"><a href="match441-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

		for(int j=0;j&lt;BrojRedova(m);j++)
			{
			    for(int k=0;k&lt;BrojKolona(m);k++)
                    mat[j][k]=m[BrojRedova(m)-j-1][BrojKolona(m)-k-1];
</font>
                for(int k=BrojKolona(m);k&lt;2*BrojKolona(m);k++)
                    mat[j][k]=m[BrojRedova(m)-j-1][k-BrojKolona(m)];

<a name="7"></a><font color="#0000FF"><a href="match441-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

                for(int k=2*BrojKolona(m);k&lt;3*BrojKolona(m);k++)
                    mat[j][k]=m[BrojRedova(m)-j-1][3*BrojKolona(m)-k-1];
</font>			}
        }
        else if(i==BrojRedova(m))
        {
<a name="0"></a><font color="#FF0000"><a href="match441-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

            for(int j=BrojRedova(m);j&lt;2*BrojRedova(m);j++)
			{
                for(int k=0;k&lt;BrojKolona(m);k++)
                    mat[j][k]=m[j-BrojRedova(m)][BrojKolona(m)-k-1];
</font>
<a name="3"></a><font color="#00FFFF"><a href="match441-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

                for(int k=BrojKolona(m);k&lt;2*BrojKolona(m);k++)
                    mat[j][k]=m[j-BrojRedova(m)][k-BrojKolona(m)];

                for(int k=2*BrojKolona(m);k&lt;3*BrojKolona(m);k++)
</font><a name="5"></a><font color="#FF0000"><a href="match441-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

                    mat[j][k]=m[j-BrojRedova(m)][3*BrojKolona(m)-k-1];
</font>			}
        }
        else if(i==2*BrojRedova(m))
        {
<a name="2"></a><font color="#0000FF"><a href="match441-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

            for(int j=2*BrojRedova(m);j&lt;3*BrojRedova(m);j++)
			{
			    for(int k=0;k&lt;BrojKolona(m);k++)
                    mat[j][k]=m[3*BrojRedova(m)-j-1][BrojKolona(m)-k-1];
</font>
                for(int k=BrojKolona(m);k&lt;2*BrojKolona(m);k++)
                    mat[j][k]=m[3*BrojRedova(m)-j-1][k-BrojKolona(m)];

                for(int k=2*BrojKolona(m);k&lt;3*BrojKolona(m);k++)
                    mat[j][k]=m[3*BrojRedova(m)-j-1][3*BrojKolona(m)-k-1];
			}
        }
    }
	return mat;
}

// Glavni program
int main() 
{
    try
    {
 	int m1, n1;
 	std::cout &lt;&lt; "Unesite dimenzije matrice (m n): ";
 	std::cin &gt;&gt; m1 &gt;&gt; n1;
 	if(m1&lt;0 || n1&lt;0)
 	{
 		std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";
 		return 0;
 	}
 	
 	std::cout &lt;&lt; "Unesite elemente matrice: "&lt;&lt;std::endl;
	auto A(UnesiMatricu(m1,n1));

	auto v(OgledaloMatrica(A));
 	
 	IspisiMatricu(v);
    }
    catch(std::domain_error izuzetak)
    {
        std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
    }    
 	
 	return 0;
}</pre>
</body>
</html>
