<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student6419.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z1/Z2/student3819.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
<a name="0"></a><font color="#FF0000"><a href="match51-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_96.gif"/></a>

typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica;
Matrica HOgledaloMatrica(Matrica m) {
    Matrica mat(m.size(), std::vector&lt;double&gt;(m[0].size()));
    for(int i(0); i&lt;m.size(); i++) {
        for(int j(0); j&lt;m[i].size(); j++) {
            mat[i][j]=m[i][m[i].size()-1-j];
        }
    }
    return mat;
}
Matrica VOgledaloMatrica(Matrica m) {                                           //uzastopnim pozivanjem VOgledaloMatrica i HOgledaloMatrica dobijemo kombinovano ogledalo
    if(m.size()!=0) {
        Matrica mat(m.size(), std::vector&lt;double&gt;(m[0].size()));
        for(int i(0); i&lt;m.size(); i++) {
            for(int j(0); j&lt;m[i].size(); j++) {
                mat[i][j]=m[m.size()-1-i][j];
            }
        }
        return mat;
    }
}
Matrica OgledaloMatrica(Matrica m) {
    if(m.size()!=0) {
        for(int i(0); i&lt;m.size()-1; i++) {
            if(m[i].size()!=m[i+1].size())
                throw std::domain_error("Matrica nije korektna");               //bacen izuzetak u slucaju da je matrica grbava
        }
    }
    if(m.size()==0) return m;
    Matrica vm=VOgledaloMatrica(m);
    Matrica hm=HOgledaloMatrica(m);
    Matrica hvm=HOgledaloMatrica(VOgledaloMatrica(m));
    Matrica hhvm=HOgledaloMatrica(hvm);
    Matrica mat(3*m.size(), std::vector&lt;double&gt;(3*m[0].size()));
    for(int i(0); i&lt;mat.size(); i++) {
        for(int j(0); j&lt;mat[0].size(); j++) {
            if((i&lt;m.size() &amp;&amp; j&lt;m[0].size()) || (i&lt;m.size() &amp;&amp; j&gt;2*m[0].size()-1) || (i&gt;2*m.size()-1 &amp;&amp; j&lt;m[0].size()) || (i&gt;2*m.size()-1 &amp;&amp; j&gt;2*m[0].size()-1)) {
                if(i&lt;m.size() &amp;&amp; j&lt;m[0].size())
                    mat[i][j]=hvm[i][j];
                else if(i&lt;m.size() &amp;&amp; j&gt;2*m[0].size()-1)
                    mat[i][j]=hhvm[i][3*m[0].size()-1-j];
                else if(i&gt;2*m.size()-1 &amp;&amp; j&lt;m[0].size())
                    mat[i][j]=hm[3*m.size()-1-i][j];
                else if(i&gt;2*m.size()-1 &amp;&amp; j&gt;2*m[0].size()-1)
                    mat[i][j]=m[3*m.size()-1-i][3*m[0].size()-1-j];
            }
            else if(i&gt;m.size()-1 &amp;&amp; j&gt;m[0].size()-1 &amp;&amp; i&lt;2*m.size() &amp;&amp; j&lt;2*m[0].size())
                mat[i][j]=hvm[2*m.size()-1-i][2*m[0].size()-1-j];
            else if(i&lt;m.size() &amp;&amp; j&gt;m[0].size()-1 &amp;&amp; j&lt;2*m[0].size())
                mat[i][j]=hvm[i][2*m[0].size()-1-j];
            else if(i&gt;m.size()-1 &amp;&amp; i&lt;2*m.size() &amp;&amp; j&lt;m[0].size())
                mat[i][j]=hvm[2*m.size()-1-i][j];
            else if(i&gt;m.size()-1 &amp;&amp; i&lt;2*m.size() &amp;&amp; j&gt;2*m[0].size()-1)
                mat[i][j]=vm[2*m.size()-1-i][3*m[0].size()-1-j];
            else 
                mat[i][j]=hm[3*m.size()-1-i][2*m[0].size()-1-j];
        }
    }
    return mat;
}
int main() {
    int m, n;
    std::cout &lt;&lt; "Unesite dimenzije matrice (m n): ";
    std::cin &gt;&gt; m &gt;&gt; n;
    if(m&lt;0 || n&lt;0) {
        std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!";
        return 0;
    }
    Matrica mat(m, std::vector&lt;double&gt;(n));
    Matrica M;
    std::cout &lt;&lt; "Unesite elemente matrice: \n";
    for(int i(0); i&lt;m; i++) {
        for(int j(0); j&lt;n; j++) {
            double element;
            std::cin &gt;&gt; element;
            mat[i][j]=element;
        }
    }
    std::cout &lt;&lt; "Rezultantna matrica: \n";
    try {                                                                       //samo poziv f-je u try bloku, moze se sve stavit ali bez potrebe
        M=OgledaloMatrica(mat);
        for(int i(0); i&lt;M.size(); i++) {
            for(int j(0); j&lt;M[i].size(); j++) {
                std::cout &lt;&lt; std::setw(4) &lt;&lt; M[i][j];
</font>            }
            std::cout &lt;&lt; std::endl;
        }
    }
    catch(std::domain_error grbava) {
        std::cout &lt;&lt; grbava.what() &lt;&lt; std::endl;
    }
    return 0;
}</pre>
</body>
</html>
