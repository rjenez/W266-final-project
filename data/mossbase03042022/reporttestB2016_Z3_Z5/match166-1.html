<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z5/student3119.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z5/student9129.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;stdexcept&gt;

<a name="0"></a><font color="#FF0000"><a href="match166-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

int duzina__rijeci(std::string s){
    int brojac = 0;
    for(auto c: s){
        if((c&gt;='a' &amp;&amp; c&lt;='z') || (c&gt;='A' &amp;&amp; c&lt;='Z') || (c&gt;='0' &amp;&amp; c&lt;='9') )brojac++;
    }
    return brojac;
}

struct Dijete{
    std::string ime;
    Dijete *sljedeci;
};

std::vector&lt;std::set&lt;std::string&gt;&gt; Razvrstavanje(std::vector&lt;std::string&gt; v, int k){
    
    try
    {
    if(k&lt;1 || k&gt;v.size())throw std::logic_error("Razvrstavanje nemoguce");
    
    int vel = v.size();                               //23 i 3
    int br_prvih_timova = vel%k;                     //2
    int br_clanova1 = vel/k+1;                       //8
    int br_clanova2 = vel/k;                         //7
   
    std::vector&lt;std::set&lt;std::string&gt;&gt; t;
    t.resize(k);
    
    Dijete *pocetak(nullptr),*prethodni(nullptr);
    for(int i=0;i&lt;v.size();i++){
        Dijete *novi(new Dijete);
        novi-&gt;ime = v[i]; novi-&gt;sljedeci = nullptr; 
        
        if(pocetak == nullptr)pocetak = novi;
        else prethodni-&gt;sljedeci = novi;
        prethodni = novi;
    }
    
    prethodni-&gt;sljedeci = pocetak;// zadnji pok na cvor postavljamo da pokazuje na pocetak
   
   
   /*
    int tr_vel = 0;
  //samo provjera kruznog ispisa elemenata
  int i = 0;
      for(Dijete *p = pocetak;;p=p-&gt;sljedeci){
       std::cout&lt;&lt;p-&gt;ime&lt;&lt;" ";
       i++;
       if(i==10)break;
   }
   std::cout&lt;&lt;std::endl;
   
   //PRIMJER ISPRAVNOG BRISANJA drugog poka!!
   
   //auto p = pocetak-&gt;sljedeci;
   //pocetak-&gt;sljedeci = p-&gt;sljedeci;
   //delete p;
    
    
    //sada provjera ispravnog brisanja pocetka!!
    prethodni-&gt;sljedeci = pocetak-&gt;sljedeci;
    auto p=  pocetak;
    pocetak = pocetak-&gt;sljedeci;
    delete p;
    i = 0;
    
    //poslije deleta trebalo bi da ipise sve elemente osim tog i to u krug
       for(Dijete *p = pocetak;;p=p-&gt;sljedeci){
       std::cout&lt;&lt;p-&gt;ime&lt;&lt;" ";
       i++;
       if(i==10)break;
   }
   
   */
   int tr_vel = 0;
   Dijete *trenutni = nullptr;
   for(int i=0;i&lt;k;i++){
            for(int j=0;(i&gt;=br_prvih_timova) ? (j&lt;br_clanova2) : (j&lt;br_clanova1);j++){
                //brisem pocetak, prethodni i dalje pokazuje prije pocetka !!
                if(i==0 &amp;&amp; j==0){
                t[i].insert(pocetak-&gt;ime);
                tr_vel = duzina__rijeci(pocetak-&gt;ime);  
                prethodni-&gt;sljedeci = pocetak-&gt;sljedeci;
                auto p = pocetak;
                pocetak = pocetak-&gt;sljedeci;
                delete p;
                trenutni = pocetak;
                
                }else{
                    Dijete *prijetrenutnog = nullptr;
                for(int h=0;h&lt;tr_vel-1;h++){
                    if(h==tr_vel-2)prijetrenutnog = trenutni;
                    trenutni = trenutni-&gt;sljedeci;
                    
                }
                
                t[i].insert(trenutni-&gt;ime);
                
                tr_vel = duzina__rijeci(trenutni-&gt;ime);
                prijetrenutnog-&gt;sljedeci = trenutni-&gt;sljedeci;
                auto p = trenutni;
                trenutni = trenutni-&gt;sljedeci;
                delete p;
                }
            }
    }
   
   
    return t;
    }
    catch(std::bad_alloc)
    {
        
    }
}

/*
#include &lt;new&gt;
#include &lt;cstdlib&gt;
const unsigned MAX_RAM = 15 * sizeof (Dijete);
static unsigned Alocirano;
void *operator new (size_t size)
    {
        Alocirano += size;
        if (Alocirano &gt;= MAX_RAM)
            throw std::bad_alloc();
        return std::malloc(size);
    }

void operator delete (void *p) noexcept
    {
        std::free(p);
    }

*/
int main ()
{
    
//AT18 (skriveni) - testira da li su atributi strukture string i 'glupi pokazivac
//Takodjer se vrsi provjera da li su string i 'glupi' pokazivac JEDINI atributi strukture.
//Test je eliminatoran, tj. ako ovaj test pada (zadatak se ne kompajlira) dobiva se 0 poena

    
    struct Dummy {
        std::string element;
        Dummy* veza;
    };
    
    
    std::cout &lt;&lt; (sizeof (Dummy) == sizeof (Dijete) ? "OK" : "NOT OK");
    
    Dijete d;
    d.ime = "Ana";
    Dijete* glupiPok{nullptr};
    d.sljedeci = glupiPok;
    
    
	return 0;
</font>}</pre>
</body>
</html>
