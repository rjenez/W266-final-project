<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student1424.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student6553.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;cstring&gt;
#include &lt;complex&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;

enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
enum class Smjerovi
{
<a name="0"></a><font color="#FF0000"><a href="match99-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_98.gif"/></a>

    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};
enum class Komande
{
    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj,PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};
enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

bool provjera_unosa()
{
	while(std::cin.peek()==' ') std::cin.get();
	if(std::cin.peek()=='\n') return false;
	return true;
}
void PrijaviGresku(KodoviGresaka greska)
{
	const char*p[4] {"Nerazumljiva komanda!", "Komanda trazi parametar koji nije naveden!", "Zadan je suvisan parametar nakon komande!","Parametar komande nije ispravan!"};
	for(int i=0; i&lt;4; i++) {
		if(greska==KodoviGresaka(i)) std::cout&lt;&lt;p[i]&lt;&lt;std::endl;
	}
}

void odstrani_gresku()
{
	if(provjera_unosa() || !std::cin) {
		std::cin.clear();
		std::cin.ignore(1000,'\n');
	}
}

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
bool provjera(int x, int y, int n)
{
	if(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;n &amp;&amp; y&lt;n) return true;
	return false;
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
	for(int i=0; i&lt;mine.size(); i++) {
		if(mine.at(i).size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
		for(int j=0; j&lt;2; j++) {
			if(mine.at(i).at(j)&lt;0 || mine.at(i).at(j)&gt;=n) throw std::domain_error("Ilegalne pozicije mina");
		}

	}
	if(n&lt;=0) throw std:: domain_error("Ilegalna velicina");
	Tabla ploca(n, std::vector&lt;Polje&gt;(n,Polje::Prazno));
	for(int i=0; i&lt;mine.size(); i++) {
		ploca.at(mine.at(i).at(0)).at(mine.at(i).at(1))=Polje::Mina;
	}

	return ploca;
}

int BrojMina(const Tabla &amp;polja, int x, int y)
{
	int broj(0),dimenzija(polja.size());
	for(int i=x-1; i&lt;=x+1; i++) {
		for(int j=y-1; j&lt;=y+1; j++) {
			if(provjera(i,j,dimenzija)&amp;&amp; (i==x-1 || i==x+1 || j==y-1 || j==y+1) &amp;&amp; polja.at(i).at(j)==Polje::Mina) broj++;
		}
	}
	return broj;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu (const Tabla &amp;polja, int x, int y)
{
	if(!provjera(x,y,polja.size())) throw std::domain_error("Polje ("+ std::to_string(x)+"," +std::to_string(y)+") ne postoji");
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina(3, std::vector&lt;int&gt;(3,0));
	for(int i=x-1; i&lt;=x+1; i++) {
		for(int j=y-1; j&lt;=y+1; j++) {
			okolina.at(i-x+1).at(j-y+1)=BrojMina(polja, i,j);
		}
	}
	return okolina;
}
void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(!provjera(x,y,polja.size())) throw std::domain_error("Polje ("+ std::to_string(x)+"," +std::to_string(y)+") ne postoji");
	for(int i=0; i&lt;3; i++) {
		if(polja.at(x).at(y)==Polje(i)) polja.at(x).at(y)=Polje(i+3);
	}
}

void DeblokirajPolje (Tabla &amp;polja, int x, int y)
{
	if(!provjera(x,y,polja.size())) throw std::domain_error("Polje ("+ std::to_string(x)+"," +std::to_string(y)+") ne postoji");
	for(int i=3; i&lt;6; i++) {
		if(polja.at(x).at(y)==Polje(i)) polja.at(x).at(y)=Polje(i-3);
	}
}
Status Pomocna( Tabla &amp;polja, int x, int y, int&amp; nova1, int&amp; nova2)
{
	
	int dimenzija(polja.size());
	if(!provjera(x,y,dimenzija)) throw std::out_of_range("Izlazak van igrace table\n");
	if(polja.at(x).at(y)==Polje::BlokiranoPosjeceno || polja.at(x).at(y)==Polje::BlokiranoPrazno || polja.at(x).at(y)==Polje::BlokiranoMina)
		throw std::logic_error("Blokirano polje\n");

	if(polja.at(x).at(y)==Polje::Mina) {
		polja=Tabla (dimenzija, std::vector&lt;Polje&gt;(polja.size(), Polje::Prazno));
		return Status::KrajPoraz;
	}
	polja.at(nova1).at(nova2)=Polje::Posjeceno;
	nova1=x;
	nova2=y;
	for(int i=0; i&lt;dimenzija; i++) {
		for(int j=0; j&lt;dimenzija; j++) {
			if(polja.at(i).at(j)!=Polje::Posjeceno &amp;&amp; polja.at(i).at(j)!=Polje::Mina) return Status::NijeKraj;

		}
	}
	return Status:: KrajPobjeda;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
	int pomocna1(x), pomocna2(y);
	std::vector&lt;std::vector&lt;int&gt; &gt; promjena {{pomocna1-1,pomocna2-1}, {pomocna1-1,pomocna2},{pomocna1-1,pomocna2+1},{pomocna1,pomocna2+1}
		,{pomocna1+1,pomocna2+1},{pomocna1+1,pomocna2},{pomocna1+1,pomocna2-1},{pomocna1,pomocna2-1}
	};

	for(int i=0; i&lt;8; i++) {
		if(smjer==Smjerovi(i)) {
			pomocna1=promjena.at(i).at(0);
			pomocna2=promjena.at(i).at(1);
		}
	}
	try {
		return Pomocna(polja, pomocna1, pomocna2, x,y);
	} catch(...) {
		throw;
	}
}

Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	int pomocna1(novi_x),pomocna2(novi_y);
	try {
		return Pomocna(polja, pomocna1, pomocna2, x,y);
	} catch(...) {
		throw;
	}
}
bool UnosSmjera(Smjerovi &amp;smjer, KodoviGresaka &amp;greska)
{
	const char* niz_smjerovi[] {"GL","G","GD","D","DoD","Do","DoL","L"};
	char smjer1[30];
	int i;

	if(provjera_unosa()) {
		std::cin&gt;&gt;std::setw(29)&gt;&gt;smjer1;
		for( i=0; i&lt;8; i++) {
			if(strcmp(smjer1,niz_smjerovi[i])==0) {
				smjer=Smjerovi(i);
				if(provjera_unosa()) {

					greska=KodoviGresaka::SuvisanParametar;
					odstrani_gresku();
					return false;
				}
				return true;
			}
		}
		if(i==8) {
			greska=KodoviGresaka::NeispravanParametar;
			odstrani_gresku();
			return false;
		}
	}
	greska=KodoviGresaka::NedostajeParametar;
	odstrani_gresku();
	return false;
}
bool UnosCijelih(int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	int n;

	if(provjera_unosa()) {

		if(!(std::cin&gt;&gt;n) ||  (std::cin.peek()!=' ' &amp;&amp; std::cin.peek()!='\n')) {
			greska=KodoviGresaka::NeispravanParametar;
			odstrani_gresku();
			return false;
		} else {
			x=n;

			if(provjera_unosa()) {

				if(!(std::cin&gt;&gt;n) || (std::cin.peek()!='\n' &amp;&amp; std::cin.peek()!=' ')) {
					greska=KodoviGresaka::NeispravanParametar;
					odstrani_gresku();
					return false;
				} else {
					y=n;
					if(provjera_unosa()) {

						greska=KodoviGresaka::SuvisanParametar;
						odstrani_gresku();
						return false;
					}
					return true;
				}
			} else {
				greska=KodoviGresaka::NedostajeParametar;
				
			}
		}
	}
	greska=KodoviGresaka::NedostajeParametar;
	return false;
}
bool UnosKomande (Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	const char * naredbe [7] {"P1","P&gt;","B","D","PO","Z","K"};
	bool pogreska(true);
	char komanda1[30];

	std::cin&gt;&gt;std::ws;
	std::cin&gt;&gt;std::setw(29)&gt;&gt;komanda1;
	int indeks(-1);
	for(int i=0; i&lt;7; i++) {
		if(strcmp(komanda1, naredbe[i])==0) {
			indeks=i;
			komanda=Komande(i);
		}

	}

	if(indeks!=-1) {
		if(indeks==0) pogreska=UnosSmjera(smjer,greska);

		else if(indeks &lt; 4) pogreska=UnosCijelih(x,y,greska);
		else {
			if(provjera_unosa()) {

				greska=KodoviGresaka::SuvisanParametar;
				odstrani_gresku();
				return false;
			}

			return true;
		}
	} else {
		pogreska=false;
		greska=KodoviGresaka::PogresnaKomanda;
		odstrani_gresku();
	}
	return pogreska;
}
void UnosMina(Komande &amp;komanda, Tabla&amp;polja,int &amp;x, int&amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0,int p_y=0)
{
	std::vector&lt;std::vector&lt;int&gt;&gt; mine;
	int n;
	bool greska(false);
	do {
		std::cout&lt;&lt;"Unesite broj polja: ";

		std::cin&gt;&gt;n;
		greska=false;
		bool unos=provjera_unosa();
		if(!std::cin  || n&lt;=0 || unos) {
			greska=true;
			std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
			if(!std::cin || unos ) {
				std::cin.clear();
				std::cin.ignore(1000, '\n');
			}
		}


	} while(greska);


	std::complex&lt;int&gt; kompleksni;
	std::cout&lt;&lt;"Unesite pozicije mina: ";
	do {
		greska=false;
		std::cin&gt;&gt;std::ws;
		if(std::cin.peek()=='.') {
			std::cin.clear();

			std::cin.ignore(1000,'\n');
			break;
		}
		if(std::cin.peek()!='(') greska=true;
		std::cin&gt;&gt;kompleksni;
		if(!std::cin || greska || !provjera(kompleksni.real(),kompleksni.imag(), n)) {
			std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
			if(!std::cin || greska) {
				std::cin.clear();
				std::cin.ignore(1000,'\n');
			}
		} else {
			std::vector&lt;int&gt; d {kompleksni.real(),kompleksni.imag()};
			mine.push_back(d);
		}
	} while(true);
	polja=KreirajIgru(n, mine);
}
void PrikaziIspis(Komande &amp;komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0)
{
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina=PrikaziOkolinu(polja, x,y);
	for(std::vector&lt;int&gt; d: okolina) {
		for(int m: d) std::cout&lt;&lt;m&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}
}
void DB(Komande &amp;komanda, Tabla&amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0)
{
	if(komanda==Komande::Blokiraj) BlokirajPolje(polja, p_x,p_y);
	else DeblokirajPolje(polja, p_x,p_y);
}
void zavrsi (Komande &amp;komanda, Tabla&amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0)
{
	polja=Tabla(polja.size(),std::vector&lt;Polje&gt;(polja.size(),Polje::Prazno));
	throw std::runtime_error("Dovidjenja!");
}
void Polozaj(Komande &amp;komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0)
{

	Status stanje;
	try {
		if(komanda==Komande::PomjeriJednoMjesto) stanje=Idi(polja, x,y,p_smjer);
		else stanje=Idi(polja,x,y,p_x,p_y);
		if(stanje!=Status::NijeKraj) {

			if(stanje==Status::KrajPoraz) std::cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;std::endl;
			else std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;std::endl;
			zavrsi(komanda,polja, x,y);
		} else std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
	} catch(...) {
		throw;
	}
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0)
{
	void (*pok[7])(Komande&amp;,Tabla&amp;,  int&amp;, int&amp;, Smjerovi, int, int)= {Polozaj,Polozaj,DB,DB, PrikaziIspis,zavrsi, UnosMina};

	try {
		for(int i=0; i&lt;7; i++) {
			if(komanda==Komande(i)) pok[i](komanda,polja,x,y,p_smjer,p_x,p_y);
		}
	} catch(...) {
		throw;
	}
}


int main ()
{
	KodoviGresaka greska;
	Komande komanda;
	Smjerovi smjer;
	int x(0), y(0),novi_x(0),novi_y(0);
	Tabla polja;
	while(true) {
		try {
			std::cout&lt;&lt;"Unesite komandu: ";
			if(UnosKomande(komanda, smjer, novi_x,novi_y, greska)) {
				IzvrsiKomandu(komanda,polja,x,y,smjer,novi_x,novi_y);
			} else {
				PrijaviGresku(greska);
			}
		}

		catch(std::domain_error izuzetak) {
			std::cout&lt;&lt;izuzetak.what();
			return 0;
		} catch(std::out_of_range izuzetak) {
			std::cout&lt;&lt;izuzetak.what();
			return 0;
		} catch(std::logic_error izuzetak) {
			std::cout&lt;&lt;izuzetak.what();
		} catch(std::runtime_error izuzetak) {
			std::cout&lt;&lt;izuzetak.what();
			return 0;
		}
	}
	return 0;
</font>}</pre>
</body>
</html>
