<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5287.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5287.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

<a name="1"></a><font color="#00FF00"><a href="match86-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

using std::vector;
using std::string;

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
</font>};
enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka {
<a name="0"></a><font color="#FF0000"><a href="match86-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_96.gif"/></a>

	PogresnaKomanda, NedostajeParmetar, NeispravanParametar, SuvisanParametar
};
enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

typedef vector&lt;vector&lt;Polje&gt;&gt; Tabla;

//Global Var
int s_praznihPolja = 0;
//Oke
void ClearTable(Tabla &amp;polja){
	for(vector&lt;Polje&gt; &amp;red : polja)
		for(Polje &amp;p : red)
			p = Polje::Prazno;
}
//Oke
Tabla KreirajIgru(int n, const vector&lt;vector&lt;int&gt;&gt; &amp;mine){
	//Throw domain_error
	if(n &lt;= 0)
		throw std::domain_error("Ilegalna velicina");

	//Postavi tablu na Prazno
	Tabla newTable(n);
	
	for(vector&lt;Polje&gt; &amp;v : newTable){
		v.resize(n);
		for(Polje &amp;p : v){
			p = Polje::Prazno;
		}
	}
	
	//Postavi mine
	for(vector&lt;int&gt; mina : mine){
		//Moraju biti tacno dvije koord mine
		if(mina.size() != 2)
			throw std::domain_error("Ilegalan format zadavanja mina");
		
		//Koordinate moraju biti unutar table
		if( (mina[0] &lt; 0 || mina[0] &gt;= n) || (mina[1] &lt; 0 || mina[1] &gt;= n) )
			throw std::domain_error("Ilegalne pozicije mina");
		
		//Postavi minu, mozda ne valjaju koord
		newTable[mina[0]][mina[1]] = Polje::Mina;
	}
	
	//Mozda treba -1, zbog pozicije na koju se igrac postavi!
	s_praznihPolja = n*n - mine.size();
	
	return newTable;
}
//Oke
int GetFieldSum(const Tabla &amp;polja, int n, int x, int y){
	int sum = 0;
	
	for(int i = -1; i &lt;= 1; i++){
		for(int j = -1; j &lt;= 1; j++){
			//Ne gledaj trenutni element
			if(i != 0 || j != 0){
				//Ako je polja u tabli
				if(x + j &gt;= 0 &amp;&amp; x + j &lt; n &amp;&amp; y + i &gt;= 0 &amp;&amp; y + i &lt; n){
					//Te ako je mina, prebroj ga
					if(polja[y+i][x+j] == Polje::Mina){
						sum++;
					}
				}
			}
		}
	}
	
	return sum;
}
//Oke
vector&lt;vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	vector&lt;vector&lt;int&gt;&gt; okolina(3, vector&lt;int&gt;(3));
	int n = polja.size();
	
	//Mozda treba zamijeniti x i y u ispisu
	if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n)
		throw std::domain_error("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
	
	for(int i = 0; i &lt; 3; i++){
		for(int j = 0; j &lt; 3; j++){
			okolina[i][j] = GetFieldSum(polja, polja.size(), x+j-1, y+i-1);
		}
	}
	
	return okolina;
}
//Oke
void BlokirajPolje(Tabla &amp;polja, int x, int y){
	int n = polja.size();
	if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n)
		throw std::domain_error("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
	
	switch(polja[x][y]){
		case Polje::Prazno:
			polja[x][y] = Polje::BlokiranoPrazno;
			s_praznihPolja--;
			break;
		case Polje::Posjeceno:
			polja[x][y] = Polje::BlokiranoPosjeceno;
			break;
		case Polje::Mina:
			polja[x][y] = Polje::BlokiranoMina;
			break;
		default:
			break;
	}
}
//Oke
void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	int n = polja.size();
	if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n)
		throw std::domain_error("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
	
	switch(polja[x][y]){
		case Polje::BlokiranoPrazno:
			polja[x][y] = Polje::Prazno;
			s_praznihPolja++;
			break;
		case Polje::BlokiranoPosjeceno:
			polja[x][y] = Polje::Posjeceno;
			break;
		case Polje::BlokiranoMina:
			polja[x][y] = Polje::Mina;
			break;
		default:
			break;
	}
}
//Oke, valjda
Status Idi(Tabla &amp;polja, int &amp;y, int &amp;x, Smjerovi smjer){
	int n = polja.size();
	
	double pi = 4 * std::atan(1);
	int dx = std::round(std::sin(-int(smjer) * pi/4 - pi/2 - pi/4));
	int dy = std::round(std::cos(-int(smjer) * pi/4 - pi/2 - pi/4));
	
	if(x+dx &lt; 0 || x+dx &gt;= n || y+dy &lt; 0 || y+dy &gt;= n)
		throw std::out_of_range("Izlazak van igrace table");
	
	//Provjeri jel' polje blokirano
	if(polja[y+dy][x+dx] == Polje::BlokiranoPosjeceno || polja[y+dy][x+dx] == Polje::BlokiranoPrazno || polja[y+dy][x+dx] == Polje::BlokiranoMina)
		throw std::logic_error("Blokirano polje");
	
	//Oznaci polje kao posjeceno
	polja[y][x] = Polje::Posjeceno;
	s_praznihPolja--;
	
	//Pomjeri igraca
	x += dx;
	y += dy;
	
	//Provjeri jel' mina
	if(polja[y][x] == Polje::Mina){
		//Ocisti tablu
		ClearTable(polja);
		
		return Status::KrajPoraz;
	}
	
	if(s_praznihPolja == 0)
		return Status::KrajPobjeda;
	
	
	return Status::NijeKraj;
}
//Oke, valjda
Status Idi(Tabla &amp;polja, int &amp;y, int &amp;x, int novi_y, int novi_x){
	int n = polja.size();
	
	if(novi_x &lt; 0 || novi_x &gt;= n || novi_y &lt; 0 || novi_y &gt;= n)
		throw std::out_of_range("Izlazak van igrace table");
	
	//Provjeri jel' polje blokirano
	if(polja[novi_y][novi_x] == Polje::BlokiranoPosjeceno || polja[novi_y][novi_x] == Polje::BlokiranoPrazno || polja[novi_y][novi_x] == Polje::BlokiranoMina)
		throw std::logic_error("Blokirano polje");
	
	//Oznaci polje kao posjeceno
	polja[y][x] = Polje::Posjeceno;
	s_praznihPolja--;
	
	//Pomjeri igraca
	x = novi_x;
	y = novi_y;
	
	//Provjeri jel' mina
	if(polja[y][x] == Polje::Mina){
		//Ocisti tablu
		ClearTable(polja);
		return Status::KrajPoraz;
	}
	
	if(s_praznihPolja == 0)
		return Status::KrajPobjeda;
	
	
	return Status::NijeKraj;
}
//Oke
void PrijaviGresku(KodoviGresaka kod){
	const char* msgs[4]{
		"Nerazumljiva komanda!",
		"Komanda trazi parametar koji nije naveden!",
		"Parametar komande nije ispravan!",
		"Zadan je suvisan parametar nakon komande!"
	};
	
	for(int i = 0; i &lt; 4; i++){
		if(int(kod) == i){
			std::cout &lt;&lt; msgs[i];
			break;
		}
	}
}

bool CheckExcessParams(){
    char next;

	//Ako ima razmaka ili tabova, ukloni ih
	while(next = std::cin.peek(), next == ' ' || next == '\t')
		std::cin.get();
	
	if(std::cin.peek() == '\n'){
		std::cin.get();
		return false;
	}
    
    std::cin.ignore(1024, '\n');
    return true;
}
//Oke
bool InputCoord(int &amp;x, int y, KodoviGresaka &amp;greska){
	int tempx, tempy;
	string cmd;
	char next;
	
	//Unesi koord
	std::cin &gt;&gt; tempx;
	if(next = std::cin.peek(), next != '\n' &amp;&amp; next != '\t' &amp;&amp; next != ' '){
		greska = KodoviGresaka::NeispravanParametar;
		return false;
	}
	//Ako nije int, neispravan parametar
	if(!std::cin){
		greska = KodoviGresaka::NeispravanParametar;
		std::cin.clear();
		
		std::cin &gt;&gt; cmd;
		//Jel' manjak parametar ili je neispravan?
		if(cmd == "K" || cmd == "Z" || cmd == "PO" || cmd == "B" || cmd == "D" || cmd == "P1" || cmd == "P&gt;")
			greska = KodoviGresaka::NedostajeParmetar;
		
		return false;
	}
	//Unesi koord y
	std::cin &gt;&gt; tempy;
	
	if(next = std::cin.peek(), next != '\n' &amp;&amp; next != '\t' &amp;&amp; next != ' '){
		greska = KodoviGresaka::NeispravanParametar;
		return false;
	}
	//Ako nije int, neispravan parametar
	if(!std::cin){
		greska = KodoviGresaka::NeispravanParametar;
		std::cin.clear();
		
		std::cin &gt;&gt; cmd;
		//Jel' manjak parametar ili je neispravan?
		if(cmd == "K" || cmd == "Z" || cmd == "PO" || cmd == "B" || cmd == "D" || cmd == "P1" || cmd == "P&gt;")
			greska = KodoviGresaka::NedostajeParmetar;
		
		return false;
	}
	
	if(CheckExcessParams()){
		greska = KodoviGresaka::SuvisanParametar;
		return false;
	}
	
	x = tempx;
	y = tempy;
	return true;
}
//Oke
bool InputDir(Smjerovi &amp;smjer, KodoviGresaka &amp;greska){
	string dir; 
	Smjerovi sm;
	bool input = false;
	const char* possibleDirs[]{
		"GL", "G", "GD", "D", "DoD", "Do", "DoL", "L"
	};
	
	std::cin &gt;&gt; dir;
	
	for(int i = 0; i &lt; 8; i++){
		if(dir == possibleDirs[i]){
			input = true;
			sm = Smjerovi(i);
			break;
		}
	}
	if(!input){
		greska = KodoviGresaka::NeispravanParametar;
		
		//Jel' manjak parametar ili je neispravan?
		if(dir == "K" || dir == "Z" || dir == "PO" || dir == "B" || dir == "D" || dir == "P1" || dir == "P&gt;")
			greska = KodoviGresaka::NedostajeParmetar;
		
		return false;
	}
	
	if(CheckExcessParams()){
		greska = KodoviGresaka::SuvisanParametar;
		return false;
	}
	
	smjer = sm;
	
	return true;
}
//Oke
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	string cmd;
	bool input;
	
	//Unos komande
	std::cin &gt;&gt; cmd;
	
	//Bezparametarske komande
	if(cmd == "PO" || cmd == "K" || cmd == "Z"){
		if(CheckExcessParams()){
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		if(cmd == "PO")
			komanda = Komande::PrikaziOkolinu;
		else if(cmd == "K")
			komanda = Komande::KreirajIgru;
		else
			komanda = Komande::ZavrsiIgru;
	}
	//Koordinatne komande
	else if(cmd == "P&gt;" || cmd == "B" || cmd == "D"){
		input = InputCoord(x, y, greska);
		if(!input)
			return false;
		
		if(cmd == "P&gt;")
			komanda = Komande::PomjeriDalje;
		else if(cmd == "B")
			komanda = Komande::Blokiraj;
		else
			komanda = Komande::Deblokiraj;
	}else if(cmd == "P1"){
		input = InputDir(smjer, greska);
		if(!input)
			return false;
		
		komanda = Komande::PomjeriJednoMjesto;
	}else{
		greska = KodoviGresaka::PogresnaKomanda;
		std::cin.ignore();
		return false;
	}
	
	return true;
}

bool InputInt(int &amp;broj){
	int temp;
	std::cin &gt;&gt; temp;
	
	if(!std::cin){
		std::cin.clear();
		std::cin.ignore(1024, '\n');
		std::cout &lt;&lt; "Greska, unesite ponovo!\n";
		return false;
	}
	
	char next;
	if(next = std::cin.peek(), next != '\n' &amp;&amp; next != '\t' &amp;&amp; next != ' ' &amp;&amp; next != ',' &amp;&amp; next != ')'){
		std::cin.ignore(1024, '\n');
		std::cout &lt;&lt; "Greska, unesite ponovo!\n";
		return false;
	}
	
	broj = temp;
	return true;
}

bool CharBroj(char c){
	return c &gt;= '0' &amp;&amp; c &lt;= '9';
}

bool UnosMina(int n, vector&lt;vector&lt;int&gt;&gt; &amp;mine){
	int x, y;
	char c;
	
	std::cin &gt;&gt; c;
	
	if(c == '.')
		return true;
	
	if(c != '('){
		std::cout &lt;&lt; "Greska, unesite ponovo!\n";
		std::cin.ignore(1024, '\n');
		return false;
	}
	
	bool intOk = InputInt(x);
	if(intOk){
		if(x &gt;= n){
			std::cout &lt;&lt; "Greska, unesite ponovo!\n";
			std::cin.ignore(1024, '\n');
			return false;
		}
	}else{
		std::cout &lt;&lt; "Greska, unesite ponovo!\n";
		std::cin.ignore(1024, '\n');
		return false;
	}
		
	std::cin &gt;&gt; c;
	if(c != ','){
		std::cout &lt;&lt; "Greska, unesite ponovo!\n";
		std::cin.ignore(1024, '\n');
		return false;
	}
	
	intOk = InputInt(y);
	if(intOk){
		if(y &gt;= n){
			std::cout &lt;&lt; "Greska, unesite ponovo!\n";
			std::cin.ignore(1024, '\n');
			return false;
		}
	}else {
		std::cout &lt;&lt; "Greska, unesite ponovo!\n";
		std::cin.ignore(1024, '\n');
		return false;
	}
		
	std::cin &gt;&gt; c;
	if(c != ')'){
		std::cout &lt;&lt; "Greska, unesite ponovo!\n";
		std::cin.ignore(1024, '\n');
		return false;
	}
	
	mine.push_back({x, y});
	return false;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0){
	try{
		if(komanda == Komande::KreirajIgru){
			int n;
			std::cout &lt;&lt; "Unesite broj polja: ";
			while(!InputInt(n));
			
			std::cout &lt;&lt; "Unesite pozicije mina: ";
			vector&lt;vector&lt;int&gt;&gt; mine;
			while(!UnosMina(n, mine));
			
			polja = KreirajIgru(n, mine);
		}
		else if(komanda == Komande::Blokiraj)
			BlokirajPolje(polja, x, y);
		else if(komanda == Komande::Deblokiraj)
			DeblokirajPolje(polja, x, y);
		else if(komanda == Komande::PrikaziOkolinu){
			auto okolina = PrikaziOkolinu(polja, x, y);
			for(vector&lt;int&gt; red : okolina){
				for(int i : red)
					std::cout &lt;&lt; i &lt;&lt; " ";
				std::cout &lt;&lt; std::endl;
			}
		}
	}catch(std::exception &amp;err){
		std::cout &lt;&lt; err.what() &lt;&lt; std::endl;
		return;
	}
	
	if(komanda == Komande::PomjeriJednoMjesto){
		Status state;
		try{
			state = Idi(polja, x, y, p_smjer);
		}catch(std::exception &amp;err){
			std::cout &lt;&lt; err.what() &lt;&lt; std::endl;
			return;
		}
		if(state == Status::KrajPobjeda){
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja";
			ClearTable(polja);
			throw std::runtime_error("Igra zavrsena");
		}else if(state == Status::KrajPoraz){
			std::cout &lt;&lt; "Nagazili ste na minu";
			ClearTable(polja);
			throw std::runtime_error("Igra zavrsena");
		}
		std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")\n";
	}
	else if(komanda == Komande::PomjeriDalje){
		Status state;
		try{
			state = Idi(polja, x, y, p_x, p_y);
		}catch(std::exception &amp;err){
			std::cout &lt;&lt; err.what() &lt;&lt; std::endl;
			return;
		}
		if(state == Status::KrajPobjeda){
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja";
			ClearTable(polja);
			throw std::runtime_error("Igra zavrsena");
		}else if(state == Status::KrajPoraz){
			std::cout &lt;&lt; "Nagazili ste na minu";
			ClearTable(polja);
			throw std::runtime_error("Igra zavrsena");
		}
		std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")\n";
	}
	else if(komanda == Komande::ZavrsiIgru){
		ClearTable(polja);
		throw std::runtime_error("Igra zavrsena");
	}
}

int main () {
	Tabla tabla{};
	Komande komanda;
	KodoviGresaka greska;
	int x = 0, y = 0, nx = 0, ny = 0;
	Smjerovi smjer;
	bool input;
	
	while(true){
		try{
			std::cout &lt;&lt; "Unesite komandu: ";
			input = UnosKomande(komanda, smjer, nx, ny, greska);
			if(input){
				if(komanda != Komande::PomjeriDalje){
					if(komanda == Komande::Blokiraj || komanda == Komande::Deblokiraj)
						IzvrsiKomandu(komanda, tabla, nx, ny, smjer);
					else
						IzvrsiKomandu(komanda, tabla, x, y, smjer);
				}else
					IzvrsiKomandu(komanda, tabla, x, y, smjer, nx, ny);
				
			}
			else{
				PrijaviGresku(greska);
				std::cout &lt;&lt; std::endl;
			}
		}catch(std::runtime_error err){
			//std::cout &lt;&lt; err.what();
			std::cout &lt;&lt; "Dovidjenja!";
</font>			break;
		}
	}
	
	return 0;
}</pre>
</body>
</html>
