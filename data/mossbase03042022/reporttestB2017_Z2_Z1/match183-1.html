<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student7597.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student8257.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;

<a name="0"></a><font color="#FF0000"><a href="match183-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using std::vector;

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
	ZavrsiIgru, KreirajIgru
};

enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar
};
enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};

enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
typedef vector&lt;vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n,const vector&lt;vector&lt;int&gt;&gt; &amp;mine) {
	if(n&lt;=0) throw std::domain_error("Ilegalna velicina");  // Provjera ispravnosti
	for(vector&lt;int&gt; koord : mine) {
		if(koord.size() != 2) throw std::domain_error("Ilegalan format zadavanja mina");
		for(int koordinata : koord)
			if(koordinata &gt;= n || koordinata &lt; 0 ) throw std::domain_error("Ilegalne pozicije mina");
	} // !!
	Tabla novaTabla(n,vector&lt;Polje&gt;(n,Polje::Prazno)); // Kreiranje table
	for(vector&lt;int&gt; koord : mine)
		novaTabla.at(koord.at(0)).at(koord.at(1)) = Polje::Mina;
	return novaTabla;
}
int brojMinaUOkolini(const Tabla &amp;polja , int x , int y) {
		int brojMina = 0;
		for(int i=x-1;i&lt;x+1;i++) {
			for(int j=y-1;j&lt;y+1;j++) {
				if(i&lt;0 || j&lt;0 || i==j)
					continue;
				if(polja.at(i).at(j) == Polje::Mina)
					brojMina++;
			}
		}
		return brojMina;
}

vector&lt;vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y &gt;= polja.size())
			throw std::domain_error("Polje (x,y) ne postoji");
	vector&lt;vector&lt;int&gt;&gt; okolina(3);
	int red=0;
	for(int i=x-1;i&lt;x+1;i++) {
		for(int j=y-1;j&lt;y+1;j++) {
			okolina.at(red).push_back(brojMinaUOkolini(polja,i,j);
		}
	}
	return okolina;
}
void BlokirajPolje(Tabla &amp;polja ,int x ,int y) {
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y &gt;= polja.size())
			throw std::domain_error("Polje (x,y) ne postoji");
	if(int(polja.at(x).at(y))&gt;2) return ;
	polja.at(x).at(y) = Polje(int(polja.at(x).at(y))+3);
	/*if(polja.at(x).at(y)==Polje::Prazno)
		polja.at(x).at(y)=Polje::BlokiranoPrazno;
	else if(polja.at(x).at(y)==Polje::Posjeceno)
		polja.at(x).at(y)=Polje::BlokiranoPosjeceno;
	else if(polja.at(x).at(y)==Polje::Mina)
		polja.at(x).at(y)=Polje::BlokiranoMina;*/
}
void DeblokirajPolje(Tabla &amp;polja , int x , int y) {
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y &gt;= polja.size())
			throw std::domain_error("Polje (x,y) ne postoji");
	if(int(polja.at(x).at(y))&lt;=2) return ;
	polja.at(x).at(y) = Polje(int(polja.at(x).at(y))-3);
}
Status statusTable(const Tabla &amp;polja,int x, int y) {
	if(polja.at(x).at(y) == Polje::Mina)
		return Status::KrajPoraz;
	for(vector&lt;Polje&gt; red : Tabla)
		for(Polje polje : red)
			if(polje==Polje::Prazno) return Status::NijeKraj;
	return Status::KrajPobjeda;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	polja.at(x).at(y) = Polje::Posjeceno;
	if(smjer == Smjerovi::GoreLijevo)   x-- , y--;
	if(smjer == Smjerovi::Gore)         x--;
	if(smjer == Smjerovi::GoreDesno)    x-- , y++;
	if(smjer == Smjerovi::Desno)  	     	  y++;
	if(smjer == Smjerovi::DoljeDesno)   x++ , y++;
	if(smjer == Smjerovi::Dolje)        x++;
	if(smjer == Smjerovi::DoljeLijevo)  x++ , y--;
	if(smjer == Smjerovi::Lijevo)       	  y--:
	if(x&lt;0 || y&lt;0 || x&gt;polja.size() || y&gt;polja.size())
		throw std::out_of_range("Izlazak van igrace table");
	if(int(polja.at(x).at(y))&gt;2) 
		throw std::logic_eror("Blokirano polje");
	return statusTable(polja);
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	polja.at(x).at(y) = Polje::Posjeceno;
	x = novi_x; 
	y = novi_y;
	if(x&lt;0 || y&lt;0 || x&gt;polja.size() || y&gt;polja.size())
		throw std::out_of_range("Izlazak van igrace table");
	if(int(polja.at(x).at(y))&gt;2) 
		throw std::logic_eror("Blokirano polje");
	return statusTable(polja);
}
void PrijaviGresku(KodoviGresaka greska) {
	if(greska==KodoviGresaka::PogresnaKomanda) std::cout&lt;&lt;"Nerazumljiva komanda!";
	if(greska==KodoviGresaka::NedostajeParmetar) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!";
	if(greska==KodoviGresaka::NeispravanParametar) std::cout&lt;&lt;"Parametar komande nije ispravan!";
	if(greska==KodoviGresaka::SuvisanParametar) std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!";
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y,KodoviGresaka &amp;greska) {
	string unos;
	std::getline(std::cin,unos);
}














int main ()
{
	return 0;
</font>}</pre>
</body>
</html>
