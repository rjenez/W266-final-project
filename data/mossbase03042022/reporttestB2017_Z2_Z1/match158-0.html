<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student3568.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student3568.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.
 
	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

enum class Polje 
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande
{
<a name="1"></a><font color="#00FF00"><a href="match158-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_40.gif"/></a>

    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

bool IspravnoPolje(int x, int y, int n)
{
	return(x&gt;=0 &amp;&amp; x&lt;=n-1 &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=n-1);

}

Tabla KreirajIgru (int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{

	if(n&lt;=0)
		throw std::domain_error("Ilegalna velicina!");

	Tabla t(n, std::vector&lt;Polje&gt;(n, Polje :: Prazno));

	for(int i=0; i&lt;mine.size(); i++) {
		if(mine.at(i).size() != 2)
			throw std::domain_error ("Ilegalan format zadavanja mina!");

		for(int j=0; j&lt;mine.at(0).size(); j++) {
			if(mine.at(i).at(j) &lt; 0 || mine.at(i).at(j) &gt; n-1
			        || mine.at(i).at(j+1) &lt; 0 || mine.at(i).at(j+1) &gt; n-1 )
				throw std::domain_error ("Ilegalne pozicije mina!");

			t.at(mine.at(i).at(j)).at(mine.at(i).at(j+1)) = Polje::Mina;
			j++;
		}
	}

	return t;
}

int BrojMinaUOkolini(const Tabla &amp;polja, int x, int y)
{
	int mine(0);

	for(int i=x-1; i&lt;=x+1; i++) {
		for(int j=y-1; j&lt;=y+1; j++) {
			if(IspravnoPolje(i,j,polja.size()) &amp;&amp; (i!=x || j!=y) &amp;&amp; polja.at(i).at(j)==Polje :: Mina)
				mine++;
		}
	}

	return mine;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu (const Tabla &amp;polja, int x, int y)
{

	if(!IspravnoPolje(x,y,polja.size()))
		throw std::domain_error (std::string("Polje (") + std::to_string(x) + std::string(",") + std::to_string(y) + std::string(") ne postoji"));
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina(3, std::vector&lt;int&gt;(3,0));
	int m(0), n(0);
	for(int i=x-1; i&lt;=x+1; i++) {
		n=0;
		for(int j=y-1; j&lt;=y+1; j++) {
			okolina.at(m).at(n)=BrojMinaUOkolini(polja, i, j);
			n++;
		}
		m++;
	}

	return okolina;
}

void BlokirajPolje (Tabla &amp;polja, int x, int y)
{

	if(x&lt;0 || x&gt;polja.size()-1 || y&lt;0 || y&gt;polja.size()-1)
		throw std::domain_error (std::string("Polje (") + std::to_string(x) + std::string(",") + std::to_string(y) + std::string(") ne postoji"));

	if (polja.at(x).at(y) == Polje :: Prazno)
		polja.at(x).at(y) = Polje :: BlokiranoPrazno;
</font>	else if (polja.at(x).at(y) == Polje :: Posjeceno)
		polja.at(x).at(y) = Polje :: BlokiranoPosjeceno;
	else if (polja.at(x).at(y) == Polje :: Mina)
<a name="2"></a><font color="#0000FF"><a href="match158-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

		polja.at(x).at(y) = Polje :: BlokiranoMina;
}

void DeblokirajPolje (Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 || x&gt;polja.size()-1 || y&lt;0 || y&gt;polja.size()-1)
		throw std::domain_error (std::string("Polje (") + std::to_string(x) + std::string(",") + std::to_string(y) + std::string(") ne postoji"));

	if (polja.at(x).at(y) == Polje :: BlokiranoPrazno)
		polja.at(x).at(y) = Polje :: Prazno;
</font>	else if (polja.at(x).at(y) == Polje :: BlokiranoPosjeceno)
		polja.at(x).at(y) = Polje :: Posjeceno;
<a name="0"></a><font color="#FF0000"><a href="match158-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_41.gif"/></a>

	else if (polja.at(x).at(y) == Polje :: BlokiranoMina)
		polja.at(x).at(y) = Polje :: Mina;
}

void OcistiMatricu(Tabla &amp;polja)
{
	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja.at(i).size(); j++)
			polja.at(i).at(j) = Polje :: Prazno;
	}
}

int BrojPraznih (const Tabla &amp;polja)
{
	int brojac(0);

	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; i&lt;polja.at(i).size(); j++) {
			if(polja.at(i).at(j) == Polje :: Prazno)
				brojac++;
		}
	}

	return brojac;
}


Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{

	const int pomak[8][2] {{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1}};
	int tmp_x(x+pomak[int(smjer)][0]), tmp_y(y+pomak[int(smjer)][1]);

	if(polja.at(tmp_x).at(tmp_y) == Polje :: BlokiranoPosjeceno ||
	        polja.at(tmp_x).at(tmp_y) == Polje :: BlokiranoPrazno ||
	        polja.at(tmp_x).at(tmp_y) == Polje :: BlokiranoMina)
		throw std::logic_error ("Blokirano polje");
	if(IspravnoPolje(tmp_x, tmp_y, polja.size())) {
		x=tmp_x;
		x=tmp_y;
	} else
		throw std::out_of_range ("Izlazak van igrace table.");

	if(polja.at(x).at(y) == Polje :: Mina) {
		OcistiMatricu(polja);
		return Status :: KrajPoraz;
	} else if(polja.at(x).at(y) == Polje :: Prazno &amp;&amp; BrojPraznih(polja)==0) {
		return Status :: KrajPobjeda;
	}

	polja.at(x).at(y) = Polje :: Posjeceno;
	return Status :: NijeKraj;

}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if(polja.at(novi_x).at(novi_y) == Polje :: BlokiranoPosjeceno ||
	        polja.at(novi_x).at(novi_y) == Polje :: BlokiranoPrazno ||
	        polja.at(novi_x).at(novi_y) == Polje :: BlokiranoMina)
		throw std::logic_error ("Blokirano polje");

	if(IspravnoPolje(novi_x, novi_y, polja.size())) {
		x=novi_x;
		y=novi_y;
	} else
		throw std::out_of_range ("Izlazak van igrace table.");

	if(polja.at(x).at(y) == Polje :: Mina) {
		OcistiMatricu(polja);
		return Status :: KrajPoraz;
	} else if(polja.at(x).at(y) == Polje :: Prazno &amp;&amp; BrojPraznih(polja)==0) {
		return Status :: KrajPobjeda;
	}

	polja.at(x).at(y) = Polje :: Posjeceno;
	return Status :: NijeKraj;
}

void PrijaviGresku (KodoviGresaka greska)
{
	switch (greska) {
	case KodoviGresaka::PogresnaKomanda :
		std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl;
		break;
	case KodoviGresaka::NedostajeParametar :
		std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
		break;
	case KodoviGresaka::NeispravanParametar :
		std::cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; std::endl;
		break;
	case KodoviGresaka::SuvisanParametar :
		std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt; std::endl;
	}
}
 

int main ()
</font>{
	return 0;
}
</pre>
</body>
</html>
