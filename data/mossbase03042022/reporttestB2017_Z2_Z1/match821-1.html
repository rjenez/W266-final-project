<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student8892.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student2035.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

enum class Polje{Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};
enum class Smjerovi{GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class Status{NijeKraj, KrajPoraz, KrajPobjeda}; 
enum class KodoviGresaka{PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar}; 
enum class Komande{PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru}; 
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

void ObrisiTablu(Tabla &amp;igra) {
	for(int i=0; i&lt;igra.size(); i++)
	for(int j=0; j&lt;igra[i].size(); j++)
	igra[i][j]=Polje::Prazno; }

void ProvjeraVektoraMina(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine, bool &amp;ilegalnapozicija, bool &amp;ilegalanformat, int n) {
	for(int i=0; i&lt;mine.size(); i++) {
		if(mine[i].size()!=2) ilegalanformat=true; //eh sad ovdje dal da breakam ili ne jer ne znam kojim redosljedom ide ono cudo?
		for(int j=0; j&lt;mine[i].size(); j++) {
			if(mine[i][j]&gt;=n || mine[i][j]&lt;0) ilegalnapozicija=true; } } }

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	if(n&lt;=0) throw std::domain_error("Ilegalna velicina");
	bool ilegalnapozicija(false), ilegalanformat(false); 
	ProvjeraVektoraMina(mine, ilegalnapozicija, ilegalanformat, n); 
	if(ilegalanformat) throw std::domain_error("Ilegalan format zadavanja mina");
	if(ilegalnapozicija) throw std::domain_error("Ilegalne pozicije mina"); 
	Tabla igra(n, std::vector&lt;Polje&gt; (n, Polje::Prazno)); 
	for(int i=0; i&lt;mine.size(); i++)
	igra[mine[i][0]][mine[i][1]]=Polje::Mina; 
	return igra; }

int SumaOkoline(const Tabla &amp;polja, int x, int y) {
	int suma(0); 
	for(int i=x-1; i&lt;=x+1; i++) {
		if(i&lt;0) continue;
		if(i==polja.size()) continue; 
	for(int j=y-1; j&lt;=y+1; j++)
	{	if(j&lt;0) continue;
		if(j==polja.size()) continue;
		if(i==x &amp;&amp; j==y) continue;
	
		if(i&lt;polja.size() &amp;&amp; i&gt;=0 &amp;&amp; j&lt;polja.size() &amp;&amp; j&gt;=0 &amp;&amp; polja.at(i).at(j)==Polje::Mina) suma++; 
	
	} }
	return suma; }

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || polja.size()==0) throw std::domain_error("Polje (" +std::to_string(x) +"," +std::to_string(y)+") ne postoji"); 
	if(y&gt;=polja[0].size()) throw std::domain_error("Polje (" + std::to_string(x)+"," +std::to_string(y)+") ne postoji"); 
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina(3, std::vector&lt;int&gt; (3,0));
	for(int i=0; i&lt;3; i++)
	for(int j=0; j&lt;3; j++){
//	if(x-1+i&gt;=0 &amp;&amp; y-1+j&gt;=0 &amp;&amp; x-1+i&lt;polja.size() &amp;&amp; y-1+j&lt;polja.size())
	okolina[i][j]=SumaOkoline(polja, x-1+i, y-1+j); } 
	return okolina; }

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size()) throw std::domain_error(static_cast&lt;std::string&gt;("Polje (") +std::to_string(x) + "," + std::to_string(y)+ ") ne postoji"); 
	if(y&gt;=polja[0].size()) throw std::domain_error("Polje (" +std::to_string(x) + "," +std::to_string(y) + ") ne postoji"); 
	if(polja[x][y]==Polje::Prazno) polja[x][y]=Polje::BlokiranoPrazno; 
	else if(polja[x][y]==Polje::Mina) polja[x][y]=Polje::BlokiranoMina; 
<a name="1"></a><font color="#00FF00"><a href="match821-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	else if(polja[x][y]==Polje::Posjeceno) polja[x][y]=Polje::BlokiranoPosjeceno; }

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size()) throw std::domain_error("Polje (" +std::to_string(x) +"," + std::to_string(y)+ ") ne postoji"); 
</font>	if(y&gt;=polja[0].size()) throw std::domain_error("Polje (" +std::to_string(x) + "," + std::to_string(y) +") ne postoji"); 
	if(polja[x][y]==Polje::BlokiranoPrazno) polja[x][y]=Polje::Prazno; 
	else if(polja[x][y]==Polje::BlokiranoPosjeceno) polja[x][y]=Polje::Posjeceno; 
<a name="4"></a><font color="#FF00FF"><a href="match821-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

	else if(polja[x][y]==Polje::BlokiranoMina) polja[x][y]=Polje::Mina; }

bool PostojiJosPraznih(const Tabla &amp;polja) { //ovdje se uzdam da mi je ok tabla ali eto mozda dodaj neku provjeru
</font>	for(int i=0; i&lt;polja.size(); i++)
	for(int j=0; j&lt;polja[i].size(); j++) 
		if(polja[i][j]==Polje::Prazno) return true;
	return false; }

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	int potencijalno_novi_x(x);
	int potencijalno_novi_y(y); 
	if(smjer==Smjerovi::GoreLijevo) {
		potencijalno_novi_x=x-1;
		potencijalno_novi_y=y-1;
	}
	else if(smjer==Smjerovi::Gore) {
		potencijalno_novi_x=x-1;
	}
	else if(smjer==Smjerovi::GoreDesno) {
		potencijalno_novi_x=x-1;
		potencijalno_novi_y=y+1; 
	}
	else if(smjer==Smjerovi::Desno) {
		potencijalno_novi_y=y+1; 
	}
	else if(smjer==Smjerovi::DoljeDesno) {
		potencijalno_novi_x=x+1;
		potencijalno_novi_y=y+1; 
	}
	else if(smjer==Smjerovi::Dolje) {
		potencijalno_novi_x=x+1; 
	}
	else if(smjer==Smjerovi::DoljeLijevo) {
		potencijalno_novi_x=x+1;
		potencijalno_novi_y=y-1; 
	}
	else if(smjer==Smjerovi::Lijevo) {
		potencijalno_novi_y=y-1; 
	}
	if(potencijalno_novi_x&lt;0 || potencijalno_novi_y&lt;0 || potencijalno_novi_x&gt;=polja.size() || potencijalno_novi_y&gt;=polja[0].size()) throw std::out_of_range("Izlazak van igrace table"); 
	//razdvoji ovaj uslov za svaki slucaj
<a name="5"></a><font color="#FF0000"><a href="match821-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

	if(polja[potencijalno_novi_x][potencijalno_novi_y]==Polje::BlokiranoPosjeceno || polja[potencijalno_novi_x][potencijalno_novi_y]==Polje::BlokiranoPrazno || polja[potencijalno_novi_x][potencijalno_novi_y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
	polja[x][y]=Polje::Posjeceno; 
</font><a name="3"></a><font color="#00FFFF"><a href="match821-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

	x=potencijalno_novi_x;
	y=potencijalno_novi_y;
	if(polja[x][y]==Polje::Mina) { ObrisiTablu(polja); return Status::KrajPoraz; } 
</font>	if(!PostojiJosPraznih(polja)) { ObrisiTablu(polja); return Status::KrajPobjeda; }
	return Status::NijeKraj; }

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	if(novi_x&lt;0 || novi_y&lt;0 || novi_x&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table"); 
	if(novi_y&gt;=polja[0].size()) throw std::out_of_range("Izlazak van igrace table"); 
<a name="6"></a><font color="#00FF00"><a href="match821-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

	if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno || polja[novi_x][novi_y]==Polje::BlokiranoPrazno || polja[novi_x][novi_y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje"); 
	polja[x][y]=Polje::Posjeceno; 
</font>	x=novi_x;
	y=novi_y;
	if(polja[x][y]==Polje::Mina) { ObrisiTablu(polja); return Status::KrajPoraz;	} 
	if(!PostojiJosPraznih(polja)) { ObrisiTablu(polja); return Status::KrajPobjeda; } 
	return Status::NijeKraj; }

bool JesuLiSviBrojevi(std::string rijec) {
	for(int i=0; i&lt;rijec.size(); i++)
	if(!(rijec[i]&gt;='0' &amp;&amp; rijec[i]&lt;='9')) return false; //************************************************ovo provjeri asja
	return true; }

bool ProvjeraZaP1(const std::vector&lt;std::string&gt; &amp;recenica, KodoviGresaka &amp;greska, Komande &amp;komanda, Smjerovi &amp;smjer) {
	if(recenica.size()&lt; 2) { 
		greska=KodoviGresaka::NedostajeParametar;
		return false; }
	if(recenica.size()&gt;2) {
		greska=KodoviGresaka::SuvisanParametar; 
		return false; }
	std::vector&lt;std::string&gt; lista{"GL", "G", "GD", "D", "DoD", "Do", "DoL", "L"};
	for(int i=0; i&lt;8; i++) {
	if(recenica[1]==lista[i]) { 
	komanda=Komande::PomjeriJednoMjesto;
	smjer=static_cast&lt;Smjerovi&gt;(i);  // *********************WISHFUL THINKING ALL THE WAY***********************
	return true; } }
	greska=KodoviGresaka::NeispravanParametar;
	return false; }

bool ProvjeraZaPO(const std::vector&lt;std::string&gt; &amp;recenica, KodoviGresaka &amp;greska, Komande &amp;komanda) {
	if(recenica.size()&gt;1) {
		greska=KodoviGresaka::SuvisanParametar; 
		return false;
	}
	komanda=Komande::PrikaziOkolinu;
	return true; }

bool ProvjeraZaZ(const std::vector&lt;std::string&gt; &amp;recenica, KodoviGresaka &amp;greska, Komande &amp;komanda) {
	if(recenica.size()&gt;1) {
		greska=KodoviGresaka::SuvisanParametar;
		return false;
	}
	komanda=Komande::ZavrsiIgru; 
	return true; }
	
bool ProvjeraZaK(const std::vector&lt;std::string&gt; &amp;recenica, KodoviGresaka &amp;greska, Komande &amp;komanda) {
	if(recenica.size()&gt;1) {
		greska=KodoviGresaka::SuvisanParametar;
		return false;
	}
	komanda=Komande::KreirajIgru;
	return true; }

bool ProvjeraZaOveSa3Parametra(const std::vector&lt;std::string&gt; &amp;recenica, KodoviGresaka &amp;greska, int &amp;x, int &amp;y) {
	if(recenica.size()&gt;=2 &amp;&amp; !JesuLiSviBrojevi(recenica[1])) {greska=KodoviGresaka::NeispravanParametar; return false;}
	if(recenica.size()&lt;3) {
		greska=KodoviGresaka::NedostajeParametar; 
		return false;
	}
	if(recenica.size()&gt;3) {
		greska=KodoviGresaka::SuvisanParametar;
		return false; 
	}
	
	if(!JesuLiSviBrojevi(recenica[1]) || !JesuLiSviBrojevi(recenica[2])) {
		greska=KodoviGresaka::NeispravanParametar; 
		return false;
	}
	x=std::stoi(recenica[1]);
	y=std::stoi(recenica[2]); //std::cout&lt;&lt; "U ONOJ SAM PROVJERI x i y su" &lt;&lt;x &lt;&lt; " " &lt;&lt; y; 
	return true; }
	
bool ProvjeraZaPs(const std::vector&lt;std::string&gt; &amp;recenica, KodoviGresaka &amp;greska, Komande &amp;komanda, int &amp;x, int &amp;y) {
	if(!ProvjeraZaOveSa3Parametra(recenica, greska, x, y)) return false;
	komanda=Komande::PomjeriDalje;
	return true; }

bool ProvjeraZaB(const std::vector&lt;std::string&gt; &amp;recenica, KodoviGresaka &amp;greska, Komande &amp;komanda, int &amp;x, int &amp;y) {
	if(!ProvjeraZaOveSa3Parametra(recenica, greska, x, y)) return false; 
	komanda=Komande::Blokiraj;
	return true; }
	
bool ProvjeraZaD(const std::vector&lt;std::string&gt; &amp;recenica, KodoviGresaka &amp;greska, Komande &amp;komanda, int &amp;x, int &amp;y) {
	if(!ProvjeraZaOveSa3Parametra(recenica, greska, x, y)) return false;
	komanda=Komande::Deblokiraj; 
<a name="2"></a><font color="#0000FF"><a href="match821-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

	return true; }

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) { 
	std::string recenica; 
	std::getline(std::cin, recenica);
</font>	int brojrijeci(0);
	std::vector&lt;std::string&gt; lista; 
	std::string rijec; 
	bool bio_razmak(1); 
	for(int i=0; i&lt;recenica.size(); i++) {
		if(recenica[i]==' ') {
			bio_razmak=true; 
		}
		else{	if(bio_razmak) {
				while(recenica[i]!=' ' &amp;&amp; i!=recenica.size()) {
					rijec.push_back(recenica[i]); 
					i++;	}
					lista.push_back(rijec); 
					brojrijeci++;
					i--;
					rijec.resize(0);
					bio_razmak=false; } }
	}
	if(lista.size()==0) return false; //stavi neku greksu 
	if(lista[0]=="P1") { if(!ProvjeraZaP1(lista, greska, komanda, smjer)) return false; //1
		return true;
	}
	if(lista[0]=="PO") { if(!ProvjeraZaPO(lista, greska, komanda)) return false; //2
	return true; }
	if(lista[0]=="Z") { if(!ProvjeraZaZ(lista, greska, komanda)) return false; //3
	return true; }
	if(lista[0]=="K")	{ if(!ProvjeraZaK(lista, greska, komanda)) return false; //4
	return true; }
	if(lista[0]=="P&gt;") { if(!ProvjeraZaPs(lista, greska, komanda, x, y)) return false; //5
	return true; }
	if(lista[0]=="B") { if(!ProvjeraZaB(lista, greska, komanda, x, y)) return false; //6
		return true; }
	if(lista[0]=="D") { if(!ProvjeraZaD(lista, greska, komanda, x, y)) return false; //7
		return true;
	}
	greska=KodoviGresaka::PogresnaKomanda;
	return false; }

<a name="7"></a><font color="#0000FF"><a href="match821-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

void PrijaviGresku(KodoviGresaka greska) {
	if(greska==KodoviGresaka::PogresnaKomanda) std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl; 
	else if(greska==KodoviGresaka::NedostajeParametar) std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
</font>	else if(greska==KodoviGresaka::NeispravanParametar) std::cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; std::endl;
	else if(greska==KodoviGresaka::SuvisanParametar) std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt;std::endl; }

bool IspravnostUnosaKoordinataZaIgru(std::string linija, int &amp;x, int &amp;y, int n) { //valjda radi nemam pojma iskreno
	unsigned short broj_otvorenih_zagrada(0); 
	unsigned short broj_zatvorenih_zagrada(0); 
	unsigned int short broj_zareza(0);
	unsigned short sve_ostalo_sto_nije_cifra_ili_space(0); 
	for(int i=0; i&lt;linija.size(); i++) {
		/*prvo brisem sve space*/
		if(linija[i]==' ') {
			linija.erase(linija.begin()+i); 
			i--;
		}
		else if(linija[i]=='(') broj_otvorenih_zagrada++;
		else if(linija[i]==')') broj_zatvorenih_zagrada++;
		else if(linija[i]==',') broj_zareza++; 
		else if(!(linija[i]&gt;='0' &amp;&amp; linija[i]&lt;='9')) sve_ostalo_sto_nije_cifra_ili_space++; //ovdje sam valjda osigurala da su svi cifre ostali
	}
	if(broj_otvorenih_zagrada!=1 || linija.size()&lt;5 || broj_zatvorenih_zagrada!=1 || broj_zareza!=1 || sve_ostalo_sto_nije_cifra_ili_space!=0) return false;
	if(linija[0]!='(' || linija[linija.size()-1]!=')') return false;
	std::string broj1, broj2; 
		int i=1;
		while(linija[i]!=',') {broj1.push_back(linija[i]); i++;}
		if(linija[i]==',') i++; 
		while(i!=linija.size()-1) {broj2.push_back(linija[i]); i++; }
		if(broj1.size()==0 || broj2.size()==0) return false;
		x=std::stoi(broj1); if(x&gt;=n) return false;
		y=std::stoi(broj2); if(y&gt;=n) return false;
		return true; }

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0) {
	if(komanda==Komande::ZavrsiIgru) {
		ObrisiTablu(polja); 
		throw std::runtime_error("Igra zavrsena");
	}
	else if(komanda==Komande::PomjeriJednoMjesto) {
		try {
		Status tekuci(Idi(polja, x, y, p_smjer)); // OVDJE nisi dodala jer mislis da je ok
		if(tekuci==Status::KrajPoraz || tekuci==Status::KrajPobjeda) {
			if(tekuci==Status::KrajPoraz) std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
			if(tekuci==Status::KrajPobjeda) std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
			ObrisiTablu(polja); 
			throw std::runtime_error("Igra zavrsena");
		}
		
		std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt;")" &lt;&lt; std::endl;  }
		catch(std::out_of_range asja) {
<a name="8"></a><font color="#00FFFF"><a href="match821-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

			std::cout &lt;&lt; asja.what() &lt;&lt; std::endl; //to endl or not to endl
		}
		catch(std::logic_error m) {
			std::cout &lt;&lt; m.what() &lt;&lt; std::endl; // ditto
		} 
	}
	
	else if(komanda==Komande::PomjeriDalje) {
</font>		try {
		Status tekuci(Idi(polja, x, y, p_x, p_y));
		if(tekuci==Status::KrajPoraz || tekuci==Status::KrajPobjeda) {
			if(tekuci==Status::KrajPoraz) std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl; 
			if(tekuci==Status::KrajPobjeda) std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
			ObrisiTablu(polja); 
			throw std::runtime_error("Igra zavrsena"); 
		}
		
		std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl; }
		catch(std::out_of_range asja) {
<a name="9"></a><font color="#FF00FF"><a href="match821-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

			std::cout &lt;&lt; asja.what() &lt;&lt; std::endl;  //opet isto s endline da ili ne
		}
		catch(std::logic_error m) {
			std::cout &lt;&lt; m.what() &lt;&lt; std::endl; // endl?????????????
		}
	}
	
	else if(komanda==Komande::Blokiraj) {
</font><a name="0"></a><font color="#FF0000"><a href="match821-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		try {
			BlokirajPolje(polja, p_x, p_y); /*///////////*/
		}
		catch(std::domain_error a) {
			std::cout &lt;&lt; a.what() &lt;&lt; std::endl; //ne znam jel ovdje treba novi red or not, eventualno jos jedno thow nemam poja
		}
	}
	
	else if(komanda==Komande::Deblokiraj) {
		try{
			DeblokirajPolje(polja, p_x, p_y); /*/////////////////////////////////*/
		}
		catch(std::domain_error a) {
			std::cout &lt;&lt; a.what() &lt;&lt; std::endl; //ditto
		}
	}
	
	else if(komanda==Komande::PrikaziOkolinu) {
</font>		try {
		std::vector&lt;std::vector&lt;int&gt;&gt; okolo(PrikaziOkolinu(polja, x, y));
		for(auto &amp;x : okolo) { //mozda treba s obicnom petljom da osiguras da ti nije onaj zadnji razmak razmak
			for(auto &amp;y : x) 
			std::cout &lt;&lt; y &lt;&lt; " "; 
<a name="10"></a><font color="#FF0000"><a href="match821-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

			std::cout &lt;&lt; std::endl;
		} }
		catch(std::domain_error d) {
			std::cout &lt;&lt; d.what() &lt;&lt; std::endl; //to endl or not
		}
	}
	else if(komanda==Komande::KreirajIgru) {
</font>		try {
		std::cout &lt;&lt; "Unesite broj polja: "; // TO END LINE OR NOT TO END LINE?
		int n; //safe unos uradi ne mogu sad ja to *****************************************
		std::cin &gt;&gt; n ;
		while(n&lt;=0) {
			std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl; 
			std::cout &lt;&lt; "Unesite broj polja: ";
			std::cin &gt;&gt; n; 
		}
		std::cin.ignore(100000, '\n');
		std::cin.clear();//ovdje pazi jel ovako ili nije
		std::string pozicija; 
		std::cout &lt;&lt; "Unesite pozicije mina: ";
		
		std::vector&lt;std::vector&lt;int&gt;&gt; mine;
		int nekox(0), nekoy(0), i(0);
		
		while(pozicija.size()!=1 || pozicija[0]!='.') {
			std::getline(std::cin, pozicija); 
			if(pozicija==".") break;
		while(!IspravnostUnosaKoordinataZaIgru(pozicija, nekox, nekoy, n) &amp;&amp; pozicija!=".") { //dodaj ono
			std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl; 
			std::getline(std::cin, pozicija); 
		}
			mine.resize(i+1);
			mine[i].resize(2); 
			mine[i][0]=nekox;
			mine[i][1]=nekoy;
			i++;
		}
		polja=KreirajIgru(n,mine); 	} 
	catch (std::domain_error d) {
	//	std::cout &lt;&lt; "Greska,unesite ponovo!" &lt;&lt; std::endl; 
	} }
}

int main ()
{
	try {
		Tabla igra;
		int x(0),y(0), p_x(1), p_y(1);
		Komande komanda;
		Smjerovi smjer;
		KodoviGresaka greska;
		while(1) {
			std::cout &lt;&lt; "Unesite komandu: ";
			while(!UnosKomande(komanda, smjer, p_x, p_y, greska)) PrijaviGresku(greska); 
			IzvrsiKomandu(komanda, igra , x, y, smjer, p_x, p_y);
		}
	}
	catch(std::runtime_error a) {
		std::cout &lt;&lt; "Dovidjenja!"; 
	}
	
	return 0;
}</pre>
</body>
</html>
