<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student7255.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student7945.cpp<p></p><pre>
//B 2017/2018, ZadaÄ‡a 2, Zadatak 1
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina 
};
enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
<a name="0"></a><font color="#FF0000"><a href="match121-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_62.gif"/></a>

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0){
	try {
		
		
		
		
	}
	catch(std::domain_error izuzetak){
		std::cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
	}
	catch(std::out_of_range izuzetak){
		std::cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
	}
	catch(std::logic_error izuzetak){
		std::cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
	}
}


bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	std::string s;

}


void Prijavigresku(KodoviGresaka greska){
	switch (greska) {
		case KodoviGresaka::PogresnaKomanda : std::cout&lt;&lt;"Nerazumljiva komanda!"; break;
		case KodoviGresaka::NedostajeParametar : std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"; break;
		case KodoviGresaka::NeispravanParametar : std::cout&lt;&lt;"Parametar komande nije ispravan!"; break;
		case KodoviGresaka::SuvisanParametar : std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"; break;
	}
}

Tabla KreirajIgru(int n, const Matrica &amp;mine){
	Tabla kreirana_tabla(0);
	if(n&lt;=0){
		throw std::domain_error ("Ilegalna velicina");
		return kreirana_tabla;
	}
	if(mine.at(0).size()!=2){
		throw std::domain_error ("Ilegalan format zadavanja mina");
	}
	for(int i=0; i&lt;mine.size(); i++){
		for(int j=0; j&lt;mine.at(i).size(); j++){
			if(mine.at(i).at(j)&gt;n || mine.at(i).at(j)&lt;0){
				throw std::domain_error ("Ilegalne pozicije mina");
			}
		}
	}
	//Postavljamo tablu na prazna polja
	kreirana_tabla.resize(n);
	for(int i=0; i&lt;n; i++){
		kreirana_tabla.at(i).resize(n);
		for(int j=0; j&lt;n; j++){
			kreirana_tabla.at(i).at(j)=Polje::Prazno;
		}
	}
	//Postavljamo mine u tablu
	for(int i=0; i&lt;n; i++){
		for(int j=0; j&lt;n; j++){
			for(int k=0; k&lt;mine.size(); k++){
				if(i==mine.at(k).at(0) &amp;&amp; j==mine.at(k).at(1)){
					kreirana_tabla.at(i).at(j)=Polje::Mina;
				}
			}
		}
	}
	return kreirana_tabla;
}

int OkolinaTacke(const Tabla &amp;polja, int x, int y){
	int br_mina(0);
	int vel(polja.size());
	if(x-1&gt;=0 &amp;&amp; x-1&lt;=vel &amp;&amp; y-1&gt;=0 &amp;&amp; y-1&lt;=vel &amp;&amp; polja.at(x-1).at(y-1)==Polje::Mina) br_mina++;
	if(x-1&gt;=0 &amp;&amp; x-1&lt;=vel &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=vel &amp;&amp; polja.at(x-1).at(y)==Polje::Mina) br_mina++;
	if(x-1&gt;=0 &amp;&amp; x-1&lt;=vel &amp;&amp; y+1&gt;=0 &amp;&amp; y+1&lt;=vel &amp;&amp; polja.at(x-1).at(y+1)==Polje::Mina) br_mina++;
	if(x&gt;=0 &amp;&amp; x&lt;=vel &amp;&amp; y-1&gt;=0 &amp;&amp; y-1&lt;=vel &amp;&amp; polja.at(x).at(y-1)==Polje::Mina) br_mina++;
	if(x&gt;=0 &amp;&amp; x&lt;=vel &amp;&amp; y+1&gt;=0 &amp;&amp; y+1&lt;=vel &amp;&amp; polja.at(x).at(y+1)==Polje::Mina) br_mina++;
	if(x+1&gt;=0 &amp;&amp; x+1&lt;=vel &amp;&amp; y-1&gt;=0 &amp;&amp; y-1&lt;=vel &amp;&amp; polja.at(x+1).at(y-1)==Polje::Mina) br_mina++;
	if(x+1&gt;=0 &amp;&amp; x+1&lt;=vel &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=vel &amp;&amp; polja.at(x+1).at(y)==Polje::Mina) br_mina++;
	if(x+1&gt;=0 &amp;&amp; x+1&lt;=vel &amp;&amp; y+1&gt;=0 &amp;&amp; y+1&lt;=vel &amp;&amp; polja.at(x+1).at(y+1)==Polje::Mina) br_mina++;
	
	return br_mina;
}

Matrica PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	if(x&gt;polja.size() || y&gt;polja.size() || x&lt;0 || y&lt;0 ){
		throw std::domain_error ("Polje (x,y) ne postoji");
	}
	Matrica okolina(3);
	for(int i=0; i&lt;3; i++){
		okolina.at(i).resize(3);
	}
	int vel(polja.size());
	if(x-1&gt;=0 &amp;&amp; x-1&lt;=vel &amp;&amp; y-1&gt;=0 &amp;&amp; y-1&lt;=vel) okolina.at(0).at(0)=OkolinaTacke(polja,x-1,y-1);
	else okolina.at(0).at(0)=0;
	if(x-1&gt;=0 &amp;&amp; x-1&lt;=vel) okolina.at(0).at(1)=OkolinaTacke(polja,x-1,y);
	else okolina.at(0).at(1)=0;
	if(x-1&gt;=0 &amp;&amp; x-1&lt;=vel &amp;&amp; y+1&gt;=0 &amp;&amp; y+1&lt;=vel) okolina.at(0).at(2)=OkolinaTacke(polja,x-1,y+1);
	else okolina.at(0).at(2)=0;
	if(y-1&gt;=0 &amp;&amp; y-1&lt;=vel) okolina.at(1).at(0)=OkolinaTacke(polja,x,y-1);
	else okolina.at(1).at(0)=0;
	okolina.at(1).at(1)=OkolinaTacke(polja,x,y);
	if(y+1&gt;=0 &amp;&amp; y+1&lt;=vel) okolina.at(1).at(2)=OkolinaTacke(polja,x,y+1);
	else okolina.at(1).at(2)=0;
	if(x+1&gt;=0 &amp;&amp; x+1&lt;=vel &amp;&amp; y-1&gt;=0 &amp;&amp; y-1&lt;=vel) okolina.at(2).at(0)=OkolinaTacke(polja,x+1,y-1);
	else okolina.at(2).at(0)=0;
	if(x+1&gt;=0 &amp;&amp; x+1&lt;=vel) okolina.at(2).at(1)=OkolinaTacke(polja,x+1,y);
	else okolina.at(2).at(1)=0;
	if(x+1&gt;=0 &amp;&amp; x+1&lt;=vel &amp;&amp; y+1&gt;=0 &amp;&amp; y+1&lt;=vel) okolina.at(2).at(2)=OkolinaTacke(polja,x+1,y+1);
	else okolina.at(2).at(2)=0;
	return okolina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
		if(x&gt;polja.size() || y&gt;polja.size() || x&lt;0 || y&lt;0 ){
		throw std::domain_error ("Polje (x,y) ne postoji");
	}
	if(polja.at(x).at(y)==Polje::Prazno){
		polja.at(x).at(y)=Polje::BlokiranoPrazno;
</font>	}
	else if(polja.at(x).at(y)==Polje::Posjeceno){
		polja.at(x).at(y)=Polje::BlokiranoPosjeceno;
	}	
	else if(polja.at(x).at(y)==Polje::Mina){
<a name="2"></a><font color="#0000FF"><a href="match121-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

		polja.at(x).at(y)=Polje::BlokiranoMina;
	}
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&gt;polja.size() || y&gt;polja.size() || x&lt;0 || y&lt;0 ){
		throw std::domain_error ("Polje (x,y) ne postoji");
	}
	if(polja.at(x).at(y)==Polje::BlokiranoPrazno){
		polja.at(x).at(y)=Polje::Prazno;
</font>	}
	else if(polja.at(x).at(y)==Polje::BlokiranoPosjeceno){
<a name="1"></a><font color="#00FF00"><a href="match121-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_28.gif"/></a>

		polja.at(x).at(y)=Polje::Posjeceno;
	}	
	else if(polja.at(x).at(y)==Polje::BlokiranoMina){
		polja.at(x).at(y)=Polje::Mina;
	}
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	polja.at(x).at(y)=Polje::Posjeceno;
	int vel(polja.size());
	switch(smjer) {
		case Smjerovi::GoreLijevo : 
			if(x==0 || y==0) throw std::out_of_range ("Izlazak van igrace table");
			x=x-1; y=y-1; break;
		case Smjerovi::Gore : 
			if(x==0) throw std::out_of_range ("Izlazak van igrace table");
			x=x-1; break;
		case Smjerovi::GoreDesno : 
			if(x==0 || y==vel-1) throw std::out_of_range ("Izlazak van igrace table");
			x=x-1; y=y+1; break;
		case Smjerovi::Desno : 
			if(y==vel-1) throw std::out_of_range ("Izlazak van igrace table");
			y=y+1; break;
		case Smjerovi::DoljeDesno : 
			if(x==vel-1 || y==vel-1) throw std::out_of_range ("Izlazak van igrace table");
			x=x+1; y=y+1; break;
		case Smjerovi::Dolje : 
			if(x==vel-1) throw std::out_of_range ("Izlazak van igrace table");
			x=x+1; break;
		case Smjerovi::DoljeLijevo : 
			if(x==vel-1 || y==0) throw std::out_of_range ("Izlazak van igrace table");
			x=x+1; y=y-1; break;
		case Smjerovi::Lijevo : 
			if(y==0) throw std::out_of_range ("Izlazak van igrace table");
			y=y-1; break;
	} 
	if(polja.at(x).at(y)==Polje::BlokiranoPrazno || polja.at(x).at(y)==Polje::BlokiranoPosjeceno 
		|| polja.at(x).at(y)==Polje::BlokiranoMina) throw std::logic_error ("Blokirano polje");
	
	//Provjera da li je krajporaz
	if(polja.at(x).at(y)==Polje::Mina) {
		for(int i=0; i&lt;polja.size(); i++){
			for(int j=0; j&lt;polja.at(i).size(); j++){
				polja.at(i).at(j)=Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	//Provjera da li je krajpobjeda
	int br_polja(vel*vel);
	int br_mina(0), br_posjeceno(0);
	for(int i=0; i&lt;vel; i++){
		for(int j=0; j&lt;vel; j++){
			if(polja.at(i).at(j)==Polje::Mina) br_mina++;
			else if(polja.at(i).at(j)==Polje::Posjeceno) br_posjeceno++;
		}
	}
	if(br_polja==br_mina+br_posjeceno) return Status::KrajPobjeda;

	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	polja.at(x).at(y)=Polje::Posjeceno;
	int vel(polja.size());
	if(novi_x&lt;0 || novi_x&gt;vel-1 || novi_y&lt;0 || novi_y&gt;vel-1) throw std::out_of_range ("Izlazak van igrace table");
	if(polja.at(novi_x).at(novi_y)==Polje::BlokiranoPrazno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoPosjeceno 
		|| polja.at(novi_x).at(novi_y)==Polje::BlokiranoMina) throw std::logic_error ("Blokirano polje");
	if(polja.at(novi_x).at(novi_y)==Polje::Mina) return Status::KrajPoraz;
	x=novi_x; y=novi_y;
	
	//provjera za krajpobjeda
	
	return Status::NijeKraj;
}

int main ()
</font>{
	
	return 0;
}</pre>
</body>
</html>
