<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student2868.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student2868.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;

enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande
{
<a name="1"></a><font color="#00FF00"><a href="match38-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

bool PoljeNijeValidno(int x, int y, int vel)
{
	return (x&lt;0 || y&lt;0 || x&gt;=vel || y&gt;=vel);
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
	if (n&lt;=0)
		throw std::domain_error("Ilegalan velicina");
	Tabla rez(n, std::vector&lt;Polje&gt;(n, Polje::Prazno));
	for (int i = 0; i &lt; mine.size(); i++) {
		if (mine.at(i).size()!=2)
			throw std::domain_error("Ilegalan format zadavanja mina");
		if ((mine.at(i).at(0)&lt;0) || (mine.at(i).at(1)&lt;0) || (mine.at(i).at(0))&gt;=n || (mine.at(i).at(1)&gt;=n))
			throw std::domain_error("Ilegalne pozicije mina");
		rez.at(mine.at(i).at(0)).at(mine.at(i).at(1))=Polje::Mina;
	}
	return rez;
}

int OkolnaSumaMina(const Tabla &amp;polja, int x, int y)
{
	int suma(0);
	for (int i = x-1; i &lt;= x+1; i++) {
		for (int j = y-1; j &lt;= y+1; j++) {
			if (PoljeNijeValidno(i,j,polja.size()) || (i==x &amp;&amp; j==y))
				continue;
			if (polja.at(i).at(j)==Polje::Mina)
				suma++;
		}
	}
	return suma;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
	std::string greska("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
	if (PoljeNijeValidno(x,y,polja.size()))
		throw std::domain_error(greska);
	std::vector&lt;std::vector&lt;int&gt;&gt; rez(3, std::vector&lt;int&gt;(3));
	int i(0),j(0);
	for (int k = x-1; k &lt;= x+1; k++) {
		for (int g = y-1; g &lt;= y+1; g++) {
			rez.at(i).at(j++)=OkolnaSumaMina(polja, k, g);
			if (j==3) {
				i++;
				if (i==3)
					return rez;
				j=0;
			}
		}
	}

	return rez;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	std::string greska("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
	if (PoljeNijeValidno(x,y,polja.size()))
		throw std::domain_error(greska);
	if (polja.at(x).at(y)==Polje::Mina)
		polja.at(x).at(y)=Polje::BlokiranoMina;
</font>	else if (polja.at(x).at(y)==Polje::Posjeceno)
		polja.at(x).at(y)=Polje::BlokiranoPosjeceno;
<a name="3"></a><font color="#00FFFF"><a href="match38-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	else if (polja.at(x).at(y)==Polje::Prazno)
		polja.at(x).at(y)=Polje::BlokiranoPrazno;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
	std::string greska("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
	if (PoljeNijeValidno(x,y,polja.size()))
		throw std::domain_error(greska);
	if (polja.at(x).at(y)==Polje::BlokiranoMina)
		polja.at(x).at(y)=Polje::Mina;
</font>	else if (polja.at(x).at(y)==Polje::BlokiranoPosjeceno)
<a name="2"></a><font color="#0000FF"><a href="match38-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_13.gif"/></a>

		polja.at(x).at(y)=Polje::Posjeceno;
	else if (polja.at(x).at(y)==Polje::BlokiranoPrazno)
		polja.at(x).at(y)=Polje::Prazno;
}

bool JelKraj(const Tabla &amp;polja, const int &amp;x, const int &amp;y)
{
	for (int i = 0; i &lt; polja.size(); i++) {
		for (int j = 0; j &lt; polja.size(); j++) {
			if (i==x &amp;&amp; j==y)
				continue;
			if (polja.at(i).at(j)==Polje::Prazno)
				return false;
		}
	}
	return true;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
	int px(x), py(y);
	if (smjer==Smjerovi::GoreLijevo) {
		px--;
		py--;
	} else if (smjer==Smjerovi::Gore) {
		px--;
	} else if (smjer==Smjerovi::GoreDesno) {
		py++;
		px--;
	} else if (smjer==Smjerovi::Desno) {
		py++;
	} else if (smjer==Smjerovi::DoljeDesno) {
		px++;
		py++;
	} else if (smjer==Smjerovi::Dolje) {
		px++;
	} else if (smjer==Smjerovi::DoljeLijevo) {
		py--;
		px++;
	} else if (smjer==Smjerovi::Lijevo) {
		py--;
	}
	if (PoljeNijeValidno(px,py,polja.size()))
		throw std::out_of_range("Izlazak van igrace table");
	if (polja.at(px).at(py)==Polje::BlokiranoPosjeceno || polja.at(px).at(py)==Polje::BlokiranoPrazno || polja.at(px).at(py)==Polje::BlokiranoMina)
		throw std::logic_error("Blokirano polje");
	polja.at(x).at(y)=Polje::Posjeceno;
	x=px;
	y=py;
	if (polja.at(x).at(y)==Polje::Mina)
		return Status::KrajPoraz;
	if (JelKraj(polja,x,y))
		return Status::KrajPobjeda;
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if (PoljeNijeValidno(novi_x,novi_y,polja.size()))
		throw std::out_of_range("Izlazak van igrace table");
	if (polja.at(novi_x).at(novi_y)==Polje::BlokiranoPosjeceno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoPrazno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoMina)
		throw std::logic_error("Blokirano polje");
	polja.at(x).at(y)=Polje::Posjeceno;
	x=novi_x;
	y=novi_y;
	if (polja.at(x).at(y)==Polje::Mina)
		return Status::KrajPoraz;
	if (JelKraj(polja,x,y))
		return Status::KrajPobjeda;
	return Status::NijeKraj;
}

void PrijaviGresku(KodoviGresaka greska)
{
	if (greska==KodoviGresaka::PogresnaKomanda)
		std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl;
	else if (greska==KodoviGresaka::NedostajeParametar)
</font>		std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
	else if (greska==KodoviGresaka::NeispravanParametar)
<a name="0"></a><font color="#FF0000"><a href="match38-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_64.gif"/></a>

		std::cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; std::endl;
	else if (greska==KodoviGresaka::SuvisanParametar)
		std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt; std::endl;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	std::string unos;
	std::getline(std::cin, unos);
	bool pocetak(true), kraj(false);
	for (int i = 0; i &lt; unos.length(); i++) {
		if ((pocetak &amp;&amp; unos.at(i)==' ')||(kraj &amp;&amp; unos.at(i)==' '))
			continue;
		pocetak=false;
		if (unos.at(i)=='P' &amp;&amp; i+1 &lt; unos.length() &amp;&amp; unos.at(i+1)=='1') {
			for (int j = i+2; j &lt; unos.length(); j++) {
				if (unos.at(j)==' ')
					continue;
				if (unos.at(j)=='G' &amp;&amp; j+1&lt;unos.length() &amp;&amp; unos.at(j+1)=='L') {
					for (int k = j+2; k &lt; unos.length(); k++) {
						if (unos.at(k)!=' ') {
							greska=KodoviGresaka::SuvisanParametar;
							return false;
						}
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::GoreLijevo;
					return true;
				} else if (unos.at(j)=='G' &amp;&amp; j+1&lt;unos.length() &amp;&amp; unos.at(j+1)=='D') {
					for (int k = j+2; k &lt; unos.length(); k++) {
						if (unos.at(k)!=' ') {
							greska=KodoviGresaka::SuvisanParametar;
							return false;
						}
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::GoreDesno;
					return true;
				} else if (unos.at(j)=='G') {
					for (int k = j+1; k &lt; unos.length(); k++) {
						if (unos.at(k)!=' ') {
							greska=KodoviGresaka::SuvisanParametar;
							return false;
						}
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::Gore;
					return true;
				} else if (unos.at(j)=='D' &amp;&amp; j+1&lt;unos.length() &amp;&amp; unos.at(j+1)=='o' &amp;&amp; j+2&lt;unos.length() &amp;&amp; unos.at(j+2)=='D') {
					for (int k = j+3; k &lt; unos.length(); k++) {
						if (unos.at(k)!=' ') {
							greska=KodoviGresaka::SuvisanParametar;
							return false;
						}
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::DoljeDesno;
					return true;
				} else if (unos.at(j)=='D' &amp;&amp; j+1&lt;unos.length() &amp;&amp; unos.at(j+1)=='o' &amp;&amp; j+2&lt;unos.length() &amp;&amp; unos.at(j+2)=='L') {
					for (int k = j+3; k &lt; unos.length(); k++) {
						if (unos.at(k)!=' ') {
							greska=KodoviGresaka::SuvisanParametar;
							return false;
						}
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::DoljeLijevo;
					return true;
				} else if (unos.at(j)=='D' &amp;&amp; j+1&lt;unos.length() &amp;&amp; unos.at(j+1)=='o') {
					for (int k = j+2; k &lt; unos.length(); k++) {
						if (unos.at(k)!=' ') {
							greska=KodoviGresaka::SuvisanParametar;
							return false;
						}
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::Dolje;
					return true;
				} else if (unos.at(j)=='D') {
					for (int k = j+1; k &lt; unos.length(); k++) {
						if (unos.at(k)!=' ') {
							greska=KodoviGresaka::SuvisanParametar;
							return false;
						}
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::Desno;
					return true;
				} else if (unos.at(j)=='L') {
					for (int k = j+1; k &lt; unos.length(); k++) {
						if (unos.at(k)!=' ') {
							greska=KodoviGresaka::SuvisanParametar;
							return false;
						}
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::Lijevo;
					return true;
				} else {
					greska=KodoviGresaka::NeispravanParametar;
					return false;
				}
			}
			greska=KodoviGresaka::NedostajeParametar;
			return false;
		} else if (unos.at(i)=='P' &amp;&amp; i+1 &lt; unos.length() &amp;&amp; unos.at(i+1)=='O') {
			for (int k = i+2; k &lt; unos.length(); k++) {
				if (unos.at(k)!=' ') {
					greska=KodoviGresaka::SuvisanParametar;
					return false;
				}
			}
			komanda=Komande::PrikaziOkolinu;
			return true;
		} else if ((unos.at(i)=='P' &amp;&amp; i+1 &lt; unos.length() &amp;&amp; unos.at(i+1)=='&gt;')||(unos.at(i)=='B')||(unos.at(i)=='D')) {
			int k(i+1);
			if (unos.at(i)=='P' &amp;&amp; i+1 &lt; unos.length() &amp;&amp; unos.at(i+1)=='&gt;')
				k=i+2;
			for (; k &lt; unos.length(); k++) {
				if (unos.at(k)!=' ' &amp;&amp; !(unos.at(k)&gt;='0' &amp;&amp; unos.at(k)&lt;='9')) {
					greska=KodoviGresaka::NeispravanParametar;
					return false;
				}
			}
			if ((unos.at(i)=='P' &amp;&amp; i+1 &lt; unos.length() &amp;&amp; unos.at(i+1)=='&gt;')&amp;&amp;(k==i+2)) {
				greska=KodoviGresaka::NedostajeParametar;
				return false;
			} else if (k==i+1) {
				greska=KodoviGresaka::NedostajeParametar;
				return false;
			}
			k=i+1;
			if (unos.at(i)=='P' &amp;&amp; i+1 &lt; unos.length() &amp;&amp; unos.at(i+1)=='&gt;')
				k=i+2;
			bool drugi_put(false);
			int xbroj(0), ybroj(0);
			for (; k &lt; unos.length(); k++) {
				if (unos.at(k)&gt;='0' &amp;&amp; unos.at(k)&lt;='9' &amp;&amp; !(unos.at(k-1)&gt;='0' &amp;&amp; unos.at(k-1)&lt;='9')) {
					if (!drugi_put) {
						std::deque&lt;int&gt; pomocni;
						int j(k);
						for (; j &lt; unos.length(); j++) {
							if (unos.at(j)&gt;='0' &amp;&amp; unos.at(j)&lt;='9')
								pomocni.push_front(unos.at(j)-'0');
							else
								break;
						}
						bool okey(false);
						for (; j &lt; unos.length(); j++) {
							if (unos.at(j)==' ')
								continue;
							if (unos.at(j)&gt;='0' &amp;&amp; unos.at(j)&lt;='9') {
								okey=true;
								break;
							}
						}
						if (!okey) {
							greska=KodoviGresaka::NeispravanParametar;
							return false;
						}

						for (j = 0; j &lt; pomocni.size(); j++)
							xbroj+=pomocni.at(j)*pow(10,j);
						drugi_put=true;
					} else {
						std::deque&lt;int&gt; pomocni;
						int j(k);
						for (; j &lt; unos.length(); j++) {
							if (unos.at(j)&gt;='0' &amp;&amp; unos.at(j)&lt;='9')
								pomocni.push_front(unos.at(j)-'0');
							else
								break;
						}
						bool okey(true);
						for (; j &lt; unos.length(); j++) {
							if (unos.at(j)==' ')
								continue;
							okey=false;
							break;
						}
						if (!okey) {
							greska=KodoviGresaka::SuvisanParametar;
							return false;
						}
						for (j = 0; j &lt; pomocni.size(); j++)
							ybroj+=pomocni.at(j)*pow(10,j);
					}
				}
			}
			x=xbroj;
			y=ybroj;
			if (unos.at(i)=='P' &amp;&amp; i+1 &lt; unos.length() &amp;&amp; unos.at(i+1)=='&gt;')
				komanda=Komande::PomjeriDalje;
			else if(unos.at(i)=='B')
				komanda=Komande::Blokiraj;
			else if(unos.at(i)=='D')
				komanda=Komande::Deblokiraj;
			return true;
		} else if (unos.at(i)=='Z') {
			for (int j = i+1; j &lt; unos.length(); j++) {
				if (unos.at(j)!=' ') {
					greska=KodoviGresaka::SuvisanParametar;
					return false;
				}
			}
			komanda=Komande::ZavrsiIgru;
			return true;
		} else if (unos.at(i)=='K') {
			for (int j = i+1; j &lt; unos.length(); j++) {
				if (unos.at(j)!=' ') {
					greska=KodoviGresaka::SuvisanParametar;
					return false;
				}
			}
			komanda=Komande::KreirajIgru;
			return true;
		} else {
			greska=KodoviGresaka::PogresnaKomanda;
			return false;
		}
	}
	return true;
}

void Zavrsi(Tabla &amp;polja)
{
	for (int i = 0; i &lt; polja.size(); i++) {
		for (int j = 0; j &lt; polja.at(i).size(); j++)
			polja.at(i).at(j)=Polje::Prazno;
	}
	throw std::runtime_error("Igra zavrsena");
}

void IzvrsiKomandu (Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0)
{
	if (komanda==Komande::PomjeriJednoMjesto) {
		Status s;
		try {
			s=Idi(polja, x, y, p_smjer);
		} catch (const std::exception &amp;error) {
			std::cout &lt;&lt; error.what() &lt;&lt; std::endl;
			return;
		}
		if (s==Status::KrajPobjeda) {
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
			Zavrsi(polja);
		} else if (s==Status::KrajPoraz) {
			std::cout &lt;&lt; "Nagazili ste minu" &lt;&lt; std::endl;
			Zavrsi(polja);
		}
		std::cout &lt;&lt; "Tekuca pozicija igraca je " &lt;&lt; "("&lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
	} else if (komanda==Komande::PomjeriDalje) {
		Status s;
		try {
			s=Idi(polja, x, y, p_x, p_y);
		} catch (const std::exception &amp;error) {
			std::cout &lt;&lt; error.what() &lt;&lt; std::endl;
			return;
		}
		if (s==Status::KrajPobjeda) {
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
			Zavrsi(polja);
		} else if (s==Status::KrajPoraz) {
			std::cout &lt;&lt; "Nagazili ste minu" &lt;&lt; std::endl;
			Zavrsi(polja);
		}
		std::cout &lt;&lt; "Tekuca pozicija igraca je " &lt;&lt; "("&lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
	} else if (komanda==Komande::Blokiraj) {
		try {
			BlokirajPolje(polja, p_x, p_y);
		} catch (const std::exception &amp;error) {
			std::cout &lt;&lt; error.what() &lt;&lt; std::endl;
			return;
		}
	} else if (komanda==Komande::Deblokiraj) {
		try {
			DeblokirajPolje(polja, p_x, p_y);
		} catch (const std::exception &amp;error) {
			std::cout &lt;&lt; error.what() &lt;&lt; std::endl;
			return;
		}
	} else if (komanda==Komande::PrikaziOkolinu) {
		std::vector&lt;std::vector&lt;int&gt;&gt; matrica;
		try {
			matrica=PrikaziOkolinu(polja, x, y);
		} catch (const std::exception &amp;error) {
			std::cout &lt;&lt; error.what() &lt;&lt; std::endl;
			return;
		}
		for (int i = 0; i &lt; matrica.size(); i++) {
			for (int j = 0; j &lt; matrica.at(i).size(); j++)
				std::cout &lt;&lt; matrica.at(i).at(j) &lt;&lt; " ";
			std::cout &lt;&lt; std::endl;
		}
	} else if (komanda==Komande::ZavrsiIgru) {
		Zavrsi(polja);
	} else if (komanda==Komande::KreirajIgru) {
		int n;
		bool ponovi;
		do {
			ponovi=false;
			std::cout &lt;&lt; "Unesite broj polja: ";
			std::cin &gt;&gt; n;
			if (n&lt;=0 || !std::cin || std::cin.peek()!='\n') {
				std::cin.clear();
				std::cin.ignore(10000,'\n');
				std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
				ponovi=true;
			}
		} while(ponovi);
		polja.resize(n);
		for (int i = 0; i &lt; polja.size(); i++)
			polja.at(i).resize(n);
		std::vector&lt;std::vector&lt;int&gt;&gt; mine;
		int i(0);
		std::cout &lt;&lt; "Unesite pozicije mina: ";
		do {
			std::complex&lt;int&gt; komplunos;
			std::cin &gt;&gt; komplunos;
			std::cin.clear();
			if (std::cin.peek()=='.') {
				std::cin.ignore(10000,'\n');
				break;
			}
			if (!std::cin || (std::cin.peek()!='\n' &amp;&amp; std::cin.peek()!='.' &amp;&amp; std::cin.peek()!=' ') || PoljeNijeValidno(real(komplunos), imag(komplunos), polja.size())) {
				std::cin.ignore(10000,'\n');
				std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
				continue;
			}
			mine.resize(i+1);
			mine.at(i).push_back(real(komplunos));
			mine.at(i).push_back(imag(komplunos));
			i++;
		} while (true);
		x=0;
		y=0;
		polja=KreirajIgru(n, mine);
	}
}


int main ()
{
	Tabla polja;
	Komande kom;
	Smjerovi smj;
	KodoviGresaka gres;
	int x(0), y(0);
	int novi_x(0), novi_y(0);
	do {
		std::cout &lt;&lt; "Unesite komandu: ";
		if (UnosKomande(kom, smj, novi_x,novi_y,gres)==false)
			PrijaviGresku(gres);
		else {
			try {
				IzvrsiKomandu(kom, polja, x, y, smj, novi_x, novi_y);
			} catch (...) {
				std::cout &lt;&lt; "Dovidjenja!";
				return 0;
			}
		}
	} while(true);
</font>
	return 0;
}</pre>
</body>
</html>
