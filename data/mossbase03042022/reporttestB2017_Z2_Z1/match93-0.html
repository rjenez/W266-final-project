<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student1066.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student1066.cpp<p></p><pre>
#include &lt;iostream&gt;  // NAPOMENA: ČESTO MI SE DEŠAVALO DA SAM MORAO VEĆE DIJELOVE KODA KOPIRATI TAKO DA NE MISLITE DA SAM PREPISAO
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande
{
<a name="1"></a><font color="#00FF00"><a href="match93-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_19.gif"/></a>

    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

typedef std::vector&lt;std::vector&lt;int&gt;&gt; IntMatrica;

void PrijaviGresku (KodoviGresaka greska)
{
    if (greska==KodoviGresaka::PogresnaKomanda) std::cout&lt;&lt;"Nerazumljiva komanda!";
    else if (greska==KodoviGresaka::NedostajeParametar) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!";
    else if (greska==KodoviGresaka::NeispravanParametar) std::cout&lt;&lt;"Parametar komande nije ispravan!";
    else if (greska==KodoviGresaka::SuvisanParametar) std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!";
}

Tabla KreirajIgru (int n, const IntMatrica &amp;mine)
{
    if (n&lt;=0) throw std::domain_error ("Ilegalna veličina");
    Tabla tabla(n);
    for (int i = 0; i&lt;n; i++) // Inicijalizacija polja table na Prazno
        for (int j = 0; j&lt;n; j++)
            tabla.at(i).push_back(Polje::Prazno);    // Ubaciavnje Praznih polja

    for (int i = 0; i&lt;mine.size(); i++) {
        if (mine.at(i).size()!=2) throw std::domain_error ("Ilegalan format zadavanja mina");  // Ako je format različit od 2 baca se izuzetak
        for (int j = 0; j&lt;2; j++) {
            if (mine.at(i).at(0)&gt;=n || mine.at(i).at(1)&gt;=n || mine.at(i).at(0)&lt;0 || mine.at(i).at(1)&lt;0) throw std::domain_error ("Ilegalan format zadavanja mina");
            tabla.at(mine.at(i).at(0)).at(mine.at(i).at(1))=Polje::Mina;   // Ubacivanje mina
        }
    }
    return tabla;
}

IntMatrica PrikaziOkolinu (const Tabla &amp;polja, int x, int y)
{
    if (x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.size()) throw std::domain_error ("Polje (x,y) ne postoji");
    int suma(0);
    IntMatrica mat(3,std::vector&lt;int&gt;(3));
    for (int r=x-1; r&lt;=x+1; r++) {   // Ako je x,y , inda idem od gornjeg lijevog ugla, tj. x-1, y-1, sabirati sve matrice okolo tih vrijesnoti
        for (int q=y-1; q&lt;=y+1; q++) {
            int a=r;
            int b=q;
            for (int i=a-1; i&lt;=a+1; i++) {
                for (int j=b-1; j&lt;=b+1; j++) {
                    if (i==a &amp;&amp; j==b) continue;
                    if ((i&gt;=0 &amp;&amp; i&lt;polja.size()) &amp;&amp; (j&gt;=0 &amp;&amp; j&lt;polja.size()) &amp;&amp; polja.at(i).at(j)==Polje::Mina)  // Ako je unutar polja i ako je mina suma mina oko tog polja ++
                        suma++;
                }
            }
            mat.at(r-x+1).at(q-y+1)=suma;  // Ubacivanje u matricu sumu mina oko tog polja
            suma=0;
        }
    }
    return mat;
}

void BlokirajPolje (Tabla &amp;polja, int x, int y)
{
    if (x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.size()) throw std::domain_error ("Polje (x,y) ne postoji");
    if (polja.at(x).at(y)==Polje::Prazno) polja.at(x).at(y)=Polje::BlokiranoPrazno;
</font>    else if (polja.at(x).at(y)==Polje::Posjeceno) polja.at(x).at(y)=Polje::BlokiranoPosjeceno;
<a name="2"></a><font color="#0000FF"><a href="match93-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

    else if (polja.at(x).at(y)==Polje::Mina) polja.at(x).at(y)=Polje::BlokiranoMina;
}

void DeblokirajPolje (Tabla &amp;polja, int x, int y)
{
    if (x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.size()) throw std::domain_error ("Polje (x,y) ne postoji");
    if (polja.at(x).at(y)==Polje::BlokiranoPrazno) polja.at(x).at(y)=Polje::Prazno;
</font><a name="0"></a><font color="#FF0000"><a href="match93-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_73.gif"/></a>

    else if (polja.at(x).at(y)==Polje::BlokiranoPosjeceno) polja.at(x).at(y)=Polje::Posjeceno;
    else if (polja.at(x).at(y)==Polje::BlokiranoMina) polja.at(x).at(y)=Polje::Mina;
}

Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
    if (novi_x&lt;0 || novi_x&gt;=polja.size() || novi_y&lt;0 || novi_y&gt;=polja.size()) throw std::out_of_range ("Izlazak van igrace table");
    if (polja.at(novi_x).at(novi_y)==Polje::BlokiranoPosjeceno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoPrazno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoMina) throw std::logic_error ("Blokirano Polje");
    if (polja.at(novi_y).at(novi_y)==Polje::Mina) {
        for (int i = 0; i&lt;polja.size(); i++)
            for (int j = 0; j&lt;polja.size(); j++)
                polja.at(i).at(j)=Polje::Prazno;
        return Status::KrajPoraz;
    }
    bool prazno(true);
    for (int i = 0; i&lt;polja.size(); i++) {
        for (int j = 0; j&lt;polja.size(); j++) {
            if (polja.at(i).at(j)==Polje::Prazno) prazno=false;
        }
    }
    if (prazno) return Status::KrajPobjeda;
    x=novi_x;
    y=novi_y;
    return Status::NijeKraj;

}

Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
    polja.at(x).at(y)=Polje::Posjeceno;
    int x_prim(x),y_prim(y);
    if (smjer==Smjerovi::GoreLijevo) {
        x=x-1;
        y=y-1;
    } else if (smjer==Smjerovi::Gore) {
        x=x-1;
    } else if (smjer==Smjerovi::GoreDesno) {
        x=x-1;
        y=y+1;
    } else if (smjer==Smjerovi::Desno) {
        y=y+1;
    } else if (smjer==Smjerovi::DoljeDesno) {
        x=x+1;
        y=y+1;
    } else if (smjer==Smjerovi::Dolje) {
        x=x+1;
    } else if (smjer==Smjerovi::DoljeLijevo) {
        x=x+1;
        y=y-1;
    } else if (smjer==Smjerovi::Lijevo) {
        y=y-1;
    }
    return Idi(polja,x_prim,y_prim,x,y);
}

bool UlazDimenzije (double n)     // Provjerava sve mogucnosti ulaza
{
    if (fabs(n-int(n))&gt;0.00001) return false;
    else if (!std::cin || std::cin.peek()!='\n') return false;
    else if (n&lt;0) return false;
    return true;
}

bool UlazMine (double M, int n)     // Provjerava sve mogucnosti ulaza kao i da li je ulaz bio tacka
{
    if (fabs(M-int(M))&gt;0.00001) return false;
    else if (!std::cin || std::cin.peek()!='\n') return false;
    else if (M&lt;0 || M&gt;=n) return false;
    return true;
}

IntMatrica UnesiMine (const int n) // Popraviti unos
{
    std::vector&lt;std::complex&lt;int&gt;&gt; M;
    std::complex&lt;int&gt; Mina;
    bool zapamti(false);
    while (1) {
        std::cin&gt;&gt;Mina;
        if (zapamti &amp;&amp; std::cin.peek()=='\n') break;
        if (!(UlazMine(real(Mina),n) &amp;&amp; UlazMine(imag(Mina),n))) {
            std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
            std::cin.clear();
            std::cin.ignore(10000, '\n');
            zapamti=false;
            continue;
        }
        if((real(Mina)==0 &amp;&amp; imag(Mina)==0)) {
            zapamti=false;
            std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
            continue;
        }
        zapamti=true;
        M.push_back(Mina);
    }
    IntMatrica vrati(M.size(),std::vector&lt;int&gt;(2));
    for (int i = 0; i&lt;M.size(); i++) {
        vrati.at(i).at(0)=real(M.at(i));
        vrati.at(i).at(1)=imag(M.at(i));
    }
    return vrati;

}

int UnesiBrojPolja (double &amp;n)
{
    while (1) {
        std::cin&gt;&gt;n;
        if (!UlazDimenzije(n)) {
            std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
            std::cin.clear();
            std::cin.ignore(10000,'\n');
        } else return n;
    }
}

std::string PrvaRijec (std::string s)
{
    std::string vrati;
    while (s.at(0)==' ')
        s.erase(s.begin());
    int i=0;
    while (i&lt;s.size() &amp;&amp; s.at(i)!=' ') {
        vrati.push_back(s.at(i));
        i++;
    }
    return vrati;
}

std::string PrveDvijeRijeci (std::string s)
{
    std::string vrati;
    while (s.at(0)==' ')
        s.erase(s.begin());
    int i =0;
    while (i&lt;s.size() &amp;&amp; s.at(i)!=' ') {
        vrati.push_back(s.at(i));
        i++;
    }
    while (i&lt;s.size() &amp;&amp; s.at(i)==' ')
        s.erase(s.begin()+i);

    vrati.push_back(' ');
    while (i&lt;s.size() &amp;&amp; s.at(i)!=' ') {
        vrati.push_back(s.at(i));
        i++;
    }
    return vrati;
}

std::vector&lt;int&gt; DvaBroja (std::string s)
{
    std::vector&lt;int&gt; vrati(2);
    int i(0);
    while (s.at(0)==' ')
        s.erase(s.begin());
    while (i&lt;s.size() &amp;&amp; s.at(i)!=' ')
        i++;
    while (s.size()&gt;i &amp;&amp; s.at(i)==' ')
        i++;

    std::vector &lt;int&gt; cifre;
    while (s.size()&gt;i &amp;&amp; s.at(i)&gt;='0' &amp;&amp; s.at(i)&lt;='9') {
        cifre.push_back(s.at(i)-'0');
        i++;
    }
    int suma(0);
    for (int j = 0; j&lt;cifre.size(); j++)
        suma+=cifre.at(j)*pow(10,cifre.size()-j-1);
    vrati.at(0)=suma;
    while (s.size()&gt;i &amp;&amp; s.at(i)==' ')
        i++;

    cifre.resize(0);
    if (!(s.size()&gt;i &amp;&amp; s.at(i)&gt;='0' &amp;&amp; s.at(i)&lt;='9')) return {-1,-1};
    while (s.size()&gt;i &amp;&amp; s.at(i)&gt;='0' &amp;&amp; s.at(i)&lt;='9') {
        cifre.push_back(s.at(i)-'0');
        i++;
    }
    suma=0;
    for (int j = 0; j&lt;cifre.size(); j++)
        suma+=cifre.at(j)*pow(10,cifre.size()-j-1);
    vrati.at(1)=suma;

    while (s.size()&gt;i &amp;&amp; s.at(i)==' ')
        i++;
    if (i==s.size()) return vrati;
    return {-1,-1};
}

void IzvrsiKomandu (Komande komanda, Tabla &amp;polja, int &amp;x, int&amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0)
{
    if (komanda==Komande::PomjeriJednoMjesto) {
        Status trenutni_status(Idi(polja,x,y,p_smjer));
        if (trenutni_status==Status::KrajPobjeda) std::cout&lt;&lt;"Bravo, obisli ste sva polja";
        else if (trenutni_status==Status::KrajPoraz) std::cout&lt;&lt;"Nagazili ste na minu";
        else
            std::cout&lt;&lt;"Tekuca pozicija igraca je: ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
    } else if (komanda==Komande::PomjeriDalje) {
        std::cin&gt;&gt;p_x&gt;&gt;p_y;
        Idi(polja,x,y,p_x,p_y);
    } else if (komanda==Komande::Blokiraj) {
        BlokirajPolje(polja,x,y);
    } else if (komanda==Komande::Deblokiraj) {
        DeblokirajPolje(polja,x,y);
    } else if (komanda==Komande::PrikaziOkolinu) {
        IntMatrica okolina(PrikaziOkolinu(polja,x,y));
        for (int i = 0; i&lt;okolina.size(); i++) {
            for (int j=0; j&lt;okolina.size(); j++) {
                std::cout&lt;&lt;okolina.at(i).at(j)&lt;&lt;" ";
            }
            std::cout &lt;&lt; std::endl;
        }

    }

    else if (komanda==Komande::ZavrsiIgru) throw std::runtime_error ("Igra zavrsena");

    else if (komanda==Komande::KreirajIgru) {
        double b;
        std::cout&lt;&lt;"Unesite broj polja: ";
        int n(UnesiBrojPolja(b));  // Unos dimenzije ploče
        std::cout&lt;&lt;"Unesite pozicije mina: ";
        IntMatrica M(UnesiMine(n));  // Unos mina
        Tabla MineSweeper(KreirajIgru(n,M));  // Kreiranje igre
    }
}

//BIo sam prvo napisao u main sadrzaj ove funkcije pa sam ga cijelog kopirao gore nazada tako da ne mislite da sam prepisao nesto
bool UnosKomande (Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
    std::string s;
    std::getline(std::cin,s);

    if (PrveDvijeRijeci(s)=="P1 GL") {
        komanda=Komande::PomjeriJednoMjesto;
        smjer=Smjerovi::GoreLijevo;
    } else if (PrveDvijeRijeci(s)=="P1 G") {
        komanda=Komande::PomjeriJednoMjesto;
        smjer=Smjerovi::Gore;
    } else if (PrveDvijeRijeci(s)=="P1 GD") {
        komanda=Komande::PomjeriJednoMjesto;
        smjer=Smjerovi::GoreDesno;
    } else if (PrveDvijeRijeci(s)=="P1 D") {
        komanda=Komande::PomjeriJednoMjesto;
        smjer=Smjerovi::Desno;
    } else if (PrveDvijeRijeci(s)=="P1 DoD") {
        komanda=Komande::PomjeriJednoMjesto;
        smjer=Smjerovi::DoljeDesno;
    } else if (PrveDvijeRijeci(s)=="P1 Do") {
        komanda=Komande::PomjeriJednoMjesto;
        smjer=Smjerovi::Dolje;
    } else if (PrveDvijeRijeci(s)=="P1 DoL") {
        komanda=Komande::PomjeriJednoMjesto;
        smjer=Smjerovi::DoljeLijevo;
    } else if (PrveDvijeRijeci(s)=="P1 L") {
        komanda=Komande::PomjeriJednoMjesto;
        smjer=Smjerovi::Lijevo;
    }

    else if (PrvaRijec(s)=="P&gt;") {
        auto parametri(DvaBroja(s));
        if (parametri.at(0)==-1) {
            greska=KodoviGresaka::NedostajeParametar;
            return false;
        } else {
            x=parametri.at(0);
            y=parametri.at(1);
        }
        komanda=Komande::PomjeriDalje;
    }

    else if (PrvaRijec(s)=="B") {
        auto parametri(DvaBroja(s));
        if (parametri.at(0)==-1) {
            greska=KodoviGresaka::NedostajeParametar;
            return false;
        } else {
            x=parametri.at(0);
            y=parametri.at(1);
        }
        komanda=Komande::Blokiraj;
    } else if (PrvaRijec(s)=="D") {
        auto parametri(DvaBroja(s));
        if (parametri.at(0)==-1) {
            greska=KodoviGresaka::NedostajeParametar;
            return false;
        } else {
            x=parametri.at(0);
            y=parametri.at(1);
        }
        komanda=Komande::Deblokiraj;
    }

    else if (PrvaRijec(s)=="PO") {
        komanda=Komande::PrikaziOkolinu;
    }

    else if (PrvaRijec(s)=="Z") {
        komanda=Komande::ZavrsiIgru;
    }

    else if (PrvaRijec(s)=="K") {
        komanda=Komande::KreirajIgru;
    } else {
        greska=KodoviGresaka::PogresnaKomanda;
        return false;
    }
    return true;
}

int main ()
{
    try {
        KodoviGresaka kod_greske;
        Komande komanda;
        komanda=Komande::KreirajIgru;
        Smjerovi smjer;
        Tabla MineSweeper;

        int x(0),y(0);
        for(;;) {
            std::cout&lt;&lt;"Unesite komandu: ";
            if ((UnosKomande(komanda,smjer,x,y,kod_greske)))
                IzvrsiKomandu(komanda,MineSweeper,x,y,smjer);
            else {
                PrijaviGresku(kod_greske);
                break;
            }
        }
        std::cout&lt;&lt;"Dovidjenja";
    } catch (std::domain_error izuzetak) {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
    } catch (std::out_of_range izuzetak) {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
    } catch (std::logic_error izuzetak) {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
    } catch (std::runtime_error izuzetak) {
        std::cout&lt;&lt;izuzetak.what();
    }
    return 0;
</font>}</pre>
</body>
</html>
