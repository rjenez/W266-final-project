<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5380.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5380.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt; 
#include &lt;stdexcept&gt;
#include &lt;string&gt;

enum class Polje {
	 Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo	
};

enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar	
};

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

std::string FormirajTekst(int x, int y) {
	std::string tekst("Polje (");
	tekst += std::to_string(x);
	tekst += ",";
	tekst += std::to_string(y);
	tekst += ") ne postoji";
	return tekst;
}

void OcistiTablu(Tabla &amp;tab) {
	for(int i = 0; i &lt; tab.size(); i++)
		for(int j = 0; j &lt; tab.size(); j++)
			tab[i][j] = Polje::Prazno;
}

Status ProvjeriStatus(Tabla tab, int x, int y) {
	if(tab[x][y] == Polje::Mina) {
		OcistiTablu(tab);	
		return Status::KrajPoraz;
	}
	bool krajPobjeda = true;
	for(int i = 0; i &lt; tab.size(); i++)
		for(int j = 0; j &lt; tab.size(); j++)
			if((i != x || j != y) &amp;&amp; (tab[i][j] == Polje::Prazno || tab[i][j] == Polje::BlokiranoPrazno)) {
				krajPobjeda = false;
				i = tab.size();
				break;
			}
	if(krajPobjeda) return Status::KrajPobjeda;
	return Status::NijeKraj;
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	for(int i = 0; i &lt; mine.size(); i++) {
		if(mine[i].size() != 2) throw std::domain_error("Ilegalan format zadavanja mina");
	}
	
	Tabla tab(n);
	for(int i = 0; i &lt; n; i++) {
		tab[i].resize(n);
		for(int j = 0; j &lt; n; j++)
			tab[i][j] = Polje::Prazno;
	}
	
	for(int i = 0; i &lt; mine.size(); i++) {
		if(mine[i][0] &lt; 0 || mine[i][0] &gt;= n || mine[i][1] &lt; 0 || mine[i][1] &gt;= n)
			throw std::domain_error("Ilegalne pozicije mina");
	}
	if(n &lt;= 0) throw std::domain_error("Ilegalna velicina");
<a name="0"></a><font color="#FF0000"><a href="match870-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	for(int i = 0; i &lt; mine.size(); i++)
		tab[mine[i][0]] [mine[i][1]] = Polje::Mina;
	return tab;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(Tabla tab, int x, int y) {
</font>	if(x &lt; 0 || y &lt; 0 || x &gt;= tab.size() || y &gt;= tab.size()) throw std::domain_error(FormirajTekst(x, y));
	
	std::vector&lt;std::vector&lt;int&gt;&gt; mat;
	
	for(int i = 1; i &gt;= -1; i--) {
		int tmp_x = x-i;
		std::vector&lt;int&gt; tmp_r;
		for(int j = 1; j &gt;= -1; j--) {
			int br = 0, tmp_y = y-j;
			for(int k = tmp_x - 1; k &lt;= tmp_x + 1; k++)
				for(int l = tmp_y - 1; l &lt;= tmp_y + 1; l++)
					if(k &gt;= 0 &amp;&amp; l &gt;= 0 &amp;&amp; k &lt; tab.size() &amp;&amp; l &lt; tab.size() &amp;&amp; (k != tmp_x || l != tmp_y) &amp;&amp;
						(tab[k][l] == Polje::Mina || tab[k][l] == Polje::BlokiranoMina ))
							br++;
				
			tmp_r.push_back(br);
			br=0;
		}
		mat.push_back(tmp_r);
		tmp_r.resize(0);
	}
	return mat;
}

void BlokirajPolje(Tabla &amp;tab, int x, int y) {
	if(x &lt; 0 || y &lt; 0 || x &gt;= tab.size() || y &gt;= tab.size()) throw std::domain_error(FormirajTekst(x,y));
	if(tab[x][y] == Polje::Prazno) tab[x][y] = Polje::BlokiranoPrazno;
<a name="2"></a><font color="#0000FF"><a href="match870-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	if(tab[x][y] == Polje::Posjeceno) tab[x][y] = Polje::BlokiranoPosjeceno;
	if(tab[x][y] == Polje::Mina) tab[x][y] = Polje::BlokiranoMina;
}

void DeblokirajPolje(Tabla &amp;tab, int x, int y) {
	if(x &lt; 0 || y &lt; 0 || x &gt;= tab.size() || y &gt;= tab.size()) throw std::domain_error(FormirajTekst(x, y));
</font>	if(tab[x][y] == Polje::BlokiranoPrazno) tab[x][y] = Polje::Prazno;
<a name="3"></a><font color="#00FFFF"><a href="match870-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	if(tab[x][y] == Polje::BlokiranoPosjeceno) tab[x][y] = Polje::Posjeceno;
	if(tab[x][y] == Polje::BlokiranoMina) tab[x][y] = Polje::Mina;
}

Status Idi(Tabla &amp;tab, int &amp;cur_x, int &amp;cur_y, Smjerovi smjer) {
</font>	int new_x = cur_x, new_y = cur_y;
	
	switch(smjer) {
		case Smjerovi::GoreLijevo :
			new_x -= 1;
			new_y -= 1;
			break;
		case Smjerovi::Gore :
			new_x -= 1;
			break;
		case Smjerovi::GoreDesno :
			new_x -= 1;
			new_y += 1;
			break;
		case Smjerovi::Lijevo :
			new_y -= 1;
			break;
		case Smjerovi::Desno :
			new_y += 1;
			break;
		case Smjerovi::DoljeLijevo :
			new_x += 1;
			new_y -= 1;
			break;
		case Smjerovi::Dolje :
			new_x += 1;
			break;
		case Smjerovi::DoljeDesno :
			new_x += 1;
			new_y += 1;
			break;
	}
	
	if(new_x &lt; 0 || new_y &lt; 0 || new_x &gt;= tab.size() || new_y &gt;= tab.size()) throw std::out_of_range("Izlazak van igrace table");
	Polje polje = tab[new_x][new_y];
	if(polje == Polje::BlokiranoPosjeceno || polje == Polje::BlokiranoPrazno || polje == Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
	tab[cur_x][cur_y] = Polje::Posjeceno;
	cur_x = new_x; cur_y = new_y;
	return ProvjeriStatus(tab, cur_x, cur_y);
}

Status Idi(Tabla &amp;tab, int &amp;cur_x, int &amp;cur_y, int new_x, int new_y) {
	if(new_x &lt; 0 || new_y &lt; 0 || new_x &gt;= tab.size() || new_y &gt;= tab.size()) throw std::out_of_range("Izlazak van igrace table");
	Polje polje = tab[new_x][new_y];
	if(polje == Polje::BlokiranoPosjeceno || polje == Polje::BlokiranoPrazno || polje == Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
	tab[cur_x][cur_y] = Polje::Posjeceno;
	cur_x = new_x; cur_y = new_y;
	return ProvjeriStatus(tab, cur_x, cur_y);
}

<a name="1"></a><font color="#00FF00"><a href="match870-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

void PrijaviGresku(KodoviGresaka greska) {
	if(greska == KodoviGresaka::PogresnaKomanda) std::cout &lt;&lt; "Nerazumljiva komanda!\n";
	if(greska == KodoviGresaka::NedostajeParametar) std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!\n";
	if(greska == KodoviGresaka::NeispravanParametar) std::cout &lt;&lt; "Parametar komande nije ispravan!\n";
	if(greska == KodoviGresaka::SuvisanParametar) std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!\n";
</font>}

void preskociRazmake(std::string u, int &amp;i) {
	while(i &lt; u.length() &amp;&amp; u[i] == ' ') i++;
}

bool procitajBrojeve(std::string str, int &amp;i, KodoviGresaka &amp;greska, int &amp;br1, int &amp;br2) {
	preskociRazmake(str, i);
	
	if(i == str.length()) {
		greska = KodoviGresaka::NedostajeParametar;
		return false;
	}
	if(!(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')) {
		greska = KodoviGresaka::NeispravanParametar;
		return false;
	}
	else {
		int c1 = i;
		while(i &lt; str.length() &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') i++;
		int c2 = i;
		preskociRazmake(str, i);
		if(i == str.length()) {
			greska = KodoviGresaka::NedostajeParametar;
			return false;
		}
		int c3 = i;
		while(i &lt; str.length() &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') i++;
		int c4 = i;
		preskociRazmake(str, i);
		if(i &lt; str.length()) {
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
		br1 = stoi(str.substr(c1, c2-c1));
		br2 = stoi(str.substr(c3, c4-c3));
		return true;
	}
	return false;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
	std::string str;
	std::getline(std::cin, str);
	std::vector&lt;std::string&gt; smj {"G", "D", "L", "GL", "GD", "Do", "DoD", "DoL"};
	
	for(int i = 0; i &lt; str.length(); i++) {
		preskociRazmake(str, i);
		if(str.substr(i,2) == "P1") {
			i += 2;
			preskociRazmake(str, i);
			int tmp = i, ind = -1;
			for(int j = 0; j &lt;= 2; j++)
				if(str.substr(i,1) == smj[j]) {tmp = i+1; ind = j;}
			for(int j = 3; j &lt;= 5; j++)
				if(str.substr(i,2) == smj[j]) {tmp = i+2; ind = j;}
			for(int j = 6; j &lt;= 7; j++)
				if(str.substr(i,3) == smj[j]) {tmp = i+3; ind = j;}
			if(tmp != i) {
				preskociRazmake(str, tmp);
				if(tmp &lt; str.length()) {
					greska = KodoviGresaka::SuvisanParametar;
					return false;
				}
			}
			else {
				preskociRazmake(str, tmp);
				if(tmp &lt; str.length()) greska = KodoviGresaka::NeispravanParametar;
				else greska = KodoviGresaka::NedostajeParametar;
				return false;
			}
			if(ind == 0) smjer = Smjerovi::Gore;
			if(ind == 1) smjer = Smjerovi::Desno;
			if(ind == 2) smjer = Smjerovi::Lijevo;
			if(ind == 3) smjer = Smjerovi::GoreLijevo;
			if(ind == 4) smjer = Smjerovi::GoreDesno;
			if(ind == 5) smjer = Smjerovi::Dolje;
			if(ind == 6) smjer = Smjerovi::DoljeDesno;
			if(ind == 7) smjer = Smjerovi::DoljeLijevo;
			komanda = Komande::PomjeriJednoMjesto;
			return true;
		}
		else if (str.substr(i,2) == "P&gt;") {
			i += 2;
			if(procitajBrojeve(str, i, greska, x, y)) {
				komanda = Komande::PomjeriDalje;
				return true;
			}
			return false;
		}
		else if(str[i] == 'B') {
			i++;
			if(procitajBrojeve(str, i, greska, x, y)) {
				komanda = Komande::Blokiraj;
				return true;
			}
			return false;
		}
		else if(str[i] == 'D') {
			i++;
			if(procitajBrojeve(str, i, greska, x, y)) {
				komanda = Komande::Deblokiraj;
				return true;
			}
			return false;
		}
		else if(str.substr(i,2) == "PO") {
			i += 2;	
			preskociRazmake(str, i);
			if(i &lt; str.length()) {
				greska = KodoviGresaka::SuvisanParametar;
				return false;
			}
			komanda = Komande::PrikaziOkolinu;
			return true;
		}
		else if(str[i] == 'Z') {
			i++;
			preskociRazmake(str, i);
			if(i &lt; str.length()) {
				greska = KodoviGresaka::SuvisanParametar;
				return false;
			}
			komanda = Komande::ZavrsiIgru;
			return true;
		}
		else if(str[i] == 'K') {
			i++;
			preskociRazmake(str, i);
			if(i &lt; str.length()) {
				greska = KodoviGresaka::SuvisanParametar;
				return false;
			}
			komanda = Komande::KreirajIgru;
			return true;
		}
		else {
			greska = KodoviGresaka::PogresnaKomanda;
			return false;
		}
	}
	return false;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi, int, int);

void IspisPomjerajucaKomanda(Status stat, int x, int y, Tabla &amp;polja) {
<a name="4"></a><font color="#FF00FF"><a href="match870-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")\n";
	if(stat == Status::KrajPobjeda) {
		std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja\n";
		IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y, Smjerovi::Gore, 0, 0);
</font><a name="8"></a><font color="#00FFFF"><a href="match870-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

	}
	if(stat == Status::KrajPoraz) {
		std::cout &lt;&lt; "Nagazili ste na minu\n";
		IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y, Smjerovi::Gore, 0, 0);
</font>	}
	
}

<a name="7"></a><font color="#0000FF"><a href="match870-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
	try {
		if(komanda == Komande::PomjeriJednoMjesto) {
</font>			Status stat = Idi(polja, x, y, p_smjer);
			IspisPomjerajucaKomanda(stat, x, y, polja);
		}
		else if(komanda == Komande::PomjeriDalje) {
			Status stat = Idi(polja, p_x, p_y, x, y);
			IspisPomjerajucaKomanda(stat, x, y, polja);
		}
<a name="6"></a><font color="#00FF00"><a href="match870-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		else if(komanda == Komande::Blokiraj) BlokirajPolje(polja, x, y);
		else if(komanda == Komande::Deblokiraj) DeblokirajPolje(polja, x, y);
		else if(komanda == Komande::PrikaziOkolinu) {
</font>			auto tmp = PrikaziOkolinu(polja, x, y);
			for(auto i : tmp) {
				for(auto j : i) std::cout &lt;&lt; j &lt;&lt; " ";
				std::cout &lt;&lt; std::endl;
			}
			
		}
		else if(komanda == Komande::ZavrsiIgru) {
			OcistiTablu(polja);
			throw std::runtime_error("Igra zavrsena");
		}
<a name="5"></a><font color="#FF0000"><a href="match870-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		else if(komanda == Komande::KreirajIgru) {
			int n;
			std::vector&lt;std::vector&lt;int&gt;&gt; mine;
			for(;;) {
				std::cout &lt;&lt; "Unesite broj polja: ";
				std::cin &gt;&gt; n;
				if(!std::cin) {
</font>					std::cout &lt;&lt; "Greska, unesite ponovo!\n";
					std::cin.clear();
					std::cin.ignore(1000, '\n');
				}
				else if(n &lt;= 0) std::cout &lt;&lt; "Greska, unesite ponovo!\n";
				else break;
			}
			std::cout &lt;&lt; "Unesite pozicije mina: ";
			for(;;) {
				std::string str;
				getline(std::cin, str);
				if(str == ".") break;
				
				for(int i = 0; i &lt; str.length(); i++) {
					preskociRazmake(str, i);
					if(i == str.length() || str[i++] != '(') {
						std::cout &lt;&lt; "Greska, unesite ponovo!\n";
						break;
					}
					int c1 = i;
					while(i &lt; str.length() &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') i++;
					int c2 = i;
					preskociRazmake(str, i);
					if(i == str.length() || str[i] != ',') {
						std::cout &lt;&lt; "Greska, unesite ponovo!\n";
						break;
					}
					int c3 = ++i;
					while(i &lt; str.length() &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') i++;
					int c4 = i;
					preskociRazmake(str, i);
					if(i == str.length() || str[i] != ')') {
						std::cout &lt;&lt; "Greska, unesite ponovo!\n";
						break;
					}
					i++;
					preskociRazmake(str, i);
					if(i != str.length()) {
						std::cout &lt;&lt; "Greska, unesite ponovo!\n";
						break;
					}
					
					int br1 = stoi(str.substr(c1, c2-c1)), br2 = stoi(str.substr(c3, c4-c3));
					if(br1 &gt;= n || br2 &gt;= n || (br1 == 0 &amp;&amp; br2 == 0)) {
						std::cout &lt;&lt; "Greska, unesite ponovo!\n";
						break;
					}
					mine.push_back(std::vector&lt;int&gt;{br1,br2});
					break;
				}
			}
			polja = KreirajIgru(n, mine);
		}
		
		
	}
	catch(std::domain_error e) {
		std::cout &lt;&lt; e.what() &lt;&lt; "\n";
	}
	catch(std::logic_error e) {
		std::cout &lt;&lt; e.what() &lt;&lt; "\n";
	}
	catch(std::out_of_range e) {
		std::cout &lt;&lt; e.what() &lt;&lt; "\n";
	}
}



int main ()
{
	try {
		Komande kom;
		Smjerovi sm;
		KodoviGresaka greska;
		Tabla polja;
		int x = 0, y = 0;
		for(;;) {
			std::cout &lt;&lt; "Unesite komandu: ";
			
			bool xd =UnosKomande(kom, sm, x, y, greska);
			if (xd) IzvrsiKomandu(kom, polja, x, y, sm);
			else PrijaviGresku(greska);
		}
	}
	catch(std::runtime_error e) {
		std::cout &lt;&lt; "Dovidjenja!";
	}

	return 0;
}</pre>
</body>
</html>
