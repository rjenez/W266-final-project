<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student1793.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student1793.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;

<a name="6"></a><font color="#00FF00"><a href="match480-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

using namespace std;

enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
</font>};

enum Status {
    NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande
{
    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};


typedef std::vector&lt;std::vector&lt;Polje&gt;&gt;Tabla;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
	if(n&lt;=0)throw("Ilegalna velicina");
	for(int i=0; i&lt;mine.size(); i++) {
		if(mine[i].size()!=2) {
			throw domain_error("Ilegalan format zadavanja mina");
		}
		if(mine[i][0]&lt;0 || mine[i][0]&gt;=n || mine[i][1]&lt;0 || mine[i][1]&gt;=n) {
			throw domain_error("Ilegalane pozicije mina");
		}
	}
	Tabla tabla = vector&lt;vector&lt;Polje&gt;&gt;(n,vector&lt;Polje&gt;(n,Polje::Prazno));
	for(int i=0; i&lt;mine.size(); i++) {
		tabla[ mine[i][0] ][ mine[i][1] ] = Polje::Mina;
	}
	return tabla;
}

string int2string(int broj)
{
	string rezultat;
	bool negativan=false;
	if (broj ==0) return "0";
	if(broj&lt;0) {
		negativan = true;
		broj*=-1;
	}
	while(broj!=0) {
		int cifra = broj%10;
		rezultat.push_back(cifra+'0');
		broj/=10;
	}
	for(int i=0,j=rezultat.size()-1; i&lt;j; i++,j--) {
		char temp = rezultat[i];
		rezultat[i] = rezultat[j];
		rezultat[j] = temp;
	}
	if(negativan) rezultat = "-" + rezultat;
	return rezultat;
}

bool ispravneKoordinate(const Tabla&amp; polja,int x, int y)
{
	return x&gt;=0&amp;&amp;x&lt;polja.size()&amp;&amp;y&gt;=0&amp;&amp;y&lt;polja.size();
}

int brojSusjednihMina(const Tabla&amp;polja,int x, int y)
{
	int brojMina=0;
	if(!ispravneKoordinate(polja,x,y)) return 0;

	vector&lt;vector&lt;int&gt;&gt; susjedi = {{x-1,y-1},{x-1,y},{x-1,y+1},{x,y-1},{x,y+1},{x+1,y-1},{x+1,y},{x+1,y+1}};

	for(int i=0; i&lt;susjedi.size(); i++) {
		if(ispravneKoordinate(polja,susjedi[i][0],susjedi[i][1]) ) {
			if(polja[ susjedi[i][0] ][ susjedi[i][1] ] == Polje::Mina) {
				brojMina++;
			}
		}
	}
	return brojMina;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{

	if(!ispravneKoordinate(polja,x,y)) {
		throw domain_error("Polje ("+int2string(x)+","+int2string(y)+" ) ne postoji");
	}

	std::vector&lt;std::vector&lt;int&gt;&gt; okolina (3,std::vector&lt;int&gt;(3));

	vector&lt;vector&lt;int&gt;&gt; susjedi = {
		{x-1,y-1},
		{x-1,y},
		{x-1,y+1},
		{x,y-1},
		{x,y},
		{x,y+1},
		{x+1,y-1},
		{x+1,y},
		{x+1,y+1}
	};

	for(int i=0; i&lt;okolina.size(); i++) {
		for(int j=0; j&lt;okolina.size(); j++) {
			okolina[i][j] = brojSusjednihMina(polja,susjedi[i*3+j][0],susjedi[i*3+j][1]);
		}
	}
	return okolina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(!ispravneKoordinate(polja,x,y)) {
		throw domain_error("Polje ( "+int2string(x)+","+int2string(y)+" ) ne postoji");
	}
	
	
	if(polja[x][y]==Polje::Prazno) {
		polja[x][y] = Polje::BlokiranoPrazno;
	} else if(polja[x][y]==Polje::Posjeceno) {
		polja[x][y] = Polje::BlokiranoPosjeceno;
<a name="9"></a><font color="#FF00FF"><a href="match480-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

	} else if(polja[x][y]==Polje::Mina) {
		polja[x][y] = Polje::BlokiranoMina;
	}
	
	/*cout&lt;&lt;"BLOKIRANJE"&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;endl;
	switch(polja[x][y] ) {
	case Polje::Prazno:
		cout&lt;&lt;"Prazno"&lt;&lt;endl;
		break;
	case Polje::Posjeceno:
		cout&lt;&lt;"Posjeceno"&lt;&lt;endl;
		break;
	case Polje::Mina:
		cout&lt;&lt;"Mina"&lt;&lt;endl;
		break;
	case Polje::BlokiranoPrazno:
		cout&lt;&lt;"BlokiranoPrazno"&lt;&lt;endl;
		break;
	case Polje::BlokiranoPosjeceno:
		cout&lt;&lt;"BlokiranoPosjeceno"&lt;&lt;endl;
		break;
	case Polje::BlokiranoMina:
		cout&lt;&lt;"BlokiranoMina"&lt;&lt;endl;
		break;

	}*/
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y)
</font>{
	if(!ispravneKoordinate(polja,x,y)) {
		throw domain_error("Polje ("+int2string(x)+","+int2string(y)+" ) ne postoji");
	}
	if(polja[x][y]==Polje::BlokiranoPrazno) {
		polja[x][y] = Polje::Prazno;
	} else if(polja[x][y]==Polje::BlokiranoPosjeceno) {
		polja[x][y] = Polje::Posjeceno;
<a name="2"></a><font color="#0000FF"><a href="match480-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	} else if(polja[x][y]==Polje::BlokiranoMina) {
		polja[x][y] = Polje::Mina;
	}
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
</font>{
	int novoX=x,novoY=y;
	switch(smjer) {
	case Smjerovi::GoreLijevo :
		novoX--;
		novoY--;
		break;
	case Smjerovi::Gore :
		novoX--;
		break;
	case Smjerovi::GoreDesno :
		novoX--;
		novoY++;
		break;
	case Smjerovi::Lijevo :
		novoY--;
		break;
	case Smjerovi::Desno :
		novoY++;
		break;
	case Smjerovi::DoljeLijevo :
		novoX++;
		novoY--;
		break;
	case Smjerovi::Dolje :
		novoX++;
		break;
	case Smjerovi::DoljeDesno :
		novoX++;
		novoY++;
		break;
	}
	if(!ispravneKoordinate(polja,novoX,novoY)) {
<a name="7"></a><font color="#0000FF"><a href="match480-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		throw out_of_range("Izlazak van igrace table");
	}

	if(polja[novoX][novoY]==Polje::BlokiranoPosjeceno ||
	        polja[novoX][novoY]==Polje::BlokiranoPrazno ||
</font>	        polja[novoX][novoY]==Polje::BlokiranoMina) {
		throw logic_error("Blokirano polje");
	}

<a name="10"></a><font color="#FF0000"><a href="match480-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

	if(polja[novoX][novoY]==Polje::Mina) {
		for(int i=0; i&lt;polja.size(); i++) {
			for(int j=0; j&lt;polja[i].size(); j++) {
</font>				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}

	polja[novoX][novoY]=Polje::Posjeceno;
	polja[x][y]=Polje::Posjeceno;
	x=novoX;
<a name="3"></a><font color="#00FFFF"><a href="match480-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	y=novoY;

	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja[i].size(); j++) {
			if(polja[i][j] == Polje::Prazno)
</font>				return Status::NijeKraj;
		}
	}
	return Status::KrajPobjeda;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if(!ispravneKoordinate(polja,novi_x,novi_y)) {
<a name="8"></a><font color="#00FFFF"><a href="match480-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		throw out_of_range("Izlazak van igrace table");
	}
	if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno ||
	        polja[novi_x][novi_y]==Polje::BlokiranoPrazno ||
</font>	        polja[novi_x][novi_y]==Polje::BlokiranoMina) {
		throw logic_error("Blokirano polje");
	}

<a name="11"></a><font color="#00FF00"><a href="match480-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

	if(polja[novi_x][novi_y]==Polje::Mina) {
		for(int i=0; i&lt;polja.size(); i++) {
			for(int j=0; j&lt;polja[i].size(); j++) {
</font>				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}

	polja[novi_x][novi_y]=Polje::Posjeceno;
	polja[x][y]=Polje::Posjeceno;
	x=novi_x;
<a name="4"></a><font color="#FF00FF"><a href="match480-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	y=novi_y;

	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja[i].size(); j++) {
			if(polja[i][j] == Polje::Prazno)
</font>				return Status::NijeKraj;
		}
	}

<a name="0"></a><font color="#FF0000"><a href="match480-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	return Status::KrajPobjeda;
}

void PrijaviGresku(KodoviGresaka kodGreske)
{
	if(kodGreske == KodoviGresaka::PogresnaKomanda) {
		cout&lt;&lt;"Nerazumljiva komanda!";
	} else if(kodGreske == KodoviGresaka::NedostajeParametar) {
		cout&lt;&lt;"Komanda trazi parametar koji nije naveden!";
	} else if(kodGreske == KodoviGresaka::NeispravanParametar) {
		cout&lt;&lt;"Parametar komande nije ispravan!";
	} else if(kodGreske == KodoviGresaka::SuvisanParametar) {
		cout&lt;&lt;"Zadan je suvisan parametar nakon komande!";
</font>	}
}

int string2int(string s)
{
	for(auto z : s) {
		if(z&lt;'0'||z&gt;'9') throw invalid_argument("Neispravan Parametar");
	}
	int broj=0;
	for(auto z : s) {
		int cifra = z-'0';
		broj = broj*10+cifra;
	}
	return broj;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y,KodoviGresaka &amp;greska)
{
	string unos;
	string k,p1,p2,ostatak;

	getline(cin,unos);
	int i=0;
	while(unos[i]==' '&amp;&amp;i&lt;unos.size())i++;
	while(unos[i]!=' '&amp;&amp;i&lt;unos.size()) {
		k.push_back(unos[i]);
		i++;
	}
	while(unos[i]==' '&amp;&amp;i&lt;unos.size())i++;
	while(unos[i]!=' '&amp;&amp;i&lt;unos.size()) {
		p1.push_back(unos[i]);
		i++;
	}
	while(unos[i]==' '&amp;&amp;i&lt;unos.size())i++;
	while(unos[i]!=' '&amp;&amp;i&lt;unos.size()) {
		p2.push_back(unos[i]);
		i++;
	}
	while(unos[i]==' '&amp;&amp;i&lt;unos.size())i++;
	while(unos[i]!=' '&amp;&amp;i&lt;unos.size()) {
		ostatak.push_back(unos[i]);
		i++;
	}

	if(k=="P1") {
<a name="12"></a><font color="#0000FF"><a href="match480-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

		if(p1=="GL") {
			smjer = Smjerovi::GoreLijevo;
		} else if(p1=="G") {
			smjer = Smjerovi::Gore;
		} else if(p1=="GD") {
			smjer = Smjerovi::GoreDesno;
</font>		} else if(p1=="D") {
			smjer = Smjerovi::Desno;
		} else if(p1=="DoD") {
			smjer = Smjerovi::DoljeDesno;
		} else if(p1=="Do") {
			smjer = Smjerovi::Dolje;
		} else if(p1=="DoL") {
			smjer = Smjerovi::DoljeLijevo;
		} else if(p1=="L") {
			smjer = Smjerovi::Lijevo;
		} else {
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
		if(p2!="") {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		komanda=Komande::PomjeriJednoMjesto;

	} else if(k=="P&gt;") {
		if(p1==""||p2=="") {
			greska = KodoviGresaka::NedostajeParametar;
			return false;
		}
		if(ostatak!="") {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		try {
			int prvi = string2int(p1);
			int drugi = string2int(p2);
			x=prvi;
			y=drugi;

			komanda=Komande::PomjeriDalje;

		} catch(invalid_argument e) {
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
	} else if(k=="B") {

		if(p1==""||p2=="") {
			greska = KodoviGresaka::NedostajeParametar;
			return false;
		}
		if(ostatak!="") {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		try {
			int prvi = string2int(p1);
			int drugi = string2int(p2);
			x=prvi;
			y=drugi;
		} catch(invalid_argument e) {
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
		komanda = Komande::Blokiraj;


	} else if(k=="D") {
		if(p1==""||p2=="") {
			greska = KodoviGresaka::NedostajeParametar;
			return false;
		}
		if(ostatak!="") {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		try {
			int prvi = string2int(p1);
			int drugi = string2int(p2);
			x=prvi;
			y=drugi;
		} catch(invalid_argument e) {
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
		komanda = Komande::Deblokiraj;

	} else if(k=="PO") {
		if(p1!="") {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		komanda = Komande::PrikaziOkolinu;
	} else if(k=="Z") {
		if(p1!="") {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		komanda = Komande::ZavrsiIgru;
	} else if(k=="K") {
		if(p1!="") {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
<a name="5"></a><font color="#FF0000"><a href="match480-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		komanda = Komande::KreirajIgru;
	} else {
		greska = KodoviGresaka::PogresnaKomanda;
		return false;
	}
	return true;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x=0, int p_y=0)
</font>{
	try {
		Status s;
		vector&lt;vector&lt;int&gt;&gt; okolina;
		switch(komanda) {
		case Komande::PomjeriJednoMjesto :
			s = Idi(polja, x, y, p_smjer);
			if (s == Status::KrajPobjeda) {
				cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;endl;
				IzvrsiKomandu(Komande::ZavrsiIgru,polja,x,y,p_smjer,p_x,p_y);
			} else if(s == Status::KrajPoraz) {
				cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;endl;
				IzvrsiKomandu(Komande::ZavrsiIgru,polja,x,y,p_smjer,p_x,p_y);
			} else {
				cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;endl;
			}
			break;
		case Komande::PomjeriDalje :
			s = Idi(polja,x,y,p_x,p_y);
			if (s == Status::KrajPobjeda) {
				cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;endl;
				IzvrsiKomandu(Komande::ZavrsiIgru,polja,x,y,p_smjer,p_x,p_y);
			} else if(s == Status::KrajPoraz) {
				cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;endl;
				IzvrsiKomandu(Komande::ZavrsiIgru,polja,x,y,p_smjer,p_x,p_y);
			} else {
				cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;endl;
			}
			break;
		case Komande::Blokiraj :
			BlokirajPolje(polja, p_x, p_y);
			break;
		case Komande::Deblokiraj :
			DeblokirajPolje(polja, p_x, p_y);
			break;
		case Komande::PrikaziOkolinu :
<a name="1"></a><font color="#00FF00"><a href="match480-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

			okolina = PrikaziOkolinu(polja, x, y);
			for(int i=0; i&lt;okolina.size(); i++) {
				for(int j=0; j&lt;okolina[i].size(); j++) {
					cout&lt;&lt;okolina[i][j]&lt;&lt;" ";
				}
				cout&lt;&lt;endl;
</font>			}
			break;
		case Komande::ZavrsiIgru :
			for(int i=0; i&lt;polja.size(); i++) {
				for(int j=0; j&lt;polja[i].size(); j++) {
					polja[i][j]=Polje::Prazno;
				}
			}
			throw runtime_error("Igra zavrsena");
			break;
		case Komande::KreirajIgru : {
			int broj_polja;
			string recenica;
			vector&lt;vector&lt;int&gt;&gt; mine;
			complex&lt;int&gt;pomocna;
			while(true) {
				cout&lt;&lt;"Unesite broj polja: ";
				cin&gt;&gt;broj_polja;
				if(!cin) {
					cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
					cin.clear();
					cin.ignore(1000,'\n');
				} else if(broj_polja&lt;=0) {
					cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
				} else {
					break;
				}

			}

			cout&lt;&lt;"Unesite pozicije mina: ";
			while(true) {
				cin&gt;&gt;pomocna;
				if(!cin) {

					cin.clear();
					getline(cin,recenica);
					if(recenica[0]=='.')break;
					cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
				} else {
					int x = pomocna.real();
					int y = pomocna.imag();
					if(x&lt;0||x&gt;=broj_polja||y&lt;0||y&gt;=broj_polja) {
						cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
						continue;
					}
					vector&lt;int&gt; v;
					v.push_back(x);
					v.push_back(y);
					mine.push_back(v);
				}
			}

			polja = KreirajIgru(broj_polja,mine);
		}

		}
	} catch(domain_error e) {
		cout&lt;&lt;e.what()&lt;&lt;endl;
	} catch(out_of_range e) {
		cout&lt;&lt;e.what()&lt;&lt;endl;
	} catch(logic_error e) {
		cout&lt;&lt;e.what()&lt;&lt;endl;
	}
}

int main()
{
	try {
		Tabla polja;
		Komande komanda;
		Smjerovi smjer;
		int x=0,y=0,p_x,p_y;
		KodoviGresaka greska;
		while(true) {
			cout&lt;&lt;"Unesite komandu: ";
			if( UnosKomande(komanda,smjer,p_x,p_y,greska)) {
				IzvrsiKomandu(komanda, polja,x,y,smjer,p_x,p_y );
			} else {
				PrijaviGresku(greska);
			}
		}
	} catch(runtime_error e) {
		cout&lt;&lt;"Dovidjenja!"&lt;&lt;endl;
	}


	return 0;
}</pre>
</body>
</html>
