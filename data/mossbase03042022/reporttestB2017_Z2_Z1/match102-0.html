<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student2567.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student2567.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

<a name="0"></a><font color="#FF0000"><a href="match102-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_39.gif"/></a>

using namespace std;

enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande
{
    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};


Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
    Tabla T;    // inicijalizira tabelu
    if(n &lt;= 0) throw std::domain_error ("Ilegalna veličina");
    T.resize(n);
    for(int i = 0; i &lt; n; i++)
        T[i].resize(n);    //postavljamo veličinu

    for(int i = 0; i &lt; n; i++)    //postavimo sva polja da su prazna, moze se desiti da baci izzuzetak ispod pa da ostane ne inicijalizirano
        for(int j = 0;  j &lt; n; j++)
            T[i][j] = Polje::Prazno;

    for(int i = 0; i &lt; mine.size(); i++)
    {
        if(mine[i].size() != 2)   throw std::domain_error ("Ilegalan format zadavanja mina");
        if((mine[i][0] &gt; (n-1) &amp;&amp; mine[i][0] &lt; 0) || (mine[i][1] &gt; (n-1) &amp;&amp; mine[i][1] &lt; 0)) throw std::domain_error ("Ilegalne pozicije mina");
        T[mine[i][0]][mine[i][1]] = Polje::Mina;
    }

    return T;
}

bool JelUnutra (int n, int i , int j)
{
    if(i &lt; 0 || i &gt; (n-1) || j &lt; 0 || j &gt; (n-1)) return false;
    return true;
}

int Prebroj (const Tabla &amp;polja, int i, int j)
{
    int n = polja.size();
    int broj = 0;
    if(JelUnutra(n,i-1,j) &amp;&amp; polja[i-1][j]==Polje::Mina) broj++;
    if(JelUnutra(n,i-1,j-1) &amp;&amp; polja[i-1][j-1]==Polje::Mina) broj++;
    if(JelUnutra(n,i-1,j+1) &amp;&amp; polja[i-1][j+1]==Polje::Mina) broj++;
    if(JelUnutra(n,i+1,j) &amp;&amp; polja[i+1][j]==Polje::Mina) broj++;
    if(JelUnutra(n,i+1,j-1) &amp;&amp; polja[i+1][j-1]==Polje::Mina) broj++;
    if(JelUnutra(n,i+1,j+1) &amp;&amp; polja[i+1][j+1]==Polje::Mina) broj++;
    if(JelUnutra(n,i,j-1) &amp;&amp; polja[i][j-1]==Polje::Mina) broj++;
    if(JelUnutra(n,i,j+1) &amp;&amp; polja[i][j+1]==Polje::Mina) broj++;

    return broj;

}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
    int n = polja.size();
    if(x &lt; 0 || x &gt; (n-1) || y &lt; 0 || y &gt; (n-1)  )throw std::domain_error ("Polje (x,y) ne postoji");

    std::vector&lt;std::vector&lt;int&gt;&gt; m;
    m.resize(3);
    for(int i = 0; i &lt; 3; i++)
        m[i].resize(3);

    m[0][0] = Prebroj(polja,x-1,y-1);
    m[0][1] = Prebroj(polja,x-1,y);
    m[0][2] = Prebroj(polja,x-1,y+1);
    m[1][0] = Prebroj(polja,x,y-1);
    m[1][1] = Prebroj(polja,x,y);
    m[1][2] = Prebroj(polja,x,y+1);
    m[2][0] = Prebroj(polja,x+1,y-1);
    m[2][1] = Prebroj(polja,x+1,y);
    m[2][2] = Prebroj(polja,x+1,y+1);

    return m;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
    int n = polja.size();
    if(x &lt; 0 || x &gt; (n-1) || y &lt; 0 || y &gt; (n-1)  )throw std::domain_error ("Polje (x,y) ne postoji");

    if(polja[x][y] == Polje::Mina) polja[x][y] = Polje::BlokiranoMina;
    if(polja[x][y] == Polje::Prazno) polja[x][y] = Polje::BlokiranoPrazno;
</font><a name="3"></a><font color="#00FFFF"><a href="match102-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

    if(polja[x][y] == Polje::Posjeceno) polja[x][y] = Polje::BlokiranoPosjeceno;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
    int n = polja.size();
    if(x &lt; 0 || x &gt; (n-1) || y &lt; 0 || y &gt; (n-1)  )throw std::domain_error ("Polje (x,y) ne postoji");

    if(polja[x][y] == Polje::BlokiranoMina) polja[x][y] = Polje::Mina;
    if(polja[x][y] == Polje::BlokiranoPrazno) polja[x][y] = Polje::Prazno;
</font><a name="1"></a><font color="#00FF00"><a href="match102-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_29.gif"/></a>

    if(polja[x][y] == Polje::BlokiranoPosjeceno) polja[x][y] = Polje::Posjeceno;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
    int n = polja.size();
    if(novi_x &lt; 0 || novi_x &gt; n-1 || novi_y &lt; 0 || novi_y &gt; n-1) throw std::out_of_range ("Izlazak van igrace table");
    if(polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoMina || polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno) throw std::logic_error ("Blokirano polje");
    x = novi_x;
    y = novi_y;

    if(polja[x][y] == Polje::Mina) return Status::KrajPoraz;

    for(int i = 0; i &lt; n; i++)
    {
        for(int j = 0; j &lt; n; j++)
        {
            if(polja[i][j] == Polje::Prazno)
            {
                return Status::NijeKraj;
            }
        }
    }
    return Status::KrajPobjeda;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
    int novi_x, novi_y;

    if(smjer == Smjerovi::Desno) {novi_x = x; novi_y = y+1; }
    if(smjer == Smjerovi::Dolje) {novi_x = x+1; novi_y = y; }
    if(smjer == Smjerovi::DoljeDesno) {novi_x = x+1; novi_y = y+1; }
    if(smjer == Smjerovi::DoljeLijevo) {novi_x = x+1; novi_y = y-1; }
    if(smjer == Smjerovi::Gore) {novi_x = x-1; novi_y = y; }
    if(smjer == Smjerovi::GoreDesno) {novi_x = x-1; novi_y = y+1; }
    if(smjer == Smjerovi::GoreLijevo) {novi_x = x-1; novi_y = y-1; }
    if(smjer == Smjerovi::Lijevo) {novi_x = x; novi_y = y-1; }
    
    return Idi(polja, x, y, novi_x, novi_y);
}


void PrijaviGresku(KodoviGresaka kod_greske)
{
    if(kod_greske == KodoviGresaka::PogresnaKomanda) std::cout &lt;&lt; "Nerazumljiva komanda!\n";
    else if(kod_greske == KodoviGresaka::NedostajeParametar) std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!\n";
    else if(kod_greske == KodoviGresaka::NeispravanParametar) std::cout &lt;&lt; "Parametar komande nije ispravan!\n";
    else if(kod_greske == KodoviGresaka::SuvisanParametar) std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!\n";
}

bool jeLiBroj(string mozdaBroj) {
    for (int i = 0; i &lt; mozdaBroj.length(); i++) {
        if (mozdaBroj[i] &lt; '0' || mozdaBroj[i] &gt; '9') {
            return false;
        }
    }
    return true;
}

int parsiraj(string naredba, int start, string&amp; dioNaredbe) {
    int i = start;
    for (; i &lt; naredba.length(); i++) {
        if (dioNaredbe.length() == 0 &amp;&amp; naredba[i] == ' ') {
            continue;
        } else if (naredba[i] == ' ') {
            break;
        }
        dioNaredbe += naredba[i];
    }
    return i;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
    string korisnickiUnosSaTastature;
    cout &lt;&lt; "Unesite komandu: " &lt;&lt; endl;
    getline(std::cin, korisnickiUnosSaTastature);
    string sifraKomande = "";
    string argument1 = "";
    string argument2 = "";
    string argument3 = "";
    int pozicija = parsiraj(korisnickiUnosSaTastature, 0, sifraKomande);
    pozicija = parsiraj(korisnickiUnosSaTastature, pozicija, argument1);
    pozicija = parsiraj(korisnickiUnosSaTastature, pozicija, argument2);
    pozicija = parsiraj(korisnickiUnosSaTastature, pozicija, argument3);
    
    if (argument3.length() &gt; 0) {
        greska = KodoviGresaka::SuvisanParametar;
        return false;
    }
    
    if (sifraKomande == "P1") {
        if (argument2.length() &gt; 0) {
            greska = KodoviGresaka::SuvisanParametar;
            return false;
        }
        komanda = Komande::PomjeriJednoMjesto;
        if (argument1 == "GL") { smjer = Smjerovi::GoreLijevo; }
        else if (argument1 == "G") { smjer = Smjerovi::Gore; }
        else if (argument1 == "GD") { smjer = Smjerovi::GoreDesno; }
</font>        else if (argument1 == "D") { smjer = Smjerovi::Desno; }
        else if (argument1 == "DoD") { smjer = Smjerovi::DoljeDesno; }
        else if (argument1 == "Do") { smjer = Smjerovi::Dolje; }
<a name="2"></a><font color="#0000FF"><a href="match102-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_22.gif"/></a>

        else if (argument1 == "DoL") { smjer = Smjerovi::DoljeLijevo; }
        else if (argument1 == "L") { smjer = Smjerovi::Lijevo; }
        else {
            if (argument1.length() == 0) { greska = KodoviGresaka::NedostajeParametar;}
            else { greska = KodoviGresaka::NeispravanParametar; }
            return false;
        }
        return true;
    }
    if (sifraKomande == "P&gt;" || sifraKomande == "B" || sifraKomande == "D") {
        if (sifraKomande == "P&gt;") { komanda = Komande::PomjeriDalje; }
        if (sifraKomande == "B") { komanda = Komande::Blokiraj; }
        if (sifraKomande == "D") { komanda = Komande::Deblokiraj; }
        if (argument1.length() == 0 || argument2.length() == 0) {
            greska = KodoviGresaka::NedostajeParametar;
            return false;
        }
        if (!jeLiBroj(argument1) || !jeLiBroj(argument2)) {
            greska = KodoviGresaka::NeispravanParametar;
            return false;
        }
        x = stoi(argument1);
        y = stoi(argument2);
        return true;
    }
    if (sifraKomande == "PO" || sifraKomande == "Z" || sifraKomande == "K") {
        if (sifraKomande == "PO") { komanda = Komande::PrikaziOkolinu; }
        if (sifraKomande == "Z") { komanda = Komande::ZavrsiIgru; }
        if (sifraKomande == "K") { komanda = Komande::KreirajIgru; }
        
        if (argument1.length() &gt; 0) {
            greska = KodoviGresaka::SuvisanParametar;
            return false;
        }
        return true;
    }
    greska = KodoviGresaka::PogresnaKomanda;
    return false;
    
}

int main()
{




     while(true) {
        Komande komanda;
        Smjerovi smjer;
        int x;
        int y;
        KodoviGresaka greska;
        bool sveURedu = UnosKomande(komanda, smjer, x, y, greska);
        if (!sveURedu) {
            switch(greska) {
                case KodoviGresaka::PogresnaKomanda:
                cout &lt;&lt; "PogresnaKomanda" &lt;&lt; endl;
                break;
            case KodoviGresaka::NedostajeParametar:
                cout &lt;&lt; "NedostajeParametar" &lt;&lt; endl;
                break;
            case KodoviGresaka::SuvisanParametar:
                cout &lt;&lt; "SuvisanParametar" &lt;&lt; endl;
                break;
            case KodoviGresaka::NeispravanParametar:
                cout &lt;&lt; "NeispravanParametar" &lt;&lt; endl;
                break;
            }
        }
        switch(komanda) {
            case Komande::PomjeriJednoMjesto:
                cout &lt;&lt; "PomjeriJednoMjesto" &lt;&lt; endl;
                switch(smjer) {
                    case Smjerovi::GoreLijevo:
                    cout &lt;&lt; "GoreLijevo" &lt;&lt; endl;
                    break;
                case Smjerovi::Gore:
                    cout &lt;&lt; "Gore" &lt;&lt; endl;
                    break;
                case Smjerovi::GoreDesno:
                    cout &lt;&lt; "GoreDesno" &lt;&lt; endl;
                    break;
                case Smjerovi::Desno:
                    cout &lt;&lt; "Desno" &lt;&lt; endl;
                    break;
                case Smjerovi::DoljeDesno:
                    cout &lt;&lt; "DoljeDesno" &lt;&lt; endl;
                    break;
                case Smjerovi::Dolje:
                    cout &lt;&lt; "Dolje" &lt;&lt; endl;
                    break;
                case Smjerovi::DoljeLijevo:
                    cout &lt;&lt; "DoljeLijevo" &lt;&lt; endl;
                    break;
                case Smjerovi::Lijevo:
                    cout &lt;&lt; "Lijevo" &lt;&lt; endl;
                    break;
                }
                break;
            case Komande::PomjeriDalje:
                cout &lt;&lt; "PomjeriDalje" &lt;&lt; endl;
                break;
            case Komande::Blokiraj:
                cout &lt;&lt; "Blokiraj" &lt;&lt; endl;
                break;
            case Komande::Deblokiraj:
                cout &lt;&lt; "Deblokiraj" &lt;&lt; endl;
                break;
            case Komande::PrikaziOkolinu:
                cout &lt;&lt; "PrikaziOkolinu" &lt;&lt; endl;
                break;
            case Komande::ZavrsiIgru:
                cout &lt;&lt; "ZavrsiIgru" &lt;&lt; endl;
                break;
            case Komande::KreirajIgru:
                cout &lt;&lt; "KreirajIgru" &lt;&lt; endl;
                break;
        }
        cout &lt;&lt; x &lt;&lt; endl &lt;&lt; y &lt;&lt; endl;
    }  
    
    return 0;
</font>}
</pre>
</body>
</html>
