<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5961.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student7795.cpp<p></p><pre>
/*	ADDING HOTFIXES | TESTED LOCALLY	*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;complex&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;limits&gt;
#include &lt;cstdlib&gt;

// 	Types for output	//
<a name="0"></a><font color="#FF0000"><a href="match62-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum class CustomException 	{TackaEx, PoljeEx, PotezEx};
enum class InputType 		{None, Text, Number, Empty, Mine, Field};

enum class Status 			{NijeKraj, KrajPoraz, KrajPobjeda};
enum class Smjerovi 		{GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class Polje 			{Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};
enum class Komande 			{PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};
enum class KodoviGresaka 	{PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
//	Types of Inputs, Errors and a bit of everythings	//
std::vector&lt;std::string&gt; 	MOVE_TYPE 		{"GL", "G", "GD", "D", "DoD", "Do", "DoL", "L"};
std::vector&lt;std::string&gt; 	INPUT_COMMANDS 	{"P1", "P&gt;", "B", "D", "PO", "Z", "K"};
std::vector&lt;InputType&gt; 		INPUT_VALUE_TYPE 	{InputType::Text, InputType::Number, InputType::Number, InputType::Number, 
											InputType::Empty, InputType::Empty, InputType::Empty};
std::vector&lt;Komande&gt; 		INPUT_COMMAND_TYPE 	{Komande::PomjeriJednoMjesto, Komande::PomjeriDalje, Komande::Blokiraj, Komande::Deblokiraj, 
											Komande::PrikaziOkolinu, Komande::ZavrsiIgru, Komande::KreirajIgru};
std::vector&lt;std::string&gt; 	GRESKE_TEXT {
	"Nerazumljiva komanda!", 
	"Komanda trazi parametar koji nije naveden!", 
	"Zadan je suvisan parametar nakon komande!",
	"Parametar komande nije ispravan!"
};
using Tabla 		= 	std::vector&lt;std::vector&lt;Polje&gt;&gt;;
using Red 		=	std::vector&lt;Polje&gt;;
struct Tacka	{int x, y; };
constexpr int SIZE_CHECK_MATRIX {1};
/*	Lambda one-liners 	*/
bool PointInTable	(const Tacka &amp;t, const int &amp;x, const int &amp;y) { return (t.x &gt;= 0 &amp;&amp; t.y &gt;= 0 &amp;&amp; t.x &lt; x &amp;&amp; t.y &lt; y); }
bool PointInTable	(const Tacka &amp;t, const Tabla &amp;polja) { return (t.x &gt;= 0 &amp;&amp; t.y &gt;= 0 &amp;&amp; t.x &lt; polja.size() &amp;&amp; t.y &lt; polja.at(t.x).size()); }
auto clearMatrix 	= 	[](Tabla &amp;polja) {std::fill(polja.begin(), polja.end(), Red(polja.size(), Polje::Prazno));};
auto PrijaviGresku 	= 	[](const KodoviGresaka &amp;greska) -&gt; void {std::cout &lt;&lt; GRESKE_TEXT.at(static_cast&lt;int&gt;(greska) - static_cast&lt;int&gt;(KodoviGresaka::PogresnaKomanda)) &lt;&lt; std::endl; };
auto CharNotDigit	= 	[](const char &amp;c) { return !std::isdigit(c); };
auto isStrNumber	=	[](const std::string &amp;str) -&gt; bool { return (!str.empty() &amp;&amp; (std::find_if(str.begin(), str.end(), CharNotDigit) == str.end())); };
auto TekucaPozicija = 	[](const int &amp;x, const int &amp;y) -&gt; void {std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")\n";};
auto RetEmptyCode 	= 	[](KodoviGresaka &amp;kod) -&gt; bool { kod = KodoviGresaka::SuvisanParametar; return false; };
void finishGame(Tabla &amp;polja) {
	clearMatrix(polja);
	throw std::runtime_error("Igra zavrsena");
}
bool printExitValues(Tabla &amp;polja, Status _value) {
	if (_value == Status::KrajPoraz) std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
	else if (_value == Status::KrajPobjeda) std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
	else return false;
	finishGame(polja);
	return true;
}
/*	function to convert string to number	*/
bool StrToNumber(const std::string &amp;str, int &amp;outputNum) {
	if(((str.at(0) == '-' &amp;&amp; isStrNumber(str.substr(1))) ||  isStrNumber(str)) 
		&amp;&amp; str.length() &lt; 14 &amp;&amp; str.length() &gt; 0) {
		long num(std::atol(str.c_str()));
		
		if (static_cast&lt;long&gt;(std::numeric_limits&lt;int&gt;::max()) &gt;= num) {
			outputNum = static_cast&lt;int&gt;(num);
			return true;
		}
	}
	return false;
}
/*		USER DEFINED FUNCTIONS 			*/
/* 		increase enum field value 		*/
template &lt;typename IEnumType&gt;
inline void IncreaseEnumValue(IEnumType &amp;_field, const IEnumType &amp;upperBound, int _value = int()) {
	_field = static_cast&lt;IEnumType&gt;((std::abs(static_cast&lt;int&gt;(_field) + _value)) % (static_cast&lt;int&gt;(upperBound) + 1));
}
/* 	check validity of table 		*/
bool LegalnaTabla(const Tabla &amp;polja) {
	size_t dimenzija {polja.size()};
	for(auto red:polja) 
		if(red.size() != dimenzija) 
			return false;
	return true;
}
/* 	custom exception handling 	*/
void Exception(const Tabla &amp;polja, const int &amp;x, const int &amp;y, CustomException _value = CustomException::TackaEx) {
	switch(_value) {
		case CustomException::TackaEx: 
			if(!PointInTable({x, y}, polja))	 	throw std::domain_error(std::string{"Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji"});
		break;
		case CustomException::PoljeEx:
			if(!LegalnaTabla(polja))				throw std::domain_error("Ilegalna velicina polja");
		break;		
		case CustomException::PotezEx:
			if(!PointInTable({x, y}, polja))	 	throw std::out_of_range("Izlazak van igrace table");
		break;
	}
}
/* 	function to sum number of mines around (x,y) location 	*/
int 	SumBySizeField(const Tabla &amp;polja, const int &amp;x, const int &amp;y) {
	int _suma {0};
	for(int i{x-SIZE_CHECK_MATRIX}; i &lt;= x+SIZE_CHECK_MATRIX; ++i)
		for(int j{y-SIZE_CHECK_MATRIX}; j &lt;= y+SIZE_CHECK_MATRIX; ++j)
			if((i != x || j != y) &amp;&amp; PointInTable({ i, j }, polja) 
				&amp;&amp; (polja.at(i).at(j) == Polje::Mina)) 
				++_suma;
	return _suma;
}
/* 	function to get words from given string 	*/
/* 	funkcija zapravo pretvori 	*/
std::vector&lt;std::string&gt; StringToWords(std::string input) {
	std::vector&lt;std::string&gt; output{};
	size_t size{0}, len{0}, start{0};
	bool _set {false};
	for(int i{0};i &lt; input.length(); ++i) {
		if(isspace(input.at(i))) {
			if(_set) {
				if(size++ &lt; 3) output.push_back(input.substr(start, len));
				else {
					input.erase(input.begin(), input.begin() + start); 
					output.push_back(input); 
					return output; 
				} 
				_set = false;
			}
		}
		else if(!_set) {
			_set 	= true;
			start 	= i;
			len 		= 0;
		} 
		len++;
	}
	if(_set &amp;&amp; size &lt;= 3) output.push_back(input.substr(start, len));
	return output;
}
/* 	print specific matrix 	*/
template &lt;typename T&gt;
void printTable(const std::vector&lt;std::vector&lt;T&gt;&gt; &amp;polja){
   	for(auto red:polja) {
     	for(auto clan:red) std::cout &lt;&lt; int(clan) &lt;&lt; " ";
          std::cout &lt;&lt; std::endl;
     }
}
/*	function to read valid number		*/
template &lt;typename T, typename funkT&gt;
void UnosBroja(std::string promptText, std::string errorMessage, InputType type, 
			funkT checkFunction, bool &amp;checkValue, T upperBound,
		 	T &amp;var1, T &amp;var2) {
		 		
     std::cout &lt;&lt; promptText;
     for(;;) {
	     std::string input;
	     getline(std::cin, input);
	     if(type == InputType::Field) {
	     	std::vector&lt;std::string&gt; words = StringToWords(input);
		     int _num (0);
		     if(words.size() != 1 || !StrToNumber(words.at(0), _num) || _num &lt;= 0)
		     	std::cout &lt;&lt; errorMessage &lt;&lt; std::endl &lt;&lt; promptText;
		     else {
	     		var1 = _num;
	     		checkValue = true;
	     		return;
		     }
	     }
	     else if(type == InputType::Mine) {
	     	char charCheck {'\0'};
	     	int INPUT_NUM {std::sscanf(input.c_str(), "(%d,%d) %c", &amp;var1, &amp;var2, &amp;charCheck)};
		     if(input != "." &amp;&amp; ((INPUT_NUM != 2 &amp;&amp; INPUT_NUM != 3)  || int(charCheck) != 0 || 
		     		!checkFunction(var1) || !checkFunction(var2) || var1 &gt;= upperBound || var2 &gt;= upperBound || var1 &lt; 0 || var2 &lt; 0)) {
		     	std::cout &lt;&lt; errorMessage &lt;&lt; std::endl;
		     } 
		     else {
			     if(input == ".") checkValue = true;
			     return;
		     }
	     }
     }
}
/*									*/
/* 	Minesweeper functions to implement 	*/
/*									*/
Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	// error check		//
	if (std::find_if(mine.begin(), mine.end(), [](const std::vector&lt;int&gt; &amp;mina) { return mina.size() != 2; }) != mine.end())
		throw std::domain_error("Ilegalan format zadavanja mina");
	if (std::find_if(mine.begin(), mine.end(), [n](const std::vector&lt;int&gt; &amp;mina) { return !PointInTable({ mina.at(0), mina.at(1) }, n, n); }) != mine.end())
		throw std::domain_error("Ilegalne pozicije mina");
	if(n &lt;= 0) 	
		throw std::domain_error("Ilegalna velicina");
	// 	initialise table	//
	Tabla outputField;
	try { outputField = Tabla(n, Red(n, Polje::Prazno)); }
	catch(...) { throw std::domain_error("Ilegalna velicina"); }
	// 	set values and return	//
	std::for_each(mine.begin(), mine.end(), [&amp;outputField](const std::vector&lt;int&gt; &amp;mina) {
		outputField.at(mina.at(0)).at(mina.at(1)) = Polje::Mina;	
	});
	return outputField;
}
/*	show surrouding function 	*/
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) { 
	std::vector&lt;std::vector&lt;int&gt;&gt; outputMatrix(3, std::vector&lt;int&gt;(3, 0));
	if (polja.empty()) return outputMatrix;
	Exception(polja, x, y, CustomException::TackaEx);
	// fill matrix with data	//
	for(int i{ x - SIZE_CHECK_MATRIX }; i &lt;= x + SIZE_CHECK_MATRIX; ++i) {
		std::vector&lt;int&gt; tempRow(3, 0);
		for(int j{ y - SIZE_CHECK_MATRIX }; j &lt;= y + SIZE_CHECK_MATRIX; ++j) 
			tempRow.at(std::abs(j - y + SIZE_CHECK_MATRIX)) = SumBySizeField(polja, i, j);
		outputMatrix.at(std::abs(i - x + SIZE_CHECK_MATRIX)) = tempRow;
	}
	return outputMatrix;
}
/*	block specific position	*/
void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	Exception(polja, x, y, CustomException::TackaEx);
	
	if(polja.at(x).at(y) &gt;= Polje::BlokiranoPrazno) return;
	IncreaseEnumValue&lt;Polje&gt;(polja.at(x).at(y), Polje::BlokiranoMina, static_cast&lt;int&gt;(Polje::BlokiranoPrazno));
}
/*	unblock specific position	*/
void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	Exception(polja, x, y, CustomException::TackaEx);
	
	if(polja.at(x).at(y) &lt; Polje::BlokiranoPrazno) return;
	IncreaseEnumValue&lt;Polje&gt;(polja.at(x).at(y), Polje::BlokiranoMina, -static_cast&lt;int&gt;(Polje::BlokiranoPrazno));
}
/*	goto specific position on table with 5 parameters	*/
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	// 	handle exceptions
	Exception(polja, novi_x, novi_y, CustomException::PotezEx);
	if(polja.at(novi_x).at(novi_y) &gt;= Polje::BlokiranoPrazno) 
		throw std::logic_error("Blokirano polje");
	// 	Exception(polja, x, y, CustomException::TackaEx); // CHECK IF REALLY NEEDED
	//	GameOver	//
	if(polja.at(novi_x).at(novi_y) == Polje::Mina) {
		clearMatrix(polja);
		return Status::KrajPoraz;
	}
	if (PointInTable({ x, y}, polja))
		polja.at(x).at(y) = Polje::Posjeceno;
	x = novi_x;
	y = novi_y;
	for(int i (0); i &lt; polja.size(); ++i) 
		for(int j (0); j &lt; polja.at(i).size(); ++j)
			if((i != x || j != y) &amp;&amp; polja.at(i).at(j) == Polje::Prazno)
				return Status::NijeKraj;
	return Status::KrajPobjeda;
}
/* 	goto specific position on table with 4 parameters	*/
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	Tacka point ({x, y});
	if(smjer &lt;= Smjerovi::GoreDesno) 									point.x += -1;
	else if(!(smjer == Smjerovi::Lijevo || smjer == Smjerovi::Desno)) 		point.x += 1;
	
	if(smjer &gt;= Smjerovi::DoljeLijevo || smjer == Smjerovi::GoreLijevo)		point.y += -1;
	else if(!(smjer == Smjerovi::Gore || smjer == Smjerovi::Dolje)) 			point.y += 1;
	
	return Idi(polja, x, y, point.x, point.y);
}
/*	function to do certain command	*/
void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp; y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
	try {
		if(komanda == Komande::PomjeriJednoMjesto) {
			Status retCode (Idi(polja, x, y, p_smjer));		
			TekucaPozicija(x, y);
			printExitValues(polja, retCode);
		}
		else if(komanda == Komande::PomjeriDalje) {	
			Status retCode (Idi(polja, x, y, p_x, p_y));		
			TekucaPozicija(x, y);
			printExitValues(polja, retCode);
		}
		else if(komanda == Komande::Blokiraj)		BlokirajPolje(polja, p_x, p_y);
		else if(komanda == Komande::Deblokiraj)		DeblokirajPolje(polja, p_x, p_y);
		else if(komanda == Komande::PrikaziOkolinu)	printTable(PrikaziOkolinu(polja, x, y));
		else if(komanda == Komande::ZavrsiIgru) 	finishGame(polja);
		else if(komanda == Komande::KreirajIgru) {
			int n, _notdef;
			bool checkValue {false};
			std::vector&lt;std::vector&lt;int&gt;&gt; mine;
			
			UnosBroja&lt;int&gt;("Unesite broj polja: ", "Greska, unesite ponovo!", InputType::Field,
				[](int num) { return (num &gt; 0); }, checkValue, std::numeric_limits&lt;int&gt;::max(), n, _notdef);
			
			checkValue = false;
			std::cout &lt;&lt; "Unesite pozicije mina: ";
			for(;!checkValue;) {
				std::vector&lt;int&gt; par(2);
				UnosBroja&lt;int&gt;("", "Greska, unesite ponovo!", InputType::Mine,
					[](int num) { return (num &gt;= 0); }, checkValue, n, par.at(0), par.at(1));
				if(!checkValue &amp;&amp; std::find(mine.begin(), mine.end(), par) == mine.end()) 
					mine.push_back(par);
			}
			polja = KreirajIgru(n, mine);
			x = 0; y = 0;
		}
	}
	catch(std::runtime_error) { throw; }
	catch(std::exception &amp;e) {
		std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
	}
}
/*	function to read user game command		*/
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
	std::string input;
	InputType _setType{InputType::None};
	
	std::getline(std::cin, input);
	std::vector&lt;std::string&gt; words = StringToWords(input);
	//	wrong command exception		//
	auto it = std::find(INPUT_COMMANDS.begin(), INPUT_COMMANDS.end(), words.at(0));
	if(it != INPUT_COMMANDS.end()) 	_setType = INPUT_VALUE_TYPE.at((it - INPUT_COMMANDS.begin()));
	else {
		greska = KodoviGresaka::PogresnaKomanda;
		return false;
	}
	// 	missing parameter exception 	//
	if(words.size() == 1 &amp;&amp; _setType != InputType::Empty) {
		greska = KodoviGresaka::NedostajeParametar;
		return false;
	}
	else if(_setType == InputType::Empty &amp;&amp; words.size() &gt; 1)	return RetEmptyCode(greska);
	// 	invalid parameter exception	//
	if(_setType == InputType::Text) {
		auto iter = std::find(MOVE_TYPE.begin(), MOVE_TYPE.end(), words.at(1));
		if(iter != MOVE_TYPE.end()) {
  			if(words.size() &gt; 2) return RetEmptyCode(greska);
			smjer = static_cast&lt;Smjerovi&gt;((iter - MOVE_TYPE.begin()) + static_cast&lt;int&gt;(Smjerovi::GoreLijevo));
		}
		else {
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
	}
	else if(_setType == InputType::Number) {
		int _checkNum[2];
		if(!StrToNumber(words.at(1), _checkNum[0]) || !StrToNumber(words.at(2), _checkNum[1])) {
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
		else {
  			if(words.size() &gt; 3) return RetEmptyCode(greska);
  			x = _checkNum[0];
  			y = _checkNum[1];
 		}
	}
	//	update the command 		//
	komanda = INPUT_COMMAND_TYPE.at(it - INPUT_COMMANDS.begin());
	return true;
}
/* main function logic */
int main () {
	Komande komanda;
	Smjerovi smjer;
	Tabla polja;
	int x{0}, y{0}, p_x{0}, p_y{0};
	KodoviGresaka greska;
	for(;;) {
		try {
			std::cout &lt;&lt; "Unesite komandu: ";
			if(UnosKomande(komanda, smjer, p_x, p_y, greska))
				IzvrsiKomandu(komanda, polja, x, y, smjer, p_x, p_y);
			else PrijaviGresku(greska);
		}
		catch(std::runtime_error) {
			std::cout &lt;&lt; "Dovidjenja!";
			return 0;
		}
		catch(...) {
			return -1;
		}
	}
	return 0;
</font>}</pre>
</body>
</html>
