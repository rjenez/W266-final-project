<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4110.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4110.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;string&gt;

enum class Polje {Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};
enum class Smjerovi{GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class Status{NijeKraj,KrajPoraz,KrajPobjeda};
enum class KodoviGresaka{PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
<a name="1"></a><font color="#00FF00"><a href="match87-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_26.gif"/></a>

enum class Komande{PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	if(n&lt;=0) throw std::domain_error("Ilegalna velicina");
	for(int i=0;i&lt;mine.size();i++){
		if(mine[i].size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
	}
	for(int i=0;i&lt;mine.size();i++){
		for(int j=0;j&lt;2;j++){
			if(!(mine[i][j]&gt;=0&amp;&amp;mine[i][j]&lt;n)) throw std::domain_error("Ilegalne pozicije mina");
		}
	}
	Tabla a(n,std::vector&lt;Polje&gt;(n,Polje::Prazno));
	for(int i=0;i&lt;mine.size();i++){
		a[mine[i][0]][mine[i][1]]=Polje::Mina;
	}
	return a;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	if(!(x&gt;=0&amp;&amp;x&lt;polja.size())||!(y&gt;=0&amp;&amp;y&lt;polja.size())) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	Matrica a(3,std::vector&lt;int&gt;(3));
	std::vector&lt;int&gt; v;
	Matrica m;
	int prva{0},druga{0};
	for(int i=x-1;i&lt;=x+1;i++){
		for(int j=y-1;j&lt;=y+1;j++){
			int br{0};
			v.push_back(i);
			v.push_back(j+1);
			m.push_back(v);
			v.resize(0);
			
			v.push_back(i);
			v.push_back(j-1);
			m.push_back(v);
			v.resize(0);
			
			v.push_back(i+1);
			v.push_back(j);
			m.push_back(v);
			v.resize(0);
			
			v.push_back(i-1);
			v.push_back(j);
			m.push_back(v);
			v.resize(0);
			
			v.push_back(i-1);
			v.push_back(j-1);
			m.push_back(v);
			v.resize(0);
			
			v.push_back(i+1);
			v.push_back(j+1);
			m.push_back(v);
			v.resize(0);
			
			v.push_back(i-1);
			v.push_back(j+1);
			m.push_back(v);
			v.resize(0);
			
			v.push_back(i+1);
			v.push_back(j-1);
			m.push_back(v);
			v.resize(0);
			
			
			for(int k=0;k&lt;m.size();k++){
				if(!(m[k][0]&gt;=0&amp;&amp;m[k][0]&lt;polja.size())||!(m[k][1]&gt;=0&amp;&amp;m[k][1]&lt;polja.size())) {m.erase(m.begin()+k);k--;}
				
			}
			
			for(int k=0;k&lt;m.size();k++){
				if(polja[m[k][0]][m[k][1]]==Polje::Mina)br++;
			}
			a[prva][druga]=br;
			druga++;
			m.resize(0);
		}
		druga=0;
		prva++;
	}
	return a;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	//std::string string1("Polje ("), string2(","),string3(") ne postoji");
	if(!(x&gt;=0&amp;&amp;x&lt;polja.size())||!(y&gt;=0&amp;&amp;y&lt;polja.size()))  throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if(polja[x][y]==Polje::Prazno)polja[x][y]=Polje::BlokiranoPrazno;
</font><a name="2"></a><font color="#0000FF"><a href="match87-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

	if(polja[x][y]==Polje::Mina)polja[x][y]=Polje::BlokiranoMina;
	if(polja[x][y]==Polje::Posjeceno)polja[x][y]=Polje::BlokiranoPosjeceno;
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	if(!(x&gt;=0&amp;&amp;x&lt;polja.size())||!(y&gt;=0&amp;&amp;y&lt;polja.size())) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if(polja[x][y]==Polje::BlokiranoPrazno)polja[x][y]=Polje::Prazno;
</font><a name="0"></a><font color="#FF0000"><a href="match87-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_64.gif"/></a>

	if(polja[x][y]==Polje::BlokiranoMina)polja[x][y]=Polje::Mina;
	if(polja[x][y]==Polje::BlokiranoPosjeceno)polja[x][y]=Polje::Posjeceno;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	polja[x][y]=Polje::Posjeceno;
	std::vector&lt;std::vector&lt;int&gt;&gt; a{{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1}};
	x+=a[int(smjer)][0];
	y+=a[int(smjer)][1];
	if(!(x&gt;=0&amp;&amp;x&lt;polja.size())||!(y&gt;=0&amp;&amp;y&lt;polja.size())) throw std::out_of_range("Izlazak van igrace table");
	if(int(polja[x][y])&gt;2) throw std::logic_error("Blokirano polje");
	if(polja[x][y]==Polje::Mina) {
		Tabla prazna(polja.size(),std::vector&lt;Polje&gt;(polja.size(),Polje::Prazno));
		polja=prazna;
		return Status::KrajPoraz;
	}
	int br{0};
	for(int i=0;i&lt;polja.size();i++){
		for(int j=0;j&lt;polja.size();j++){
			if(polja[i][j]==Polje::Prazno) br++;
		}
	}
	if(br==0) return Status::KrajPobjeda;
	return Status::NijeKraj;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	polja[x][y]=Polje::Posjeceno;
	x=novi_x;
	y=novi_y;
	if(!(x&gt;=0&amp;&amp;x&lt;polja.size())||!(y&gt;=0&amp;&amp;y&lt;polja.size())) throw std::out_of_range("Izlazak van igrace table");
	if(int(polja[x][y])&gt;2) throw std::logic_error("Blokirano polje");
	if(polja[x][y]==Polje::Mina) {
		Tabla prazna(polja.size(),std::vector&lt;Polje&gt;(polja.size(),Polje::Prazno));
		polja=prazna;
		return Status::KrajPoraz;
	}
	int br{0};
	for(int i=0;i&lt;polja.size();i++){
		for(int j=0;j&lt;polja.size();j++){
			if(polja[i][j]==Polje::Prazno) br++;
		}
	}
	if(br==0) return Status::KrajPobjeda;
	return Status::NijeKraj;
}
void PrijaviGresku(KodoviGresaka a){
	if(int(a)==0)std::cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;std::endl;
	if(int(a)==1)std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;std::endl;
	if(int(a)==3)std::cout&lt;&lt;"Parametar komande nije ispravan!"&lt;&lt;std::endl;
	if(int(a)==2)std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;std::endl;
}


bool Cifre(std::string a){
	for(int i=0;i&lt;a.length();i++){
		if(!(a[i]&gt;='0'&amp;&amp;a[i]&lt;='9')) return false;
	}
	return true;
}
int PretvoriString(std::string a){
	int k{1},broj{0};
	for(int i=a.length()-1;i&gt;=0;i--){
		broj+=(int(a[i])-48)*k;
		k*=10;
	}
	return broj;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	std::string a,z;
	std::vector&lt;std::string&gt;b{"P1","P&gt;","B","D","PO","Z","K"},k;
	std::getline(std::cin,a);
	for(int i=0;i&lt;a.length();i++){
		while(a[i]==' ' &amp;&amp; i&lt;a.length())i++;
		while(a[i]!=' ' &amp;&amp; i&lt;a.length()){
			z.push_back(a[i]);
			i++;
		}
		k.push_back(z);
		z.resize(0);
		while(a[i]==' '&amp;&amp;i&lt;a.length())i++;
		i--;
}

int br{0},indeks;
for(int i=0;i&lt;k.size();i++){
	for(int j=0;j&lt;b.size();j++){
		if(k[i]==b[j]&amp;&amp;br==0){ komanda=Komande(j);br++;indeks=i;}
	}
}
if(br==0){
	greska=KodoviGresaka::PogresnaKomanda;
	for(int i=0;i&lt;a.length();i++){
		if(a[i]=='B'||a[i]=='K'||a[i]=='Z'){
			if(a[i+1]!=' ') greska=KodoviGresaka::SuvisanParametar;
		}
		if(a[i]=='P'&amp;&amp;a[i+1]=='O'&amp;&amp;a[i+2]!=' ') greska=KodoviGresaka::SuvisanParametar;
	}
}
else{
if(int(komanda)==0){
	int br{0};
	std::vector&lt;std::string&gt;b{"GL","G","GD","D","DoD","Do","DoL","L"};
	if((indeks+1)&gt;k.size()) greska=KodoviGresaka::NedostajeParametar;
	else{
	for(int i=0;i&lt;b.size();i++){
		if(k[indeks+1]==b[i]){ smjer=Smjerovi(i);br++;}
	}}
	if(br==0) greska=KodoviGresaka::SuvisanParametar;
}
if(int(komanda)&gt;0&amp;&amp;int(komanda)&lt;4){
	if((indeks+2)&gt;k.size()) greska=KodoviGresaka::NedostajeParametar;
	else{
	if(Cifre(k[indeks+1])&amp;&amp;Cifre(k[indeks+2])){
		x=PretvoriString(k[indeks+1]);
		y=PretvoriString(k[indeks+2]);
	}
	if(!(Cifre(k[indeks+1])&amp;&amp;Cifre(k[indeks+2]))) greska=KodoviGresaka::SuvisanParametar;
	}
}
}
if(int(greska)&gt;=0&amp;&amp;int(greska)&lt;3) return false;
return true;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0){
	if(komanda==Komande::Blokiraj){
	try{ BlokirajPolje(polja,x,y);}
	catch(std::domain_error e) {std::cout&lt;&lt;e.what()&lt;&lt;std::endl;}}
	
	if(komanda==Komande::Deblokiraj){
	try {DeblokirajPolje(polja,x,y);}
	catch(std::domain_error e) {std::cout&lt;&lt;e.what()&lt;&lt;std::endl;}}
	
	if(komanda==Komande::PomjeriJednoMjesto){
		try{
	Status a(Idi(polja,x,y,p_smjer));
	if(a==Status::KrajPobjeda)std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;") "&lt;&lt;"Bravo obisli ste sva sigurna polja"&lt;&lt;std::endl;
	if(a==Status::KrajPoraz)std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;") "&lt;&lt;"Nagazili ste na minu"&lt;&lt;std::endl;
	if(a==Status::NijeKraj)std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;}
	catch(std::out_of_range e) {std::cout&lt;&lt;e.what()&lt;&lt;std::endl;}
	catch(std::logic_error e) {std::cout&lt;&lt;e.what()&lt;&lt;std::endl;}
	}
	if(komanda==Komande::PrikaziOkolinu){
		try{
		Matrica a(PrikaziOkolinu(polja,x,y));
		for(int i=0;i&lt;3;i++){
			for(int j=0;j&lt;3;j++){
				std::cout&lt;&lt;a[i][j]&lt;&lt;" ";
			}
			std::cout&lt;&lt;std::endl;
		}
		}
		catch(std::domain_error e) {std::cout&lt;&lt;e.what()&lt;&lt;std::endl;}
	}
	if(komanda==Komande::ZavrsiIgru){
		for(int i=0;i&lt;polja.size();i++){
			for(int j=0;j&lt;polja.size();j++)
			polja[i][j]=Polje::Prazno;
		}
		throw std::runtime_error("Igra zavrsena");
	}
	if(komanda==Komande::KreirajIgru){
		try{
		int n;
		std::cout&lt;&lt;"Unesite broj polja: ";
		std::cin&gt;&gt;n;
		while(!std::cin||n&lt;=0){
			std::cout&lt;&lt;"Greska, unesite ponovo!";
			std::cin.clear();
			std::cin.ignore(10000,'\n');
			std::cout&lt;&lt;"Unesite broj polja: ";
			std::cin&gt;&gt;n;
		}
		std::vector&lt;std::complex&lt;int&gt;&gt; a;
		std::complex&lt;int&gt;b;
		std::cout&lt;&lt;"Unesite pozicije mina: ";
			
		while(!std::cin.peek()=='.'){
			std::cin&gt;&gt;b;
			while(!std::cin){
			std::cout&lt;&lt;"Greska, unesite ponovo!";
			std::cin.clear();
			std::cin.ignore(10000,'\n');
			std::cin&gt;&gt;b;
		}
			a.push_back(b);
		}
		std::vector&lt;std::vector&lt;int&gt;&gt;c(a.size(),std::vector&lt;int&gt;(2));
		
		for(int i=0;i&lt;a.size();i++){
			c[i][0]=std::real(a[i]);
			c[i][1]=std::imag(a[i]);
		}
        polja=KreirajIgru(n,c);
			}
		catch(std::domain_error e){
			std::cout&lt;&lt;e.what();
		}
	}
			
	
	
	
}

int main ()
{
    std::cout&lt;&lt;"Unesite komandu: ";
    Komande komanda;
    Smjerovi smjer;
    int x,y;
    KodoviGresaka greska;
    Tabla polja;
    if(UnosKomande(komanda,smjer,x,y,greska)) IzvrsiKomandu(komanda,polja,x,y,smjer);
    else PrijaviGresku(greska);
    
	return 0;
</font>}</pre>
</body>
</html>
