<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student3732.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student6053.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;complex&gt;
#include &lt;vector&gt;

using namespace std;

enum class Polje{Prazno,Posjeceno,Mina,BlokiranoPrazno,BlokiranoMina,BlokiranoPosjeceno};
enum class Smjerovi{GoreLijevo,Gore,GoreDesno,Desno,DoljeDesno,Dolje,DoljeLijevo,Lijevo};
enum class Status {NijeKraj,KrajPoraz,KrajPobjeda};
enum class KodoviGresaka{PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
enum class Komande{PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};

typedef vector&lt;vector&lt;Polje&gt;&gt; Tabla;
typedef vector&lt;vector&lt;int&gt;&gt; Matrica;

bool Slovo(char a){
	return ((a&gt;='A' || a&lt;='Z') || (a&gt;='a' || a&lt;='z')) ;
}
bool Broj(char a){
	a-='0';
	return a&gt;=0 &amp;&amp; a&lt;=9; 
}
Tabla KreirajIgru(int n,Matrica &amp;mine){
	Tabla d;
<a name="12"></a><font color="#0000FF"><a href="match366-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

	d.resize(n);
	for(int i=0;i&lt;n;i++){
		d[i].resize(n);
		for(int j=0;j&lt;n;j++)
</font>		d[i][j]=Polje::Prazno;
	}
	for(int i=0;i&lt;mine.size();i++)
	if(mine[i].size()!=2)
			throw domain_error("Ilegalan format zadavanja mina\n");
	for(int i=0;i&lt;d.size();i++)
	{
		for(int j=0;j&lt;d[i].size();j++)
		{
			for(int k=0;k&lt;mine.size();k++)
			{
					if(mine[k][0]&gt;=n || mine[k][1]&gt;=n)
						throw domain_error("Ilegalne pozicije mina\n");
					if(i==mine[k][0] || j==mine[k][1])
						d[i][j]=Polje::Mina;
			}
		}
}
return d;
}

Matrica PrikaziOkolinu(const Tabla &amp;polja,int x,int y){
	Matrica m;
	m.resize(3);
	for(int i=0;i&lt;3;i++)
	m[i].resize(3);
	int k=0;
	int red(0);
	int kol(0);
	for(int i=x-1;i&lt;x-1+3;i++){
    kol=0;
		for(int j=y-1;j&lt;y-1+3;j++)
		{
			int br;
			if(x&gt;=polja.size() || x&lt;0 || y&lt;0 || y&gt;=polja[k].size())
				throw domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji\n");
			if(i-1&lt;polja.size() || j&gt;-2 || j-1&lt;polja[k].size() || i&gt;-2 || polja[i-1][j-1]==Polje::Mina) br++;
			if(i&lt;polja.size() || j&gt;-2 || j+1&lt;polja[k].size() &amp;&amp; i&gt;-1 &amp;&amp; polja[i][j+1]==Polje::Mina) br++;
			if(i-1&lt;polja.size() &amp;&amp; j&gt;-2 &amp;&amp; j+1&lt;polja[k].size() &amp;&amp; i&gt;0 &amp;&amp; polja[i-1][j+1]==Polje::Mina) 	br++;
			if(i+1&lt;polja.size() &amp;&amp; j&gt;-2 &amp;&amp; j+1&lt;polja[k].size() &amp;&amp; i&gt;-2 &amp;&amp; polja[i+1][j+1]==Polje::Mina) br++;
			if(i+1&lt;polja.size() &amp;&amp; j&gt;-1 &amp;&amp; j&lt;polja[k].size() &amp;&amp; i&gt;-2 &amp;&amp; polja[i+1][j]==Polje::Mina)	br++;
			if(i&lt;polja.size() &amp;&amp; j&gt;0 &amp;&amp; j-1&lt;polja[k].size()  &amp;&amp; i&gt;-1 &amp;&amp; polja[i][j-1]==Polje::Mina)	br++;
			if(i+1&lt;polja.size() &amp;&amp; j&gt;0 &amp;&amp; j-1&lt;polja[k].size() &amp;&amp; i&gt;-2 &amp;&amp; polja[i+1][j-1]==Polje::Mina)	br++;
			if(i-1&lt;polja.size() &amp;&amp; j&gt;-1 &amp;&amp; j&lt;polja[k].size() &amp;&amp; i&gt;0 &amp;&amp; polja[i-1][j]==Polje::Mina)	br++;
			m[red][kol]=br;
			kol++;
		}
		red++;
		k++;
	}

	return m;
}
void BlokirajPolje(Tabla &amp;polja,int a,int b) {
	if(a&gt;=polja.size() || a&lt;0 || b&lt;0 || b&gt;=polja[0].size()) throw domain_error("Polje ("+std::to_string(a)+","+std::to_string(b)+") ne postoji\n");
	if(polja[a][b]==Polje::Prazno) polja[a][b]=Polje::BlokiranoPrazno;
	if(polja[a][b]==Polje::Posjeceno) polja[a][b]=Polje::BlokiranoPosjeceno;
<a name="9"></a><font color="#FF00FF"><a href="match366-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

	if(polja[a][b]==Polje::Mina) polja[a][b]=Polje::BlokiranoMina;
}
void DeblokirajPolje(Tabla &amp;polja,int a,int b) {
	if(a&gt;=polja.size() || a&lt;0 || b&lt;0 || b&gt;=polja[0].size()) throw domain_error("Polje ("+std::to_string(a)+","+std::to_string(b)+") ne postoji\n");
</font>	if(polja[a][b]==Polje::BlokiranoPrazno) polja[a][b]=Polje::Prazno;
	if(polja[a][b]==Polje::BlokiranoPosjeceno) polja[a][b]=Polje::Posjeceno;
<a name="8"></a><font color="#00FFFF"><a href="match366-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

	if(polja[a][b]==Polje::BlokiranoMina) polja[a][b]=Polje::Mina;
}
Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,Smjerovi smjer) {
</font>	if(polja.size()==0 || (smjer==Smjerovi::GoreLijevo and (y==0 || x==0)) || (smjer==Smjerovi::Gore and x==0) || (smjer==Smjerovi::GoreDesno and (y==polja[0].size()-1 || x==0)) || (smjer==Smjerovi::Desno and y==polja[0].size()-1) || (smjer==Smjerovi::DoljeDesno and (y==polja[0].size()-1 || x==polja.size()-1)) || (smjer==Smjerovi::Dolje and x==polja.size()-1) || (smjer==Smjerovi::DoljeLijevo and (x==polja.size()-1 || y==0)) || (smjer==Smjerovi::Lijevo and y==0))
		throw out_of_range("Izlazak van igrace table\n");
	if(smjer==Smjerovi::GoreLijevo) {
<a name="2"></a><font color="#0000FF"><a href="match366-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		if(polja[x-1][y-1]==Polje::BlokiranoPrazno || polja[x-1][y-1]==Polje::BlokiranoPosjeceno || polja[x-1][y-1]==Polje::BlokiranoMina)
</font>			throw logic_error("Blokirano polje\n");
		polja[x][y]=Polje::Posjeceno;
		x--;
		y--;
	}
	if(smjer==Smjerovi::Gore) {
<a name="6"></a><font color="#00FF00"><a href="match366-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

		if(polja[x-1][y]==Polje::BlokiranoPrazno || polja[x-1][y]==Polje::BlokiranoPosjeceno || polja[x-1][y]==Polje::BlokiranoMina)
</font>			throw logic_error("Blokirano polje\n");
		polja[x][y]=Polje::Posjeceno;
		x--;
	}
	if(smjer==Smjerovi::GoreDesno) {
<a name="3"></a><font color="#00FFFF"><a href="match366-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		if(polja[x-1][y+1]==Polje::BlokiranoPrazno || polja[x-1][y+1]==Polje::BlokiranoPosjeceno || polja[x-1][y+1]==Polje::BlokiranoMina)
			throw logic_error("Blokirano polje\n");
</font>		polja[x][y]=Polje::Posjeceno;
		x--;
		y++;
	}
	if(smjer==Smjerovi::Desno) {
<a name="4"></a><font color="#FF00FF"><a href="match366-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		if(polja[x][y+1]==Polje::BlokiranoPrazno || polja[x][y+1]==Polje::BlokiranoPosjeceno || polja[x][y+1]==Polje::BlokiranoMina)
			throw logic_error("Blokirano polje\n");
</font>		polja[x][y]=Polje::Posjeceno;
		y++;
	}
	if(smjer==Smjerovi::DoljeDesno)
	{
<a name="1"></a><font color="#00FF00"><a href="match366-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if(polja[x+1][y+1]==Polje::BlokiranoPrazno || polja[x+1][y+1]==Polje::BlokiranoPosjeceno || polja[x+1][y+1]==Polje::BlokiranoMina)
			throw logic_error("Blokirano polje\n");
</font>		polja[x][y]=Polje::Posjeceno;
		x++;
		y++;
	}
	if(smjer==Smjerovi::Dolje)	{
<a name="5"></a><font color="#FF0000"><a href="match366-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		if(polja[x+1][y]==Polje::BlokiranoPrazno || polja[x+1][y]==Polje::BlokiranoPosjeceno || polja[x+1][y]==Polje::BlokiranoMina)
			throw logic_error("Blokirano polje\n");
</font>		polja[x][y]=Polje::Posjeceno;
		x++;
	}
	if(smjer==Smjerovi::DoljeLijevo) {
<a name="0"></a><font color="#FF0000"><a href="match366-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		if(polja[x+1][y-1]==Polje::BlokiranoPrazno || polja[x+1][y-1]==Polje::BlokiranoPosjeceno || polja[x+1][y-1]==Polje::BlokiranoMina)
			throw logic_error("Blokirano polje\n");
</font>		polja[x][y]=Polje::Posjeceno;
		x++;
		y--;
	}
	if(smjer==Smjerovi::Lijevo)	{
<a name="7"></a><font color="#0000FF"><a href="match366-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

		if(polja[x][y-1]==Polje::BlokiranoPrazno || polja[x][y-1]==Polje::BlokiranoPosjeceno || polja[x][y-1]==Polje::BlokiranoMina)
</font>			throw logic_error("Blokirano polje\n");
		polja[x][y]=Polje::Posjeceno;
		y--;
	}
	if(polja[x][y]==Polje::Mina){
		for(int i=0;i&lt;polja.size();i++)
			for(int j=0;j&lt;polja[i].size();j++)
				polja[i][j]=Polje::Prazno;
		return Status::KrajPoraz;
	}
for(int i=0;i&lt;polja.size();i++) {
		for(int j=0;j&lt;polja[i].size();j++){
			if(i==x and j==y) continue;
			bool kraj;
<a name="10"></a><font color="#FF0000"><a href="match366-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

			kraj= (polja[i][j]!=Polje::Posjeceno and polja[i][j]!=Polje::Mina);
			if(kraj)
				return Status::NijeKraj;
		}
	}
	return Status::KrajPobjeda;
}
Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,int novi_x,int novi_y) {
</font>	if(novi_x&lt;0 or novi_y&lt;0 or novi_x&gt;polja.size() or novi_y&gt;polja[x].size())
		throw out_of_range("Izlazak van igrace table\n");
<a name="11"></a><font color="#00FF00"><a href="match366-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

	polja[x][y]=Polje::Posjeceno;
	x=novi_x;
	y=novi_y;
	if(polja[x][y]==Polje::Mina){
</font>		for(int i=0;i&lt;polja.size();i++)
			for(int j=0;j&lt;polja[i].size();j++)
				polja[i][j]=Polje::Prazno;
		return Status::KrajPoraz;
	}
	if(polja[x][y]==Polje::BlokiranoPosjeceno or polja[x][y]==Polje::BlokiranoPrazno or polja[x][y]==Polje::BlokiranoMina)
		throw logic_error("Blokirano polje\n");
	polja[x][y]=Polje::Posjeceno;
	for(int i=0;i&lt;polja.size();i++){
		for(int j=0;j&lt;polja[i].size();j++){
			bool kraj;
			kraj= (polja[i][j]!=Polje::Posjeceno and polja[i][j]!=Polje::Mina);
			if(kraj)
				return Status::NijeKraj;
		}
	}
	return Status::KrajPobjeda;
}
void PrijaviGresku(KodoviGresaka greska){
	if(greska==KodoviGresaka::PogresnaKomanda) cout&lt;&lt;"Nerazumljiva komanda!\n";
	else if(greska==KodoviGresaka::NedostajeParametar) cout&lt;&lt;"Komanda trazi parametar koji nije naveden!\n";
	else if(greska==KodoviGresaka::NeispravanParametar) cout&lt;&lt;"Parametar komande nije ispravan!\n";
	else if(greska==KodoviGresaka::SuvisanParametar) cout&lt;&lt;"Zadan je suvisan parametar nakon komande!\n";
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	string s;
	getline(cin,s);
	while(s.length()!=0 and s[0]==' ') s.erase(s.begin()+0);
	while(s.length()!=0 and s[s.length()-1]==' ') s.erase(s.begin()+s.length()-1);
	if(!s.length()) {
		greska=KodoviGresaka::PogresnaKomanda;
		return false;
	}
	if(!Slovo(s[0])){
		greska=KodoviGresaka::PogresnaKomanda;
		return false;
	}
	if(s=="K"){
		komanda=Komande::KreirajIgru;
		return true;
	}
	if(s[0]=='K' and s.length()!=1){
		greska=KodoviGresaka::SuvisanParametar;
		return false;
	}
	if(s=="Z"){
		komanda=Komande::ZavrsiIgru;
		return true;
	}
	if(s=="PO"){
		komanda=Komande::PrikaziOkolinu;
		return true;
	}
	if(s[0]=='D'){
		while(s.length()!=1 and s[1]==' ') s.erase(s.begin()+1);
		if(s.length()&lt;3) {
			greska=KodoviGresaka::NedostajeParametar;
			return false;
		}
		if(s[1]!='-' and !Broj(s[1])) {
			greska=KodoviGresaka::NeispravanParametar;
			return false;
		}
		if(!Broj(s[s.length()-1])) {
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}
		int i=1;
		bool negativan;
		negativan=s[1]=='-';
		int duzina(0);
		if(negativan){
			i++;
			duzina++;
		}
		while(Broj(s[i])){
			i++;
			duzina++;
		}
		string a=s.substr(1,duzina);
		x=std::stoi(a);
		auto pomoc=i+1;
		if(!Broj(s[pomoc]) and s[pomoc]!='-') {
			greska=KodoviGresaka::NeispravanParametar;
			return false;
		}
		negativan=s[i+1]=='-';
		i=i+1;
		duzina=0;
		if(negativan){
			i++;
			duzina++;
		}
		while(Broj(s[i])){
			i++;
			duzina++;
		}
		if(pomoc+duzina!=s.length()){
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}
		a=s.substr(pomoc,duzina);
		y=std::stoi(a);
		komanda=Komande::Deblokiraj;
		return true;
	}
	if(s[0]=='B') {
		while(s.length()!=1 and s[1]==' ') s.erase(s.begin()+1);
		if(s.length()&lt;3) {
			greska=KodoviGresaka::NedostajeParametar;
			return false;
		}
		if(s[1]!='-' and !Broj(s[1])) {
			greska=KodoviGresaka::PogresnaKomanda;
			return false;
		}
		if(!Broj(s[s.length()-1])) {
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}
		int i=1;
		bool negativan;
		negativan=s[1]=='-';
		int duzina(0);
		if(negativan){
			i++;
			duzina++;
		}
		while(Broj(s[i])) {
			i++;
			duzina++;
		}
		string a=s.substr(1,duzina);
		x=std::stoi(a);
		auto pomoc=i+1;
		if(!Broj(s[pomoc]) and s[pomoc]!='-') {
			greska=KodoviGresaka::PogresnaKomanda;
			return false;
		}
		negativan=s[i+1]=='-';
		i=i+1;
		duzina=0;
		if(negativan){
			i++;
			duzina++;
		}
		while(Broj(s[i])){
			i++;
			duzina++;
		}
		if(pomoc+duzina!=s.length()){
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}
		a=s.substr(pomoc,duzina);
		y=std::stoi(a);
		komanda=Komande::Blokiraj;
		return true;
	}
	if(s[0]=='P' and s[1]=='&gt;'){
		while(s.length()!=2 and s[2]==' ') s.erase(s.begin()+2);
		if(s.length()&lt;4)
		{
			greska=KodoviGresaka::NedostajeParametar;
			return false;
		}
		if(s[2]!='-' and !Broj(s[2])){
			greska=KodoviGresaka::NeispravanParametar;
			return false;
		}
		if(!Broj(s[s.length()-1])){
			greska=KodoviGresaka::NeispravanParametar;
			return false;
		}
		int i=2;
		bool negativan;
		negativan=s[2]=='-';
		int duzina(0);
		if(negativan){
			i++;
			duzina++;
		}
		while(Broj(s[i])){
			i++;
			duzina++;
		}
		string a=s.substr(2,duzina);
		x=std::stoi(a);
		auto pomoc=i+1;
		if(!Broj(s[pomoc]) and s[pomoc]!='-'){
			greska=KodoviGresaka::PogresnaKomanda;
			return false;
		}
		negativan=s[i+1]=='-';
		i=i+1;
		duzina=0;
		if(negativan){
			i++;
			duzina++;
		}
		while(Broj(s[i])){
			i++;
			duzina++;
		}
		if(pomoc+duzina!=s.length()){
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}
		a=s.substr(pomoc,duzina);
		y=std::stoi(a);
		komanda=Komande::PomjeriDalje;
		return true;
	}
	if(s[0]=='P' and s[1]=='1'){
		while(s.length()!=2 and s[2]==' ')
			s.erase(s.begin()+2);
		if(s.length()&lt;3){
			greska=KodoviGresaka::NedostajeParametar;
			return false;
		}
		if(!Slovo(s[2])){
			greska=KodoviGresaka::NeispravanParametar;
			return false;
		}
		if(s.length()&gt;5){
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}
		if(s[2]=='G'){
			if(s[3]=='L'){
				smjer=Smjerovi::GoreLijevo;
				komanda=Komande::PomjeriJednoMjesto;
				return true;
			}
			else if(s[3]=='D'){
				smjer=Smjerovi::GoreDesno;
				komanda=Komande::PomjeriJednoMjesto;
				return true;
			}
			else if(s.length()==3){
				smjer=Smjerovi::Gore;
				komanda=Komande::PomjeriJednoMjesto;
				return true;
			}
		}
		if(s[2]=='L' and s.length()==3){
			smjer=Smjerovi::Lijevo;
			komanda=Komande::PomjeriJednoMjesto;
			return true;
		}
		if(s[2]=='D'){
			if(s[3]=='o'){
				if(s[4]=='D'){
					smjer=Smjerovi::DoljeDesno;
					komanda=Komande::PomjeriJednoMjesto;
					return true;
				}
				if(s[4]=='L'){
					smjer=Smjerovi::DoljeLijevo;
					komanda=Komande::PomjeriJednoMjesto;
					return true;
				}
				if(s.length()==4){
					smjer=Smjerovi::Dolje;
					komanda=Komande::PomjeriJednoMjesto;
					return true;
				}
			}
			if(s.length()==3){
				smjer=Smjerovi::Desno;
				komanda=Komande::PomjeriJednoMjesto;
				return true;
			}
		}
		if(s[2]=='L' and s.length()==3){
			smjer=Smjerovi::Lijevo;
			komanda=Komande::PomjeriJednoMjesto;
			return true;
		}
	}
	greska=KodoviGresaka::PogresnaKomanda;
	return false;
}
void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0){
	Status f=Status::NijeKraj;
	if(komanda==Komande::PomjeriJednoMjesto) {
		f=Idi(polja,x,y,p_smjer);
		if(f==Status::KrajPobjeda){
			cout&lt;&lt;"Bravo, obisli ste sva sigurna polja\n";
			komanda=Komande::ZavrsiIgru;
		}
		else if(f==Status::KrajPoraz){
			cout&lt;&lt;"Nagazili ste minu\n";
			komanda=Komande::ZavrsiIgru;
		}
		else cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")\n";
	}
	if(komanda==Komande::PomjeriDalje) {
		f=Idi(polja,x,y,p_x,p_y);
		if(f==Status::KrajPobjeda) {
			cout&lt;&lt;"Bravo, obisli ste sva sigurna polja\n";
			komanda=Komande::ZavrsiIgru;
		}
		if(f==Status::KrajPoraz) {
			cout&lt;&lt;"Nagazili ste minu\n";
			komanda=Komande::ZavrsiIgru;
		}
		else cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")\n";
	}
	if(komanda==Komande::Blokiraj) BlokirajPolje(polja,p_x,p_y);
	if(komanda==Komande::Deblokiraj) DeblokirajPolje(polja,p_x,p_y);
	if(komanda==Komande::PrikaziOkolinu) {
		auto frk=PrikaziOkolinu(polja,x,y);
		for(auto a:frk) {
			for(auto b:a)
				cout&lt;&lt;b&lt;&lt;" ";
			cout&lt;&lt;"\n";
		}
	}
	if(komanda==Komande::ZavrsiIgru) {
		for(int i=0;i&lt;polja.size();i++)
			for(int j=0;j&lt;polja[i].size();j++)
				polja[i][j]=Polje::Prazno;
		throw std::runtime_error("Igra zavrsena");
	}
	if(komanda==Komande::KreirajIgru) {
		cout&lt;&lt;"Unesite broj polja: ";
		int t;
		cin&gt;&gt;t;
		while(!cin) {
			cout&lt;&lt;"Greska, unesite ponovo!\n";
			cin.clear();
			cin.ignore(10000,'\n');
			cin&gt;&gt;t;
		}
		cin.ignore(10000,'\n');
		Matrica mine;
		cout&lt;&lt;"Unesite pozicije mina: ";
		int j=0;
		for(;;)
		{
			if(cin.peek()=='.') {
				cin.ignore(10000,'\n'); break;
			}
			string o;
			getline(cin,o);
			if(o.length()&lt;5) {
				cout&lt;&lt;"Greska, unesite ponovo!\n"; continue;
			}
			if(o[0]!='(' or (!Broj(o[1]) and o[1]!='-') or o[o.length()-1]!=')') {
				cout&lt;&lt;"Greska, unesite ponovo!\n"; continue;
			}
			bool negativan=false;
			if(o[0]=='-' and Broj(o[1])) negativan=true;
			if(o[0]=='-' and !Broj(o[1])) {
				cout&lt;&lt;"Greska, unesite ponovo!\n"; continue;
			}
			int duzina=0;
			int i=1;
			if(negativan) {
				i++;
				duzina++;
			}
			while(Broj(o[i])) {
				i++;
				duzina++;
			}
			if(o[i]!=',') {
				cout&lt;&lt;"Greska, unesite ponovo!\n"; continue;
			}
			auto r=o.substr(1,duzina);
			auto a=std::stoi(r);
			duzina=0;
			i++;
			if(o[i]=='-' and Broj(o[i+1])) negativan=true;
			if(o[0]=='-' and !Broj(o[i+1])) {
				cout&lt;&lt;"Greska, unesite ponovo!\n"; continue;
			}
			auto pomoc=i;
			if(negativan){
				i++;
				duzina++;
			}
			while(Broj(o[i])){
				i++;
				duzina++;
			}
			if(o[i]!=')') {
				cout&lt;&lt;"Greska, unesite ponovo!\n"; continue;
			}
			r=o.substr(pomoc,duzina);
			auto b=std::stoi(r);
			if(a&lt;0 or a&gt;=t or b&lt;0 or b&gt;=t) {
				cout&lt;&lt;"Greska, unesite ponovo!\n";
				continue;
			}
			if(a==0 and b==0) {
				cout&lt;&lt;"Greska, unesite ponovo!\n"; continue;
			}
			j++;
			mine.resize(j);
			mine[j-1].push_back(a);
			mine[j-1].push_back(b);
		}
		try	{
			polja=KreirajIgru(t,mine);
		}
		catch(std::domain_error e) {
			cout&lt;&lt;e.what();
		}
	}
}

int main () {
	Smjerovi smjer;
	Komande komanda;
	KodoviGresaka greska;
	int x=0;
	int y=0;
	int p_x=0;
	int p_y=0;;
	Tabla polja;
	try {
		for(;;) {
			try {
				cout&lt;&lt;"Unesite komandu: ";
				bool mo=UnosKomande(komanda,smjer,p_x,p_y,greska);
				if(mo){
					IzvrsiKomandu(komanda,polja,x,y,smjer,p_x,p_y);
				}
				else {
					PrijaviGresku(greska);
				}
			}
			catch(std::domain_error e) {
				cout&lt;&lt;e.what(); continue;
			}
			catch(std::out_of_range e) {
				cout&lt;&lt;e.what(); continue;
			}
			catch(std::logic_error e) {
				cout&lt;&lt;e.what(); continue;
			}
		}
	}
	catch(std::runtime_error) { cout&lt;&lt;"Dovidjenja!\n"; }
	return 0;
}</pre>
</body>
</html>
