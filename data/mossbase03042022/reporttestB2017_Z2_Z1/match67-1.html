<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4011.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student3116.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;


<a name="0"></a><font color="#FF0000"><a href="match67-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;

enum class Polje {
 Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;


Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{   
	if(n&lt;=0) throw domain_error("Ilegalna velicina");
	Tabla t(n,vector&lt;Polje&gt;(n));
	
	
	for(int i=0;i&lt;mine.size();i++)
		if(mine[i].size()!=2) throw domain_error("Ilegalan format zadavanja mina");
	
	for(int i=0;i&lt;mine.size();i++)
		for(int j=0;j&lt;mine[i].size();j++)
			if(mine[i][j]&gt;n || mine[i][j]&lt;0) throw domain_error("Ilegalne pozicije mina");
	
	for(int i=0;i&lt;mine.size();i++)
	{
		t[mine[i][0]][mine[i][1]]=(Polje)2;
	}
	
	return t;
}


int SaberiSusjede(const Tabla &amp;polja,int x,int y)
{   
	int suma=0;
	
	if(x&gt;0 &amp;&amp; x&lt;polja.size()-1 &amp;&amp; y&gt;0 &amp;&amp; y&lt;polja[0].size()-1)
	{    
	
	      for(int i=x-1;i&lt;=x+1;i++)
	      	for(int j=y-1;j&lt;=y+1;j++)
	      		if(i==x &amp;&amp; j==y) continue;
	      		else if((int)polja[i][j]==2) 
	      			suma++;
	      	
	}
	else if(x==0)
	{
		if(y==0)
		{
			for(int i=0;i&lt;=x+1;i++)
				for(int j=0;j&lt;=y+1;j++)
					if(i==x &amp;&amp; j==y) continue;
	      			else if((int)polja[i][j]==2) 
	      					suma++;
		}	
		else if (y==polja[0].size()-1)
		{
			for(int i=0;i&lt;=x+1;i++)
				for(int j=polja[0].size()-1;j&gt;=polja[0].size()-2;j--)
					if(i==x &amp;&amp; j==y) continue;
	      			else if((int)polja[i][j]==2) 
	      					suma++;
		}
		else if(y&gt;0 &amp;&amp; y&lt;polja[0].size()-1)
		{
			for(int i=0;i&lt;=x+1;i++)
				for(int j=0;j&lt;=y+1;j++)
					if(i==x &amp;&amp; j==y) continue;
	      			else if((int)polja[i][j]==2) 
	      					suma++;
		}
		
	}
	else if(x==polja.size()-1)
	{
		if(y==0)
		{
			for(int i=polja.size()-1;i&gt;=polja.size()-2;i--)
				for(int j=0;j&lt;=y+1;j++)
					if(i==x &amp;&amp; j==y) continue;
	      			else if((int)polja[i][j]==2) 
	      					suma++;
		}	
		else if (y==polja[0].size()-1)
		{
			for(int i=polja.size()-1;i&gt;=polja.size()-2;i--)
				for(int j=polja[0].size()-1;j&gt;=polja[0].size()-2;j--)
					if(i==x &amp;&amp; j==y) continue;
	      			else if((int)polja[i][j]==2) 
	      					suma++;
		}
		else if(y&gt;0 &amp;&amp; y&lt;polja[0].size()-1)
		{
			for(int i=polja.size()-1;i&gt;=polja.size()-2;i--)
				for(int j=0;j&lt;=y+1;j++)
					if(i==x &amp;&amp; j==y) continue;
	      			else if((int)polja[i][j]==2) 
	      					suma++;
		}
	}
	else if(y==0)
	{
		if(x&gt;0 &amp;&amp; x&lt;polja.size()-1)
		{
		    for(int i=x-1;i&lt;=x+1;i++)
		    {
		    	for(int j=y;j&lt;=y+1;j++)
		    			if(i==x &amp;&amp; j==y) continue;
	      				else if((int)polja[i][j]==2) 
	      					suma++;
		    }
		}
	}
	else if(y==polja[0].size()-1)
	{
		if(x&gt;0 &amp;&amp; x&lt;polja.size()-1)
		{
			for(int i=x-1;i&lt;=x+1;i++)
			{
				for(int j=y;j&gt;=y-1;j--)
					if(i==x &amp;&amp; j==y) continue;
	      			else if((int)polja[i][j]==2) 
	      					suma++;
			}
		}
	}
	
	
	return suma;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{   
	if(x&lt;0 || y&lt;0 || x&gt;polja.size()-1 || y&gt;polja[0].size()-1){string s;s="Polje (";s.push_back(x+'0');s.push_back(',');s.push_back(y+'0');s+=") ne postoji"; throw domain_error(s);}//dodaj x,y u izuzetak!!!!
	vector&lt;vector&lt;int&gt;&gt; o(3,vector&lt;int&gt;(3));
	
	for(int i=x-1;i&lt;=x+1;i++)
	{
		for(int j=y-1;j&lt;=y+1;j++)
		{
			if(i&gt;=0 &amp;&amp; j&gt;=0 &amp;&amp; i&lt;polja.size() &amp;&amp; j&lt;polja[0].size())
				o[fabs(x-i-1)][fabs(y-j-1)]=SaberiSusjede(polja,i,j);
			
		}
	}
	return o;

}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 || y&lt;0 || x&gt;polja.size()-1 || y&gt;polja[0].size()-1){string s;s="Polje (";s.push_back(x+'0');s.push_back(',');s.push_back(y+'0');s+=") ne postoji"; throw domain_error(s);}//dodaj x,y u izuzetak!!!!	
	 
	if((int)polja[x][y]&lt;=3)
		polja[x][y]=(Polje)((int)polja[x][y]+3);
	
	
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 || y&lt;0 || x&gt;polja.size()-1 || y&gt;polja[0].size()-1){string s;s="Polje (";s.push_back(x+'0');s.push_back(',');s.push_back(y+'0');s+=") ne postoji"; throw domain_error(s);}//dodaj x,y u izuzetak!!!!
	
	if((int)polja[x][y]&gt;=3 &amp;&amp; (int)polja[x][y]&lt;6)
		polja[x][y]=(Polje)((int)polja[x][y]-3);
	
}

enum class Smjerovi {
 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};


Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{   	
	
	
		//if(x-1&lt;0 || y-1&lt;0 || x+1&gt;polja.size()-1 || y+1&gt;polja.size()-1) throw out_of_range("Izlazak van igrace table");//Postavi izuzetak prekoracenja x,y
		switch((int)smjer)
		{
			case 0:
			if(x-1&lt;0 || y-1&lt;0)  throw out_of_range("Izlazak van igrace table");
			if((int)polja[x-1][y-1]&gt;=3) throw logic_error("Blokirano polje");
			polja[x][y]=(Polje)1;
			x=x-1;y=y-1;
			if((int)polja[x][y]==2) return Status::KrajPoraz;
			
			break;
			
			case 1:
			if(x-1&lt;0)  throw out_of_range("Izlazak van igrace table");
			if((int)polja[x-1][y]&gt;=3) throw logic_error("Blokirano polje");
			polja[x][y]=(Polje)1;
			x=x-1;
			if((int)polja[x][y]==2) return Status::KrajPoraz;
			
			break;
			
			case 2:
			if(x-1&lt;0 || y+1&gt;polja.size()-1)  throw out_of_range("Izlazak van igrace table");
			if((int)polja[x-1][y+1]&gt;=3) throw logic_error("Blokirano polje");
			polja[x][y]=(Polje)1;
			x=x-1;y=y+1;
			if((int)polja[x][y]==2) return Status::KrajPoraz;
	    	break;
			
			case 3:
			if(y+1&gt;polja.size()-1)  throw out_of_range("Izlazak van igrace table");
			if((int)polja[x][y+1]&gt;=3) throw logic_error("Blokirano polje");
			polja[x][y]=(Polje)1;
			y=y+1;
			if((int)polja[x][y]==2) return Status::KrajPoraz;
			break;
			
			case 4:
			if(x+1&gt;polja.size()-1 || y+1&gt;polja.size()-1)  throw out_of_range("Izlazak van igrace table");
			if((int)polja[x+1][y+1]&gt;=3) throw logic_error("Blokirano polje");
			polja[x][y]=(Polje)1;
			x=x+1;y=y+1;
			if((int)polja[x][y]==2) return Status::KrajPoraz;
			break;
			
			case 5:
			if(x+1&gt;polja.size()-1)  throw out_of_range("Izlazak van igrace table");
			if((int)polja[x+1][y]&gt;=3) throw logic_error("Blokirano polje");
			polja[x][y]=(Polje)1;
			x=x+1;
			if((int)polja[x][y]==2) return Status::KrajPoraz;
			break;
			
			case 6:
			if(x+1&gt;polja.size()-1 || y-1&lt;0)  throw out_of_range("Izlazak van igrace table");
			if((int)polja[x+1][y-1]&gt;=3) throw logic_error("Blokirano polje");
			polja[x][y]=(Polje)1;
			x=x+1;y=y-1;
			if((int)polja[x][y]==2) return Status::KrajPoraz;
			break;
			
			case 7:
			if(y-1&lt;0)  throw out_of_range("Izlazak van igrace table");
			if((int)polja[x][y-1]&gt;=3) throw logic_error("Blokirano polje");
			polja[x][y]=(Polje)1;
			y=y-1;
			if((int)polja[x][y]==2) return Status::KrajPoraz;
			break;
			
		}

		
		return Status::NijeKraj;
}


Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if(novi_y&lt;0 || novi_y&gt;polja.size()-1 || novi_x&lt;0 || novi_x&gt;polja.size()-1) throw out_of_range("Izlazak van igrace table");
	if((int)polja[x][y]&gt;3) throw logic_error("Blokirano polje");
	
	if(polja[x][y]==Polje::Mina) return Status::KrajPoraz;	
	x=novi_x;y=novi_y;
	
	if((int)polja[x][y]&lt;2) //polja[x][y]=Polje::BlokiranoPosjeceno;
	  polja[x][y]=(Polje)1;
	
	return Status::NijeKraj;
}

enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

void PrijaviGresku(KodoviGresaka greska)
{
	switch((int)greska)
	{
		case 0:
			cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;endl;
			break;
		case 1:
			cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;endl;
			break;
		case 2:
			cout&lt;&lt;"Parametar komande nije ispravan!"&lt;&lt;endl;
			break;
		case 3:
			cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;endl;
			break;
	}
}

enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{	
	string c;
	
	cin&gt;&gt;c;
	

		if(c[0]=='P')
		{
			if(c[1]=='1')
			{   
				komanda=Komande::PomjeriJednoMjesto;
				return true;
				
			}
			else if(c[1]=='&gt;')
			{	
				komanda=Komande::PomjeriDalje;
				cin&gt;&gt;x&gt;&gt;y;
				return true;
			}
			else if(c[1]=='O')
			{
				komanda=Komande::PrikaziOkolinu;
				return true;
			}
			
		}
		else if(c[0]=='B')
		{  
			komanda=Komande::Blokiraj;
			cin&gt;&gt;x&gt;&gt;y;
			return true;
		}
		else if(c[0]=='D')
		{
			komanda=Komande::Deblokiraj;
			cin&gt;&gt;x&gt;&gt;y;
			return true;
		}
		else if(c[0]=='Z')
		{
			komanda=Komande::ZavrsiIgru;
			return true;
		}
		else if(c[0]=='K')
		{  
			komanda=Komande::KreirajIgru;
			return true;
		}		
		else
		{
			   	greska=(KodoviGresaka)0;
				 return false;	
		}
	
	return false;
	
}



void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0)
{
	switch((int)komanda)
	{
		case 0:
			Idi(polja,x,y,p_smjer);
			break;
		case 1:
		//	cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;" "&lt;&lt;p_x&lt;&lt;" "&lt;&lt;p_y;
			Idi(polja,x,y,p_x,p_y);//cout&lt;&lt;(int)polja[x][y];
			if((int)polja[x][y]==2) cout&lt;&lt;"Mina"&lt;&lt;endl;
			else if((int)polja[x][y]&gt;2 &amp;&amp; (int)polja[x][y]&lt;7) cout&lt;&lt;"Blokirano polje"&lt;&lt;endl;
			else cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;endl;
			break;
		case 2:
			BlokirajPolje(polja,x,y);
			//cout&lt;&lt;(int)polja[x][y];
			break;
		case 3:
			DeblokirajPolje(polja,x,y);
			break;
		case 4:
			PrikaziOkolinu(polja,x,y);
			break;
		case 5:
			//ZavrsiIgru
			break;
		case 6:
			cout&lt;&lt;"Unesite broj polja: ";
			int n;
			cin&gt;&gt;n;
			cout&lt;&lt;"Unesite pozicije mina: ";
			vector&lt;vector&lt;int&gt;&gt; mine;
			for(;;)
			{
				string s;
				cin&gt;&gt;s;vector&lt;int&gt; v;
				
				if(s.size()==1 &amp;&amp; s[0]=='.')break;
				
				for(int i=0;i&lt;s.size();i++)
				{	
					if(s[i]=='(' || s[i]==',')
					{
						i++;int broj=0;
						while(s[i]&gt;='0' &amp;&amp; s[i]&lt;='9')
						{
							 broj=broj*10+(s[i]-'0');
							 i++;
						}
						v.push_back(broj);
					}
					if(s[i]==',')i--;
				}
				
				mine.push_back(v);
			}
			
			polja=KreirajIgru(n,mine);
			break;
	}
}


void ispisiTablu(std::vector&lt;std::vector&lt;Polje&gt;&gt; polja){
   for(int i = 0; i &lt; polja.size(); i++) {
          for(int j = 0; j &lt; polja[i].size(); j++) std::cout &lt;&lt; int(polja[i][j]) &lt;&lt; " ";
          std::cout &lt;&lt; std::endl;
        }
}

int main ()
{	
	/*
	Komande komanda;
		Smjerovi smjer;
		int x=0,y=0;Tabla polja;
		KodoviGresaka greska;
		
	for(;;)
	{   
	
		cout&lt;&lt;"Unesite komandu: ";
		if(UnosKomande(komanda,smjer,x,y,greska))
		{	if((int)komanda==5){ cout&lt;&lt;"Dovidjenja!"; return 0;}
			IzvrsiKomandu(komanda,polja,x,y,smjer,x,y);
		}
		
	}*/
	
  int x = 0, y = 0;
 std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla;
  IzvrsiKomandu(Komande::KreirajIgru, tabla, x, y);
  ispisiTablu(tabla);
  IzvrsiKomandu(Komande::KreirajIgru, tabla, x, y);
  ispisiTablu(tabla);
  IzvrsiKomandu(Komande::KreirajIgru, tabla, x, y);
</font>
    
	return 0;
}</pre>
</body>
</html>
