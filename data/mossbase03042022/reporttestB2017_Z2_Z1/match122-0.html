<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student8705.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student8705.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
<a name="0"></a><font color="#FF0000"><a href="match122-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using std::vector;
using std::string;
using std::cin;

enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
typedef vector&lt;vector&lt;Polje&gt;&gt; Tabla;
enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
enum class Komande
{
    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};
template &lt;typename T&gt; string int_str(T x)
{
	std::ostringstream s; s &lt;&lt; x; return s.str();
}
Tabla KreirajIgru(int n, const vector&lt;vector&lt;int&gt;&gt; &amp;mine)
{
	for (const vector&lt;int&gt; &amp;v : mine)
		if (v.size() != 2) throw std::domain_error("Ilegalan format zadavanja mina");
	if (n &lt;= 0) throw std::domain_error("Ilegalna velicina");
	for (const vector&lt;int&gt; &amp;v : mine)
		if (v.at(0) &lt; 0 || v.at(1) &lt; 0 || v.at(0) &gt;= n || v.at(1) &gt;= n) throw std::domain_error("Ilegalne pozicije mina");
	Tabla t(n, vector&lt;Polje&gt;(n, Polje::Prazno));
	for (const vector&lt;int&gt; &amp;v : mine)
		t.at(v.at(0)).at(v.at(1)) = Polje::Mina;
	return t;
}
vector&lt;vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
	if (x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.at(0).size())
		throw std::domain_error("Polje (" + int_str(x) + ',' + int_str(y) + ") ne postoji");
	vector&lt;vector&lt;int&gt;&gt; mat(3, vector&lt;int&gt;(3));
	for (int i(0); i &lt; 3; i++)
		for (int j(0); j &lt; 3; j++)
			for (int k(x+i-2); k &lt;= x+i; k++)
				for (int l(y+j-2); l &lt;= y+j; l++)
					if ((k != x+i-1 || l != y+j-1) &amp;&amp; 0 &lt;= k &amp;&amp; k &lt; polja.size()
					&amp;&amp; 0 &lt;= l &amp;&amp; l &lt; polja.at(k).size() &amp;&amp; polja.at(k).at(l) == Polje::Mina) mat.at(i).at(j)++;
	return mat;
}
void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if (x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.at(0).size())
		throw std::domain_error("Polje (" + int_str(x) + ',' + int_str(y) + ") ne postoji");
	if (int(polja.at(x).at(y)) &lt; 3) polja.at(x).at(y) = Polje(int(polja.at(x).at(y))+3);
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
	if (x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.at(0).size())
		throw std::domain_error("Polje (" + int_str(x) + ',' + int_str(y) + ") ne postoji");
	if (int(polja.at(x).at(y)) &gt;= 3) polja.at(x).at(y) = Polje(int(polja.at(x).at(y))-3);
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if (novi_x &lt; 0 || novi_y &lt; 0 || novi_x &gt;= polja.size() || novi_y &gt;= polja.at(0).size())
		throw std::out_of_range("Izlazak van igrace table");
	if (int(polja.at(novi_x).at(novi_y)) &gt;= 3) throw std::logic_error("Blokirano polje");
	polja.at(x).at(y) = Polje::Posjeceno;
	if (polja.at(x = novi_x).at(y = novi_y) == Polje::Mina)
	{
		polja = Tabla(polja.size(), vector&lt;Polje&gt;(polja.at(0).size(), Polje::Prazno));
		return Status::KrajPoraz;
	}
	for (const auto &amp;v : polja)
		for (const Polje &amp;q : v)
			if (q == Polje::Prazno &amp;&amp; (&amp;polja.at(x).at(y) != &amp;q)) return Status::NijeKraj;
	return Status::KrajPobjeda;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
	int _y[] {-1, 0, 1, 1, 1, 0, -1, -1};
	return Idi(polja, x, y, x + ((int(smjer)+1) % 4 != 0) * (int(smjer) &lt; 4 ? -1 : 1), y + _y[int(smjer)]);
}
void PrijaviGresku(KodoviGresaka kod)
{
	char ispisi[4][42]{"Nerazumljiva komanda", "Komanda trazi parametar koji nije naveden",
        "Zadan je suvisan parametar nakon komande", "Parametar komande nije ispravan"};
	std::cout &lt;&lt; ispisi[int(kod)] &lt;&lt; "!\n";
}
bool ukloni() {	return cin.get() || true; }
bool procitaj(char c) { return cin.peek() == c &amp;&amp; ukloni(); }
bool cifra(char c) { return '0' &lt;= c &amp;&amp; c &lt;= '9'; }
bool ocisti()
{
	cin.clear();
	cin.ignore(10000, '\n');
	return false;
}
bool ucitaj_sa_razmakom(char c)
{
	while (procitaj(' '));
	return cin.peek() == c;
}
bool unos_koord(int &amp;x, int &amp;y)
{
	int c(cin.peek()), a, b;
	if (c == '\n') cin.get();
	if (!ucitaj_sa_razmakom('(')) return ocisti();
	cin.get();
	while ((c = cin.peek()) == ' ') cin.get();
	if (!cifra(c) || !(cin &gt;&gt; a) || !ucitaj_sa_razmakom(',')) return ocisti();
	cin.get();
	while ((c = cin.peek()) == ' ') cin.get();
	if (!cifra(c) || !(cin &gt;&gt; b) || !ucitaj_sa_razmakom(')')) return ocisti();
	cin.get();
	if (!ucitaj_sa_razmakom('\n')) return ocisti();
	x = a; y = b;
	return !ocisti();
}
bool samo_razmak()
{
	if (cin.peek() != ' ' &amp;&amp; cin.peek() != '\n') return false;
	while (procitaj(' ')); 
	return cin.peek() == '\n';
}
bool ucitaj_broj(int &amp;x)
{
	int y;
	if (cifra(cin.peek()) &amp;&amp; cin &gt;&gt; y &amp;&amp; (cin.peek() == '\n' || cin.peek() == ' ')) x = y;
	else return false;
	return true;
}
bool vrati_gresku(int gr, KodoviGresaka &amp;greska)
{
	greska = KodoviGresaka(gr);
	return ocisti();
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	int a, b, c;
	if (cin.peek() == '\n') return vrati_gresku(0, greska);
	if ((c = cin.get()) == ' ' &amp;&amp; cin.peek() != '\n') c = cin.get();
	if (c == 'K' || c == 'Z')
		if (!samo_razmak()) return vrati_gresku(2, greska);
		else komanda = c == 'K' ? Komande::KreirajIgru : Komande::ZavrsiIgru;
	else if (c == 'B' || c == 'D' || (c == 'P' &amp;&amp; procitaj('&gt;')))
		if (samo_razmak()) return vrati_gresku(1, greska);
		else if (ucitaj_broj(a) &amp;&amp; (samo_razmak() || cifra(cin.peek())) &amp;&amp; ucitaj_broj(b) &amp;&amp; samo_razmak())
		{
			komanda = c == 'B' ? Komande::Blokiraj : (c == 'D' ? Komande::Deblokiraj : Komande::PomjeriDalje);
			x = a; y = b;
		}
		else return vrati_gresku(3, greska);
	else if (c == 'P')
		if (procitaj('O'))
			if (!samo_razmak()) return vrati_gresku(2, greska);
			else komanda = Komande::PrikaziOkolinu;
		else if (procitaj('1'))
		{
			if (samo_razmak()) return vrati_gresku(1, greska);
			string s;
			cin &gt;&gt; s;
			string komande[]{"GL", "G", "GD", "D", "DoD", "Do", "DoL", "L"};
			if (samo_razmak())
				for (int i(0); i &lt; 8; i++)
					if (s == komande[i])
					{
						smjer = Smjerovi(i);
						komanda = Komande::PomjeriJednoMjesto;
						return !ocisti();
					}
			return vrati_gresku(3, greska);
		}
		else return vrati_gresku(0, greska);
	else return vrati_gresku(0, greska);
	return !ocisti();
}
void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0)
{
	try
	{
		Status st(Status::NijeKraj);
		if (int(komanda) &lt; 2)
		{
			st = komanda == Komande::PomjeriDalje ? Idi(polja, x, y, p_x, p_y) : Idi(polja, x, y, p_smjer);
			std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")\n";
			if (st == Status::KrajPobjeda) std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja\n";
			else if (st == Status::KrajPoraz) std::cout &lt;&lt; "Nagazili ste na minu\n";
		}
		if (st != Status::NijeKraj || komanda == Komande::ZavrsiIgru)
		{
			if (!polja.empty()) polja = Tabla(polja.size(), vector&lt;Polje&gt;(polja.at(0).size(), Polje::Prazno));
			throw std::runtime_error("Igra zavrsena");
		}
		switch (komanda)
		{
			case Komande::Blokiraj:
				BlokirajPolje(polja, p_x, p_y); break;
			case Komande::Deblokiraj:
				DeblokirajPolje(polja, p_x, p_y); break;
			case Komande::PrikaziOkolinu:
				for (const vector&lt;int&gt; &amp;v : PrikaziOkolinu(polja, x, y))
				{
					for (int x : v) std::cout &lt;&lt; x &lt;&lt; ' ';
					std::cout &lt;&lt; std::endl;
				}
				break;
			case Komande::KreirajIgru:
			{
				int n, _x(0), _y(0);
				std::cout &lt;&lt; "Unesite broj polja: ";
				while (!((cifra(cin.peek()) || procitaj(' ')) &amp;&amp; ucitaj_broj(n) &amp;&amp; samo_razmak() &amp;&amp; n &gt; 0)) 
				{
					std::cout &lt;&lt; "Greska, unesite ponovo!\nUnesite broj polja: ";
					ocisti();
				}
				ocisti();
				std::cout &lt;&lt; "Unesite pozicije mina: ";
				vector&lt;vector&lt;int&gt;&gt; mine;
				while (cin.peek() != '.')
					if (!unos_koord(_x, _y) || _x &lt; 0 || _y &lt; 0 || _x &gt;= n || _y &gt;= n || (_x == 0 &amp;&amp; _y == 0))
						std::cout &lt;&lt; "Greska, unesite ponovo!\n";
					else mine.push_back({_x, _y});
				polja = KreirajIgru(n, mine);
				ocisti();
			}
			default: break;
		}
	}
	catch (std::runtime_error e) { throw; }
	catch (const std::exception &amp;e) { std::cout &lt;&lt; e.what() &lt;&lt; '\n'; }
}
int main()
{
	try
	{
		Komande kom;
		Smjerovi smjer;
		Tabla tabla;
		int x(0), y(0), _x(0), _y(0);
		KodoviGresaka greska;
		for (;;)
			try
			{
				std::cout &lt;&lt; "Unesite komandu: ";
				if (UnosKomande(kom, smjer, _x, _y, greska)) IzvrsiKomandu(kom, tabla, x, y, smjer, _x, _y);
				else PrijaviGresku(greska);
			}
			catch (std::logic_error e) { std::cout &lt;&lt; e.what() &lt;&lt; std::endl; }
			catch (...) { throw; }
	}
	catch (...) { std::cout &lt;&lt; "Dovidjenja!"; }
</font>	return 0;
}</pre>
</body>
</html>
