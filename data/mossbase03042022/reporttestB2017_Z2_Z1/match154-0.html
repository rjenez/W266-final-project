<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4659.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4659.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

<a name="0"></a><font color="#FF0000"><a href="match154-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;

enum class Polje {
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi {
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
    NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
    PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar
};

typedef vector&lt;vector&lt;Polje&gt;&gt; Tabla;

Status TrenutniStatus(Tabla t, int x, int y) {
	if(t.at(x).at(y) == Polje::Mina)
		return Status::KrajPoraz;
		
	for(int i=0; i&lt;t.size(); i++) 
		for(int j=0; j&lt;t.size(); j++) 
			if(i != x &amp;&amp; j != y &amp;&amp; t.at(i).at(j) != Polje::Posjeceno &amp;&amp; t.at(i).at(j) != Polje::Mina)
				return Status::NijeKraj;
		
	return Status::KrajPobjeda;
}	

bool BlokiranoPolje(Tabla t, int x, int y) {
	if(t.at(x).at(y) == Polje::BlokiranoPrazno || t.at(x).at(y) == Polje::BlokiranoPosjeceno || t.at(x).at(y) == Polje::BlokiranoMina)
		return true;
		
	return false;
}

Tabla KreirajIgru(int n, const vector&lt;vector&lt;int&gt;&gt; &amp;mine) {
	if(n &lt;= 0)
		throw domain_error("Ilegalna velicina");
		
	for(int i=0; i&lt;mine.size(); i++) {
		if(mine.at(i).size() != 2)
			throw domain_error("Ilegalan format zadavanja mina");
		if(mine.at(i).at(0) &gt;= n || mine.at(i).at(0) &lt; 0 || mine.at(i).at(1) &gt;= n || mine.at(i).at(1) &lt; 0)
			throw domain_error("Ilegalne pozicije mina");
	}
		
	Tabla t(n);
	
	for(int i=0; i&lt;n; i++)
		t.at(i).resize(n);
		
	for(int i=0; i&lt;n; i++)
		for(int j=0; j&lt;n; j++)
			t.at(i).at(j) = Polje::Prazno;
	
	for(int i=0; i&lt;mine.size(); i++) {
		t.at(mine.at(i).at(0)).at(mine.at(i).at(1)) = Polje::Mina;
	}
	
	return t;
}

void IspisiTablu(Tabla t){
	for(int i=0; i&lt;t.size(); i++) {
		for(int j=0; j&lt;t.at(0).size(); j++) {
			if(t.at(i).at(j) == Polje::Prazno)
				cout &lt;&lt; "0 ";
			else
				cout &lt;&lt; "1 ";
		}
		
		cout &lt;&lt; endl;
	}
}

std::vector&lt;vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y);

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size())
		throw domain_error("Polje (x,y) ne postoji");
		
	if(polja.at(x).at(y) == Polje::Prazno)
		polja.at(x).at(y) == Polje::BlokiranoPrazno;
	else if(polja.at(x).at(y) == Polje::Mina)
		polja.at(x).at(y) == Polje::BlokiranoMina;
	else if(polja.at(x).at(y) == Polje::Posjeceno)
		polja.at(x).at(y) == Polje::BlokiranoPosjeceno;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size())
		throw domain_error("Polje (x,y) ne postoji");
		
	if(polja.at(x).at(y) == Polje::BlokiranoPrazno)
		polja.at(x).at(y) == Polje::Prazno;
	else if(polja.at(x).at(y) == Polje::BlokiranoMina)
		polja.at(x).at(y) == Polje::Mina;
	else if(polja.at(x).at(y) == Polje::BlokiranoPosjeceno)
		polja.at(x).at(y) == Polje::Posjeceno;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	if(((smjer == Smjerovi::Gore || smjer == Smjerovi::GoreDesno || smjer == Smjerovi::GoreLijevo) &amp;&amp; y == 0) ||
		((smjer == Smjerovi::Dolje || smjer == Smjerovi::DoljeDesno || smjer == Smjerovi::DoljeLijevo) &amp;&amp; y == polja.size() - 1) ||
		((smjer == Smjerovi::Lijevo || smjer == Smjerovi::GoreLijevo || smjer == Smjerovi::DoljeLijevo) &amp;&amp; x == 0) ||
		((smjer == Smjerovi::Desno || smjer == Smjerovi::GoreDesno || smjer == Smjerovi::DoljeDesno) &amp;&amp; x == polja.size() - 1))
			throw out_of_range("Izlazak van igrace table");
			
	if((smjer == Smjerovi::Gore &amp;&amp; BlokiranoPolje(polja, x, y - 1)) ||
		(smjer == Smjerovi::Dolje &amp;&amp; BlokiranoPolje(polja, x, y + 1)) ||
		(smjer == Smjerovi::Lijevo &amp;&amp; BlokiranoPolje(polja, x - 1, y)) ||
		(smjer == Smjerovi::Desno &amp;&amp; BlokiranoPolje(polja, x + 1, y)) ||
		(smjer == Smjerovi::GoreLijevo &amp;&amp; BlokiranoPolje(polja, x - 1, y - 1)) ||
		(smjer == Smjerovi::GoreDesno &amp;&amp; BlokiranoPolje(polja, x + 1, y - 1)) ||
		(smjer == Smjerovi::DoljeLijevo &amp;&amp; BlokiranoPolje(polja, x - 1, y + 1)) ||
		(smjer == Smjerovi::DoljeDesno &amp;&amp; BlokiranoPolje(polja, x + 1, y + 1)))
			throw logic_error("Blokirano polje");
			
	polja.at(x).at(y) = Polje::Posjeceno;
			
	switch(smjer) {
		case Smjerovi::Gore:
			y--;
			break;
		case Smjerovi::Dolje:
			y++;
			break;
		case Smjerovi::Lijevo:
			x--;
			break;
		case Smjerovi::Desno:
			x++;
			break;
		case Smjerovi::GoreLijevo:
			y--;
			x--;
			break;
		case Smjerovi::GoreDesno:
			y--;
			x++;
			break;
		case Smjerovi::DoljeLijevo:
			y++;
			x--;
			break;
		case Smjerovi::DoljeDesno:
			y++;
			x++;
	}
			
	Status trenutniStatus = TrenutniStatus(polja, x, y);
	
	if(trenutniStatus == Status::KrajPoraz) 
		for(int i=0; i&lt;polja.size(); i++) 
			for(int j=0; j&lt;polja.size(); j++)
				polja.at(i).at(j) = Polje::Prazno;
	
	return trenutniStatus;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	if(novi_x &lt; 0 || novi_x &gt;= polja.size() || novi_y &lt; 0 || novi_y &gt;= polja.size())
		throw out_of_range("Izlazak van igrace table");
		
	if(BlokiranoPolje(polja, novi_x, novi_y))
		throw logic_error("Blokirano polje");
		
		
	polja.at(x).at(y) = Polje::Posjeceno;
	
	x = novi_x;
	y = novi_y;
		
	Status trenutniStatus = TrenutniStatus(polja, x, y);
	
	if(trenutniStatus == Status::KrajPoraz) 
		for(int i=0; i&lt;polja.size(); i++) 
			for(int j=0; j&lt;polja.size(); j++)
				polja.at(i).at(j) = Polje::Prazno;
	
	return trenutniStatus;
}

int main ()
{
	vector&lt;vector&lt;int&gt;&gt; mine = {{0,0}, {0,2}, {1,3}};
	Tabla t = KreirajIgru(4,mine);
</font>	IspisiTablu(t);
}</pre>
</body>
</html>
