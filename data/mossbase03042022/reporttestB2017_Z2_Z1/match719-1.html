<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student9524.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4966.cpp<p></p><pre>
/*B 2017/2018, Zadaća 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;complex&gt;

enum class Polje { Prazno=0, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina }; 
enum class Smjerovi { GoreLijevo=0, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo };
enum class Status { NijeKraj=0, KrajPoraz, KrajPobjeda };
enum class KodoviGresaka { PogresnaKomanda=0, NedostajeParametar, SuvisanParametar, NeispravanParametar};
enum class Komande { PomjeriJednoMjesto=0, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
typedef std::vector&lt;int&gt; Vektor;
typedef std::vector&lt;Vektor&gt; Matrica;
<a name="1"></a><font color="#00FF00"><a href="match719-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	if (n&lt;=0) throw std::domain_error("Ilegalna veličina");
	for (int i=0;i&lt;mine.size();i++) {
		if (mine[i].size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
</font>		for (int j=0;j&lt;mine[i].size();j++) {
<a name="8"></a><font color="#00FFFF"><a href="match719-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

			if (mine[i][j]&gt;=n || mine[i][j]&lt;0 || (mine[i][0]==0 &amp;&amp; mine[i][1]==0)) throw std::domain_error("Ilegalne pozicije mina");
		}
	}
	Tabla tabla;
</font>	for (int i=0;i&lt;n;i++) 
<a name="2"></a><font color="#0000FF"><a href="match719-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		tabla.push_back(std::vector&lt;Polje&gt;(n, Polje::Prazno));
	for (int i=0;i&lt;mine.size();i++) 
		tabla[mine[i][0]][mine[i][1]]=Polje::Mina;
	return tabla;
</font>}
Matrica PrikaziOkolinu (const Tabla &amp;tabla, int x, int y) {
	if (x&lt;0 || y&lt;0 || x&gt;=tabla.size() || y&gt;=tabla.size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	Matrica mat(3, std::vector&lt;int&gt;(3));
	std::vector&lt;Matrica&gt; indeksi{{{x-2,y-2},{x-2,y-1},{x-2,y}},{{x-1,y-2},{x-1,y-1},{x-1,y}},{{x,y-2},{x,y-1},{x,y}}};
	for (int i=0;i&lt;3;i++){
		for (int j=0;j&lt;3;j++) {
			int suma(0);
			for (int k=indeksi[i][j][0];k&lt;indeksi[i][j][0]+3;k++) {
				if (k&lt;0 || k&gt;=tabla.size())
					continue;
				for (int l=indeksi[i][j][1];l&lt;indeksi[i][j][1]+3;l++) {
					if (l&lt;0 || l&gt;=tabla.size())
						continue;
					if (tabla[k][l]==Polje::Mina &amp;&amp; (k!=indeksi[i][j][0]+1 || l!=indeksi[i][j][1]+1))
						suma++;
				}
			}
			mat[i][j]=suma;
		}
	}
	return mat;
}
void BlokirajPolje(Tabla &amp;tabla, int x, int y) {
<a name="3"></a><font color="#00FFFF"><a href="match719-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	if (x&lt;0 || y&lt;0 || x&gt;=tabla.size() || y&gt;=tabla.size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if (tabla[x][y]==Polje::Prazno) tabla[x][y]=Polje::BlokiranoPrazno;
</font><a name="5"></a><font color="#FF0000"><a href="match719-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	if (tabla[x][y]==Polje::Posjeceno) tabla[x][y]=Polje::BlokiranoPosjeceno;
	if (tabla[x][y]==Polje::Mina) tabla[x][y]=Polje::BlokiranoMina;
}
void DeblokirajPolje(Tabla &amp;tabla, int x, int y) {
	if (x&lt;0 || y&lt;0 || x&gt;=tabla.size() || y&gt;=tabla.size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
</font><a name="4"></a><font color="#FF00FF"><a href="match719-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	if (tabla[x][y]==Polje::BlokiranoPrazno) tabla[x][y]=Polje::Prazno;
</font>	if (tabla[x][y]==Polje::BlokiranoPosjeceno) tabla[x][y]=Polje::Posjeceno;
	if (tabla[x][y]==Polje::BlokiranoMina) tabla[x][y]=Polje::Mina;
}
void OcistiTablu(Tabla &amp;tabla) {
	for (int i=0;i&lt;tabla.size();i++)
		for (int j=0;j&lt;tabla[i].size();j++) 
			tabla[i][j]=Polje::Prazno;
}
bool ImaLiPraznih(Tabla &amp;tabla, const int x, const int y) {
	bool imalipraznih(false);
	for (int i=0;i&lt;tabla.size();i++) {
		for (int j=0;j&lt;tabla.size();j++) {
			if (i==x &amp;&amp; j==y) continue;
			if (tabla[i][j]==Polje::Prazno)
				imalipraznih=true;
		}
	}
	return imalipraznih;
}
Status Idi(Tabla &amp;tabla, int &amp;x, int &amp;y, Smjerovi smjer) {
	Matrica mat{{x-1,y-1},{x-1,y},{x-1,y+1},{x,y+1},{x+1,y+1},{x+1,y},{x+1,y-1},{x,y-1}};
	if (mat[static_cast&lt;int&gt;(smjer)][0]&lt;0 || mat[static_cast&lt;int&gt;(smjer)][0]&gt;=tabla.size() || mat[static_cast&lt;int&gt;(smjer)][1]&lt;0 || mat[static_cast&lt;int&gt;(smjer)][1]&gt;=tabla.size()) 
		throw std::out_of_range("Izlazak van igrace table");
	if (tabla[mat[static_cast&lt;int&gt;(smjer)][0]][mat[static_cast&lt;int&gt;(smjer)][1]]==Polje::BlokiranoPosjeceno || tabla[mat[static_cast&lt;int&gt;(smjer)][0]][mat[static_cast&lt;int&gt;(smjer)][1]]==Polje::BlokiranoPrazno || tabla[mat[static_cast&lt;int&gt;(smjer)][0]][mat[static_cast&lt;int&gt;(smjer)][1]]==Polje::BlokiranoMina)
		throw std::logic_error("Blokirano polje");
	if (tabla[mat[static_cast&lt;int&gt;(smjer)][0]][mat[static_cast&lt;int&gt;(smjer)][1]]==Polje::Mina) {
		OcistiTablu(tabla);
		return Status::KrajPoraz;
	} 
	tabla[x][y]=Polje::Posjeceno;
	x=mat[static_cast&lt;int&gt;(smjer)][0]; y=mat[static_cast&lt;int&gt;(smjer)][1];
	if (!ImaLiPraznih(tabla, x, y))
		return Status::KrajPobjeda;
	return Status::NijeKraj;
}
Status Idi(Tabla &amp;tabla, int &amp;x, int &amp;y, int novix, int noviy) {
<a name="6"></a><font color="#00FF00"><a href="match719-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	if (novix&lt;0 || noviy&lt;0 || novix&gt;=tabla.size() || noviy&gt;=tabla.size())
		throw std::out_of_range("Izlazak van igrace table");
	if (tabla[novix][noviy]==Polje::BlokiranoPosjeceno || tabla[novix][noviy]==Polje::BlokiranoPrazno || tabla[novix][noviy]==Polje::BlokiranoMina)
</font>		throw std::logic_error("Blokirano polje");
	if (tabla[novix][noviy]==Polje::Mina) {
		OcistiTablu(tabla);
		return Status::KrajPoraz;
	}
	tabla[x][y]=Polje::Posjeceno;
	x=novix; y=noviy;
	if (!ImaLiPraznih(tabla, x, y))
		return Status::KrajPobjeda;
	return Status::NijeKraj;
}
void PrijaviGresku(KodoviGresaka greska) {
	std::vector&lt;std::string&gt; vektor{{"Nerazumljiva komanda!"}, {"Komanda trazi parametar koji nije naveden!"}, {"Zadan je suvisan parametar nakon komande!"}, {"Parametar komande nije ispravan!"}};
	std::cout&lt;&lt;vektor[static_cast&lt;int&gt;(greska)]&lt;&lt;std::endl;
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
	std::vector&lt;std::string&gt; vektor{{"P1"},{"P&gt;"},{"B"},{"D"},{"PO"},{"Z"},{"K"}};
	std::vector&lt;std::string&gt; smjerovi{{"GL"},{"G"},{"GD"},{"D"},{"DoD"},{"Do"},{"DoL"},{"L"}};
	std::string komanda1;
	std::cin.sync();
	std::cin&gt;&gt;std::ws&gt;&gt;komanda1;
	auto it=std::find(vektor.begin(), vektor.end(), komanda1);
	if (it!=vektor.end()) {
		if (it-vektor.begin()&gt;=1 &amp;&amp; it-vektor.begin()&lt;=3) {
			while (std::cin.peek()==' ')
				std::cin.get();
			if (std::cin.peek()&gt;='0' &amp;&amp; std::cin.peek()&lt;='9') {
				int xkoord, ykoord;
				std::cin&gt;&gt;xkoord;
				while (std::cin.peek()==' ')
					std::cin.get();
				if (std::cin.peek()&lt;'0' || std::cin.peek()&gt;'9') {
					greska=KodoviGresaka::NeispravanParametar;
					std::cin.ignore(50, '\n');
					return false;
				}
				else {
					std::cin&gt;&gt;ykoord;
					while (std::cin.peek()==' ')
						std::cin.get();
					if (std::cin.peek()!='\n') {
						greska=KodoviGresaka::SuvisanParametar;
						std::cin.ignore(50, '\n');
						return false;
					}
				}
				x=xkoord;
				y=ykoord;
				komanda=static_cast&lt;Komande&gt;(it-vektor.begin());
				return true;
			}
			else if (std::cin.peek()!='\n') {
				greska=KodoviGresaka::NeispravanParametar;
				std::cin.ignore(50, '\n');
				return false;
			}
			else {
				greska=KodoviGresaka::NedostajeParametar;
				std::cin.ignore(50,'\n');
				return false;
			}
		}
		else if (it-vektor.begin()==0) {
			while(std::cin.peek()==' ')
				std::cin.get();
			if (std::cin.peek()=='\n') {
				greska=KodoviGresaka::NedostajeParametar;
				std::cin.ignore(50, '\n');
				return false;
			}
			std::string smjer1;
			std::cin&gt;&gt;smjer1;
			while(std::cin.peek()==' ')
				std::cin.get();
			if (std::cin.peek()!='\n'){
				greska=KodoviGresaka::SuvisanParametar;
				std::cin.ignore(50, '\n');
				return false;
			}
			auto it2=std::find(smjerovi.begin(), smjerovi.end(), smjer1);
			if (it2==smjerovi.end()) {
				greska=KodoviGresaka::NeispravanParametar;
				std::cin.ignore(50, '\n');
				return false;
			}
			else {
				komanda=Komande::PomjeriJednoMjesto;
				smjer=static_cast&lt;Smjerovi&gt;(it2-smjerovi.begin());
				std::cin.ignore(50, '\n');
				return true;
			}
		}
		else {
			while (std::cin.peek()==' ')
				std::cin.get();
			if (std::cin.peek()!='\n') {
				greska=KodoviGresaka::SuvisanParametar;
				std::cin.ignore(50, '\n');
				return false;
			}
			komanda=static_cast&lt;Komande&gt;(it-vektor.begin());
			std::cin.ignore(50, '\n');
			return true;
		}
	}
	else {
		greska=KodoviGresaka::PogresnaKomanda;
		std::cin.ignore(50, '\n');
		return false;
	}
	return false;
}
bool ProvjeriUnos (std::string s, int &amp;x, int &amp;y) {
	for (auto it=s.begin();it!=s.end();it++) {
		if (*it==' ') {
			s.erase(it);
			it--;
		}
	}
	if (s.length()!=5) return false;
	if (s[0]=='(' &amp;&amp; s[2]==',' &amp;&amp; s[4]==')') {
		if ((s[1]&gt;='0' &amp;&amp; s[1]&lt;='9') &amp;&amp; (s[3]&gt;='0' &amp;&amp; s[3]&lt;='9')) {
			x=s[1]-'0';
			y=s[3]-'0';
			return true;
		}
	}
	return false;
}
<a name="7"></a><font color="#0000FF"><a href="match719-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
	try { 
		if (komanda==Komande::PomjeriJednoMjesto || komanda==Komande::PomjeriDalje) {
</font>			Status status;
			if (komanda==Komande::PomjeriJednoMjesto)
				status=Idi(polja, x, y, p_smjer);
			else
				status=Idi(polja, x, y, p_x, p_y);
			if (status!=Status::NijeKraj) {
				if (status==Status::KrajPobjeda) std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;std::endl;
				if (status==Status::KrajPoraz) std::cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;std::endl;
				OcistiTablu(polja);
				throw std::runtime_error("Igra zavrsena");
			}
			std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
		}
		if (komanda==Komande::Blokiraj) BlokirajPolje(polja, p_x, p_y);
		if (komanda==Komande::Deblokiraj) DeblokirajPolje(polja, p_x, p_y);
		if (komanda==Komande::PrikaziOkolinu) { 
<a name="0"></a><font color="#FF0000"><a href="match719-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

			Matrica mat=PrikaziOkolinu(polja, x, y);
			for (int i=0;i&lt;mat.size();i++) {
				for (int j=0;j&lt;mat[i].size();j++)
					std::cout&lt;&lt;mat[i][j]&lt;&lt;" ";
				std::cout&lt;&lt;std::endl;
</font>			}
		}
		if (komanda==Komande::ZavrsiIgru) { OcistiTablu(polja); throw std::runtime_error("Igra zavrsena"); }
		if (komanda==Komande::KreirajIgru) {
			int brojpolja;
			bool logicka(true);
			do {
				logicka=true;
				std::cout&lt;&lt;"Unesite broj polja: ";
				std::cin.sync();
				std::cin&gt;&gt;brojpolja;
				if (brojpolja&lt;=0) {
					logicka=false;
					std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
				}
				if (!std::cin || std::cin.peek()!='\n') {
					std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
					logicka=false;
					std::cin.clear();
					std::cin.sync();
					std::cin.ignore(100, '\n');
				}
			} while(!logicka);
			std::cout&lt;&lt;"Unesite pozicije mina: ";
			Matrica mine;
			bool dalijetacka(false);
			std::cin.get();
			do {
				std::string s;
				bool logicka2(true);
				int x, y;
				std::cin.sync();
				std::getline(std::cin, s);
				logicka2=ProvjeriUnos(s, x, y);
				if (s==".") dalijetacka=true;
				if (!logicka2) {
					if (!dalijetacka) std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
				}
				else {
					if (x&lt;0 || y&lt;0 || x&gt;=brojpolja || y&gt;=brojpolja) std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
					else { 
						std::vector&lt;int&gt; v;
						v.push_back(x); v.push_back(y);
						mine.push_back(v);
					}
				}
			} while(!dalijetacka);
			polja=KreirajIgru(brojpolja, mine);
		}
	}
	catch(std::domain_error domen) {
		std::cout&lt;&lt;domen.what()&lt;&lt;std::endl;
	}
	catch(std::out_of_range vanopsega) {
		std::cout&lt;&lt;vanopsega.what()&lt;&lt;std::endl;
	}
	catch(std::logic_error logika) {
		std::cout&lt;&lt;logika.what()&lt;&lt;std::endl;
	}
}
int main ()
{
	int x(0), y(0), p_x, p_y;
	Tabla tabla;
	Smjerovi smjer;
	KodoviGresaka greska;
	Komande komanda;
	bool logicka;
	for (;;) {
		std::cout&lt;&lt;"Unesite komandu: ";
		try {
			logicka=UnosKomande(komanda, smjer, p_x, p_y, greska);
			if (logicka) {
				IzvrsiKomandu(komanda, tabla, x, y, smjer, p_x, p_y);
			}
			else {
				PrijaviGresku(greska);
			}
		}
		catch(std::runtime_error err) {
			std::cout&lt;&lt;"Dovidjenja!";
			return 0;
		}
	}
	return 0;
}</pre>
</body>
</html>
