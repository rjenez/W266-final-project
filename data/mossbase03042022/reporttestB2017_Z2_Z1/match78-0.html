<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student3171.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student3171.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;new&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;complex&gt;

<a name="0"></a><font color="#FF0000"><a href="match78-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum class Polje
{
    Prazno=0, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
enum class Smjerovi
{
    GoreLijevo=0, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status
{
    NijeKraj=0, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka
{
    PogresnaKomanda=0, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
enum class Komande
{
    PomjeriJednoMjesto=0, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
    ZavrsiIgru, KreirajIgru
};

int string_to_int(std::string s);

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine);

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y);

void BlokirajPolje(Tabla &amp;polja, int x, int y);

void DeblokirajPolje(Tabla &amp;polja, int x, int y);

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer);

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y);

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska);

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int&amp;, int&amp;,
                   Smjerovi , int, int );

void PrijaviGresku(KodoviGresaka greska);

int main ()
{
	Tabla test {};
	Komande komanda;
	Smjerovi smjer;
	int x=0,y=0,px=0,py=0;
	KodoviGresaka greska;
//	std::cout&lt;&lt;int('.');
	try{
	for(;;)
	{
		std::cout&lt;&lt;"Unesite komandu: ";
		try{if(UnosKomande(komanda,smjer,px,py,greska))
		{
			IzvrsiKomandu(komanda,test,x,y,smjer,px,py );
		}
		else
		{
			PrijaviGresku(greska);
		}
		}
		catch(std::domain_error izuzetak)
		{
			std::cout&lt;&lt;izuzetak.what()&lt;&lt;"\n";
		}
	
		
	}
	}
	catch(std::runtime_error kraj)
	{
		std::cout&lt;&lt;"Dovidjenja!";
	}

	return 0;
}

int string_to_int(std::string s)
{
	int i=0;
	int result {0};
	while(i&lt;s.length() &amp;&amp; (s[i]&gt;='0'&amp;&amp; s[i]&lt;='9' ))
	{
		result*=10;
		result+=s[i]-'0';
		i++;
	}
	return result;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y,
                   Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0)
{

	if(komanda==Komande::PrikaziOkolinu)
	{
		auto result(PrikaziOkolinu(polja,x,y));
		for(auto red: result)
		{
			for(auto kolona : red)
				std::cout&lt;&lt;kolona&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	else if(komanda==Komande::PomjeriDalje)
	{
		Status next=Idi(polja,x,y,p_x,p_y);
		std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
		if(next==Status::KrajPoraz)
		{
			std::cout&lt;&lt;"Nagazili ste na minu";
			for(auto &amp;red:polja)
				for(auto &amp;kolona:red)
					kolona=Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
		}
		else if(next==Status::KrajPobjeda)
		{
			std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja";
			for(auto &amp;red:polja)
				for(auto &amp;kolona:red)
					kolona=Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
		}
	}
	else if(komanda==Komande::ZavrsiIgru)
	{
		for(auto &amp;red : polja)
			for(auto &amp;kolona : red)
				kolona=Polje::Prazno;
		throw std::runtime_error("Igra zavrsena");
	}
	else if(komanda== Komande::Blokiraj)
	{
		BlokirajPolje(polja,x,y);
	}
	else if(komanda==Komande::Deblokiraj)
	{
		DeblokirajPolje(polja,x,y);
	}
	else if(komanda==Komande::PomjeriJednoMjesto)
	{
		Status next(Idi(polja,x,y,p_smjer));
		std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
		if(next==Status::KrajPoraz)
		{
			std::cout&lt;&lt;"Nagazili ste na minu";
			for(auto &amp;red:polja)
				for(auto &amp;kolona:red)
					kolona=Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
		}
		else if(next == Status::KrajPobjeda)
		{
			std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja";
			for(auto &amp;red:polja)
				for(auto &amp;kolona:red)
					kolona=Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
		}
	}
	else if(komanda==Komande::KreirajIgru)
	{
		int broj_polja(0);
		for(;;)
		{
			std::cout&lt;&lt;"Unesite broj polja: ";
			std::cin&gt;&gt;broj_polja;
			if(std::cin &amp;&amp; std::cin.peek()=='\n')break;
			std::cout&lt;&lt;"Greska, unesite ponovo!";
			std::cin.clear();
			std::cin.ignore(1000,'\n');
		}
		std::complex&lt;int&gt; polje;
		std::cout&lt;&lt;"Unesite pozicije mina: ";
		std::vector&lt;std::vector&lt;int&gt;&gt; mine;
		std::vector&lt;int&gt; jedna_mina(2,0);
		try
		{
			for(;;)
			{
				for(;;)
				{
					std::cin&gt;&gt;polje;
					int p(0);
					std::cin.clear();
					if((p=std::cin.peek())==46)throw 0;
				//	std::cout&lt;&lt;p;
					if(std::cin &amp;&amp; polje.real()&gt;=0 &amp;&amp; polje.imag()&gt;=0 &amp;&amp; polje.real()&lt;=broj_polja &amp;&amp; polje.imag()&lt;=broj_polja &amp;&amp; (polje.real()!=0 || polje.imag()!=0 ) &amp;&amp; std::cin.peek()=='\n')break;
					std::cout&lt;&lt;"Greska, unesite ponovo!";
					std::cin.clear();
					std::cin.ignore(1000,'\n');
				}
				jedna_mina[0]=polje.real();
				jedna_mina[1]=polje.imag();
				mine.push_back(jedna_mina);
			}
		}
		catch(int a)
		{
		std::cin.clear();
		std::cin.ignore(1000,'\n');
		}

		polja=KreirajIgru(broj_polja,mine);

	}

}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	std::string input {};


	std::getline(std::cin,input);

	for(int i=1; i&lt;input.length(); i++)
	{
		if(input[i-1]==input[i] &amp;&amp; input[i]==' ')input.erase(input.begin()+i);
	}
	if(input[0]==' ')input.erase(input.begin());
	if(input[input.length()-1]==' ')input.erase(input.end()-1);
	std::string part[4] {};
	int k {0};
	bool neslovo(true);
	for(int i=0; i&lt;input.length(); i++)
	{
		if(input[i]==' ')
		{
			if(!neslovo)k++;

			neslovo=true;
		}
		else
		{
			if(k==4)
			{
				break;
			}
			part[k]+=input[i];
			neslovo=false;
		}
	}
//	for(auto x:part)std::cout&lt;&lt;x&lt;&lt;" ";
//	std::cout&lt;&lt;"\n";
	const std::string zero[7] {"P1","P&gt;","B","D","PO","Z","K"};
	const std::string first[8] {"GL","G","GD","D","DoD","Do","DoL","L"};
//if(part[0]==zero[6])std::cout&lt;&lt;" jest";
	for(int i=0; i&lt;7; i++)
	{
		if(zero[i]==part[0])break;
		if(i==6)
		{
			greska=KodoviGresaka::PogresnaKomanda;
			return false;
		}
	}
	if(part[0]==zero[0])
	{
		int x;
		for(int i=0; i&lt;8; i++)
		{
			if(part[1]==first[i])
			{
				x=i;
				break;
			}
			if(i==7)
			{
				if(part[1]=="")
				{
					greska=KodoviGresaka::NedostajeParametar;
					return false;
				}
				else
				{
					greska=KodoviGresaka::NeispravanParametar;
					return false;
				}
			}
		}
		if(part[2]=="")
		{
			komanda=Komande::PomjeriJednoMjesto;
			smjer=Smjerovi(x);
			return true;
		}
		else
		{
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}

	}
	for(int i=1; i&lt;4; i++)
	{
		if(zero[i]==part[0])
		{
			if(std::to_string( string_to_int(part[1]))==part[1])
			{
				if(std::to_string( string_to_int(part[2]))==part[2])
				{
					if(part[3]=="")
					{
						komanda=Komande(i);
						x=string_to_int(part[1]);
						y=string_to_int(part[2]);
						return true;
					}
					else
					{
						greska=KodoviGresaka::SuvisanParametar;
						return false;
					}
				}
				else if(part[2]=="")
				{
					greska=KodoviGresaka::NedostajeParametar;
					return false;
				}
				else
				{
					greska=KodoviGresaka::NeispravanParametar;
					return false;
				}
			}
			else if(part[1]=="")
			{
				greska=KodoviGresaka::NedostajeParametar;
				return false;
			}
			else
			{
				greska=KodoviGresaka::NeispravanParametar;
				return false;
			}
		}

	}
	for(int i=4; i&lt;7; i++)
	{
		if(part[0]==zero[i])
		{
			if(part[1]=="")
			{
				komanda=Komande(i);
				return true;
			}
			else
			{
				greska=KodoviGresaka::SuvisanParametar;
				return false;
			}
		}
		
	}
	
			greska=KodoviGresaka::PogresnaKomanda;
			return false;
	
}

void PrijaviGresku(KodoviGresaka greska)
{
	if(static_cast&lt;int&gt;(greska) &gt; 3  || static_cast&lt;int&gt;(greska) &lt;0)throw std::logic_error("Greska ne postoji!");
	std::string niz[4] {"Nerazumljiva komanda!\n","Komanda trazi parametar koji nije naveden!\n","Zadan je suvisan parametar nakon komande!\n","Parametar komande nije ispravan!\n"};
	std::cout&lt;&lt;niz[static_cast&lt;int&gt;(greska)];
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
	if (n&lt;1)throw std::domain_error("Ilegalna velicina");
	Tabla temp(n,std::vector&lt;Polje&gt;(n,Polje::Prazno));

	for(int i=0; i&lt;mine.size(); i++)
	{
		if(mine.at(i).size() != 2)throw std::domain_error("Ilegalan format zadavanja mina");
		if(mine.at(i).at(0) &gt; n-1 || mine.at(i).at(1) &gt; n-1 || mine.at(i).at(0) &lt; 0 || mine.at(i).at(1) &lt; 0)throw std::domain_error("Ilegalne pozicije mina");
		temp.at(mine.at(i).at(0)).at(mine.at(i).at(1)) = Polje::Mina;
	}
	return temp;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
	if( x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size() )
		throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");

	std::vector&lt;std::vector&lt;int&gt;&gt; result(3,std::vector&lt;int&gt;(3,0));

	for(int i = x-1; i &lt; x+2; i++ )
	{
		for(int j = y-1; j &lt; y+2; j++)
		{
			if(j &lt; 0 || i &lt; 0 || j &gt;= polja.size() || i &gt;= polja.size())continue;
			int brojac {0};
			for(int k = i-1; k &lt; i+2; k++ )
			{
				for(int q = j-1; q &lt; j+2; q++)
				{
					if( k &lt; 0 || q &lt; 0 || k &gt;= polja.size() || q &gt;= polja.size() )continue;
					if(polja.at(k).at(q) == Polje::Mina)brojac++;
					if(polja.at(i).at(j) == Polje::Mina &amp;&amp; i == k &amp;&amp; j == q)brojac--;
				}
			}
			result.at( i-(x-1) ).at( j-(y-1) ) = brojac;
		}
	}
	return result;
}

void BlokirajPolje( Tabla &amp;polja, int x, int y)
{
	if( x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size() )
		throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if(polja.at(x).at(y) &lt; Polje(3) )polja.at(x).at(y)=Polje( static_cast&lt;int&gt;(polja.at(x).at(y) ) + 3);
}

void DeblokirajPolje( Tabla &amp;polja, int x, int y)
{
	if( x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size() )
		throw std::domain_error("Polje (" + std::to_string(x) + "," + std::to_string(y) +") ne postoji");
	if(polja.at(x).at(y) &gt; Polje(2) ) polja.at(x).at(y) = Polje( static_cast&lt;int&gt;(polja.at(x).at(y)) -3);
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer )
{
	int where[8][2] { {x-1,y-1},{x-1,y},{x-1,y+1},{x,y+1},{x+1,y+1},{x+1,y},{x+1,y-1},{x,y-1} };
	int red { where[static_cast&lt;int&gt;(smjer)][0] },kolona { where[static_cast&lt;int&gt;(smjer)][1]};
	if(red &lt; 0 || kolona &lt; 0 || red &gt;= polja.size() || kolona &gt;= polja.size() )
		throw std::out_of_range("Izlazak van igrace table");
	if( static_cast&lt;int&gt;(polja.at(red).at( kolona ) ) &gt; 2)
		throw std::logic_error("Blokirano polje");

	if (polja.at(red).at(kolona) == Polje::Mina)
	{
		for(auto &amp;vanjski : polja)
		{
			for(auto &amp;unutrasnji : vanjski)
			{
				unutrasnji = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	polja.at(x).at(y) = Polje::Posjeceno;
	if(polja.at(red).at(kolona) == Polje::Prazno)
	{
		int broj_praznih {0};
		for(auto vanjski : polja)
		{
			for(auto unutrasnji : vanjski)
			{
				if(unutrasnji == Polje::Prazno)broj_praznih++;
			}
		}
		if(broj_praznih&lt;2)
			return Status::KrajPobjeda;
	}
	x=red;
	y=kolona;
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if(novi_x &lt; 0 || novi_y &lt; 0 || novi_x &gt;= polja.size() || novi_y &gt;= polja.size() )
		throw std::out_of_range("Izlazak van igrace table");
	if( static_cast&lt;int&gt;(polja.at(novi_x).at(novi_y)) &gt; 2  )
		throw std::logic_error("Blokirano polje");
	if(polja.at(novi_x).at(novi_y) == Polje::Mina )
	{
		for( auto &amp;red : polja)
		{
			for(auto &amp;kolona : red)
			{
				kolona = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	polja.at(x).at(y) = Polje::Posjeceno;
	if(polja.at(novi_x).at(novi_y) == Polje::Prazno)
	{
		int broj_praznih {0};
		for(auto red : polja)
		{
			for(auto kolona : red)
			{
				if(kolona == Polje::Prazno)
				{
					broj_praznih++;
				}
			}
		}
		if(broj_praznih &lt; 2)return Status::KrajPobjeda;
	}
	x=novi_x;
	y=novi_y;
</font>	return Status::NijeKraj;
}</pre>
</body>
</html>
