<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student8264.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student3739.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

<a name="1"></a><font color="#00FF00"><a href="match151-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_42.gif"/></a>

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina };
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru (int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	Tabla igra;
	igra.resize(n);
	for(int i=0; i&lt;n; i++){ 
		igra.at(i).resize(n);
	}
	
	for(int i=0; i&lt;mine.size(); i++) {
		for(int j=0; j&lt;mine.at(i).size(); j++) {
			if(mine.at(i).size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
			if(mine.at(i).at(j)&gt;=n) throw std::domain_error("Ilegalne pozicije mina");
			else if(j==1) {
				igra.at(mine.at(i).at(0)).at(mine.at(i).at(1))=Polje::Mina;
			}
		}
	}
	return igra;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	for(int i=0; i&lt;polja.size(); i++) {
		if(y&gt;=polja.size()) throw std::domain_error ("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
		if(x&gt;=polja[i].size()) throw std::domain_error ("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	}
	std::vector&lt;std::vector&lt;int&gt;&gt;pomocna;
	std::vector&lt;std::vector&lt;int&gt;&gt; vracamo;
	pomocna.resize(polja.size());
	for(int i=0; i&lt;polja.size(); i++) pomocna.at(i).resize(polja.at(i).size());
	
	for(int i=0; i&lt;polja.size(); i++) {
		for (int j=0; j&lt;polja.at(i).size(); j++) {
			if(polja.at(i).at(j)==Polje::Mina) pomocna.at(i).at(j)=1;
		}
	}
	vracamo.resize(3);
	for(int i=0; i&lt;3; i++) vracamo.at(i).resize(3);
	for(int i=-1; i&lt;2; i++) {
		for(int j=-1; j&lt;2; j++) {
			for(int m=-1; m&lt;2; m++) {
				for(int n=-1; n&lt;2; n++) {
					if(m==0 &amp;&amp; n==0) {continue;}
					if(m+y+i&lt;0 || n+x+j&lt;0 || n+x+j&gt;=pomocna.at(0).size() || m+y+i&gt;=pomocna.size()) {continue;}
					vracamo[i+1][j+1]+=pomocna[m+y+i][n+x+j];
					
				}
			}
		}
	}
	return vracamo;
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x&gt;=polja.at(0).size() || y&gt;=polja.size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if(polja.at(x).at(y)==Polje::BlokiranoPrazno) polja.at(x).at(y)=Polje::Prazno;
</font>	else if(polja.at(x).at(y)==Polje::BlokiranoMina) polja.at(x).at(y)=Polje::Mina;
<a name="2"></a><font color="#0000FF"><a href="match151-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

	else if(polja.at(x).at(y)==Polje::BlokiranoPosjeceno) polja.at(x).at(y)=Polje::Posjeceno;
}
void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x&gt;=polja.at(0).size() || y&gt;=polja.size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if(polja.at(x).at(y)==Polje::Prazno) polja.at(x).at(y)=Polje::BlokiranoPrazno;
</font><a name="0"></a><font color="#FF0000"><a href="match151-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_46.gif"/></a>

	else if(polja.at(x).at(y)==Polje::Mina) polja.at(x).at(y)=Polje::BlokiranoMina;
	else if(polja.at(x).at(y)==Polje::Posjeceno) polja.at(x).at(y)=Polje::BlokiranoPosjeceno;
}

enum class Smjerovi { GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo };
enum class Status { NijeKraj, KrajPoraz, KrajPobjeda};

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	int pocetnix(x), pocetniy(y);
	if(smjer==Smjerovi::GoreLijevo) {
		polja.at(x).at(y)=Polje::Posjeceno; x--; y--;
	}
	else if(smjer==Smjerovi::Gore) {
		polja.at(x).at(y)=Polje::Posjeceno; x--;
	}
	else if(smjer==Smjerovi::GoreDesno) {
		polja.at(x).at(y)=Polje::Posjeceno; x--;y++;
	}
	else if(smjer==Smjerovi::Desno) {
		polja.at(x).at(y)=Polje::Posjeceno; y++;
	}
	else if(smjer==Smjerovi::DoljeDesno) {
		polja.at(x).at(y)=Polje::Posjeceno; x++; y++;
	}
	else if(smjer==Smjerovi::Dolje) {
		polja.at(x).at(y)=Polje::Posjeceno; x++;
	}
	else if(smjer==Smjerovi::DoljeLijevo) {
		polja.at(x).at(y)=Polje::Posjeceno; x++;y--;
	}
	else if(smjer==Smjerovi::Lijevo) {
		polja.at(x).at(y)=Polje::Posjeceno; y--;
	}
	if(x&lt;0 || y&lt;0 ) {
		x=pocetnix;
		y=pocetniy;
		throw std::out_of_range ("Izlazak van igrace table");
	}
	if(x&gt;=polja.size() || y&gt;=polja.size()) {
		x=pocetnix;
		y=pocetniy;
		throw std::out_of_range("Izlazak van igrace table");
	}
	if(polja.at(x).at(y)==Polje::BlokiranoMina) {
		x=pocetnix;
		y=pocetniy;
		throw std::out_of_range ("Blokirano polje");
	}
	if(polja.at(x).at(y)==Polje::BlokiranoPosjeceno) {
		x=pocetnix;
		y=pocetniy;
		throw std::out_of_range("Blokirano polje");
	}
	if(polja.at(x).at(y)==Polje::BlokiranoPrazno){
		x=pocetnix;
		y=pocetniy;
		throw std::out_of_range("Blokirano polje");
	}
		if(polja.at(x).at(y)==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++) {
				for(int j=0; j&lt;polja.at(i).size(); j++) {
					polja.at(i).at(j)=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		if(polja.at(x).at(y)==Polje::Prazno) {
			bool minica(true);
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja.at(i).size(); j++) {
					if(polja.at(i).at(j)==Polje::Prazno) minica=false;
				}
			}
			if(minica) return Status::KrajPobjeda;
		}
		return Status::NijeKraj;
	}
enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar };
void PrijaviGresku(KodoviGresaka greska) {
	if(greska==KodoviGresaka::PogresnaKomanda) std::cout&lt;&lt;"Nerazumljiva komanda!\n";
	if(greska==KodoviGresaka::NedostajeParametar) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!\n";
	if(greska==KodoviGresaka::SuvisanParametar) std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!\n";
	if(greska==KodoviGresaka::NeispravanParametar) std::cout&lt;&lt;"Parametar komande nije ispravan!\n";
}
enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};
	


int main ()
{
	try{
	Komande komande;
	Smjerovi smjer;
	KodoviGresaka greska;
	Tabla tabla;
	int x(0), y(0);
//	while(true) {
//		std::cout&lt;&lt;"Unesite komandu: ";
		
//	}
	}
	catch(std::domain_error neispravno) {
		std::cout&lt;&lt;neispravno.what();
	}
	catch(std::out_of_range izvanopsega) {
		std::cout&lt;&lt;izvanopsega.what();
	}
	std::cout&lt;&lt;"Dovidjenja!";
	return 0;
</font>}</pre>
</body>
</html>
