<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5939.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5939.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, 
	ZavrsiIgru, KreirajIgru
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	for (int i=0; i&lt;mine.size(); i++) {
		if (mine.at(i).size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
	}
	for (int i=0; i&lt;mine.size(); i++) {
		if (mine.at(i).at(0)&gt;=n || mine.at(i).at(0)&lt;0) throw std::domain_error("Ilegalne pozicije mina");
		if (mine.at(i).at(1)&gt;=n || mine.at(i).at(1)&lt;0) throw std::domain_error("Ilegalne pozicije mina");
	}
	if (n&lt;=0) throw std::domain_error("Ilegalna velicina");
	Tabla t;
	t.resize(n);
	for (int i=0; i&lt;n; i++) t.at(i).resize(n);
	for (int i=0; i&lt;n; i++) {
		for (int j=0; j&lt;n; j++) {
			t.at(i).at(j)=Polje::Prazno;
		}
	}
	for (int i=0; i&lt;mine.size(); i++) {
		int x(mine.at(i).at(0));
		int y(mine.at(i).at(1));
<a name="2"></a><font color="#0000FF"><a href="match622-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		t.at(x).at(y)=Polje::Mina;
	}
	return t;
}

int BrojMinaOkolo(const Tabla &amp;polja, int x, int y) {
	int broj(0);
	for (int i=x-1; i&lt;=x+1; i++) {
</font>		for (int j=y-1; j&lt;=y+1; j++) {
			if (i&lt;0 || j&lt;0 || i&gt;=polja.size() || j&gt;=polja.at(0).size() || (i==x &amp;&amp; j==y)) continue;
<a name="1"></a><font color="#00FF00"><a href="match622-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

			if (polja.at(i).at(j)==Polje::Mina) broj++;
		}
	}
	return broj;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	if (x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.at(0).size())
</font><a name="5"></a><font color="#FF0000"><a href="match622-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina;
</font>	okolina.resize(3);
	for (int i=0; i&lt;3; i++) okolina.at(i).resize(3);
	for (int i=0; i&lt;3; i++) {
		for (int j=0; j&lt;3; j++) {
			okolina.at(i).at(j)=0;
		}
	}
	int brojreda(-1);
	for (int i=x-1; i&lt;=x+1; i++) {
		brojreda++;
		int brojkolone(-1);
		for (int j=y-1; j&lt;=y+1; j++) {
			brojkolone++;
			okolina.at(brojreda).at(brojkolone)=BrojMinaOkolo(polja, i, j);
		}
	}
	return okolina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	if (x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.at(0).size())
		throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if (polja.at(x).at(y)==Polje::Posjeceno) polja.at(x).at(y)=Polje::BlokiranoPosjeceno;
	if (polja.at(x).at(y)==Polje::Mina) polja.at(x).at(y)=Polje::BlokiranoMina;
	if (polja.at(x).at(y)==Polje::Prazno) polja.at(x).at(y)=Polje::BlokiranoPrazno;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if (x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.at(0).size())
		throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if (polja.at(x).at(y)==Polje::BlokiranoPosjeceno) polja.at(x).at(y)=Polje::Posjeceno;
	if (polja.at(x).at(y)==Polje::BlokiranoMina) polja.at(x).at(y)=Polje::Mina;
	if (polja.at(x).at(y)==Polje::BlokiranoPrazno) polja.at(x).at(y)=Polje::Prazno;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	polja.at(x).at(y)=Polje::Posjeceno;
	int novo_x, novo_y;
<a name="6"></a><font color="#00FF00"><a href="match622-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	if (smjer==Smjerovi::GoreLijevo) {
		novo_x=x-1;
		novo_y=y-1;
	}
	else if (smjer==Smjerovi::Gore) {
		novo_x=x-1;
</font>		novo_y=y;
	}
	else if (smjer==Smjerovi::GoreDesno) {
		novo_x=x-1;
		novo_y=y+1;
	}
	else if (smjer==Smjerovi::Desno) {
		novo_x=x;
<a name="3"></a><font color="#00FFFF"><a href="match622-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		novo_y=y+1;
	}
	else if (smjer==Smjerovi::DoljeDesno) {
		novo_x=x+1;
		novo_y=y+1;
	}
	else if (smjer==Smjerovi::Dolje) {
		novo_x=x+1;
</font>		novo_y=y;
	}
<a name="7"></a><font color="#0000FF"><a href="match622-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	else if (smjer==Smjerovi::DoljeLijevo) {
		novo_x=x+1;
		novo_y=y-1;
	}
	else if (smjer==Smjerovi::Lijevo) {
		novo_x=x;
</font>		novo_y=y-1;
	}
	if (novo_x&lt;0 || novo_y&lt;0 || novo_x&gt;=polja.size() || novo_y&gt;=polja.at(0).size()) throw std::out_of_range("Izlazak van igrace table");
	if (polja.at(novo_x).at(novo_y)==Polje::BlokiranoPosjeceno 
	|| polja.at(novo_x).at(novo_y)==Polje::BlokiranoMina 
	|| polja.at(novo_x).at(novo_y)==Polje::BlokiranoPrazno) 
		throw std::logic_error("Blokirano polje");
	x=novo_x;
	y=novo_y;
	if (polja.at(x).at(y)==Polje::Mina) {
		for (int i=0; i&lt;polja.size(); i++) {
			for (int j=0; j&lt;polja.at(i).size(); j++) {
				polja.at(i).at(j)=Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	bool prekini(false);
	for (int i=0; i&lt;polja.size(); i++) {
		for (int j=0; j&lt;polja.at(i).size(); j++) {
			if (polja.at(i).at(j)==polja.at(x).at(y)) continue;
			if (polja.at(i).at(j)==Polje::Prazno) {
				prekini=true;
				break;
			}
		}
		if (prekini) break;
	}
	if (!prekini) return Status::KrajPobjeda;
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	polja.at(x).at(y)=Polje::Posjeceno;
	int novo_x, novo_y;
	novo_x=novi_x;
	novo_y=novi_y;
	if (novo_x&lt;0 || novo_y&lt;0 || novo_x&gt;=polja.size() || novo_y&gt;=polja.at(0).size()) throw std::out_of_range("Izlazak van igrace table");
	if (polja.at(novo_x).at(novo_y)==Polje::BlokiranoPosjeceno 
	|| polja.at(novo_x).at(novo_y)==Polje::BlokiranoMina 
	|| polja.at(novo_x).at(novo_y)==Polje::BlokiranoPrazno) 
		throw std::logic_error("Blokirano polje");
	x=novo_x;
	y=novo_y;
	if (polja.at(x).at(y)==Polje::Mina) {
		for (int i=0; i&lt;polja.size(); i++) {
			for (int j=0; j&lt;polja.at(i).size(); j++) {
				polja.at(i).at(j)=Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	bool prekini(false);
	for (int i=0; i&lt;polja.size(); i++) {
		for (int j=0; j&lt;polja.at(i).size(); j++) {
			if (polja.at(i).at(j)==polja.at(x).at(y)) continue;
			if (polja.at(i).at(j)==Polje::Prazno) {
				prekini=true;
				break;
			}
		}
		if (prekini) break;
	}
	if (!prekini) return Status::KrajPobjeda;
	return Status::NijeKraj;
}

<a name="8"></a><font color="#00FFFF"><a href="match622-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

void PrijaviGresku(KodoviGresaka kod) {
	if (kod==KodoviGresaka::PogresnaKomanda)
		std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl;
	else if (kod==KodoviGresaka::NedostajeParametar)
</font>		std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
	else if (kod==KodoviGresaka::NeispravanParametar)
		std::cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; std::endl;
	else if (kod==KodoviGresaka::SuvisanParametar)
		std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt; std::endl;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska);

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
<a name="0"></a><font color="#FF0000"><a href="match622-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	if (komanda==Komande::Blokiraj) {
		try {
			BlokirajPolje(polja, x, y);
		}
		catch(std::domain_error e) {
			std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
		}
	}
	else if (komanda==Komande::Deblokiraj) {
		try {
			DeblokirajPolje(polja, x, y);
		}
		catch(std::domain_error e) {
			std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
		}
	}
	else if (komanda==Komande::PrikaziOkolinu) {
		try {
			std::vector&lt;std::vector&lt;int&gt;&gt; matrica;
			matrica=PrikaziOkolinu(polja, x, y);
</font>			for (int i=0; i&lt;3; i++) {
				for (int j=0; j&lt;3; j++) {
<a name="4"></a><font color="#FF00FF"><a href="match622-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

					std::cout &lt;&lt; matrica.at(i).at(j) &lt;&lt; " ";
				}
				std::cout &lt;&lt; std::endl;
			}
		}
		catch(std::domain_error e) {
			std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
		}
	}
	else if (komanda==Komande::PomjeriJednoMjesto) {
</font>		try {
			Status rezultat;
			rezultat=Idi(polja, x, y, p_smjer);
			std::cout &lt;&lt; "Tekuca pozicija igraca je ("+std::to_string(x)+","+std::to_string(y)+")"&lt;&lt; std::endl;
			if (rezultat==Status::KrajPobjeda) {
				std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
				for (int i=0; i&lt;polja.size(); i++) {
					for (int j=0; j&lt;polja.at(i).size(); j++) {
						polja.at(i).at(j)=Polje::Prazno;
					}
				}
				throw std::runtime_error("Igra zavrsena");
			}
			if (rezultat==Status::KrajPoraz) {
				std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
				for (int i=0; i&lt;polja.size(); i++) {
					for (int j=0; j&lt;polja.at(i).size(); j++) {
						polja.at(i).at(j)=Polje::Prazno;
					}
				}
				throw std::runtime_error("Igra zavrsena");
			}
		}
		catch(std::out_of_range e) {
<a name="9"></a><font color="#FF00FF"><a href="match622-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

			std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
		}
		catch(std::logic_error e) {
			std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
		}
	}
	else if (komanda==Komande::PomjeriDalje) {
</font>		try {
			Status rezultat;
			rezultat=Idi(polja, x, y, p_x, p_y);
			std::cout &lt;&lt; "Tekuca pozicija igraca je ("+std::to_string(x)+","+std::to_string(y)+")"&lt;&lt; std::endl;
			if (rezultat==Status::KrajPobjeda) {
				std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
				for (int i=0; i&lt;polja.size(); i++) {
					for (int j=0; j&lt;polja.at(i).size(); j++) {
						polja.at(i).at(j)=Polje::Prazno;
					}
				}
				throw std::runtime_error("Igra zavrsena");
			}
			if (rezultat==Status::KrajPoraz) {
				std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
				for (int i=0; i&lt;polja.size(); i++) {
					for (int j=0; j&lt;polja.at(i).size(); j++) {
						polja.at(i).at(j)=Polje::Prazno;
					}
				}
				throw std::runtime_error("Igra zavrsena");
			}
		}
		catch(std::out_of_range e) {
<a name="10"></a><font color="#FF0000"><a href="match622-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

			std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
		}
		catch(std::logic_error e) {
			std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
		}
	}
	else if (komanda==Komande::ZavrsiIgru) {
</font>		for (int i=0; i&lt;polja.size(); i++) {
			for (int j=0; j&lt;polja.at(i).size(); j++) {
				polja.at(i).at(j)=Polje::Prazno;
			}
		}
		throw std::runtime_error("Igra zavrsena");
	}
}

int main ()
{
	
	return 0;
}</pre>
</body>
</html>
