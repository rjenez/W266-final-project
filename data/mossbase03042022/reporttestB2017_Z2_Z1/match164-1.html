<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student9160.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4959.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

enum class Polje    { Prazno,Posjeceno,Mina,BlokiranoPrazno,BlokiranoPosjeceno,BlokiranoMina };
enum class Smjerovi { GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo };
enum class Status   { NijeKraj, KrajPoraz, KrajPobjeda };
enum class KodoviGresaka { PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar };

<a name="1"></a><font color="#00FF00"><a href="match164-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_37.gif"/></a>

enum class Komande { PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru };


typedef std::vector&lt; std::vector&lt;Polje&gt;&gt; Tabla;

// test za matricu mina
bool Test(std::vector&lt;std::vector&lt;int&gt;&gt; mat){
	for(int i(0);i&lt;mat.size();i++)
		if(mat.at(i).size()!=2)return true;
	return false;	
}

// radi ispravno
Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	
	// provjera formata mina
	if(Test(mine))throw std::domain_error("Ilegalan format zadavanja mina");
	
	// kreiranje inicijalne table
	std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla(n,std::vector&lt;Polje&gt;(n,Polje::Prazno));
	
	// kreiranje mina na mapi
	for(int i(0);i&lt;mine.size();i++)
		tabla.at(mine.at(i).at(0)).at(mine.at(i).at(1)) = Polje::Mina;
	
	return tabla;
}
// RADIIIIIIIIIII F JEAAHH
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	
	if(x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.size() ){
		std::cout&lt;&lt;"Polje ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;") ne postoji";
		throw std::domain_error("");
		
	}
	std::vector&lt;std::vector&lt;int&gt;&gt; komsije;
	// locirati sva okolna polja(ukupno 9)
	for(int xoff(-1); xoff &lt;= 1; xoff++){
		std::vector&lt;int&gt; pom2;
		for(int yoff(-1); yoff &lt;= 1; yoff++){
			
			int i(x+xoff), j(x+yoff);
			// susjedna celija pokupi broj mina okolo sebe i trpa se u vektor
			if(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; polja.size() &amp;&amp; j &lt; polja.size()){
				int mine(0);
				// svaki susjed ima 9 novih susjeda i broji mine u svom komsiluku
				for(int xoff1(-1);xoff1&lt;=1;xoff1++){
					for(int yoff1(-1);yoff1&lt;=1;yoff1++){
						
						int i1(i+xoff1), j1(j+yoff1);
						// if radi testiranja indexa
						if(i1 &gt;= 0 &amp;&amp; j1 &gt;= 0 &amp;&amp; i1 &lt; polja.size() &amp;&amp; j1 &lt; polja.size() )
							if(polja.at(i1).at(j1)==Polje::Mina)mine++;
					}
				}
				if( polja.at(i).at(j)==Polje::Mina)mine--;
				// prebrojao je mine i salje informaciju u vektor
				pom2.push_back(mine);
			}
			
		}
		// kad tri komsije prikupe informacije saljemo informacje vektora u matricu i praznimo vektor
		komsije.push_back(pom2);
	}
	// kad smo prikupili informacije o minama saljemo ih deminerima
	return komsije;
}
void BlokirajPolje(Tabla &amp;polja, int x, int y){
	
	if(x&lt;0 || y&lt;0 || y&gt;=polja.size() || x&gt;=polja.size()){
		std::cout&lt;&lt;"Polje ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;") ne postoji";
		throw std::domain_error("");
	}
	
	if(polja.at(x).at(y)==Polje::Prazno)
		polja.at(x).at(y)=Polje::BlokiranoPrazno;
</font>	else if(polja.at(x).at(y)==Polje::Mina)
		polja.at(x).at(y)=Polje::BlokiranoMina;
	else if(polja.at(x).at(y)==Polje::Posjeceno)
<a name="2"></a><font color="#0000FF"><a href="match164-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

		polja.at(x).at(y)=Polje::BlokiranoPosjeceno;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&lt;0 || y&lt;0 || y&gt;=polja.size() || x&gt;=polja.size()){
		std::cout&lt;&lt;"Polje ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;") ne postoji";
		throw std::domain_error("");
	}
	
	if(polja.at(x).at(y)==Polje::BlokiranoPrazno)
		polja.at(x).at(y)=Polje::Prazno;
</font>	else if(polja.at(x).at(y)==Polje::BlokiranoPosjeceno)
<a name="0"></a><font color="#FF0000"><a href="match164-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_44.gif"/></a>

		polja.at(x).at(y)=Polje::Posjeceno;
	else if(polja.at(x).at(y)==Polje::BlokiranoMina)
		polja.at(x).at(y)=Polje::Mina;
}
bool Blokirano(Polje p){
	return(p == Polje::BlokiranoPosjeceno || p == Polje::BlokiranoPrazno || p == Polje::BlokiranoMina);
}
bool NemaPraznih(const Tabla &amp;tabla){
	for(int i(0);i&lt;tabla.size();i++){
		for(int j(0);j&lt;tabla.size();j++){
			if(tabla.at(i).at(j)==Polje::Prazno)return false;
		}
	}
	return true;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	int x1(x),y1(y);
	if(smjer == Smjerovi::Gore)  x1--;
	else if(smjer == Smjerovi::Dolje) x1++;
	else if(smjer == Smjerovi::Desno) y1++;
	else if(smjer == Smjerovi::Lijevo) y1--;
	else if(smjer == Smjerovi::GoreDesno ) { x1--; y1++;}
	else if(smjer == Smjerovi::GoreLijevo ){ x1--; y1--;}
	else if(smjer == Smjerovi::DoljeDesno ){ x1++; y1++;}
	else if(smjer == Smjerovi::DoljeLijevo){ x1++; y1--;}
	
	if(x1&lt;0 || y1&lt;0 || x1&gt;=polja.size() || y1 &gt;= polja.size()){
		
		throw std::out_of_range("Izlazak izvan igrace table");
	}
	else if( Blokirano( polja.at(x1).at(y1) ) ){
		throw std::logic_error("Blokirano polje");
	}	
	else {
		polja.at(x).at(y) = Polje::Posjeceno;
		x = x1; y = y1;
	}
	
	if( polja.at(x).at(y) == Polje::Mina ){
		for(int i(0);i&lt;polja.size();i++)
			for(int j(0);j&lt;polja.size();j++)
				polja.at(i).at(j) = Polje::Prazno;
		return Status::KrajPoraz;
	} 
	else if( NemaPraznih(polja))return Status::KrajPobjeda;
	else return Status::NijeKraj;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	
	if(novi_x&lt;0 || novi_x&gt;=polja.size() || novi_y&lt;0 || novi_y&gt;=polja.size())
		throw std::out_of_range("Izlazak izvan igrace table");
	else if(Blokirano( polja.at(novi_x).at(novi_y) ) )
		throw std::logic_error("Blokirano polje");
	else{
		polja.at(x).at(y) = Polje::Posjeceno;
		x = novi_x; y = novi_y;
	}
	if( polja.at(x).at(y) == Polje::Mina ){
		
		for(int i(0);i&lt;polja.size();i++)
			for(int j(0);j&lt;polja.size();j++)
				polja.at(i).at(j) = Polje::Prazno;
		return Status::KrajPoraz;
		
	}
	else if( NemaPraznih(polja))return Status::KrajPobjeda;
	else return Status::NijeKraj;
}

void PrijaviGresku(KodoviGresaka g){
	if(g==KodoviGresaka::PogresnaKomanda)std::cout&lt;&lt;"Nerazumljiva komanda";
	else if(g==KodoviGresaka::NedostajeParametar)std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden";
	else if(g==KodoviGresaka::NeispravanParametar)std::cout&lt;&lt;"Parametar komande nije ispravan";
	else if(g==KodoviGresaka::SuvisanParametar)std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande";
}
bool UnosKomande(Komande &amp;komande, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	
	return false;
</font>}
int main ()
{
	
	return 0;
}</pre>
</body>
</html>
