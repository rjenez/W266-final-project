<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student6877.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student6877.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;



enum class Polje { Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina } ;
enum class Smjerovi { GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo };
enum class Status { NijeKraj, KrajPobjeda, KrajPoraz };
enum class KodoviGresaka { PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar };
enum class Komande { PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru };

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	if(n&lt;=0) throw std::domain_error("Ilegalna velicina");
	Tabla polja (n, std::vector&lt;Polje&gt;(n));
	for(int i(0);i&lt;mine.size();i++){
		if(mine.at(i).size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
	}
	for(int i(0);i&lt;mine.size();i++){
		for(int j(0);j&lt;mine.at(i).size();j++){
			if(mine.at(i).at(j)&lt;0 || mine.at(i).at(j)&gt;n) throw std::domain_error("Ilegalne pozicije mina");
		}
	}
	for(int i(0);i&lt;mine.size();i++){
		polja.at(mine.at(i).at(0)).at(mine.at(i).at(1))=Polje::Mina;
	}
<a name="12"></a><font color="#0000FF"><a href="match226-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	return polja;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	if(x&lt;0 || x&gt;polja.size() || y&lt;0 || y&gt;polja.size()) throw std::domain_error("Polje(x,y) ne postoji");
</font><a name="9"></a><font color="#FF00FF"><a href="match226-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	std::vector&lt;std::vector&lt;int&gt;&gt; okolina(3,std::vector&lt;int&gt;(3));
	int ogrx1(x-1),ogrx2(x+1),ogry1(y-1),ogry2(y+1);
</font>	if(ogrx1&lt;0) ogrx1=0;
	if(ogry1&lt;0) ogry1=0;
	if(ogrx2&gt;polja.size()) ogrx2=polja.size();
	if(ogry2&gt;polja.size()) ogry2=polja.size();
	int i(0),j(0);
	for(int k(ogrx1);k&lt;=ogrx2;k++){
		for(int l(ogry1);l&lt;=ogry2;l++){
			int ogrk1(k-1),ogrk2(k+1),ogrl1(l-1),ogrl2(l+1);
	 		if(ogrk1&lt;0) ogrk1=0;
			if(ogrl1&lt;0) ogrl1=0;
			if(ogrk2&gt;polja.size()) ogrk2=polja.size();
			if(ogrl2&gt;polja.size()) ogrl2=polja.size();
				for(int m(ogrk1);m&lt;=ogrk2;m++){
					for(int n(ogrl1);n&lt;=ogrl2;n++){
						if(!(k==m &amp;&amp; l==n)) {
							if(polja.at(m).at(n)==Polje::Mina) okolina.at(i).at(j)++;
						}
					}
				
				}
				j++;
		}
		j=0;
		i++;
	}
	return okolina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
<a name="10"></a><font color="#FF0000"><a href="match226-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	if(x&lt;0 || y&lt;0 || polja.size()&lt;x || polja.size()&lt;y) throw std::domain_error("Polje (x,y) ne postoji");
	if(polja.at(x).at(y)==Polje::Prazno) polja.at(x).at(y)=Polje::BlokiranoPrazno;
</font>	if(polja.at(x).at(y)==Polje::Posjeceno) polja.at(x).at(y)=Polje::BlokiranoPosjeceno;
	if(polja.at(x).at(y)==Polje::Mina) polja.at(x).at(y)=Polje::BlokiranoMina;
}

void DeblokirajPolje(Tabla &amp;polja, int x , int y){
<a name="11"></a><font color="#00FF00"><a href="match226-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	if(x&lt;0 || y&lt;0 || polja.size()&lt;x || polja.size()&lt;y) throw std::domain_error("Polje (x,y) ne postoji");
	if(polja.at(x).at(y)==Polje::BlokiranoPrazno) polja.at(x).at(y)=Polje::Prazno;
</font>	if(polja.at(x).at(y)==Polje::BlokiranoPosjeceno) polja.at(x).at(y)=Polje::Posjeceno;
	if(polja.at(x).at(y)==Polje::BlokiranoMina) polja.at(x).at(y)=Polje::Mina;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	int pomx(x),pomy(y);
	if(smjer==Smjerovi::GoreLijevo){
<a name="5"></a><font color="#FF0000"><a href="match226-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

		if(x-1&lt;0 || y-1&lt;0) throw std::out_of_range("Izlazak van igrace table");
		if(polja.at(x-1).at(y-1)==Polje::BlokiranoPosjeceno || polja.at(x-1).at(y-1)==Polje::BlokiranoPrazno || polja.at(x-1).at(y-1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		if(polja.at(x-1).at(y-1)==Polje::Mina){ 
			for(int i(0);i&lt;polja.size();i++){
				for(int j(0);j&lt;polja.at(i).size();j++){
					polja.at(i).at(j)=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		x--;
		y--;
	}
	if(smjer==Smjerovi::Gore){
<a name="8"></a><font color="#00FFFF"><a href="match226-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

		if(x-1&lt;0) throw std::out_of_range("Izlazak van igrace table");
		if(polja.at(x-1).at(y)==Polje::BlokiranoPosjeceno || polja.at(x-1).at(y)==Polje::BlokiranoPrazno || polja.at(x-1).at(y)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		if(polja.at(x-1).at(y)==Polje::Mina){ 
			for(int i(0);i&lt;polja.size();i++){
				for(int j(0);j&lt;polja.at(i).size();j++){
					polja.at(i).at(j)=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		x--;
	}
	if(smjer==Smjerovi::GoreDesno){
<a name="2"></a><font color="#0000FF"><a href="match226-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		if(x-1&lt;0 || y+1&gt;polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if(polja.at(x-1).at(y+1)==Polje::BlokiranoPosjeceno || polja.at(x-1).at(y+1)==Polje::BlokiranoPrazno || polja.at(x-1).at(y+1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		if(polja.at(x-1).at(y+1)==Polje::Mina){ 
			for(int i(0);i&lt;polja.size();i++){
				for(int j(0);j&lt;polja.at(i).size();j++){
					polja.at(i).at(j)=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		x--;
		y++;
	}
	
	if(smjer==Smjerovi::Desno){
<a name="3"></a><font color="#00FFFF"><a href="match226-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

		if(y+1&gt;polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if(polja.at(x).at(y+1)==Polje::BlokiranoPosjeceno || polja.at(x).at(y+1)==Polje::BlokiranoPrazno || polja.at(x).at(y+1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		if(polja.at(x).at(y+1)==Polje::Mina){ 
			for(int i(0);i&lt;polja.size();i++){
				for(int j(0);j&lt;polja.at(i).size();j++){
					polja.at(i).at(j)=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		y++;
	}
	if(smjer==Smjerovi::DoljeDesno){
<a name="1"></a><font color="#00FF00"><a href="match226-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

		if(x+1&gt;polja.size() || y+1&gt;polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if(polja.at(x+1).at(y+1)==Polje::BlokiranoPosjeceno || polja.at(x+1).at(y+1)==Polje::BlokiranoPrazno || polja.at(x+1).at(y+1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		if(polja.at(x+1).at(y+1)==Polje::Mina){ 
			for(int i(0);i&lt;polja.size();i++){
				for(int j(0);j&lt;polja.at(i).size();j++){
					polja.at(i).at(j)=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		x++;
		y++;
	}
	
	if(smjer==Smjerovi::Dolje){
<a name="6"></a><font color="#00FF00"><a href="match226-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

		if(x+1&gt;polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if(polja.at(x+1).at(y)==Polje::BlokiranoPosjeceno || polja.at(x+1).at(y)==Polje::BlokiranoPrazno || polja.at(x+1).at(y)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		if(polja.at(x+1).at(y)==Polje::Mina){ 
			for(int i(0);i&lt;polja.size();i++){
				for(int j(0);j&lt;polja.at(i).size();j++){
					polja.at(i).at(j)=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		x++;
	}
	
	if(smjer==Smjerovi::DoljeLijevo){
<a name="4"></a><font color="#FF00FF"><a href="match226-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

		if(x+1&gt;polja.size() || y-1&lt;0) throw std::out_of_range("Izlazak van igrace table");
		if(polja.at(x+1).at(y-1)==Polje::BlokiranoPosjeceno || polja.at(x+1).at(y-1)==Polje::BlokiranoPrazno || polja.at(x+1).at(y-1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		if(polja.at(x+1).at(y-1)==Polje::Mina){ 
			for(int i(0);i&lt;polja.size();i++){
				for(int j(0);j&lt;polja.at(i).size();j++){
					polja.at(i).at(j)=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
	}
	
	if(smjer==Smjerovi::Lijevo){
<a name="7"></a><font color="#0000FF"><a href="match226-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		if(y-1&lt;0) throw std::out_of_range("Izlazak van igrace table");
		if(polja.at(x).at(y-1)==Polje::BlokiranoPosjeceno || polja.at(x).at(y-1)==Polje::BlokiranoPrazno || polja.at(x).at(y-1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		if(polja.at(x).at(y-1)==Polje::Mina){ 
			for(int i(0);i&lt;polja.size();i++){
				for(int j(0);j&lt;polja.at(i).size();j++){
					polja.at(i).at(j)=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		x++;
		y--;
	}
	polja.at(pomx).at(pomy)=Polje::Posjeceno;
	for(int i(0);i&lt;polja.size();i++){
<a name="0"></a><font color="#FF0000"><a href="match226-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

		for(int j(0);j&lt;polja.size();j++){
			if(polja.at(i).at(j)==Polje::Prazno) return Status::NijeKraj; 
		}
	}
	return Status::KrajPobjeda;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	if(novi_x&lt;0 || novi_y&lt;0 || novi_x&gt;polja.size() ||novi_y&gt;polja.size()) throw std::out_of_range("Izlazak van igrace table");
	if(polja.at(novi_x).at(novi_y)==Polje::BlokiranoPosjeceno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoPrazno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>	if(polja.at(novi_x).at(novi_y)==Polje::Mina) {
		for(int i(0);i&lt;polja.size();i++){
			for(int j(0);j&lt;polja.at(i).size();j++){
				polja.at(i).at(j)=Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	polja.at(x).at(y)=Polje::Posjeceno;
	x=novi_x;
	y=novi_y;
	for(int i(0);i&lt;polja.size();i++){
<a name="13"></a><font color="#00FFFF"><a href="match226-1.html#13" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		for(int j(0);j&lt;polja.size();j++){
			if(polja.at(i).at(j)==Polje::Prazno) return Status::NijeKraj; 
		}
	}
	return Status::KrajPobjeda;
}

void PrijaviGresku(KodoviGresaka greska){
</font>	if(greska==KodoviGresaka::PogresnaKomanda) std::cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;std::endl;
	if(greska==KodoviGresaka::NedostajeParametar) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;std::endl;
	if(greska==KodoviGresaka::NeispravanParametar) std::cout&lt;&lt;"Parametar komande nije spravan!"&lt;&lt;std::endl;
	if(greska==KodoviGresaka::SuvisanParametar) std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;std::endl;
}

/*
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	std::cout&lt;&lt;"Unesite komandu: ";
	std::string kom;
	std::cin&gt;&gt;kom;
	if(kom=="K") komanda=Komande::KreirajIgru;
	if(kom=="Z") komanda=Komande::ZavrsiIgru;
	if(kom=="PO") komanda=Komande::PrikaziOkolinu;
	if(kom=="P1 GL") {
		komanda=Komande::PomjeriJednoMjesto;
		smjer::Smjerovi::GoreLijevo;
	}
	if(kom=="P1 G"){
		komanda=Komande::PomjeriJednoMjesto;
		smjer=Smjerovi::Gore;
	}
	if(kom=="P1 GD"){
		komanda=Komande::PomjeriJednoMjesto;
		smjer=Smjerovi::GoreDesno;
	}
	if(kom=="P1 D"){
		komanda=Komande::PomjeriJednoMjesto;
		smjer=Smjerovi::Desno;
	}
	if(kom=="P1 DoD"){
		komanda=Komande::PomjeriJednoMjesto;
		smjer=Smjerovi::DoljeDesno;
	}
	if(kom=="P1 Do"){
		komanda=Komande::PomjeriJednoMjesto;
		smjer=Smjerovi::Dolje;
	}
	if(kom=="P1 DoL"){
		komanda=Komande::PomjeriJednoMjesto;
		smjer=Smjerovi::DoljeLijevo;
	}
	if(kom=="P1 L"){
		komanda=Komande::PomjeriJednoMjesto;
		smjer=Smjerovi::Lijevo;
	}
}
*/
void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0);




int main ()
{
	
	return 0;
}</pre>
</body>
</html>
