<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student3485.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5261.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

enum class Polje {
Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi {
GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande {
<a name="1"></a><font color="#00FF00"><a href="match128-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_26.gif"/></a>

    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;m)
{
	if(n &lt;= 0) throw std::domain_error ("Ilegalna velicina");
	Tabla t(n, std::vector&lt;Polje&gt; (n, Polje::Prazno));
	for(int i=0; i&lt;m.size(); i++)
		if(m[i].size() != 2) 
			throw std::domain_error ("Ilegalan format zadavanja mina");
	for(int i=0; i&lt;m.size(); i++)
	{
		for(int j=0; j&lt;m[i].size(); j++)
		if(m[i][j]&lt;0 || m[i][j] &gt;=n)
			throw std::domain_error ("Ilegalne pozicije mina");
	}
	for(int i=0; i&lt;m.size(); i++)
		if(!(m[i][0] == 0  &amp;&amp; m[i][1] == 0))
			t[m[i][0]][m[i][1]] = Polje::Mina;
			
	return t;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polje, int x, int y)
{
	if(x&lt;0 || x&gt;=polje.size() || y&lt;0 || y&gt;=polje.size())
		throw std::domain_error ("Polje ("+ std::to_string(x) + "," + std::to_string(y) + ") ne postoji!");
	std::vector&lt;std::vector&lt;int&gt;&gt; O(3);
	int red(0);
	for(int i=x-1; i&lt;=x+1; i++)
	{
		for(int j=y-1; j&lt;=y+1; j++)
		{
			int br_mina(0);
			for(int k=i-1; k&lt;=i+1; k++)
			{
				for(int l=j-1; j&lt;=j+1; j++)
				{
					if(i&gt;=0 &amp;&amp; j&gt;=0 &amp;&amp; i&lt;polje.size() &amp;&amp; j&lt;polje[0].size() &amp;&amp; k&gt;=0 &amp;&amp; l&gt;=0 &amp;&amp; k&lt;polje.size() &amp;&amp; l&lt;=polje[0].size()
					&amp;&amp; !(k==i &amp;&amp; l==j) &amp;&amp; !(k==x &amp;&amp; l==y) &amp;&amp; polje[k][l] == Polje::Mina)
						br_mina++;
				}
			}
			O[red].push_back(br_mina);
		}
		red++;
	}
	return O;
}

void BlokirajPolje(Tabla &amp;polje, int x, int y)
{
	if(x&lt;0 || x&gt;=polje.size() || y&lt;0 || y&gt;=polje[0].size())
		throw std::domain_error ("Polje ("+ std::to_string(x) + "," + std::to_string(y) + ") ne postoji!");
	else if(polje[x][y] == Polje::Prazno) polje[x][y] = Polje::BlokiranoPrazno;
</font>	else if(polje[x][y] == Polje::Mina) polje[x][y] = Polje::BlokiranoMina;
<a name="2"></a><font color="#0000FF"><a href="match128-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

	else if(polje[x][y] == Polje::Posjeceno) polje[x][y] = Polje::BlokiranoPosjeceno;
}
 void DeblokirajPolje(Tabla &amp;polje, int x, int y)
 {
 	if(x&lt;0 || x&gt;=polje.size() || y&lt;0 || y&gt;=polje[0].size())
		throw std::domain_error ("Polje ("+ std::to_string(x) + "," + std::to_string(y) + ") ne postoji!");
	else if(polje[x][y] == Polje::BlokiranoPrazno) polje[x][y] = Polje::Prazno;
</font>	else if(polje[x][y] == Polje::BlokiranoMina) polje[x][y] = Polje::Mina;
<a name="0"></a><font color="#FF0000"><a href="match128-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_59.gif"/></a>

	else if(polje[x][y] == Polje::BlokiranoPosjeceno) polje[x][y] = Polje::Posjeceno;
 }

Status Idi(Tabla &amp;polje, int x, int y, Smjerovi s)
{
	if(s == Smjerovi::GoreLijevo)
	{
		if(x-1 &lt; 0 || y-1 &lt; 0)
			throw std::out_of_range ("Izlazak van igrace table");
		else if(polje[x-1][y-1] != Polje::BlokiranoPosjeceno &amp;&amp; polje[x-1][y-1] != Polje::BlokiranoMina &amp;&amp; polje[x-1][y-1] != Polje::BlokiranoPrazno) 
		{
			polje[x][y] = Polje::Posjeceno;
			x = x-1;
			y = y-1;
		}
		else throw std::logic_error ("Blokirano polje");
	}
	else if(s == Smjerovi::GoreDesno)
	{
		if(x-1 &lt; 0 || y+1 &gt;= polje[0].size())
			throw std::out_of_range ("Izlazak van igrace table");
		else if(polje[x-1][y+1] != Polje::BlokiranoPosjeceno &amp;&amp; polje[x-1][y+1] != Polje::BlokiranoMina &amp;&amp; polje[x-1][y+1] != Polje::BlokiranoPrazno)
		{
			polje[x][y] = Polje::Posjeceno;
			x = x-1;
			y = y+1;
		}
		else throw std::logic_error ("Blokirano polje");
	}
	else if(s == Smjerovi::Gore)
	{
		if(x-1 &lt; 0)
			throw std::out_of_range ("Izlazak van igrace table");
		else if(polje[x-1][y] != Polje::BlokiranoPosjeceno &amp;&amp; polje[x-1][y] != Polje::BlokiranoMina &amp;&amp; polje[x-1][y] != Polje::BlokiranoPrazno)
		{
			polje[x][y] = Polje::Posjeceno;
			x = x-1;
		}
		else throw std::logic_error ("Blokirano polje");
	}
	else if(s == Smjerovi::Desno)
	{
		if(y+1 &gt;= polje[0].size())
			throw std::out_of_range ("Izlazak van igrace table");
		else if(polje[x][y+1] != Polje::BlokiranoPosjeceno &amp;&amp; polje[x][y+1] != Polje::BlokiranoMina &amp;&amp; polje[x][y+1] != Polje::BlokiranoPrazno)
		{
			polje[x][y] = Polje::Posjeceno;
			y = y+1;
		}
		else throw std::logic_error ("Blokirano polje");
	}
	else if(s == Smjerovi::Dolje)
	{
		if(x+1 &gt;= polje.size())
			throw std::out_of_range ("Izlazak van igrace table");
		else if(polje[x+1][y] != Polje::BlokiranoPosjeceno &amp;&amp; polje[x+1][y] != Polje::BlokiranoMina &amp;&amp; polje[x+1][y] != Polje::BlokiranoPrazno)
		{
			polje[x][y] = Polje::Posjeceno;
			x = x+1;
		}
		else throw std::logic_error ("Blokirano polje");
	}
	else if(s == Smjerovi::Lijevo)
	{
		if(y-1 &lt; 0)
			throw std::out_of_range ("Izlazak van igrace table");
		else if(polje[x][y-1] != Polje::BlokiranoPosjeceno &amp;&amp; polje[x][y-1] != Polje::BlokiranoMina &amp;&amp; polje[x][y-1] != Polje::BlokiranoPrazno)
		{
			polje[x][y] = Polje::Posjeceno;
		}
		else throw std::logic_error ("Blokirano polje");
	}
	else if(s == Smjerovi::DoljeLijevo)
	{
		if(x+1 &gt;= polje.size() || y+1 &gt;= polje[0].size())
			throw std::out_of_range ("Izlazak van igrace table");
		else if(polje[x+1][y-1] != Polje::BlokiranoPosjeceno &amp;&amp; polje[x+1][y-1] != Polje::BlokiranoMina &amp;&amp; polje[x+1][y-1] != Polje::BlokiranoPrazno)
		{
			polje[x][y] = Polje::Posjeceno;
			x = x+1;
			y = y-1;
		}
		else throw std::logic_error ("Blokirano polje");
	}
	else if(s == Smjerovi::DoljeDesno)
	{
		if(x+1 &gt;= polje.size() || y+1 &gt;= polje[0].size())
			throw std::out_of_range ("Izlazak van igrace table");
		else if(polje[x+1][y+1] != Polje::BlokiranoPosjeceno &amp;&amp; polje[x+1][y+1] != Polje::BlokiranoMina &amp;&amp; polje[x+1][y+1] != Polje::BlokiranoPrazno)
		{
			polje[x][y] = Polje::Posjeceno;
			x = x+1;
			y = y+1;
		}
		else throw std::logic_error ("Blokirano polje");
	}
	
	if(polje[x][y] == Polje::Mina)
	{
		for(int i=0; i&lt;polje.size(); i++)
		{
			for(int j=0; j&lt;polje[i].size(); j++)
			{
				polje[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	else 
	{
		for(int i=0; i&lt;polje.size(); i++)
		{
			for(int j=0; j&lt;polje[i].size(); j++)
			{
				if(i != x &amp;&amp; j != y &amp;&amp; polje[x][y] == Polje::Prazno) 
					return Status::NijeKraj;
			}
		}
		
		return Status::KrajPobjeda;
	}
}

Status Idi(Tabla &amp;polje, int &amp;x, int &amp;y, int a, int b)
{
	if(a&lt;0 || a&gt;= polje.size() || b&lt;0 || b&gt;=polje.size())
		throw std::out_of_range ("Izlazak van igrace table");
	if(polje[a][b] != Polje::BlokiranoPosjeceno &amp;&amp; polje[a][b] != Polje::BlokiranoMina &amp;&amp; polje[a][b] != Polje::BlokiranoPrazno)
	{
		x = a;
		y = b;
	}
	else throw std::logic_error ("Blokirano polje");
	if(polje[x][y] == Polje::Mina)
	{
		for(int i=0; i&lt;polje.size(); i++)
		{
			for(int j=0; j&lt;polje[i].size(); j++)
			{
				polje[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	else 
	{
		for(int i=0; i&lt;polje.size(); i++)
		{
			for(int j=0; j&lt;polje[i].size(); j++)
			{
				if(i != x &amp;&amp; j != y &amp;&amp; polje[x][y] == Polje::Prazno) 
					return Status::NijeKraj;
			}
		}
		
		return Status::KrajPobjeda;
	}
}

void PrjaviGresku(KodoviGresaka &amp;g)
{
	if(g == KodoviGresaka::PogresnaKomanda)
		std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl;
	else if(g == KodoviGresaka::NedostajeParametar) 
</font>		std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
	else if(g == KodoviGresaka::NeispravanParametar)
<a name="3"></a><font color="#00FFFF"><a href="match128-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		std::cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; std::endl;
	else if(g == KodoviGresaka::SuvisanParametar)
		std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt; std::endl;
}

/*bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	
}*/
int main()
{
	return 0;
</font>}</pre>
</body>
</html>
