<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4416.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4903.cpp<p></p><pre>
/*B 2017/2018, Zadaća 2, Zadatak 1

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

<a name="0"></a><font color="#FF0000"><a href="match168-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_47.gif"/></a>

enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, std::vector&lt;std::vector&lt;int&gt;&gt; mine)
{
	int brojac(0);
	for(int i(0); i&lt;mine.size(); i++) if(mine.at(i).size()==2) brojac++;
	if(brojac==0) throw std::domain_error("Ilegalan format zadavanja mina");
	for(int i(0); i&lt;mine.size(); i++)
		if(mine.at(i).size()==2 &amp;&amp; (mine.at(i).at(0)&lt;0 || mine.at(i).at(0)&gt;=n || mine.at(i).at(1)&lt;0 || mine.at(i).at(1)&gt;=n))
			throw std::domain_error("Ilegalne pozicije mina");
	if(n&lt;=0) throw std::domain_error("Ilegalna veličina");
	try {
		Tabla poc(n, std::vector&lt;Polje&gt; (n, Polje::Prazno));
		for(int k(0); k&lt;mine.size(); k++)
			if(mine.at(k).size()==2 &amp;&amp; !(mine.at(k).at(0)==0 &amp;&amp; mine.at(k).at(1)==0)) {
				poc.at(mine.at(k).at(0)).at(mine.at(k).at(1))=Polje::Mina;
			}
		return poc;
	} catch(std::bad_alloc) {
		throw;
	}
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(Tabla tabla, int x, int y)
{
	if(x&lt;0 || x&gt;=tabla.size() || y&lt;0 || y&gt;=tabla.at(0).size()) throw std::domain_error("Polje (x,y) ne postoji");
	std::vector&lt;std::vector&lt;int&gt;&gt; br_mina(3, std::vector&lt;int&gt; (3, 0));
	for(int i(x-1); i&lt;=x+1; i++) {
		for(int j(y-1); j&lt;=y+1; j++) {
			if(i&gt;=0 &amp;&amp; i&lt;tabla.size() &amp;&amp; j&gt;=0 &amp;&amp; j&lt;tabla.size()) {
				int suma(0);
				for(int i1(i-1); i1&lt;=i+1; i1++) {
					for(int j1(j-1); j1&lt;=j+1; j1++)
						if(i1&gt;=0 &amp;&amp; i1&lt;tabla.size() &amp;&amp; j1&gt;=0 &amp;&amp; j1&lt;tabla.size() &amp;&amp; 
						tabla.at(i1).at(j1)==Polje::Mina &amp;&amp; !(i1==x &amp;&amp; j1==y) &amp;&amp; !(i1==i &amp;&amp; j1==j)) suma++;
				}
				br_mina.at(i-x+1).at(j-y+1)=suma;
			}
		}
	}
	return br_mina;
}

void BlokirajPolje(Tabla &amp;tabla, int x, int y){
	if(x&lt;0 || x&gt;=tabla.size() || y&lt;0 || y&gt;=tabla.at(0).size()) throw std::domain_error("Polje (x,y) ne postoji");
	if(tabla.at(x).at(y)==Polje::Prazno) tabla.at(x).at(y)=Polje::BlokiranoPrazno;
</font>	else if(tabla.at(x).at(y)==Polje::Mina) tabla.at(x).at(y)=Polje::BlokiranoMina;
<a name="2"></a><font color="#0000FF"><a href="match168-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

	else if(tabla.at(x).at(y)==Polje::Posjeceno) tabla.at(x).at(y)=Polje::BlokiranoPosjeceno;
}

void DeblokirajPolje(Tabla &amp;tabla, int x, int y){
	if(x&lt;0 || x&gt;=tabla.size() || y&lt;0 || y&gt;=tabla.at(0).size()) throw std::domain_error("Polje (x,y) ne postoji");
	if(tabla.at(x).at(y)==Polje::BlokiranoPrazno) tabla.at(x).at(y)=Polje::Prazno;
</font><a name="1"></a><font color="#00FF00"><a href="match168-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_39.gif"/></a>

	else if(tabla.at(x).at(y)==Polje::BlokiranoMina) tabla.at(x).at(y)=Polje::Mina;
	else if(tabla.at(x).at(y)==Polje::BlokiranoPosjeceno) tabla.at(x).at(y)=Polje::Posjeceno;
}

enum class Smjerovi {
 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

void Idi(Tabla &amp;tabla, int &amp;x, int &amp;y, Smjerovi smjer){
	if(smjer==Smjerovi::GoreLijevo){x--; y--; }
	else if(smjer==Smjerovi::Gore) x--;
	else if(smjer==Smjerovi::GoreDesno) {x--; y++; }
	else if(smjer==Smjerovi::Desno) y++;
	else if(smjer==Smjerovi::DoljeDesno) {x++; y++; }
	else if(smjer==Smjerovi::Dolje) x++;
	else if(smjer==Smjerovi::DoljeLijevo) {x++; y--; }
	else y--;
	tabla.at(x).at(y)=Polje::Posjeceno;
}

enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};

Status Idi(Tabla &amp;tabla, int &amp;x, int &amp;y, int x1, int y1){
	if(x1&lt;0 || x1&gt;=tabla.size() || y1&lt;0 || y1&gt;=tabla.at(0).size()) throw std::out_of_range("Izlazak van igrace table");
	if(tabla.at(x1).at(y1)==Polje::BlokiranoMina || tabla.at(x1).at(y1)==Polje::BlokiranoPosjeceno || tabla.at(x1).at(y1)==Polje::BlokiranoPrazno)
		throw std::logic_error("Blokirano polje");
	x=x1; y=y1;
	if(tabla.at(x1).at(y1)==Polje::Mina){
		tabla=std::vector&lt;std::vector&lt;Polje&gt;&gt; (tabla.size(), std::vector&lt;Polje&gt; (tabla.size(), Polje::Prazno));
		return Status::KrajPoraz;
	}
	if(tabla.at(x1).at(y1)==Polje::Prazno){
		int brojac(0);
		for(int i(0); i&lt;tabla.size(); i++){
			for(int j(0); j&lt;tabla.size(); j++){
				if(!(i==x1 &amp;&amp; j==y1) &amp;&amp; tabla.at(i).at(j)==Polje::Prazno) brojac++; 
			}
		}
		if(brojac==0) return Status::KrajPobjeda;
	}
	return Status::NijeKraj;
}

enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar
};

void PrijaviGresku(KodoviGresaka a){
	if(a==KodoviGresaka::PogresnaKomanda) std::cout &lt;&lt; "Nerazumljiva komanda!";
	else if(a==KodoviGresaka::NedostajeParmetar) std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!";
	else if(a==KodoviGresaka::SuvisanParametar) std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!";
	else std::cout &lt;&lt; "Parametar komande nije ispravan!";
}

enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};
/*
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	std::string a;
	std::getline(std::cin, a);
	for(int i(0); i&lt;a.size()-1; i++){
		bool jeste(true);
		if(a.at(i)=='P' &amp;&amp; a.at(i+1)=='1'){
			for(int j(0); j&lt;i; j++) if(a.(j)!=' ') jeste=false;
			for(int j(i+2); j&lt;a.size(); j++)
				if(!(a.at(j)=='G' || a.at(j)=='o' || a.at(j)=='L' || a.at(j)=='D' || a.at(j)==' ')) jeste=false;
			if(jeste){
				for(int j(i+2); j&lt;a.size(); j++){
					std::string b;
					if(a.at(j)=='G' || a.at(j)=='L' || a.at(j)=='D' || a.at(j)==' '){
						while(a.at(j)=='G' || a.at(j)=='L' || a.at(j)=='D' || a.at(j)=='o'){
							b.push_back(a.at(j));
							j++;
						}
						for(int k(j); k&lt;a.size(); k++) if(a.at(k)!=' ') jeste=false;
						break;
					}
					if(jeste){
						if(b==std::string ("GL")) {smjer=Smjerovi::GoreLijevo; return true;}
						else if(b==std::string ("G")) {smjer=Smjerovi::Gore; return true;}
						else if(b==std::string ("GD")) {smjer=Smjerovi::GoreDesno; return true;}
						else if(b==std::string ("D")) {smjer=Smjerovi::Desno; return true;}
						else if(b==std::string ("DoD")) {smjer=Smjerovi::DoljeDesno; return true;}
						else if(b==std::string ("Do")) {smjer=Smjerovi::Dolje; return true;}
						else if(b==std::string ("DoL")) {smjer=Smjerovi::DoljeLijevo; return true;}
						else return false;
					}
					else return false;
				}
			}
			else return false;
		}
/*		else  if(a.at(i)=='P' &amp;&amp; a.at(i+1)=='&gt;'){
			for(int j(0); j&lt;i; j++) if(a.(j)!=' ') jeste=false;
			for(int j(i+2); j&lt;a.size(); j++)
				if(!((a.at(j)&gt;='0' &amp;&amp; a.at(j)&lt;='9') || a.at(j)==' ')) jeste=false;
			if(jeste){
				
			}
		}
	} 
	return true;
}
*/
int main ()
</font>{
	return 0;
}




</pre>
</body>
</html>
