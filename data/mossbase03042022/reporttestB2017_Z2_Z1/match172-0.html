<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4305.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4305.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

enum class Polje {Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};
enum class Smjerovi {GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};
enum class KodoviGresaka {PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
enum class Komande {PomjeriJednoMjesto, PomjeriDalje, Blokkiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};

<a name="0"></a><font color="#FF0000"><a href="match172-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_92.gif"/></a>

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru (int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	for (int i = 0 ; i &lt; mine.size() ; i++) {
		for (int j = 0 ; j &lt; mine.at(i).size() ; j++) {
			if (mine.at(i).size() != 2) throw std::domain_error ("Ilegalan format zadavanja mina");
		}
	}
	for (int i = 0 ; i &lt; mine.size() ; i++) {
		for (int j = 0 ; j &lt; mine.at(i).size() ; j++) {
			if (mine.at(i).at(j) &gt; n)
				throw std::domain_error ("Ilegalne pozicije mina");
		}
	}
	if (n &lt;= 0) throw std::domain_error ("ilegalna velicina");
	Tabla igrica(n, std::vector&lt;Polje&gt;(n));
	for (int i = 0 ; i &lt; mine.size() ; i++) {
		int element1(0), element2(0);
		for (int j = 0 ; j &lt; mine.at(i).size() ; j++) {
			element1 = mine.at(i).at(j);
			element2 = mine.at(i).at(j + 1);
			j++;
		}
		igrica.at(element1).at(element2) = Polje::Mina;
	}
	return igrica;	
}

void BlokirajPolje (Tabla &amp;polja, int x, int y) {
	if (x &gt;= polja.size() || y &gt;= polja.at(0).size()) throw std::domain_error ("Polje (x,y) ne postoji");
	 Polje element(polja.at(x).at(y));
	 if (element == Polje::BlokiranoPrazno || element == Polje::BlokiranoPosjeceno || element == Polje::BlokiranoMina) return;
	 else if (element == Polje::Prazno)
	 	polja.at(x).at(y) = Polje::BlokiranoPrazno;
	 else if (element == Polje::Posjeceno)
	 	polja.at(x).at(y) = Polje::BlokiranoPosjeceno;
	 else if (element == Polje::Mina)
	 	polja.at(x).at(y) = Polje::BlokiranoMina;
}

void DeblokirajPolje (Tabla &amp;polja, int x, int y) {
	if (x &gt;= polja.size() || y &gt;= polja.at(0).size()) throw std::domain_error ("Polje (x,y) ne postoji");
	Polje element (polja.at(x).at(y));
	if (element == Polje::Prazno || element == Polje::Mina || element == Polje::Posjeceno) return;
	else if (element == Polje::BlokiranoPrazno)
		polja.at(x).at(y) = Polje::Prazno;
	else if (element == Polje::BlokiranoPosjeceno)
		polja.at(x).at(y) = Polje::Posjeceno;
	else if (element == Polje::BlokiranoMina)
		polja.at(x).at(y) = Polje::Mina;
}

Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	Polje pozicija(polja.at(x).at(y));
	pozicija = Polje::Posjeceno;
	Polje nova_pozicija;
	if (smjer == Smjerovi::GoreLijevo) {
		x -= 1;
		y -= 1;
		nova_pozicija = polja.at(x).at(y);
	}
	else if (smjer == Smjerovi::Gore) {
		x -= 1;
		nova_pozicija = polja.at(x).at(y);
	}
	else if (smjer == Smjerovi::GoreDesno) {
		x -= 1;
		y += 1;
		nova_pozicija = polja.at(x).at(y);
	}
	else if (smjer == Smjerovi::Lijevo) {
		y -= 1;
		nova_pozicija = polja.at(x).at(y);
	}
	else if (smjer == Smjerovi::Desno) {
		y += 1;
		nova_pozicija = polja.at(x).at(y);
	}
	else if (smjer == Smjerovi::DoljeLijevo) {
		x += 1;
		y -= 1;
		nova_pozicija = polja.at(x).at(y);
	}
	else if (smjer == Smjerovi::Dolje) {
		x += 1;
		nova_pozicija = polja.at(x).at(y);
	}
	else if (smjer == Smjerovi::DoljeDesno) {
		x += 1;
		y += 1;
		nova_pozicija = polja.at(x).at(y);
	}
	if (nova_pozicija == Polje::BlokiranoPosjeceno || nova_pozicija == Polje::BlokiranoPrazno || nova_pozicija == Polje::BlokiranoMina)
			throw std::logic_error ("Blokirano polje");
	if (nova_pozicija == Polje::Mina) {
		for (int i = 0 ; i &lt; polja.size() ; i++) {
			for (int j = 0 ; j &lt; polja.at(i).size() ; j++) {
				polja.at(i).at(j) == Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	for (int i = 0 ; i &lt; polja.size() ; i++) {
		for (int j = 0 ; j &lt; polja.at(i).size() ; j++) {
			if (nova_pozicija == Polje::Prazno &amp;&amp; nova_pozicija != pozicija) 
				return Status::NijeKraj;
				break;
		}
	}
	return Status::KrajPobjeda;
}

Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	Polje pozicija (polja.at(x).at(y));
	pozicija = Polje::Posjeceno;
	Polje nova_pozicija (polja.at(novi_x).at(novi_y));
	if (nova_pozicija == Polje::BlokiranoPosjeceno || nova_pozicija == Polje::BlokiranoPrazno || nova_pozicija == Polje::BlokiranoMina)
			throw std::logic_error ("Blokirano polje");
	if (nova_pozicija == Polje::Mina) {
		for (int i = 0 ; i &lt; polja.size() ; i++) {
			for (int j = 0 ; j &lt; polja.at(i).size() ; j++) {
				polja.at(i).at(j) = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	for (int i = 0 ; i &lt; polja.size() ; i++) {
		for (int j = 0 ; j &lt; polja.at(0).size() ; j++) {
			if (nova_pozicija == Polje::Prazno &amp;&amp; nova_pozicija != pozicija) return Status::NijeKraj;
			break;
		}
	}
	return Status::KrajPobjeda;
}

void PrijaviGresku (KodoviGresaka greska) {
	if (greska == KodoviGresaka::PogresnaKomanda)
		std::cout &lt;&lt; "Nerazumljiva komanda!";
	else if (greska == KodoviGresaka::NedostajeParametar)
		std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!";
	else if (greska == KodoviGresaka::NeispravanParametar)
		std::cout &lt;&lt; "Parametar komande nije ispravan!";
	else if (greska == KodoviGresaka::SuvisanParametar)
		std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!";
}

bool UnosKomande (Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
	
}


int main ()
</font>{
	return 0;
}</pre>
</body>
</html>
