<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5122.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5122.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;stdexcept&gt;

enum class Polje {Prazno,Posjeceno,Mina,BlokiranoPrazno,BlokiranoPosjeceno,BlokiranoMina};
enum class Smjerovi {GoreLijevo,Gore,GoreDesno,Desno,DoljeDesno,Dolje,DoljeLijevo,Lijevo};
enum class Status {NijeKraj,KrajPoraz,KrajPobjeda};
enum class KodoviGresaka {PogresnaKomanda,NedostajeParametar,SuvisanParametar,NeispravanParametar};
<a name="7"></a><font color="#0000FF"><a href="match801-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

enum class Komande {PomjeriJednoMjesto,PomjeriDalje,Blokiraj,Deblokiraj,PrikaziOkolinu,ZavrsiOkolinu,KreirajIgru};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;

Tabla KreirajIgru(int n,const Matrica &amp;mine)
</font>{

	if(n&lt;1) throw std::domain_error("Ilegalna velicina");

	Tabla Minesweeper(n,std::vector&lt;Polje&gt; (n,Polje::Prazno));

	for(int i=0; i&lt;mine.size(); i++)
		for(int j=0; j&lt;mine.at(i).size(); j++) {
			if(mine.at(0).size()!=mine.at(i).size() || mine.at(i).size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
			if(mine.at(i).at(j)&gt;n-1 || mine.at(i).at(j)&lt;0) throw std::domain_error("Ilegalne pozicije mine");
		}

	for(int i=0; i&lt;n; i++)
		for(int j=0; j&lt;n; j++)
			for(int k=0; k&lt;mine.size(); k++)
				if(mine.at(k).at(0)==i &amp;&amp; mine.at(k).at(1)==j) {
					Minesweeper.at(i).at(j)=Polje::Mina;
					break;
				}

	return Minesweeper;
}

Tabla ProsiriMinesweeper(Tabla &amp;Minesweeper)
{
	Minesweeper.insert(std::begin(Minesweeper),std::vector&lt;Polje&gt; (Minesweeper.at(0).size(),Polje::Prazno));
	Minesweeper.push_back(std::vector&lt;Polje&gt; (Minesweeper.at(0).size(),Polje::Prazno));
	for(int i=0; i&lt;Minesweeper.size(); i++)
		for(int j=0; j&lt;Minesweeper.at(i).size(); j++)
			if(j==0) Minesweeper.at(i).insert(std::begin(Minesweeper.at(i))+0,Polje::Prazno);

	for(int i=0; i&lt;Minesweeper.size(); i++)
		for(int j=0; j&lt;Minesweeper.at(i).size(); j++)
			if(j==Minesweeper.at(i).size()-1) {
				Minesweeper.at(i).push_back(Polje::Prazno);
				break;
			}

	return Minesweeper;
}

Matrica PrikaziOkolinu(const Tabla &amp;polja,int x,int y)
{

	if(x&lt;0 || y&lt;0 || x&gt;polja.size()-1 || y&gt;polja.at(0).size()-1) {
		std::string Izuzetak("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
		throw std::domain_error(Izuzetak);
	}

	Tabla KopijaMinesweeper(polja);

	if(x==0 || y==0 || x==polja.size() || y==polja.at(0).size()) {
		KopijaMinesweeper=ProsiriMinesweeper(KopijaMinesweeper);
		KopijaMinesweeper=ProsiriMinesweeper(KopijaMinesweeper);
		x=x+2;
		y=y+2;
	}

	if((x==1 &amp;&amp; y&gt;0 &amp;&amp; y&lt;polja.at(0).size()-1)||(y==1 &amp;&amp; x&gt;0 &amp;&amp; x&lt;polja.size()-1)||(x==polja.size()-2 &amp;&amp; y&gt;0 &amp;&amp; y&lt;polja.at(0).size()-1)||(y==polja.at(0).size()-2 &amp;&amp; x&gt;0 &amp;&amp; x&lt;polja.size()-1)) {
		KopijaMinesweeper=ProsiriMinesweeper(KopijaMinesweeper);
		x=x+1;
		y=y+1;
	}

	Matrica IntKopijaMineSweeper;
	IntKopijaMineSweeper.resize(KopijaMinesweeper.size());

	for(int i=0; i&lt;KopijaMinesweeper.size(); i++)
		for(int j=0; j&lt;KopijaMinesweeper.at(i).size(); j++) IntKopijaMineSweeper.at(i).push_back(int(KopijaMinesweeper.at(i).at(j)));

	Matrica PronalazakOkoline;
	PronalazakOkoline.resize(5);
	for(int i=x-2; i&lt;=x+2; i++)
		for(int j=y-2; j&lt;=y+2; j++) PronalazakOkoline.at(i).push_back(IntKopijaMineSweeper.at(i).at(j));

	Matrica OkolineElemenata;
	OkolineElemenata.resize(3);
	int BrojacRedova=0;
	int brojac=0;

	for(int i=x-2; i&lt;=x+2; i++) {
		if(i==x-2 || i==x+2) continue;
		for(int j=y-2; j&lt;=y+2; j++) {
			if(j==y-2 || j==y+2) continue;
			brojac=0;
			for(int k=i-1; k&lt;=i+1; k++)
				for(int l=j-1; l&lt;=j+1; l++) {
					if(k==i &amp;&amp; l==j) continue;
					if(PronalazakOkoline.at(k).at(l)==int(Polje::Mina)) brojac++;
				}
			OkolineElemenata.at(BrojacRedova).push_back(brojac);
		}
		BrojacRedova++;
	}

	return OkolineElemenata;

}

void BlokirajPolje(Tabla &amp;polja,int x,int y)
{
	if(x&lt;0 || y&lt;0 || x&gt;polja.size()-1 || y&gt;polja.at(0).size()-1) {
		std::string Izuzetak("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
		throw std::domain_error(Izuzetak);
	}

	for(int i=0; i&lt;polja.size(); i++)
		for(int j=0; j&lt;polja.at(i).size(); j++) {
			if(i==x &amp;&amp; j==y &amp;&amp; polja.at(i).at(j)==Polje::Prazno) polja.at(i).at(j)=Polje::BlokiranoPrazno;
			if(i==x &amp;&amp; j==y &amp;&amp; polja.at(i).at(j)==Polje::Posjeceno) polja.at(i).at(j)=Polje::BlokiranoPosjeceno;
			if(i==x &amp;&amp; j==y &amp;&amp; polja.at(i).at(j)==Polje::Mina) polja.at(i).at(j)=Polje::BlokiranoMina;
		}
}

void DeblokirajPolje(Tabla &amp;polja,int x,int y)
{

	if(x&lt;0 || y&lt;0 || x&gt;polja.size()-1 || y&gt;polja.at(0).size()-1) {
		std::string Izuzetak("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
		throw std::domain_error(Izuzetak);
	}

	for(int i=0; i&lt;polja.size(); i++)
		for(int j=0; j&lt;polja.at(i).size(); j++) {
			if(i==x &amp;&amp; j==y &amp;&amp; polja.at(i).at(j)==Polje::BlokiranoPrazno) polja.at(i).at(j)=Polje::Prazno;
			if(i==x &amp;&amp; j==y &amp;&amp; polja.at(i).at(j)==Polje::BlokiranoPosjeceno) polja.at(i).at(j)=Polje::Posjeceno;
			if(i==x &amp;&amp; j==y &amp;&amp; polja.at(i).at(j)==Polje::BlokiranoMina) polja.at(i).at(j)=Polje::Mina;

		}
}

Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,Smjerovi smjer)
{

	//Provjeravanje da li cemo nakon pomjeranja izaci iz tabele.

	if(x==0 &amp;&amp; y==0 &amp;&amp; (smjer==Smjerovi::Lijevo || smjer==Smjerovi::GoreLijevo || smjer==Smjerovi::Gore || smjer==Smjerovi::DoljeLijevo || smjer==Smjerovi::GoreDesno)) throw std::out_of_range("Izlazak van igrace table");

	if(x==polja.size()-1 &amp;&amp; y==0 &amp;&amp; (smjer==Smjerovi::Lijevo || smjer==Smjerovi::DoljeLijevo || smjer==Smjerovi::Dolje || smjer==Smjerovi::GoreLijevo || smjer==Smjerovi::DoljeDesno)) throw std::out_of_range("Izlazak van igrace table");

	if(x==0 &amp;&amp; y==polja.at(0).size()-1 &amp;&amp; (smjer==Smjerovi::Gore || smjer==Smjerovi::GoreDesno || smjer==Smjerovi::Desno || smjer==Smjerovi::GoreLijevo || smjer==Smjerovi::DoljeDesno)) throw std::out_of_range("Izlazak van igrace table");

	if(x==polja.size()-1 &amp;&amp; y==polja.at(0).size()-1 &amp;&amp; (smjer==Smjerovi::Dolje || smjer==Smjerovi::DoljeDesno || smjer==Smjerovi::Desno || smjer==Smjerovi::DoljeLijevo || smjer==Smjerovi::GoreDesno)) throw std::out_of_range("Izlazak van igrace table");

	if(x==0 &amp;&amp; y&gt;0 &amp;&amp; y&lt;polja.at(0).size()-1 &amp;&amp; (smjer==Smjerovi::GoreLijevo || smjer==Smjerovi::Gore || smjer==Smjerovi::GoreDesno)) throw std::out_of_range("Izlazak van igrace table");

	if(x==polja.size()-1 &amp;&amp; y&gt;0 &amp;&amp; y&lt;polja.at(0).size()-1 &amp;&amp; (smjer==Smjerovi::DoljeLijevo || smjer==Smjerovi::Dolje || smjer==Smjerovi::DoljeDesno)) throw std::out_of_range("Izlazak van igrace table");

	if(y==0 &amp;&amp; x&gt;0 &amp;&amp; x&lt;polja.size()-1 &amp;&amp; (smjer==Smjerovi::GoreLijevo || smjer==Smjerovi::Lijevo || smjer==Smjerovi::DoljeLijevo)) throw std::out_of_range("Izlazak van igrace table");

	if(y==polja.at(0).size()-1 &amp;&amp; x&gt;0 &amp;&amp; x&lt;polja.size()-1 &amp;&amp; (smjer==Smjerovi::GoreDesno || smjer==Smjerovi::Desno || smjer==Smjerovi::DoljeDesno)) throw std::out_of_range("Izlazak van igrace table");



	//Pomjeranje robota-igraca na zeljeno polje.
	if(smjer==Smjerovi::Gore) {
<a name="4"></a><font color="#FF00FF"><a href="match801-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		if(polja.at(x-1).at(y)==Polje::BlokiranoPrazno || polja.at(x-1).at(y)==Polje::BlokiranoPosjeceno || polja.at(x-1).at(y)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		else x=x-1;
	}

	if(smjer==Smjerovi::Desno) {
<a name="2"></a><font color="#0000FF"><a href="match801-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		if(polja.at(x).at(y-1)==Polje::BlokiranoPrazno || polja.at(x).at(y-1)==Polje::BlokiranoPosjeceno || polja.at(x).at(y-1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		else y=y-1;
	}

	if(smjer==Smjerovi::Dolje) {
<a name="5"></a><font color="#FF0000"><a href="match801-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		if(polja.at(x+1).at(y)==Polje::BlokiranoPrazno || polja.at(x+1).at(y)==Polje::BlokiranoPosjeceno || polja.at(x+1).at(y)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		else x=x+1;
	}
	if(smjer==Smjerovi::Lijevo) {
		if(polja.at(x).at(y-1)==Polje::BlokiranoPrazno || polja.at(x).at(y-1)==Polje::BlokiranoPosjeceno || polja.at(x).at(y-1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
		else y=y-1;
	}
	if(smjer==Smjerovi::GoreLijevo) {
<a name="0"></a><font color="#FF0000"><a href="match801-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		if(polja.at(x-1).at(y-1)==Polje::BlokiranoPrazno || polja.at(x-1).at(y-1)==Polje::BlokiranoPosjeceno || polja.at(x-1).at(y-1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		else {
			x=x-1;
			y=y-1;
		}
	}
	if(smjer==Smjerovi::GoreDesno) {
<a name="1"></a><font color="#00FF00"><a href="match801-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if(polja.at(x-1).at(y+1)==Polje::BlokiranoPrazno || polja.at(x-1).at(y+1)==Polje::BlokiranoPosjeceno || polja.at(x-1).at(y+1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		else {
			x=x-1;
			y=y+1;
		}
	}
	if(smjer==Smjerovi::DoljeLijevo) {
<a name="3"></a><font color="#00FFFF"><a href="match801-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		if(polja.at(x+1).at(y-1)==Polje::BlokiranoPrazno || polja.at(x+1).at(y-1)==Polje::BlokiranoPosjeceno || polja.at(x+1).at(y-1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font>		else {
			x=x+1;
			y=y-1;
		}
	}
	if(smjer==Smjerovi::DoljeDesno) {
<a name="6"></a><font color="#00FF00"><a href="match801-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if(polja.at(x+1).at(y+1)==Polje::BlokiranoPrazno || polja.at(x+1).at(y+1)==Polje::BlokiranoPosjeceno || polja.at(x+1).at(y+1)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font><a name="6"></a><font color="#00FF00"><a href="match801-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		else {
</font>			x=x+1;
			y=y+1;
		}
	}



	//Uspjesno smo pomjerili igraca na polje koje je ili prazno ili vec posjeceno ili se na tom polju nalazi mina. Proverimo kako ce se dalje odvijati tok igre.
	if(polja.at(x).at(y)==Polje::Mina) return Status::KrajPoraz;

	polja.at(x).at(y)=Polje::Posjeceno;

	for(int i=0; i&lt;polja.size(); i++)
		for(int j=0; j&lt;polja.at(i).size(); j++) if(polja.at(i).at(j)==Polje::Prazno) return Status::NijeKraj;

	return Status::KrajPobjeda;

}

Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,int novi_x,int novi_y)
{

	//Provjeravamo da li smo stali na legalno polje,unutar igrace table.
	if(novi_x&lt;0 || novi_y&lt;0 || novi_x&gt;polja.size()-1 || novi_y&gt;polja.at(0).size()-1) throw std::out_of_range("Izlazak van igrace table");

	//Provjeravamo da li smo stali na polje je blokirano.
	if(polja.at(novi_x).at(novi_y)==Polje::BlokiranoPrazno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoPosjeceno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");

	//Uspjesno smo pomjerili robota-igraca, sada trebamo vidjeti kako ce se dalje odvijati igra.
	x=novi_x;
	y=novi_y;

	if(polja.at(x).at(y)==Polje::Mina) return Status::KrajPoraz;

	polja.at(x).at(y)=Polje::Posjeceno;

	for(int i=0; i&lt;polja.size(); i++)
		for(int j=0; j&lt;polja.at(0).size(); j++) if(polja.at(i).at(j)==Polje::Prazno) return Status::NijeKraj;

	return Status::KrajPobjeda;

}

int main ()
{
	 std::vector&lt;std::vector&lt;int&gt;&gt; mine = {{0,1}, {0,4}, {1,3}, {1,4}, {2,0}, {2,1}, {2,3}} ;
    std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla = KreirajIgru(5, mine);
    std::vector&lt;std::vector&lt;int&gt;&gt; okolina = PrikaziOkolinu(tabla, 0, 0);
    for(int i = 0; i &lt; okolina.size(); i++)
    {
      for(int j = 0; j &lt; okolina[i].size(); j++) std::cout &lt;&lt; okolina[i][j] &lt;&lt; " ";
      std::cout &lt;&lt; std::endl;
    }
	return 0;
}</pre>
</body>
</html>
