<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student8909.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student8909.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;complex&gt;

enum class Polje { Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};
enum class Smjerovi { GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class Status { NijeKraj, KrajPoraz, KrajPobjeda};
enum class KodoviGresaka { PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
<a name="1"></a><font color="#00FF00"><a href="match7-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_42.gif"/></a>

enum class Komande { PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;

Tabla KreirajMatricu(int br_redova, int br_kolona)
{
	return Tabla(br_redova, std::vector&lt;Polje&gt;(br_kolona));
}

Matrica Kreiraj(int br_redova, int br_kolona)
{
	return Matrica(br_redova, std::vector&lt;int&gt;(br_kolona));
}

Matrica UnesiMatricu(int br_redova, int br_kolona)
{
	Matrica m(br_redova, std::vector&lt;int&gt;(br_kolona));
	for(int i=0; i&lt;20; i++)
	{
		for(int j=0; j&lt;2; j++)
		{
			std::cin &gt;&gt; m.at(i).at(j);
			if(m.at(i).at(j) == '.') break;
		}
	}
	return m;
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
	Tabla A = KreirajMatricu(n,n);
	
	for(int i=0; i&lt;A.size(); i++)
	{
		for(int j=0; j&lt;A.at(i).size(); j++)
		{
			A.at(i).at(j) = Polje::Prazno;
		}
	}
	
	Tabla Polja = KreirajMatricu(n,n);
	
	for(int i=0; i&lt;A.size(); i++)
	{
		for(int j=0; j&lt;A.at(i).size(); j++)
		{
			for(int k=0; k&lt;mine.size(); k++)
			{
				if(i == mine.at(k).at(0) &amp;&amp; j == mine.at(k).at(1))
				{
					Polja.at(i).at(j) = Polje::Mina;
				}
			}
		}
	}
	return Polja;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
	std::vector&lt;int&gt; niz_okolina;
	
	if(x == 1 &amp;&amp; y == 1)
	{
		int glh=x-1, glv=y-1, gsh=x-1, gsv=y, gdh=x-1, gdv=y+1,
		    slh=x, slv=y-1, tth=x, ttv=y, sdh=x, sdv=y+1,
			dlh=x+1, dlv=y-1, dsh=x+1, dsv=y, ddh=x+1, ddv=y+1;
		
		int brojac1(0), brojac2(0), brojac3(0), brojac4(0), brojac5(0), brojac6(0), brojac7(0), brojac8(0), brojac9(0);
		
		for(int i=glh; i&lt;glh+2; i++)
		{
			for(int j=glv; j&lt;glv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac1++;
				if(i == glh &amp;&amp; j == glv &amp;&amp; polja.at(i).at(j) == Polje::Mina)
					brojac1 -= 1;
			}
		}
		niz_okolina.push_back(brojac1);
		
		for(int i=gsh; i&lt;gsh+2; i++)
		{
			for(int j=gsv; j&lt;gsv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac2++;
				if(i == gsh &amp;&amp; j == gsv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac2 -= 1;
			}
		}
		niz_okolina.push_back(brojac2);
		
		for(int i=gdh; i&lt;gdh+2; i++)
		{
			for(int j=gdv; j&lt;gdv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac3++;
				if(i == gdh &amp;&amp; j == gdv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac3 -= 1;
			}
		}
		niz_okolina.push_back(brojac3);
		
		for(int i=slh - 1; i&lt;slh+2; i++)
		{
			for(int j=slv; j&lt;slv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac4++;
				if(i == slh &amp;&amp; j == slv &amp;&amp; polja.at(i).at(j) == Polje::Mina)
					brojac4 -= 1;
			}
		}
		niz_okolina.push_back(brojac4);
		
		for(int i=tth -1; i&lt;tth+2; i++)
		{
			for(int j=ttv - 1; j&lt;ttv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac5++;
				if(i == tth &amp;&amp; j == ttv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac5 -= 1;
			}
		}
		niz_okolina.push_back(brojac5);
		
		for(int i=sdh - 1; i&lt;sdh+2; i++)
		{
			for(int j=sdv - 1; j&lt;sdv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac6++;
				if(i == sdh &amp;&amp; j == sdv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac6 -= 1;
			}
		}
		niz_okolina.push_back(brojac6);
		
		for(int i=dlh - 1; i&lt;dlh+2; i++)
		{
			for(int j=dlv; j&lt;dlv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac7++;
				if(i == dlh &amp;&amp; j == dlv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac7 -= 1;
			}
		}
		niz_okolina.push_back(brojac7);
		
		for(int i=dsh-1; i&lt;dsh+2; i++)
		{
			for(int j=dsv - 1; j&lt;dsv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac8++;
				if(i == dsh &amp;&amp; j == dsv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac8 -= 1;
			}
		}
		niz_okolina.push_back(brojac8);
		
		for(int i=ddh - 1; i&lt;ddh+2; i++)
		{
			for(int j=ddv - 1; j&lt;ddv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac9++;
				if(i == ddh &amp;&amp; j == ddv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac9 -= 1;
			}
		}
		niz_okolina.push_back(brojac9);
		
		Matrica MatricaPonavljanja = Kreiraj(3,3);
		int h(0);
		for(int i=0; i&lt;3; i++)
		{
			for(int j=0; j&lt;3; j++)
			{
				MatricaPonavljanja.at(i).at(j) = niz_okolina.at(h);
				h++;
			}
		}
		return MatricaPonavljanja;
	}
	
	if(x&gt;=2 &amp;&amp; y&gt;=2)
	{
		int glh=x-1, glv=y-1, gsh=x-1, gsv=y, gdh=x-1, gdv=y+1,
			slh=x, slv=y-1, tth=x, ttv=y, sdh=x, sdv=y+1,
			dlh=x+1, dlv=y-1, dsh=x+1, dsv=y, ddh=x+1, ddv=y+1;
		
		int brojac1(0), brojac2(0), brojac3(0), brojac4(0), brojac5(0), brojac6(0), brojac7(0), brojac8(0), brojac9(0);
		
		for(int i=glh - 1; i&lt;glh+2; i++)
		{
			for(int j=glv - 1; j&lt;glv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac1++;
				if(i == glh &amp;&amp; j == glv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac1 -= 1;
			}
		}
		niz_okolina.push_back(brojac1);
		
		for(int i=gsh - 1; i&lt;gsh+2; i++)
		{
			for(int j=gsv - 1; j&lt;gsv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac2++;
				if(i == gsh &amp;&amp; j == gsv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac2 -= 1;
			}
		}
		niz_okolina.push_back(brojac2);
		
		for(int i=gdh -1; i&lt;gdh+2; i++)
		{
			for(int j=gdv - 1; j&lt;gdv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac3++;
				if(i == gdh &amp;&amp; j == gdv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac3 -= 1;
			}
		}
		niz_okolina.push_back(brojac3);
		
		for(int i=slh - 1; i&lt;slh+2; i++)
		{
			for(int j=slv -1; j&lt;slv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac4++;
				if(i == slh &amp;&amp; j == slv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac4 -= 1;
			}
		}
		niz_okolina.push_back(brojac4);
		
		for(int i=tth -1; i&lt;tth+2; i++)
		{
			for(int j=ttv - 1; j&lt;ttv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac5++;
				if(i == tth &amp;&amp; j == ttv &amp;&amp; polja.at(i).at(j) == Polje::Mina)  
					brojac5 -= 1;
			}
		}
		niz_okolina.push_back(brojac5);
		
		for(int i=sdh - 1; i&lt;sdh+2; i++)
		{
			for(int j=sdv - 1; j&lt;sdv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac6++;
				if(i == sdh &amp;&amp; j == sdv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac6 -= 1;
			}
		}
		niz_okolina.push_back(brojac6);
		
		for(int i=dlh - 1; i&lt;dlh+2; i++)
		{
			for(int j=dlv -1; j&lt;dlv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac7++;
				if(i == dlh &amp;&amp; j == dlv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac7 -= 1;
			}
		}
		niz_okolina.push_back(brojac7);
		
		for(int i=dsh-1; i&lt;dsh+2; i++)
		{
			for(int j=dsv - 1; j&lt;dsv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac8++;
				if(i == dsh &amp;&amp; j == dsv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac8 -= 1;
			}
		}
		niz_okolina.push_back(brojac8);
		
		for(int i=ddh - 1; i&lt;ddh+2; i++)
		{
			for(int j=ddv - 1; j&lt;ddv+2; j++)
			{
				if(polja.at(i).at(j) == Polje::Mina) 
					brojac9++;
				if(i == ddh &amp;&amp; j == ddv &amp;&amp; polja.at(i).at(j) == Polje::Mina) 
					brojac9 -= 1;
			}
		}
		niz_okolina.push_back(brojac9);
		
		Matrica MatricaPonavljanja = Kreiraj(3,3);
		int h(0);
		for(int i=0; i&lt;3; i++)
		{
			for(int j=0; j&lt;3; j++)
			{
				MatricaPonavljanja.at(i).at(j) = niz_okolina.at(h);
				h++;
			}
		}
		return MatricaPonavljanja;	
	}
}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 || x &gt; polja.size() || y &lt; 0 || y &gt; polja.at(0).size())
		throw std::domain_error("Polje (x,y) ne postoji");
	
	for(int i=0; i&lt;polja.size(); i++)
	{
		for(int j=0; j&lt;polja.at(i).size(); j++)
		{
			if(i == x &amp;&amp; j == y)
			{
				if(polja.at(i).at(j) == Polje::Prazno) polja.at(i).at(j) = Polje::BlokiranoPrazno;
</font>				if(polja.at(i).at(j) == Polje::Posjeceno) polja.at(i).at(j) = Polje::BlokiranoPosjeceno;
<a name="2"></a><font color="#0000FF"><a href="match7-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

				if(polja.at(i).at(j) == Polje::Mina) polja.at(i).at(j) = Polje::BlokiranoMina;
			}
		}
	}
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x &lt; 0 || x &gt; polja.size() || y &lt; 0 || y &gt; polja.at(0).size())
		throw std::domain_error("Polje (x,y) ne postoji");
		
	for(int i=0; i&lt;polja.size(); i++)
	{
		for(int j=0; j&lt;polja.at(i).size(); j++)
		{
			if(i == x &amp;&amp; j == y)
			{
				if(polja.at(i).at(j) == Polje::BlokiranoPrazno) polja.at(i).at(j) = Polje::Prazno;
</font>				if(polja.at(i).at(j) == Polje::BlokiranoPosjeceno) polja.at(i).at(j) = Polje::Posjeceno;
<a name="0"></a><font color="#FF0000"><a href="match7-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_52.gif"/></a>

				if(polja.at(i).at(j) == Polje::BlokiranoMina) polja.at(i).at(j) = Polje::Mina;
			}
		}
	}
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
	Status s;
	for(int i=0; i&lt;polja.size(); i++)
	{
		for(int j=0; j&lt;polja.at(i).size(); j++)
		{
			if(i == x &amp;&amp; j == y)
				polja.at(i).at(j) = Polje::Posjeceno;
		}
	}
	for(int i=0; i&lt;polja.size(); i++)
	{
		for(int j=0; polja.at(i).size(); j++)
		{
			if(smjer == Smjerovi::GoreLijevo)
			{
				if(polja.at(i).at(j) == Polje::Mina)
				{
					s = Status::KrajPoraz;
					return s;
				}
				else if (polja.at(i).at(j) == Polje::Prazno)
				{
					x -=1;
					y -=1;
					s = Status::NijeKraj;
					return s;
				}
				else if((i == polja.size()-1 || j == polja.at(i).size()-1) &amp;&amp; polja.at(i).at(j) == Polje::Prazno)
				{
					s = Status::KrajPobjeda;
					return s;
				}
			}
			else if (smjer == Smjerovi::Gore)
			{
				if(polja.at(i).at(j) == Polje::Mina)
				{
					s = Status::KrajPoraz;
					return s;
				}
				else if(polja.at(i).at(j) == Polje::Prazno)
				{
					x -= 1;
					s = Status::NijeKraj;
					return s;
				}
				else if((i == polja.size()-1 || j == polja.at(i).size()-1) &amp;&amp; polja.at(i).at(j) == Polje::Prazno)
				{
					s = Status::KrajPobjeda;
					return s;
				}
			}
			else if(smjer == Smjerovi::GoreDesno)
			{
				if(polja.at(i).at(j) == Polje::Mina)
				{
					s = Status::KrajPoraz;
					return s;
				}
				else if(polja.at(i).at(j) == Polje::Prazno)
				{
					s = Status::NijeKraj;
					return s;
				}
				else if((i == polja.size()-1 || j == polja.at(i).size()-1) &amp;&amp; polja.at(i).at(j) == Polje::Prazno)
				{
					s = Status::KrajPobjeda;
					return s;
				}
			}
			else if(smjer == Smjerovi::Lijevo)
			{
				if(polja.at(i).at(j) == Polje::Mina)
				{
					s = Status::KrajPoraz;
					return s;
				}
				else if(polja.at(i).at(j) == Polje::Prazno)
				{
					y -= 1;
					s = Status::NijeKraj;
					return s;
				}
				else if((i == polja.size()-1 || j == polja.at(i).size()-1) &amp;&amp; polja.at(i).at(j) == Polje::Prazno)
				{
					s = Status::KrajPobjeda;
					return s;
				}
			}
			else if(smjer == Smjerovi::Desno)
			{
				if(polja.at(i).at(j) == Polje::Mina)
				{
					s = Status::KrajPoraz;
					return s;
				}
				else if(polja.at(i).at(j) == Polje::Prazno)
				{
					x += 1;
					s = Status::NijeKraj;
					return s;
				}
				else if((i == polja.size()-1 || j == polja.at(i).size()-1) &amp;&amp; polja.at(i).at(j) == Polje::Prazno)
				{
					s = Status::KrajPobjeda;
					return s;
				}
			}
			else if(smjer == Smjerovi::DoljeLijevo)
			{
				if(polja.at(i).at(j) == Polje::Mina)
				{
					s = Status::KrajPoraz;
					return s;
				}
				else if(polja.at(i).at(j) == Polje::Prazno)
				{
					x += 1;
					y -= 1;
					s = Status::NijeKraj;
					return s;
				}
				else if((i == polja.size()-1 || j == polja.at(i).size()-1) &amp;&amp; polja.at(i).at(j) == Polje::Prazno)
				{
					s = Status::KrajPobjeda;
					return s;
				}
			}
			else if(smjer == Smjerovi::Dolje)
			{
				if(polja.at(i).at(j) == Polje::Mina)
				{
					s= Status::KrajPoraz;
					return s;
				}
				else if(polja.at(i).at(j) == Polje::Prazno)
				{
					x += 1;
					s = Status::NijeKraj;
					return s;
				}
				else if((i == polja.size()-1 || j == polja.at(i).size()-1) &amp;&amp; polja.at(i).at(j) == Polje::Prazno)
				{
					s = Status::KrajPobjeda;
					return s;
				}
			}
			else if(smjer == Smjerovi::DoljeDesno)
			{
				if(polja.at(i).at(j) == Polje::Mina)
				{
					s = Status::KrajPoraz;
					return s;
				}
				else if(polja.at(i).at(j) == Polje::Prazno)
				{
					x += 1;
					y += 1;
					s = Status::NijeKraj;
					return s;
				}
				else if((i == polja.size()-1 || j == polja.at(i).size()-1) &amp;&amp; polja.at(i).at(j) == Polje::Prazno)
				{
					s = Status::KrajPobjeda;
					return s;
				}
			}
		}
	}
}

Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, int X, int Y)
{
	if(X &lt; 0 || X &gt; polja.size() || Y &lt; 0 || Y &gt; polja.at(0).size())
		throw std::out_of_range ("Izlazak van Igrace table");
		
	for(int i=0; i&lt;polja.size(); i++ )
	{
		for(int j=0; j&lt;polja.at(i).size(); j++)
		{
			if(i == X &amp;&amp; j == Y)
			{
				if(polja.at(i).at(j) == Polje::BlokiranoPrazno)
					throw std::logic_error("Blokirano polje");
			
				if(polja.at(i).at(j) == Polje::BlokiranoPosjeceno)
					throw std::logic_error("Blokirano polje");
					
				if(polja.at(i).at(j) == Polje::BlokiranoMina)
					throw std::logic_error("Blokirano polje");
					
					x = X;
					y = Y;
			}
		}
	}
}

bool UnesiKomandu(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	std::string KOM;
	std::string NovKOM;
	std::getline (std::cin, KOM);
	
	for(int i=0; i&lt;KOM.length(); i++)
	{
		while(KOM[i] == ' ') 
			i++;
		
		while(KOM[i] != ' ' &amp;&amp; i &lt; KOM.length())
		{
			NovKOM.push_back(KOM[i]);
			i++;
		}
	}
	for(int i=0; i&lt;NovKOM.length(); i++)
	{
        if(NovKOM[i] == 'P' &amp;&amp; NovKOM[i+1] == '1')
        {
            komanda = Komande::PomjeriJednoMjesto;
            
            if(NovKOM[i+2] == 'G' &amp;&amp; NovKOM[i+3] == 'L')
            {
                smjer = Smjerovi::GoreLijevo;
                return true;
            }
            else if(NovKOM[i+2] == 'G') 
            {
                smjer = Smjerovi::Gore;
                return true;
            }
            else if(NovKOM[i+2] == 'G' &amp;&amp; NovKOM[i+3] == 'D')
            {
                smjer = Smjerovi::GoreDesno;
                return true;
            }
            else if(NovKOM[i+2] == 'D')
            {
                smjer = Smjerovi::Desno;
                return true;
            }
            else if(NovKOM[i+2] == 'D' &amp;&amp; NovKOM[i+3] == 'o' &amp;&amp; NovKOM[i+4] == 'D')
            {
                smjer = Smjerovi::DoljeDesno;
                return true;
            }
            else if(NovKOM[i+2] == 'D' &amp;&amp; NovKOM[i+3] == 'o') 
            {
                smjer = Smjerovi::Dolje;
                return true;
            }
            else if(NovKOM[i+2] == 'D' &amp;&amp; NovKOM[i+3] == 'o' &amp;&amp; NovKOM[i+4] == 'L')
            {
                smjer = Smjerovi::DoljeLijevo;
                return true;
            }
            else if(NovKOM[i+2] == 'L')
            {
                smjer = Smjerovi::Lijevo;
                return true;
            }
            else{
                greska = KodoviGresaka::PogresnaKomanda;
                return false;
            }
        }
        else if(NovKOM[i] == 'P' &amp;&amp; NovKOM[i+1] == '&gt;')
        {
            komanda = Komande::PomjeriDalje;
            if(NovKOM[i+2] &gt;= '0' &amp;&amp; NovKOM[i+2] &lt; '9'
            &amp;&amp; NovKOM[i+3] &gt;= '0' &amp;&amp; NovKOM[i+3]&lt;='9')
            {
                x = NovKOM[i+2];
                y = NovKOM[i+3];
                return true;
            }
            else if(!(NovKOM[i+2] &gt;= '0' &amp;&amp; NovKOM[i+2] &lt;= '9') ||
            		!(NovKOM[i+3] &gt;= '0' &amp;&amp; NovKOM[i+3] &lt;= '9'))
            		{
                greska = KodoviGresaka::NeispravanParametar;
                return false;
            }
            else{
                greska = KodoviGresaka::NedostajeParametar;
                return false;
            }
        }
        else if(NovKOM[i] == 'B')
        {
            komanda = Komande::Blokiraj;
            if(NovKOM[i+1] &gt;= '0' &amp;&amp; NovKOM[i+1] &lt;= '9' 
            &amp;&amp; NovKOM[i+2] &gt;= '0' &amp;&amp; NovKOM[i+2] &lt;= '9')
            {
                x = NovKOM[i+1];
                y = NovKOM[i+2];
                return true;
            }
            else if(!(NovKOM[i+1] &gt;= '0' &amp;&amp; NovKOM[i+1] &lt;= '9') ||
            		!(NovKOM[i+2] &gt;= '0' &amp;&amp; NovKOM[i+2] &lt;= '9'))
            		{
                greska = KodoviGresaka::NeispravanParametar;
                return false;
            }
            else
            {
                greska = KodoviGresaka::NedostajeParametar;
                return false;
            }
        }
        else if(NovKOM[i] == 'D')
        {
            komanda = Komande::Deblokiraj;
            if(NovKOM[i+1] &gt;= '0' &amp;&amp; NovKOM[i+1] &lt;= '9' 
            &amp;&amp; NovKOM[i+2] &gt;= '0' &amp;&amp; NovKOM[i+2] &lt;= '9')
            {
                x = NovKOM[i+1];
                y = NovKOM[i+2];
                return true;
            }
            else if(!(NovKOM[i+1] &gt;= '0' &amp;&amp; NovKOM[i+1] &lt;= '9') ||
            		!(NovKOM[i+2] &gt;= '0' &amp;&amp; NovKOM[i+2] &lt;= '9'))
            		{
                greska = KodoviGresaka::NeispravanParametar;
                return false;
            }
            else
            {
                greska = KodoviGresaka::NedostajeParametar;
                return false;
            }
        }
        if(NovKOM[i]== 'P' &amp;&amp; NovKOM[i+1] == 'O')
        {
            komanda = Komande::PrikaziOkolinu;
            if((NovKOM[i+2] &gt;= 'A' &amp;&amp; NovKOM[i+2] &lt;= 'Z') ||
            (NovKOM[i+2] &gt;= '0' &amp;&amp; NovKOM[i+2] &lt;= '9'))
            {
                greska = KodoviGresaka::SuvisanParametar;
            }
        }
        if(NovKOM[i] == 'Z')
        {
            komanda = Komande::ZavrsiIgru;
            if(NovKOM[i+1] == '\0')
            {
                return true;
            }
            else if((NovKOM[i+1] &gt;= 'A' &amp;&amp; NovKOM[i+1] &lt;= 'Z') ||
            		(NovKOM[i+1] &gt;= '0' &amp;&amp; NovKOM[i+1] &lt;= '9'))
            		{
                greska = KodoviGresaka::SuvisanParametar;
                return false;
            }
        }
        if(NovKOM[i] == 'K')
        {
            komanda = Komande::KreirajIgru;
            if(NovKOM[i+1] == '\0')
                return true;
            
            else if((NovKOM[i+1] &gt;= 'A' &amp;&amp; NovKOM[i+1] &lt;= 'Z') ||
            		(NovKOM[i+1] &gt;= '0' &amp;&amp; NovKOM[i+1] &lt;= '9'))
            		{
                greska = KodoviGresaka::SuvisanParametar;
                return false;
            }
        }
    }
}


void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x=0, int p_y=0)
{
	if(komanda == Komande::PomjeriJednoMjesto || komanda == Komande::PomjeriDalje)
	{
		std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")";
		Status status = Idi(polja, x, y, p_smjer);
		if(status == Status::KrajPobjeda) 
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja";
			
		if(status == Status::KrajPoraz)
		{
			std::cout &lt;&lt; "Nagazili ste na minu";
			for(int i=0; i&lt;polja.size(); i++)
			{
				for(int j=0; j&lt;polja.at(i).size(); j++)
					polja.at(i).at(j) == Polje::Prazno;
			}
		}
	}
	else if(komanda == Komande::PrikaziOkolinu)
	{
		Matrica P = PrikaziOkolinu(polja, x, y);
		for(int i=0; i&lt;P.size(); i++)
		{
			for(int j=0; j&lt;P.at(i).size(); j++) std::cout &lt;&lt; P.at(i).at(j) &lt;&lt; " ";
		
		std::cout &lt;&lt; std:: endl;
		}
	}
	else if(komanda == Komande::ZavrsiIgru)
	{
		for(int i=0; i&lt;polja.size(); i++)
		{
			for(int j=0; j&lt;polja.at(i).size(); j++) polja.at(i).at(j) = Polje::Prazno;
		}
		throw std::runtime_error ("Igra zavrsena");
	}
	else if(komanda == Komande::KreirajIgru)
	{
		std::complex&lt;int&gt; z;
		std::vector&lt;std::complex&lt;int&gt;&gt; v;
		int n;
		std::cout &lt;&lt; "Unesite broj polja: " &lt;&lt; std::endl;
		std::cin &gt;&gt; n;
		std::cout &lt;&lt; "Unesite pozicije mina: " &lt;&lt; std::endl;
		while(std::cin.peek() != '.')
		{
			std::cin &gt;&gt; z;
			if(real(z)&gt;n || imag(z) &gt; n) std::cout &lt;&lt; "Greska, unesite ponovo!";
		}
	}
}

int main ()
{
	int n;
	std::cout &lt;&lt; "Unesite broj polja: ";
	std::cin &gt;&gt; n;
	std::vector&lt;std::vector&lt;int&gt;&gt; mine;
	int x, y;
	char znak { ')' };
	std::cout &lt;&lt; "Unesite poziciju mina: ";
	while(znak == ')')
	{
		std::cin &gt;&gt; znak;
		if(znak != '(')
		{
			if(znak == '.') break;
			std::cin.clear();
			std::cin.ignore(300000, '\n');
			std::cout &lt;&lt; "Greska unesite ponovo!";
			znak = ')';
			continue;
		}
		std::cin &gt;&gt; x;
		std::cin &gt;&gt; znak;
		if(znak != ',' || x &gt;= n)
		{
			if(znak == '.') break;
			std::cin.clear();
			std::cin.ignore(30000, '\n');
			std::cout &lt;&lt; "Greska unesite ponovo!";
			znak = ')';
			continue;
		}
		
		std::cin &gt;&gt; y;
		std::cin &gt;&gt; znak;
		if(znak == ')' &amp;&amp; y &lt; n)
		{
			std::vector&lt;int&gt; m;
			m.push_back(x);
			m.push_back(y);
			mine.push_back(m);
			continue;
		}
		else
		{
			if(znak == '.') break;
			std::cin.clear();
			std::cin.ignore(30000, '\n');
			std::cout &lt;&lt; "Greska unesite ponovo!";
			znak = ')';
			continue;
		}
	}
	
	Tabla tab;
	
	try{
		tab = KreirajIgru(n, mine);
	}
	catch(std::domain_error izuzetak)
	{
		std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
	}
	
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina;
	std::cout &lt;&lt; "Unesite koordinate tacke za trazenje okoline: ";
	std::cin &gt;&gt; x &gt;&gt; y;
	
	try{
		okolina = PrikaziOkolinu(tab, x, y);
		BlokirajPolje(tab, x, y);
	}
	catch(std::domain_error e)
	{
		std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
</font>	}
	return 0;
}</pre>
</body>
</html>
