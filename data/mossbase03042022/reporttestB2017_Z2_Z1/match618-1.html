<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student9447.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student5897.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;complex&gt;
using namespace std;
typedef vector&lt;vector&lt;int&gt;&gt;Matrica;
enum class Polje {Prazno,Posjeceno,Mina,BlokiranoPrazno,BlokiranoPosjeceno,BlokiranoMina};
enum class Smjerovi { GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class KodoviGresaka {PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};
enum class Komande {PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};
typedef vector&lt;vector&lt;Polje&gt;&gt;Tabla;
Matrica KreirajMatricu(int broj_redova,int broj_kolona){
	return Matrica(broj_redova,vector&lt;int&gt;(broj_kolona));
}
void IspisiMatricu(Matrica mat){
	for(int i=0;i&lt;mat.size();i++){
		for(int j=0;j&lt;mat.at(i).size();j++) cout&lt;&lt;mat.at(i).at(j)&lt;&lt;" ";
		cout&lt;&lt;endl;
	}
}
void BrisiRazmake(string &amp;s){
	int i(0);
	while((s.at(i)&lt;'0' || s.at(i)&gt;'9') &amp;&amp; i&lt;s.length()){
		if(s.at(i)&gt;='0' &amp;&amp; s.at(i)&lt;='9') break;
		if(s.at(i)==' '){
			s.erase(s.begin()+i);
			i--;
		}
		i++;
	}
}
void PostaviXiY(string s,int &amp;x,int &amp;y){
	int i(0);
	while(s.at(i)&gt;='0' &amp;&amp; s.at(i)&lt;='9') i++;
	s=s.substr(i,s.size()-i);
	BrisiRazmake(s);
	x=stoi(s.substr(0,i));
	y=stoi(s.substr(0));
}
Tabla KreirajIgru(int n,const vector&lt;vector&lt;int&gt;&gt;&amp;mine){
	Tabla Mat;
	Mat.resize(n);
	for(int i=0;i&lt;Mat.size();i++) Mat.at(i).resize(n);
	for(int i=0;i&lt;Mat.size();i++){
		for(int j=0;j&lt;Mat.at(i).size();j++) Mat.at(i).at(j)=Polje::Prazno;
	}
	for(int i=0;i&lt;mine.size();i++){
		if(mine.at(i).size()!=2) throw domain_error("Ilegalan format zadavanja mina");
	}
	if(n&lt;=0) throw domain_error("Ilegalna velicina");
	for(int i=0;i&lt;Mat.size();i++){
		for(int j=0;j&lt;Mat.at(i).size();j++){
			for(int k=0;k&lt;mine.size();k++){
				if(mine.at(k).at(0)&gt;=n || mine.at(k).at(1)&gt;=n) throw domain_error("Ilegalne pozicije mina");
				if(mine.at(k).at(0)==i &amp;&amp; mine.at(k).at(1)==j) Mat.at(i).at(j)=Polje::Mina;
			}
		}
	}
	return Mat;
}
Matrica PrikaziOkolinu(const Tabla &amp;polja,int x,int y){
	for(int i=0;i&lt;polja.size();i++){
		if(x&gt;=polja.size() || y&gt;=polja.at(i).size() || x&lt;0 || y&lt;0) throw domain_error("Polje ("+to_string(y)+","+to_string(x)+") ne postoji");
	}
	Matrica Polja(KreirajMatricu(polja.size(),polja.size()));
	for(int i=0;i&lt;polja.size();i++){
		for(int j=0;j&lt;polja.at(i).size();j++){
			if(polja.at(i).at(j)==Polje::Mina) Polja.at(i).at(j)=1;
		}
	}
	Matrica Mat(KreirajMatricu(3,3));
	for(int i=-1;i&lt;2;i++){
		for(int j=-1;j&lt;2;j++){
			for(int k=-1;k&lt;2;k++){
				for(int r=-1;r&lt;2;r++){
					if(k==0 &amp;&amp; r==0) continue;
					if(k+i+x&lt;0 ||k+i+x&gt;=Polja.size() || r+j+y&lt;0 || r+j+y&gt;=Polja.at(0).size()) continue;
					Mat.at(i+1).at(j+1)+=Polja.at(k+i+x).at(r+j+y);
				}
			}
		}
		
	}
	return Mat;
}
void BlokirajPolje(Tabla &amp;polja,int x,int y){
	if(x&gt;=polja.size() || x&lt;0 || y&lt;0 || y&gt;=polja.at(0).size()) throw domain_error("Polje ("+to_string(y)+","+to_string(x)+") ne postoji");
	if(polja.at(x).at(y)==Polje::Prazno) polja.at(x).at(y)=Polje::BlokiranoPrazno;
	if(polja.at(x).at(y)==Polje::Posjeceno) polja.at(x).at(y)=Polje::BlokiranoPosjeceno;
	if(polja.at(x).at(y)==Polje::Mina) polja.at(x).at(y)=Polje::BlokiranoMina;
}
void DeblokirajPolje(Tabla &amp;polja,int x,int y){
	if(x&gt;=polja.size() || x&lt;0 || y&lt;0 || y&gt;=polja.at(0).size()) throw domain_error("Polje ("+to_string(y)+","+to_string(x)+") ne postoji");
	if(polja.at(x).at(y)==Polje::BlokiranoPrazno) polja.at(x).at(y)=Polje::Prazno;
	if(polja.at(x).at(y)==Polje::BlokiranoPosjeceno) polja.at(x).at(y)=Polje::Posjeceno;
	if(polja.at(x).at(y)==Polje::BlokiranoMina) polja.at(x).at(y)=Polje::Mina;
}
Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,Smjerovi smjer){
	if(polja.size()==0 || (smjer==Smjerovi::GoreLijevo &amp;&amp; (x==0 || y==0))) throw out_of_range("Izlazak van igrace table");
	if(smjer==Smjerovi::Gore &amp;&amp; x==0) throw out_of_range("Izlazak van igrace table");
	if(smjer==Smjerovi::GoreDesno &amp;&amp; (x==0 || y==polja.at(0).size()-1)) throw out_of_range("Izlazak van igrace table");
	if(smjer==Smjerovi::Desno &amp;&amp; y==polja.at(0).size()-1) throw out_of_range("Izlazak van igrace table");
	if(smjer==Smjerovi::DoljeDesno &amp;&amp; (x==polja.size()-1 || y==polja.at(0).size()-1)) throw out_of_range("Izlazak van igrace table");
	if(smjer==Smjerovi::Dolje &amp;&amp; x==polja.size()-1) throw out_of_range("Izlazak van igrace table");
	if(smjer==Smjerovi::DoljeLijevo &amp;&amp; (x==polja.size()-1 || y==0)) throw out_of_range("Izlazak van igrace table");
	if(smjer==Smjerovi::Lijevo &amp;&amp; y==0) throw out_of_range("Izlazak van igrace table");
	if(smjer==Smjerovi::GoreLijevo){
<a name="1"></a><font color="#00FF00"><a href="match618-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if(polja.at(x-1).at(y-1)==Polje::BlokiranoMina || polja.at(x-1).at(y-1)==Polje::BlokiranoPrazno || polja.at(x-1).at(y-1)==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
</font>		polja.at(x).at(y)=Polje::Posjeceno;
		x--; y--;
	}
	if(smjer==Smjerovi::Gore){
<a name="0"></a><font color="#FF0000"><a href="match618-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		if(polja.at(x-1).at(y)==Polje::BlokiranoMina || polja.at(x-1).at(y)==Polje::BlokiranoPrazno || polja.at(x-1).at(y)==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
</font>		polja.at(x).at(y)=Polje::Posjeceno;
		x--;
	}
	if(smjer==Smjerovi::GoreDesno){
<a name="2"></a><font color="#0000FF"><a href="match618-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		if(polja.at(x-1).at(y+1)==Polje::BlokiranoMina || polja.at(x-1).at(y+1)==Polje::BlokiranoPrazno || polja.at(x-1).at(y+1)==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
</font>		polja.at(x).at(y)=Polje::Posjeceno;
		x--; y++;
	}
	if(smjer==Smjerovi::Desno){
<a name="4"></a><font color="#FF00FF"><a href="match618-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		if(polja.at(x).at(y+1)==Polje::BlokiranoMina || polja.at(x).at(y+1)==Polje::BlokiranoPrazno || polja.at(x).at(y+1)==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
</font>		polja.at(x).at(y)=Polje::Posjeceno;
		y++;
	} 
	if(smjer==Smjerovi::DoljeDesno){
<a name="6"></a><font color="#00FF00"><a href="match618-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

		if(polja.at(x+1).at(y+1)==Polje::BlokiranoMina || polja.at(x+1).at(y+1)==Polje::BlokiranoPrazno || polja.at(x+1).at(y+1)==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
</font>		polja.at(x).at(y)=Polje::Posjeceno;
		x++; y++;
	} 
	if(smjer==Smjerovi::Dolje){
<a name="5"></a><font color="#FF0000"><a href="match618-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		if(polja.at(x+1).at(y)==Polje::BlokiranoMina || polja.at(x+1).at(y)==Polje::BlokiranoPrazno || polja.at(x+1).at(y)==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
</font>		polja.at(x).at(y)=Polje::Posjeceno;
		x++;
	}
	if(smjer==Smjerovi::DoljeLijevo){
<a name="8"></a><font color="#00FFFF"><a href="match618-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

		if(polja.at(x+1).at(y-1)==Polje::BlokiranoMina || polja.at(x+1).at(y-1)==Polje::BlokiranoPrazno || polja.at(x+1).at(y-1)==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
</font>		polja.at(x).at(y)=Polje::Posjeceno;
		x++; y--;
	}
	if(smjer==Smjerovi::Lijevo){
<a name="3"></a><font color="#00FFFF"><a href="match618-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		if(polja.at(x).at(y-1)==Polje::BlokiranoMina || polja.at(x).at(y-1)==Polje::BlokiranoPrazno || polja.at(x).at(y-1)==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
</font>		polja.at(x).at(y)=Polje::Posjeceno;
		y--;
	}
	if(polja.at(x).at(y)==Polje::Mina){
		for(int i=0;i&lt;polja.size();i++){
			for(int j=0;j&lt;polja.at(i).size();j++){ polja.at(i).at(j)=Polje::Prazno;
		}
		}
		return Status::KrajPoraz;
	}
	if(polja.at(x).at(y)==Polje::Prazno){
		bool postoji(true);
		for(int i=0;i&lt;polja.size();i++){
<a name="9"></a><font color="#FF00FF"><a href="match618-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

			for(int j=0;j&lt;polja.at(i).size();j++){
				if(polja.at(i).at(j)==Polje::Prazno) postoji=false;
</font>			}
		}
		if(postoji) return Status::KrajPobjeda;
	}
	return Status::NijeKraj;
}
Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,int novi_x,int novi_y){
	if(novi_x&gt;=polja.at(0).size() || novi_x&lt;0 || novi_y&lt;0 || novi_y&gt;=polja.size()) throw out_of_range ("Izlazak van igrace table");
	if(polja.at(novi_x).at(novi_y) == Polje::BlokiranoMina || polja.at(novi_x).at(novi_y)== Polje::BlokiranoPosjeceno || polja.at(novi_x).at(novi_y) == Polje::BlokiranoPrazno) throw logic_error ("Blokirano polje");
	else{
		x=novi_x;
		y=novi_y;
	}
	if(polja.at(x).at(y)==Polje::Mina){
		for(int i=0;i&lt;polja.size();i++){
			for(int j=0;j&lt;polja.at(i).size();j++){
				polja.at(i).at(j)=Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	if(polja.at(x).at(y)==Polje::Prazno){
		bool postoji(true);
		for(int i=0;i&lt;polja.size();i++){
<a name="10"></a><font color="#FF0000"><a href="match618-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

			for(int j=0;j&lt;polja.at(i).size();j++){
				if(polja.at(i).at(j)==Polje::Prazno) postoji=false;
</font>			}
		}
		if(postoji) return Status::KrajPobjeda;
	}
	return Status::NijeKraj;
}
void PrijaviGresku(KodoviGresaka greska){
	if(greska==KodoviGresaka::NeispravanParametar) cout&lt;&lt;"Parametar komande nije ispravan";
	if(greska==KodoviGresaka::NedostajeParametar)  cout&lt;&lt;"Komanda trazi parametar koji nije naveden";
	if(greska==KodoviGresaka::PogresnaKomanda)     cout&lt;&lt;"Nerazumljiva komanda";
	if(greska==KodoviGresaka::SuvisanParametar)    cout&lt;&lt;"Zadan je suvisan parametar nakon komande";
}
bool UnosKomande(Komande &amp;komanda,Smjerovi &amp;smjer,int &amp;x,int &amp;y,KodoviGresaka &amp;greska){
	string s;
	getline(cin,s);
	BrisiRazmake(s);
	if(s.substr(0,2)=="P1"){
		komanda=Komande::PomjeriJednoMjesto;
		s=s.substr(2,s.length()-2);
		BrisiRazmake(s);
		
		if(s.substr(0,s.length())=="G"){ smjer=Smjerovi::Gore; return true;}
	else if(s.substr(0,s.length())=="GL"){ smjer=Smjerovi::GoreLijevo; return true;}
	else if(s.substr(0,s.length())=="GD"){ smjer=Smjerovi::GoreDesno; return true;}
	else if(s.substr(0,s.length())=="Do"){ smjer=Smjerovi::Dolje; return true;}
	else if(s.substr(0,s.length())=="DoD"){ smjer=Smjerovi::DoljeDesno; return true;}
	else if(s.substr(0,s.length())=="DoL"){ smjer=Smjerovi::DoljeLijevo; return true;}
	else if(s.substr(0,s.length())=="D"){ smjer=Smjerovi::Desno; return true;}
	else if(s.substr(0,s.length())=="L"){ smjer=Smjerovi::Lijevo; return true;}
	else {
		if(s.length()==0){
			greska=KodoviGresaka::NedostajeParametar;
			return false;
		}
		else{
			greska=KodoviGresaka::NeispravanParametar;
			return false;
		}
	}
	}
else if(s.substr(0,2)=="P&gt;"){
		s=s.substr(2,s.length()-2);
		if(s.length()==0){
			greska=KodoviGresaka::NedostajeParametar;
			return false;
		}
		else{
			int i(0);
			while(i&lt;s.length()){
				if((s.at(i)&lt;'0' || s.at(i)&gt;'9') &amp;&amp; s.at(i)!=' '){
					greska=KodoviGresaka::NeispravanParametar;
					return false;
				}
				i++;
			}
		}
		komanda=Komande::PomjeriDalje;
		PostaviXiY(s,x,y);
		return true;
	}
else if(s.at(0)=='D'){
	s=s.substr(1,s.length()-1);
		if(s.length()==0){
			greska=KodoviGresaka::NedostajeParametar;
			return false;
		}
		int i(0);
		while(i&lt;s.length()){
			if((s.at(i)&lt;'0' || s.at(i)&gt;'9') &amp;&amp; s.at(i)!=' '){
				greska=KodoviGresaka::SuvisanParametar;
				return false;
			}
			i++;
		}
		komanda=Komande::Deblokiraj;
		PostaviXiY(s,x,y);
		return true;
	}
else if(s.at(0)=='B'){
		s=s.substr(1,s.length()-1);
		if(s.length()==0){
			greska=KodoviGresaka::NedostajeParametar;
			return false;
		}
		int i(0);
		while(i&lt;s.length()){
			if((s.at(i)&lt;'0' || s.at(i)&gt;'9') &amp;&amp; s.at(i)!=' '){
				greska=KodoviGresaka::SuvisanParametar;
				return false;
			}
			i++;
		}
		komanda=Komande::Blokiraj;
		PostaviXiY(s,x,y);
		return true;
	}
	else if(s.substr(0,2)=="PO"){
		komanda=Komande::PrikaziOkolinu;
		if(s.substr(0,2)=="PO" &amp;&amp; s.length()!=2){
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}
		
		return true;
	}
else if(s.at(0)=='K'){
		if(s.at(0)=='K' &amp;&amp; s.length()!=1){
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}
		komanda=Komande::KreirajIgru;
		return true;
	}
	else if(s.at(0)=='Z'){
		if(s.at(0)=='Z' &amp;&amp; s.length()!=1){
			greska=KodoviGresaka::SuvisanParametar;
			return false;
		}
		komanda=Komande::ZavrsiIgru;
		return true;
	}
	else{
		greska=KodoviGresaka::PogresnaKomanda;
		return false;
	}
	return false;
}
void IzvrsiKomandu(Komande komanda,Tabla &amp;polja,int &amp;x,int &amp;y,Smjerovi p_smjer=Smjerovi::Gore,int p_x=0,int p_y=0){
	Status stanje(Status::NijeKraj);
	if(komanda==Komande::PomjeriJednoMjesto){
		try{
			stanje=Idi(polja ,x ,y ,p_smjer);
		}
		catch(out_of_range e) 	{ cout &lt;&lt; e.what(); }
		catch(logic_error e) 	{ cout &lt;&lt; e.what(); }
		if(stanje==Status::KrajPoraz){
			cout&lt;&lt;"Nagazili ste minu";
			komanda=Komande::ZavrsiIgru;
		}
		if(stanje==Status::KrajPobjeda){
			cout&lt;&lt;"Bravo,obisli ste sva sigurna polja";
			komanda=Komande::ZavrsiIgru;
		}
		else cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
	}
	if(komanda==Komande::PomjeriDalje){
		stanje=Idi(polja,x,y,p_x,p_y);
		if(stanje==Status::KrajPoraz){
			cout&lt;&lt;"Nagazili ste minu";
			komanda=Komande::ZavrsiIgru;
		}
		if(stanje==Status::KrajPobjeda){
			cout&lt;&lt;"Bravo,obisli ste sva sigurna polja";
			komanda=Komande::ZavrsiIgru;
		}
		else cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
	}
	if(komanda==Komande::PrikaziOkolinu){
		Matrica mat=PrikaziOkolinu(polja,x,y);
		IspisiMatricu(mat);
	}
	if(komanda==Komande::Blokiraj) BlokirajPolje(polja,p_x,p_y);
	if(komanda==Komande::Deblokiraj) DeblokirajPolje(polja,p_x,p_y);
	if(komanda==Komande::ZavrsiIgru){
		for(int i=0;i&lt;polja.size();i++){
			for(int j=0;j&lt;polja.at(i).size();j++) polja.at(i).at(j)=Polje::Prazno;
		}
		throw runtime_error("Igra zavrsena");
	}
	if(komanda==Komande::KreirajIgru){
		cout&lt;&lt;"Unesite broj polja: ";
		int n;
		cin&gt;&gt;n;
		cout&lt;&lt;"Unesite pozicije mina: ";
		Matrica mine;
		complex&lt;int&gt;par;
		for(;;){
			cin.clear();
			cin.ignore(10000,'\n');
			cin&gt;&gt;par;
			if(!cin){
				cin.clear();
				if(cin.peek()=='.'){
					cin.ignore(100000,'\n');
					break;
				}
				else{
					cout&lt;&lt;"Greska,unesite ponovo"&lt;&lt;endl;
					continue;
				}
			}
			if(real(par)&lt;0 || real(par)&gt;=n || imag(par)&lt;0 || imag(par)&gt;=n){
				cout&lt;&lt;"Greska,unesite ponovo"&lt;&lt;endl;
				continue;
			}
			mine.push_back({real(par),imag(par)});
			x=0;y=0;
		}
		try{
			polja=KreirajIgru(n,mine);
		}
		catch(domain_error e){
			cout&lt;&lt;e.what();
		}
	}
}

int main (){
	Tabla tabla;
	Komande komanda;
	KodoviGresaka greska;
	Smjerovi smjer;
	int x(0),y(0),polje_x(0),polje_y(0);
	try{
		for(;;){
<a name="7"></a><font color="#0000FF"><a href="match618-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

			cout&lt;&lt;"Unesite komandu: ";
			if(UnosKomande(komanda,smjer,x,y,greska)){
				IzvrsiKomandu(komanda,tabla,x,y,smjer,polje_x,polje_y);
			}
			else PrijaviGresku(greska);
</font>		}
	}
	catch(domain_error e){
		cout&lt;&lt;e.what();
//		continue;
	}
	catch(std::logic_error e){
		cout&lt;&lt;e.what();
//		continue; 
	}
	catch(std::out_of_range e){
		cout&lt;&lt;e.what();
//		continue;
	} 
	catch(runtime_error){
		cout&lt;&lt;"Dovidjenja";
	}
	return 0;
}</pre>
</body>
</html>
