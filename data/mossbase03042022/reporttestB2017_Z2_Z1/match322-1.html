<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student2896.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student3671.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;stdexcept&gt;
#include&lt;cmath&gt;
<a name="8"></a><font color="#00FFFF"><a href="match322-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

using namespace std;

enum class Polje
{
    Prazno,Posjeceno,Mina,BlokiranoPrazno,BlokiranoPosjeceno,BlokiranoMina
};

enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
</font>};

enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};

typedef vector&lt;vector&lt;bool&gt;&gt;Logicka;
typedef vector&lt;vector&lt;Polje&gt;&gt;Tabla;

Tabla KreirajIgru(int n,const vector&lt;vector&lt;int&gt;&gt;&amp;mine)
{
	if(n&lt;0){
		throw domain_error("Ilegalna velicina");
	}
	Tabla tabla(n,vector&lt;Polje&gt;(n,Polje::Prazno));
<a name="3"></a><font color="#00FFFF"><a href="match322-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

	for(int i=0; i&lt;mine.size(); i++) {
		if(mine[i].size()!=2)
			throw domain_error("Ilegalan format zadavanja mina");
	}
	for(int i=0;i&lt;mine.size();i++){
		for(int j=0;j&lt;mine[i].size();j++){
			if((mine[i][j]&gt;=tabla.size()) || mine[i][j]&lt;0) throw domain_error("Ilegalne pozicije mina");
</font>		}
	}
	for(int i=0; i&lt;mine.size(); i++) {
		tabla[mine[i][0]][mine[i][1]]=Polje::Mina;
	}
	return tabla;
}

Logicka Izdvoji(const Tabla &amp;polja,int x, int y)
{
	Logicka m(5,vector&lt;bool&gt;(5));
	for(int i=-2; i&lt;=2; i++) {
		for(int j=-2; j&lt;=2; j++) {
			if(polja[x+i][y+j]==Polje::Mina) m[i+2][j+2]=bool(polja[x+i][y+j]);
			else m[i+2][j+2]=0;
		}
	}
	return m;
}
int JeLiMina(Logicka mat,int x,int y)
{
	int br_mina(0);
	for(int i=0; i&lt;mat.size(); i++) {
		for(int j=0; j&lt;mat[i].size(); j++) {
			if(mat[x+i][y+j]==true)
				br_mina++;
		}
	}
	return br_mina;
}


vector&lt;vector&lt;int&gt;&gt;PrikaziOkolinu(const Tabla &amp;polja,int x,int y)
{
	if(x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.size()) throw domain_error("Polje ("+to_string(x)+","+to_string(y)+") ne postoji");
	vector&lt;vector&lt;int&gt;&gt;m(3,vector&lt;int&gt;(3));
<a name="7"></a><font color="#0000FF"><a href="match322-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	Logicka l=Izdvoji(polja,x,y);
	for(int i=0; i&lt;m.size(); i++) {
		for(int j=0; j&lt;m[i].size(); j++) {
</font>			m[i][j]=JeLiMina(l,x,y);
		}
	}
	return m;
}

<a name="6"></a><font color="#00FF00"><a href="match322-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

void BlokirajPolje(Tabla &amp;polja,int x,int y)
{
	if(x&gt;=polja.size() || x&lt;0 || y&gt;=polja.size() || y&lt;0) {
</font>		throw domain_error("Polje(" + to_string(x) + "," + to_string(y) + ") ne postoji");
	}
	if(polja[x][y]==Polje::Prazno) polja[x][y]=Polje::BlokiranoPrazno;
	else if(polja[x][y]==Polje::Mina) polja[x][y]=Polje::BlokiranoMina;
<a name="4"></a><font color="#FF00FF"><a href="match322-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

	else if(polja[x][y]==Polje::Posjeceno) polja[x][y]=Polje::BlokiranoPosjeceno;
}

void DeblokirajPolje(Tabla &amp;polja,int x,int y)
{
	if(x&gt;=polja.size() || x&lt;0 || y&gt;=polja.size() || y&lt;0) {
</font><a name="10"></a><font color="#FF0000"><a href="match322-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		throw domain_error("Polje(x,y) ne postoji");
	}
	if(polja[x][y]==Polje::BlokiranoPrazno) polja[x][y]=Polje::Prazno;
	else if(polja[x][y]==Polje::BlokiranoMina) polja[x][y]=Polje::Mina;
</font><a name="2"></a><font color="#0000FF"><a href="match322-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

	else if(polja[x][y]==Polje::BlokiranoPosjeceno) polja[x][y]=Polje::Posjeceno;
}

Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,Smjerovi smjer)
{
	int i1(x),j1(y);
	if(smjer==Smjerovi::GoreLijevo) {
		i1--;
		j1--;
	} else if(smjer==Smjerovi::GoreDesno) {
		i1--;
</font>		j1++;
	} else if(smjer==Smjerovi::DoljeLijevo) {
		i1++;
		j1--;
<a name="9"></a><font color="#FF00FF"><a href="match322-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

	} else if(smjer==Smjerovi::DoljeDesno) {
		i1++;
		j1++;
	} else if(smjer==Smjerovi::Desno) {
		j1++;
	} else if(smjer==Smjerovi::Lijevo) {
		j1--;
</font>	} else if(smjer==Smjerovi::Gore) {
		i1--;
	} else if(smjer==Smjerovi::Dolje) {
		i1++;
	}
	if(i1&lt;0 || i1&gt;=polja.size() || j1&lt;0 || j1&gt;=polja.size()) {
<a name="0"></a><font color="#FF0000"><a href="match322-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

		throw out_of_range("Izlazak van igrace table");
	}
	if(polja[i1][j1]==Polje::BlokiranoPosjeceno || polja[i1][j1]==Polje::BlokiranoPrazno || polja[i1][j1]==Polje::BlokiranoMina) {
		throw logic_error("Blokirano polje");
	}
	polja[x][y]=Polje::Posjeceno;
	x=i1; 
	y=j1;
		
	if(polja[x][y]==Polje::Mina){
		for(int i=0;i&lt;polja.size();i++){
			for(int j=0;j&lt;polja[i].size();j++){
				polja[i][j]=Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	else{
		bool prazna(false);
</font>		for(int i=0;i&lt;polja.size();i++){
			for(int j=0;j&lt;polja[i].size();j++){
				if(i==x &amp;&amp; j==y) continue;
				else if(polja[i][j]==Polje::Prazno){
					prazna=true;
					break;
				}
			}
			if(prazna) break;
		}
		if(!prazna) return Status::KrajPobjeda;
	}
	return Status::NijeKraj;
}



<a name="5"></a><font color="#FF0000"><a href="match322-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

Status Idi(Tabla &amp;polja, int &amp;x,int &amp;y,int slj_x,int slj_y)
{
	if(slj_x&lt;0 || slj_x&gt;=polja.size() || slj_y&lt;0 || slj_y&gt;=polja.size())  throw out_of_range("Izlazak van igrace table");
</font><a name="1"></a><font color="#00FF00"><a href="match322-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

	if(polja[slj_x][slj_y]==Polje::BlokiranoPosjeceno || polja[slj_x][slj_y]==Polje::BlokiranoPrazno || polja[slj_x][slj_y]==Polje::BlokiranoMina)
		throw logic_error("Blokirano polje");
		
	polja[x][y]=Polje::Posjeceno;
	x=slj_x; 
	y=slj_y;
		
	if(polja[x][y]==Polje::Mina){
		for(int i=0;i&lt;polja.size();i++){
			for(int j=0;j&lt;polja[i].size();j++){
				polja[i][j]=Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	else{
		bool prazna(false);
</font>		for(int i=0;i&lt;polja.size();i++){
			for(int j=0;j&lt;polja[i].size();j++){
				if(i==x &amp;&amp; j==y) continue;
				else if(polja[i][j]==Polje::Prazno){
					prazna=true;
					break;
				}
			}
			if(prazna) break;
		}
		if(!prazna) return Status::KrajPobjeda;
	}
	return Status::NijeKraj;
}

int main ()
{
	int n;
	cout&lt;&lt;"Unesite broj polja: ";
	cin&gt;&gt;n;

	return 0;
}</pre>
</body>
</html>
