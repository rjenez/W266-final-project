<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4770.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4770.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
template &lt;typename T&gt;
std::string PretvoriUString(T x){	std::ostringstream s;	s &lt;&lt; x;		return s.str(); }
enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
enum class Komande
{
    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
    ZavrsiIgru, KreirajIgru
};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

int BrojMinaUOkolini(const Tabla &amp;polja,int x,int y)
{
	int broj_mina(0);
	for(int i=0; i&lt;=2; i++) {
		for(int j=0; j&lt;=2; j++) {
			if((x+i-1)&lt;0 || x+i-1&gt;=polja.size() || (y+j-1)&lt;0 || y+j-1&gt;=polja.size()) continue;
			if(i==1 &amp;&amp; j==1) continue;
			if(polja.at(x+i-1).at(y+j-1)==Polje::Mina) broj_mina++;
		}
	}
	return broj_mina;
}

bool DaLiJeBlokirano(Tabla &amp;polja,int x,int y)
{
<a name="4"></a><font color="#FF00FF"><a href="match954-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

	if(polja[x][y]==Polje::BlokiranoMina || polja[x][y]==Polje::BlokiranoPrazno || polja[x][y]==Polje::BlokiranoPosjeceno) return true;
</font>	return false;
}

void PostaviNaPrazno(Tabla &amp;polja)
{
	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja.size(); j++) {
			polja.at(i).at(j)=Polje::Prazno;
		}
	}
}

bool DaLiJeKraj(const Tabla &amp;polja)
{
	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja.size(); j++) {
			if(polja.at(i).at(j)!=Polje::Posjeceno) return false;
		}
	}
	return true;
}

bool DaLiJeSlovo(char x)
{
	if((x&gt;='A' &amp;&amp; x&lt;='Z')|| (x&gt;='a' &amp;&amp; x&lt;='z')) return true;
	return false;
}

bool DaLiJeBroj(char x)
{
	if(x&gt;='0' &amp;&amp; x&lt;='9') return true;
	return false;
}

int PretvoriUBroj(std::string string1, int x, int y)
{
	int i(0);
	int broj(0);
	if(y-x==1) {
		broj+=string1[x]-'0';
		return broj;
	}
	while(y&gt;=x) {
		broj+=(string1[y]-'0')*pow(10,i);
		i++;
		y--;
	}
	return broj;
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{	
<a name="5"></a><font color="#FF0000"><a href="match954-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

	if(n&lt;=0) throw std::domain_error("Ilegalna velicina");
	Tabla igraca_tabla(n, std::vector&lt;Polje&gt;(n, Polje::Prazno));
	for(int i=0; i&lt;mine.size(); i++) {
</font>		if(mine.at(i).size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
	}
	for(int i=0; i&lt;mine.size(); i++) {
		if(mine[i][0]&gt;=n || mine[i][1]&gt;=n) throw std::domain_error("Ilegalne pozicije mina");
	}
	for(int i=0; i&lt;mine.size(); i++)
		igraca_tabla[mine[i][0]][mine[i][1]] = Polje::Mina;
	return igraca_tabla;

}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
	std::vector&lt;int&gt; pomocni;
	if(x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.at(0).size()) throw std::domain_error("Polje ("+ PretvoriUString(x)+ ","+PretvoriUString(y)+") ne postoji");
	std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;
	for(int i=-1; i&lt;=1; i++) {
		for(int j=-1; j&lt;=1; j++) {
			pomocni.push_back(BrojMinaUOkolini(polja,x+i,y+j));
		}
		Matrica.push_back(pomocni);
		pomocni.resize(0);
	}
	return Matrica;
}

void BlokirajPolje(Tabla &amp;polja, int x,int y)
{
	if(x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.at(0).size()) throw std::domain_error("Polje ("+PretvoriUString(x)+","+PretvoriUString(y)+") ne postoji");
	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja.at(i).size(); j++) {
			if(i==x &amp;&amp; j==y) {
				if(polja.at(i).at(j)==Polje::Prazno) polja.at(i).at(j)=Polje::BlokiranoPrazno;
				else if(polja.at(i).at(j)==Polje::Posjeceno) polja.at(i).at(j)=Polje::BlokiranoPosjeceno;
				else if(polja.at(i).at(j)==Polje::Mina) polja.at(i).at(j)=Polje::BlokiranoMina;
			}
		}
	}
}

void DeblokirajPolje(Tabla &amp;polja, int x,int y)
{
	if(x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.at(0).size()) throw std::domain_error("Polje (" + PretvoriUString(x) + "," + PretvoriUString(y) +") ne postoji");
	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja.at(i).size(); j++) {
			if(i==x &amp;&amp; j==y) {
				if(polja.at(i).at(j)==Polje::BlokiranoPrazno) polja.at(i).at(j)=Polje::Prazno;
				else if(polja.at(i).at(j)==Polje::BlokiranoPosjeceno) polja.at(i).at(j)=Polje::Posjeceno;
				else if(polja.at(i).at(j)==Polje::BlokiranoMina) polja.at(i).at(j)=Polje::Mina;
			}
		}
	}
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
	if(!(x-1&gt;=0) &amp;&amp; !(y-1&gt;=0) &amp;&amp; smjer==Smjerovi::GoreLijevo) throw std::out_of_range("Izlazak van igrace table");
	else if(!(x-1&gt;=0) &amp;&amp; smjer==Smjerovi::Gore) throw std::out_of_range("Izlazak van igrace table");
	else if(!(x-1&gt;=0) &amp;&amp; !(y+1&lt;polja.size()) &amp;&amp; smjer==Smjerovi::GoreDesno) throw std::out_of_range("Izlazak van igrace table");
	else if(!(y-1&gt;=0) &amp;&amp; smjer==Smjerovi::Lijevo) throw std::out_of_range("Izlazak van igrace table");
	else if(!(y+1&lt;polja.size()) &amp;&amp; smjer==Smjerovi::Desno) throw std::out_of_range("Izlazak van igrace table");
	else if(!(x+1&lt;polja.size()) &amp;&amp; !(y-1&gt;=0) &amp;&amp; smjer==Smjerovi::DoljeDesno) throw std::out_of_range ("Izlazak van igrace table");
	else if(!(x+1&lt;polja.size()) &amp;&amp; smjer==Smjerovi::Dolje) throw std::out_of_range("Izlazak van igrace table");
	else if(!(x+1&lt;polja.size()) &amp;&amp; !(y+1&lt;polja.size()) &amp;&amp; smjer==Smjerovi::DoljeDesno) throw std::out_of_range("Izlazak van igrace table");
	bool mina(false);
	if(x-1&gt;=0 &amp;&amp; y-1&gt;=0 &amp;&amp; smjer==Smjerovi::GoreLijevo) {

		if(DaLiJeBlokirano(polja,x-1,y-1)) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x-=1;
		y-=1;
		if(polja[x][y]==Polje::Mina) mina=true;
	} else if(x-1&gt;=0 &amp;&amp; smjer==Smjerovi::Gore) {
		if(DaLiJeBlokirano(polja,x-1,y)) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x-=1;
		if(polja[x][y]==Polje::Mina) mina=true;
	} else if(x-1&gt;=0 &amp;&amp; y+1&lt;polja.size() &amp;&amp; smjer==Smjerovi::GoreDesno) {
		if(DaLiJeBlokirano(polja,x-1,y+1)) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x-=1;
		y+=1;
		if(polja[x][y]==Polje::Mina) mina=true;
	} else if(y-1&gt;=0 &amp;&amp; smjer==Smjerovi::Lijevo) {
		int a=x;
		int b=y-1;
		if(DaLiJeBlokirano(polja,a,b)) throw std::logic_error("Blokirano polje");
		polja[x][y]=Polje::Posjeceno;
		y-=1;
		if(polja[x][y]==Polje::Mina) mina=true;
	} else if(y+1&lt;polja.size() &amp;&amp; smjer==Smjerovi::Desno) {
		if(DaLiJeBlokirano(polja,x,y+1)) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		y+=1;
		if(polja[x][y]==Polje::Mina) mina=true;
	} else if(x+1&lt;polja.size() &amp;&amp; y-1&gt;=0 &amp;&amp; smjer==Smjerovi::DoljeLijevo) {
		if(DaLiJeBlokirano(polja,x+1,y-1)) throw std::logic_error("Blokirano polje");
		polja[x][y]=Polje::Posjeceno;
		x+=1;
		y-=1;
		if(polja[x][y]==Polje::Mina) mina=true;
	} else if(x+1&lt;polja.size() &amp;&amp; smjer==Smjerovi::Dolje) {
		if(DaLiJeBlokirano(polja,x+1,y)) throw std::logic_error("Blokirano polje");
		polja[x][y]=Polje::Posjeceno;
		x+=1;
		if(polja[x][y]==Polje::Mina) mina=true;
	} else if(x+1&lt;polja.size() &amp;&amp; y+1&lt;polja.size() &amp;&amp; smjer==Smjerovi::DoljeDesno) {
		if(DaLiJeBlokirano(polja,x+1,y+1)) throw std::logic_error("Blokirano polje");
		polja[x][y]=Polje::Posjeceno;
		x+=1;
		y+=1;
		if(polja[x][y]==Polje::Mina) mina=true;
	}
	if(mina) {
		PostaviNaPrazno(polja);
		return Status::KrajPoraz;
	} else if(DaLiJeKraj(polja)) return Status::KrajPobjeda;
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja,int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if(std::abs(x-novi_x)&lt;0 || x+novi_x&gt;polja.size() || std::abs(y-novi_y)&lt;0 || y+novi_y&gt;polja.size()) throw std::out_of_range("Izlazak van igrace table");
	if(DaLiJeBlokirano(polja,novi_x,novi_y)) throw std::logic_error("Blokirano polje");
	bool mina(false);

	x=novi_x;
	y=novi_y;
	if(polja[x][y]==Polje::Mina) mina=true;
	if(mina) {
		PostaviNaPrazno(polja);
		return Status::KrajPoraz;
	} else if(DaLiJeKraj(polja))
		return Status::KrajPobjeda;

	return Status::NijeKraj;
}

<a name="6"></a><font color="#00FF00"><a href="match954-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

void PrijaviGresku(KodoviGresaka greska)
{
	if(greska==KodoviGresaka::PogresnaKomanda) std::cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;std::endl;
	else if(greska==KodoviGresaka::NedostajeParametar) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;std::endl;
</font>	else if(greska==KodoviGresaka::NeispravanParametar)	std::cout&lt;&lt;"Parametar komande nije ispravan!"&lt;&lt;std::endl;
	else if(greska==KodoviGresaka::SuvisanParametar)	 std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;std::endl;
}
std::string OdrediSmjeric(std::string s,int brojac)
{
	std::string k("NISAMSMJERIC");
	while(brojac&lt;s.length()) {
		if(s[brojac]=='G' &amp;&amp; brojac+1&lt;s.length() &amp;&amp; s[brojac+1]=='L') {
			k="GL";
			break;
		} else if(s[brojac]=='G' &amp;&amp; brojac+1&lt;s.length() &amp;&amp; s[brojac+1]=='D') {
			k="GD";
			break;
		} else if(s[brojac]=='G') {
			k="G";
			break;
		} else if(s[brojac]=='L') {
			k="L";
			break;
		} else if(s[brojac]=='D' &amp;&amp; brojac+2&lt;s.length() &amp;&amp; s[brojac+1]=='o' &amp;&amp; s[brojac+2]=='D') {
			k="DoD";
			break;
		} else if(s[brojac]=='D' &amp;&amp; brojac+2&lt;s.length() &amp;&amp; s[brojac+1]=='o' &amp;&amp; s[brojac+2]=='L') {
			k="DoL";
			break;
		} else if(s[brojac]=='D' &amp;&amp; brojac+1&lt;s.length() &amp;&amp; s[brojac+1]=='o') {
			k="Do";
		} else if(s[brojac]=='D') {
			k="D";
			break;
		}
		brojac++;
	}
<a name="2"></a><font color="#0000FF"><a href="match954-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

	return k;
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	std::string s;
	std::getline(std::cin, s);
</font>	if(s.substr(0,2)=="P1") {
		komanda = Komande::PomjeriJednoMjesto;
		std::string smjeric(OdrediSmjeric(s,0));
		if(smjeric=="GL") smjer = Smjerovi::GoreLijevo;
		else if(smjeric=="GD") smjer = Smjerovi::GoreDesno;
		else if(smjeric=="G") smjer = Smjerovi::Gore;
		else if(smjeric=="L") smjer = Smjerovi::Lijevo;
		else if(smjeric=="D") smjer = Smjerovi::Desno;
		else if(smjeric=="DoD") smjer = Smjerovi::DoljeDesno;
		else if(smjeric=="Do") smjer = Smjerovi::Dolje;
		else if(smjeric=="DoL") smjer = Smjerovi::DoljeLijevo;
	} else if(s.substr(0,2)=="P&gt;") {
		if(2&lt;s.length() &amp;&amp; (s[2]==' ' || DaLiJeBroj(s[2]))) {
			int pomocnibrojac(2);
			while(s[pomocnibrojac]==' ') pomocnibrojac++;
			if(!DaLiJeBroj(s[pomocnibrojac])) {
				greska = KodoviGresaka::PogresnaKomanda;
				return false;
			}
			char p=s[pomocnibrojac];
			int brojac(pomocnibrojac);
			while(p!=' ' &amp;&amp; brojac&lt;s.length()) {
				brojac++;
				p=s[brojac];
			}

			if(s[brojac]!=' ') {
				greska = KodoviGresaka::PogresnaKomanda;
				return false;
			}
			x = PretvoriUBroj(s,pomocnibrojac,brojac);

			pomocnibrojac=brojac;
			while(s[pomocnibrojac]==' ') pomocnibrojac++;
			brojac = pomocnibrojac;
			while(DaLiJeBroj(s[pomocnibrojac])) pomocnibrojac++;
			y = PretvoriUBroj(s,brojac,pomocnibrojac);
			komanda = Komande::PomjeriDalje;
		} else {
			greska = KodoviGresaka::PogresnaKomanda;
			return false;
		}
	} else if(s.substr(0,2)=="PO") {
		if(s.size()!=2) {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		komanda = Komande::PrikaziOkolinu;
	} else if(s[0]=='Z') {
		if(s.size()!=1) {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		komanda = Komande::ZavrsiIgru;
	} else if(s[0]=='K') {
		if(s.size()!=1) {
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
		komanda = Komande::KreirajIgru;

	} else if(s[0]=='B' || s[0]=='D') {
		if(1&lt;s.length() &amp;&amp; (s[1]==' ' || DaLiJeBroj(s[1]))) {
			int pomocnibrojac(1);
			while(s[pomocnibrojac]==' ') pomocnibrojac++;
			if(!DaLiJeBroj(s[pomocnibrojac])) {
				greska = KodoviGresaka::PogresnaKomanda;
				return false;
			}
			char p=s[pomocnibrojac];
			int brojac(pomocnibrojac);
			while(p!=' ' &amp;&amp; brojac&lt;s.length()) {
				brojac++;
				p=s[brojac];
			}
			if(s[brojac]!=' ') {
				greska = KodoviGresaka::PogresnaKomanda;
				return false;
			}
			x = PretvoriUBroj(s,pomocnibrojac,brojac);
			pomocnibrojac=brojac;
			while(s[pomocnibrojac]==' ') pomocnibrojac++;
			brojac = pomocnibrojac;
			while(DaLiJeBroj(s[pomocnibrojac])) pomocnibrojac++;
			y = PretvoriUBroj(s,brojac,pomocnibrojac);
			if(s[0]=='B') komanda = Komande::Blokiraj;
			if(s[0]=='D') komanda = Komande::Deblokiraj;
		}
	}

	return true;
}
void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0)
{

<a name="3"></a><font color="#00FFFF"><a href="match954-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

	if(komanda  == Komande::PomjeriJednoMjesto) {
		try {
			Status status = Idi(polja,x,y,p_smjer);
			if(status==Status::NijeKraj) std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
</font>			if(status == Status::KrajPobjeda) {
				std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja";
				PostaviNaPrazno(polja);
				throw std::runtime_error ("Igra zavrsena");
			} else if( status == Status::KrajPoraz) {
				std::cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;std::endl;
				PostaviNaPrazno(polja);
				throw std::runtime_error ("Igra zavrsena");
			}
		} catch (std::out_of_range izuzetak) {
<a name="1"></a><font color="#00FF00"><a href="match954-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

			std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
		} catch (std::logic_error izuzetak1) {
			std::cout &lt;&lt; izuzetak1.what() &lt;&lt; std::endl;
		}

	} else if (komanda == Komande::PomjeriDalje) {
		try {
			Status status = Idi(polja,x,y,p_x,p_y);
			if(status==Status::NijeKraj) std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
</font>			if(status == Status::KrajPobjeda) {
				std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja";
				PostaviNaPrazno(polja);
				throw std::runtime_error ("Igra zavrsena");
			} else if(status == Status::KrajPoraz) {
				std::cout&lt;&lt;"Nagazili ste na minu";
				PostaviNaPrazno(polja);
				throw std::runtime_error ("Igra zavrsena");
			}
		} catch (std::out_of_range izuzetak) {
<a name="7"></a><font color="#0000FF"><a href="match954-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

			std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
		} catch (std::logic_error izuzetak1) {
			std::cout &lt;&lt; izuzetak1.what() &lt;&lt; std::endl;
		}
	} else if (komanda == Komande::Blokiraj) {
</font><a name="0"></a><font color="#FF0000"><a href="match954-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		try {
			BlokirajPolje(polja,p_x,p_y);
		} catch (std::domain_error izuzetak) {
			std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
		}
	} else if (komanda == Komande::Deblokiraj) {
		try {
			DeblokirajPolje(polja,p_x,p_y);
		} catch (std::domain_error izuzetak) {
			std::cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
		}
	} else if (komanda == Komande::PrikaziOkolinu) {
</font>		try {
			auto Matrica(PrikaziOkolinu(polja,x,y));
			for(auto red : Matrica) {
				for(auto broj : red) std::cout&lt;&lt;broj&lt;&lt;" ";
<a name="8"></a><font color="#00FFFF"><a href="match954-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

				std::cout&lt;&lt;std::endl;
			}
		} catch (std::domain_error izuzetak) {
			std::cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
		}
	} else if (komanda == Komande::ZavrsiIgru) {
</font>		PostaviNaPrazno(polja);
		throw std::runtime_error("Igra zavrsena");
	} else if (komanda == Komande::KreirajIgru) {
		std::cout&lt;&lt;"Unesite broj polja: ";
		int k;
		for(;;) {
			std::cin&gt;&gt;k;
			if(k&gt;0) break;
			else std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl&lt;&lt;"Unesite broj polja: ";
			
		}
		std::cin.ignore(10000,'\n');
		std::vector&lt;std::vector&lt;int&gt;&gt; mine;
		std::cout&lt;&lt;"Unesite pozicije mina: ";
		std::string mine1;
		int x,y;
		bool ispravno(true);
		for(;;) {
			std::getline(std::cin,mine1);
			if(mine1[0]=='.') break;
			if(mine1[0]!= '(' ) {
				std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
				mine1.resize(0);
				continue;
			}
			if(mine1[0]=='(') {
				int i(1);
				while(mine1.at(i)==' ' &amp;&amp; i&lt;mine1.size()) {
					i++;
				}
				if(DaLiJeBroj(mine1[i])) x=mine1[i]-'0';
				else {
					std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
					mine1.resize(0);
					continue;
				}
				if(i&lt;mine1.size()) i++;
				while(mine1.at(i)==' ' &amp;&amp; i&lt;mine1.size()) {
					i++;
				}
				if(mine1.at(i)==',') {
					if(i&lt;mine1.size()) i++;
					while(mine1.at(i)==' ' &amp;&amp; i&lt;mine1.size()) i++;
					if(DaLiJeBroj(mine1.at(i))) y = mine1[i]-'0';
					else {
						std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
						mine1.resize(0);
						continue;
					}
				} else {
					std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
					mine1.resize(0);
					continue;
				}
				if(DaLiJeBroj(mine1.at(i))) {
					if(i&lt;mine1.size()) i++;
					while(mine1.at(i)==' ' &amp;&amp; i&lt;mine.size()) {
						i++;
					}
					if(mine1.at(i)==')') {
						ispravno=true;
						if(i&lt;mine1.size()) i++;
						while(i&lt;mine1.size()) {
							if(mine1.at(i)!=' ') ispravno=false;
							i++;
						}
						if(!ispravno) {
							std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
							mine1.resize(0);
							continue;
						}
					} else {
						std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
						mine1.resize(0);
						continue;
					}
				}
				if(x&gt;k || y &gt; k) {
					std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
					mine1.resize(0);
					continue;
				}
				std::vector&lt;int&gt; pomocni;
				pomocni.push_back(x);
				pomocni.push_back(y);
				mine.push_back(pomocni);
				mine1.resize(0);
			}
		}
		polja = KreirajIgru(k,mine);
	}
}
int main ()
{

	try {
		Tabla polja;
		KodoviGresaka greske;
		Komande komanda;
		Smjerovi smjeric;
		int x(0),y(0),nx(0),ny(0);
		for(;;) {
			std::cout&lt;&lt;"Unesite komandu: ";
			if(UnosKomande(komanda,smjeric,nx,ny,greske)) {
				IzvrsiKomandu(komanda,polja,x,y,smjeric,nx,ny);
			} else PrijaviGresku(greske);
		}
	} catch(...) {
		std::cout&lt;&lt;"Dovidjenja!"&lt;&lt;std::endl;
	}
	return 0;
	
}</pre>
</body>
</html>
