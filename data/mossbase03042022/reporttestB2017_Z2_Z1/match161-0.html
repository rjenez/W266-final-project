<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4772.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4772.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

<a name="0"></a><font color="#FF0000"><a href="match161-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru (int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	if(n&lt;=0) throw std::domain_error("Ilegalna velicina");
	Tabla tabla(n, std::vector&lt;Polje&gt;(n, Polje::Prazno));
	for (int i=0; i&lt;mine.size(); i++) {
		if(mine[i].size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
		if(i&gt;=n || mine[i].size()&gt;=n) throw std::domain_error("Ilegalne pozicije mina");
	}
	for (int i=0; i&lt;mine.size(); i++) {
		int x=mine[i][0];
		int y=mine[i][1];
		tabla[x][y]=Polje::Mina;
	}
	return tabla;
}

int OkolinaPolja (const Tabla &amp;polja, int x, int y) {
	int br(0);
	if(x==0 &amp;&amp; y==0) {
		for (int i=x; i&lt;=x+1; i++) {
			for (int j=y; j&lt;=y+1; j++) {
				if (i!=x &amp;&amp; j!=y &amp;&amp; polja[i][j]==Mina) br++;
			}
		}
	} else if (x==polja.size()-1 &amp;&amp; y==0) {
		for (int i=x-1; i&lt;=x; i++) {
			for (int j=0; j&lt;=1; j++) {
				if(i!=x &amp;&amp; j!=y &amp;&amp; polja[i][j]==Mina) br++;
			}
		}
	} else if (x==0 &amp;&amp; y==polja.size()-1) {
		for (int i=0; i&lt;=x+1; i++) {
			for (int j=y-1; j&lt;=polja.size()-1) {
				if (i!=x &amp;&amp; j!=y &amp;&amp; polja[i][j]==Mina) br++;
			}
		}
	} else if (x==polja.size()-1 &amp;&amp; y==polja.size()-1) {
		for (int i=x-1; i&lt;=x; i++) {
			for (int j=y-1; j&lt;y; j++) {
				if(i!=x &amp;&amp; y!=y &amp;&amp; polja[i][j]==Mina) br++;
			}
		}
	} else if(x==0) {
		for (int i=x; i&lt;=x+1; i++) {
			for (int j=y-1; j&lt;=y+1; j++) {
				if(i!=x &amp;&amp; j!=y &amp;&amp; polja[i][j]==Mina) br++;
			}
		}
	} else if (y==0) {
		for (int i=x-1; i&lt;=x+1; i++) {
			for (int j=y; j&lt;=y+1; j++) {
				if(i!=x &amp;&amp; j!=y &amp;&amp; polja[i][j]==Mina) br++;
			}
		}
	} else if (x==polja.size()-1) {
		for (int i=x-1; i&lt;=x; i++) {
			for (int j=y-1; j&lt;=y+1; j++) {
				if (i!=x &amp;&amp; j!=&lt; &amp;&amp; polja[i][j]==Mina) br++;
			}
		}
	} else if (y==polja.size()-1) {
		for (int i=x-1; i&lt;=x+1; i++) {
			for (int j=y-1; j&lt;=y; j++) {
				if (i!=x &amp;&amp; j!=y &amp;&amp; polja[i][j]==Mina) br++;
			}
		}
	} else {
		for (int i=x-1; i&lt;=x+1; i+=2) {
			for (int j=y-1; j&lt;=y+1; j+=2) {
				if(polja[i][j]==Mina) br++;
			}
		}
	} 
	
	
	return br;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu (const Tabla &amp;polja, int x, int y) {
	if(x&gt;=polja.size() || y&gt;=polja[0].size() || x&lt;0 || y&lt;0) throw std::domain_error("Polje (x,y) ne postoji");
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina(3, std::vector&lt;int&gt;(3));
	int red, kolona;
	if(x==0) {
		okolina[0]={0,0,0};
		if(y==0) {
			okolina[1][0]=0;
			okolina[2][0]=0;
			red=1; kolona=1;
			for (int i=0; i&lt;=1; i++) {
				for (int j=0; j&lt;=1; j++) {
					okolina[red][kolona]=OkolinaPolja(polja, i, j);
					kolona++;
				}
				red++;
			}
			
		} else if(y==polja.size()-1) {
			okolina[1][2]=0;
			okolina[2][2]=0;
			red=1; kolona=0;
			for (int i=0; i&lt;=1; i++) {
				for (int j=y-1; j&lt;=y; j++) {
					okolina[red][kolona]=OkolinaPolja(polja, i, j);
					kolona++;
				}
				red++;
			}
		} else {
			red=1; kolona=0;
			for (int i=0; i&lt;=1; i++) {
				for (int j=y-1; j&lt;=y+1; j++) {
					okolina[red][kolona]=OkolinaPolja(polja, i, j);
					kolona++;
				}
				red++;
			}
		}
	}
	else if (x==polja.size()-1) {
		okolina[2]={0,0,0};
		red=0;
		if(y==0) {
			okolina[0][0]=0;
			okolina[1][0]=0;
			kolona=1;
			for (int i=x-1; i&lt;=x; i++) {
				for (int j=0; j&lt;=1; j++) {
					okolina[red][kolona]=OkolinaPolja(polja, i, j);
					kolona++;
				}
				red++;
			}
		} else if (y==polja.size()-1) {
			okolina[0][2]=0;
			okolina[1][2]=0;
			for (int i=x-1; i&lt;=x; i++) {
				for (int j=y-1; j&lt;=y; j++) {
					okolina[red][kolona]=OkolinaPolja(polja, i, j);
					kolona++;
				}
				red++;
			}
		} else {
			
			
		}
		
	}
	
}



int main ()
</font>{
	return 0;
}</pre>
</body>
</html>
