<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student2221.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student8224.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

<a name="0"></a><font color="#FF0000"><a href="match50-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_50.gif"/></a>

enum class Polje {Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};

typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
Tabla KreirajTablu(int broj_redova, int broj_kolona)
{
	return Tabla(broj_redova, std::vector&lt;Polje&gt;(broj_kolona));
}

Matrica KreirajMatricu (int broj_redova, int broj_kolona)
{
	return Matrica(broj_redova, std::vector&lt;int&gt;(broj_kolona));
}

Tabla KreirajIgru (int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
	auto tabla(KreirajTablu(n,n));
	
	std::vector&lt;std::vector&lt;int&gt;&gt; pomocni = mine;
	if (n &lt;= 0) throw std::domain_error ("Ilegalna velicina");
	for (int i = 0; i &lt; mine.size(); i++)
	{
		if (mine[i].size() != 2) throw std::domain_error ("Ilegalan format zadavanja mina");
	}
	
	for (int i = 0; i &lt; mine.size(); i++)
	{
		for (int j = 0; j &lt; mine[i].size(); j++)
		{
			if (mine[i][j] &gt; mine.size()) throw std::domain_error ("Ilegalne pozicije mina");
		}
	}
	
	for (int i = 0; i &lt; mine.size(); i++)
	{
		for (int j = 0; j &lt; mine[i].size()-1; j++)
		{
			tabla[mine[i][j]][mine[i][j+1]] = Polje::Mina;
		}
	}
	
	return tabla;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu (const Tabla &amp;polja, int x, int y)
{
	
	auto mine = KreirajMatricu(3,3);
	int brojac(0);
	for (int i = 0; i &lt; polja.size(); i++)
	{
		for (int j = 0; j &lt; polja[i].size(); j++)
		{
			
				if (x &gt; polja.size()-1 || y &gt; polja[i].size()) throw std::domain_error ("Polje (x,y) ne postoji");
			
		}
	}
	
	
	for (int i = 0; i &lt; 3; i++)
	{
		for (int j = 0; j &lt; 3; j++)
		{
			if (i == x &amp;&amp; j == y)
			{
				
			        if (polja[x-1][y] == Polje::Mina) brojac++;
			        if (polja[x][y] == Polje::Mina) brojac++;
			        if (polja[x][y-1] == Polje::Mina) brojac++;
			        mine[0][0] = brojac;
			        brojac = 0; 
				
				
					if (polja[x-1][y-1] == Polje::Mina) brojac++;
					if (polja[x-1][j+1] == Polje::Mina) brojac++;
					if (polja[x][j] == Polje::Mina) brojac++;
					if (polja[x][j+1] == Polje::Mina) brojac++;
					if (polja[x][y-1] == Polje::Mina) brojac++;
				    mine[0][1] = brojac;
				    brojac = 0; 
				
					if (polja[x-1][y+2] == Polje::Mina) brojac++;
					if (polja[x-1][y] == Polje::Mina) brojac++;
					if (polja[x][y] == Polje::Mina) brojac++;
					if (polja[x][y+1] == Polje::Mina) brojac++;
					if (polja[x][y+2] == Polje::Mina) brojac++;
				    mine[0][2] = brojac;
				    brojac = 0;
				    
				    if (polja[x-1][y-1] == Polje::Mina) brojac++;
				    if (polja[x][j-1] == Polje::Mina) brojac++;
				    if (polja[x-1][y] == Polje::Mina) brojac++;
				    if (polja[x][y] == Polje::Mina) brojac++;
				    if (polja[x+1][y-1] == Polje::Mina) brojac++;
				    if (polja[x+1][y] == Polje::Mina) brojac++;
				    mine[1][0] = brojac;
				    brojac = 0;
				    
				    if (polja[x-1][y-1] == Polje::Mina) brojac++;
				    if (polja[x-1][y] == Polje::Mina) brojac++;
				    if (polja[x-1][y+1] == Polje::Mina) brojac++;
				    if (polja[x][y+1] == Polje::Mina) brojac++;
				    if (polja[x][y-1] == Polje::Mina) brojac++;
				    if (polja[x+1][y-1] == Polje::Mina) brojac++;
				    if (polja[x+1][y] == Polje::Mina) brojac++;
				    if (polja[x+1][y+1] == Polje::Mina) brojac++;
				    mine[1][1] = brojac;
				    brojac = 0;
				    
				    if (polja[x][y] == Polje::Mina) brojac++;
				    if (polja[x-1][y] == Polje::Mina) brojac++;
				    if (polja[x-1][y+1] == Polje::Mina) brojac++;
				    if (polja[x-1][y+2] == Polje::Mina) brojac++;
				    if (polja[x][y+2] == Polje::Mina) brojac++;
				    if (polja[x+1][y-1] == Polje::Mina) brojac++;
				    if (polja[x+1][y] == Polje::Mina) brojac++;
				    if (polja[x+1][y+1] == Polje::Mina) brojac++;
				    mine[1][2] = brojac;
				    brojac = 0;
				    
				    if (polja[x+1][y-1] == Polje::Mina) brojac++;
				    if (polja[x][y-1] == Polje::Mina) brojac++;
				    if (polja[x+2][y-1] == Polje::Mina) brojac++;
				    if (polja[x+2][y] == Polje::Mina) brojac++;
				    if (polja[x][y] == Polje::Mina) brojac++;
				    mine[2][0] = brojac;
				    brojac = 0;
				    
				    if (polja[x][y-1] == Polje::Mina) brojac++;
				    if (polja[x][y] == Polje::Mina) brojac++;
				    if (polja[x][y+1] == Polje::Mina) brojac++;
				    if (polja[x+1][y-1] == Polje::Mina) brojac++;
				    if (polja[x][y+1] == Polje::Mina) brojac++;
				    if (polja[x+2][y-1] == Polje::Mina) brojac++;
				    if (polja[x+2][y] == Polje::Mina) brojac++;
				    if (polja[x+2][y+1] == Polje::Mina) brojac++;
				    mine[2][1] = brojac;
				    brojac = 0;
				    
				    if (polja[x][y] == Polje::Mina) brojac++;
				    if (polja[x][y+1] == Polje::Mina) brojac++;
				    if (polja[x][y+2] == Polje::Mina) brojac++;
				    if (polja[x+1][y] == Polje::Mina) brojac++;
				    if (polja[x+1][y+2] == Polje::Mina) brojac++;
				    if (polja[x+2][y] == Polje::Mina) brojac++;
				    if (polja[x+2][y+1] == Polje::Mina) brojac++;
				    if (polja[x+2][y+2] == Polje::Mina) brojac++;
				    mine[2][2] = brojac;
				    	
				    }
			}
		}
	return mine;
}

void BlokirajPolje (Tabla &amp;polja, int x, int y)
{
	if (polja.size() &lt; x || polja[0].size() &lt; y) throw std::domain_error ("Polje (x,y) ne postoji");
	
	for (int i = 0; i &lt; polja.size(); i++)
	{
		for (int j = 0; j &lt; polja[i].size(); j++)
		{
			if (i == x &amp;&amp; j == y)
			{
				if (polja[i][j] == Polje::Prazno) polja[i][j] = Polje::BlokiranoPrazno;
</font><a name="2"></a><font color="#0000FF"><a href="match50-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

				if (polja[i][j] == Polje::Posjeceno) polja[i][j] = Polje::BlokiranoPosjeceno;
				if (polja[i][j] == Polje::Mina) polja[i][j] = Polje::BlokiranoMina;
			}
		}
	}
}


void DeblokirajPolje (Tabla &amp;polja, int x, int y)
{
	if (polja.size() &lt; x || polja[0].size() &lt; y) throw std::domain_error ("Polje (x,y) ne postoji");
	
	for (int i = 0; i &lt; polja.size(); i++)
	{
		for (int j = 0; j &lt; polja[i].size(); j++)
		{
			if (i == x &amp;&amp; j == y)
			{
				if (polja[i][j] == Polje::BlokiranoPrazno) polja[i][j] = Polje::Prazno;
</font><a name="1"></a><font color="#00FF00"><a href="match50-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_43.gif"/></a>

				if (polja[i][j] == Polje::BlokiranoPosjeceno) polja[i][j] = Polje::Posjeceno;
				if (polja[i][j] == Polje::BlokiranoMina) polja[i][j] = Polje::Mina;
			}
		}
	}
}

enum class Smjerovi {GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};


Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
    Status s = Status::NijeKraj;
    
    if (x &gt; polja.size() || y &gt; polja[0].size()) throw std::out_of_range ("Izlazak van igrace table");
   
    
    if (x == 0 &amp;&amp; y == 0) 
    {
    	polja[x][y] = Polje::Posjeceno;
    	polja[x][y] != Polje::Mina;
    }

		   if (smjer == Smjerovi::GoreLijevo )
		   {
		   	  polja[x][y] = Polje::Posjeceno;
		   	  x = x-1;
		   	  y = y-1;
		   	  if (polja[x][y] == Polje::BlokiranoPrazno) throw std::domain_error ("Blokirano polje");
		   	  if (polja[x][y] == Polje::Mina) s = Status::KrajPoraz;
		   	  
		   }
		   
		   if (smjer == Smjerovi::Gore)
		   {
		   	  polja[x][y] = Polje::Posjeceno;
		   	  x = x-1;
		   	  y = y;
		   	  if (polja[x][y] == Polje::BlokiranoPrazno) throw std::domain_error ("Blokirano polje");
		   	  if (polja[x][y] == Polje::Mina) s = Status::KrajPoraz;
		   	  
		   }
		   
		   if (smjer == Smjerovi::GoreDesno)
		   {
		   	   polja[x][y] = Polje::Posjeceno;
		   	   x = x-1;
		   	   y = y+1;
		   	   if (polja[x][y] == Polje::BlokiranoPrazno) throw std::domain_error ("Blokirano polje");
		   	   if (polja[x][y] == Polje::Mina) s = Status::KrajPoraz;
		   	  
		   }
		   
		   if (smjer == Smjerovi::Desno)
		   {
		   	   polja[x][y] == Polje::Posjeceno;
		   	   x = x;
		   	   y = y+1;
		   	   if (polja[x][y] == Polje::BlokiranoPosjeceno || polja[x][y] == Polje::BlokiranoPrazno || polja[x][y] == Polje::BlokiranoMina) throw std::domain_error ("Blokirano polje");
		   	   if (polja[x][y] == Polje::Mina) s = Status::KrajPoraz;
		   	   
		   }
		   
		   if (smjer == Smjerovi::DoljeDesno)
		   {
		   	   polja[x][y] = Polje::Posjeceno;
		   	   x = x+1;
		   	   y = y+1;
		   	   if (polja[x][y] == Polje::BlokiranoPrazno) throw std::domain_error ("Blokirano polje");
		   	   if (polja[x][y] == Polje::Mina) s = Status::KrajPoraz;
		   	   
		   }
		   
		   if (smjer == Smjerovi::Dolje)
		   {
		   	   polja[x][y] = Polje::Posjeceno;
		   	   x = x+1;
		   	   if (polja[x][y] == Polje::BlokiranoPrazno) throw std::domain_error ("Blokirano polje");
		   	   if (polja[x][y] == Polje::Mina) s = Status::KrajPoraz;
		   	   
		   }
		   
		   if (smjer == Smjerovi::DoljeLijevo)
		   {
		   	   polja[x][y] = Polje::Posjeceno;
		   	   x = x+1;
		   	   y = y-1;
		   	   if (polja[x][y] == Polje::BlokiranoPrazno) throw std::domain_error ("Blokirano polje");
		   	   if (polja[x][y] == Polje::Mina) s = Status::KrajPoraz;
		   
		   }
		   
		   if (smjer == Smjerovi::Lijevo)
		   {
		   	   polja[x][y] = Polje::Posjeceno;
		   	   x = x;
		   	   y = y-1;
		   	   if (polja[x][y] == Polje::Mina) s = Status::KrajPoraz;
		   }
		   
		   for (int i = 0; i &lt; polja.size(); i++)
		   {
		   	  for (int j = 0; j &lt; polja[i].size(); j++)
		   	  {
		   	  	if (polja[i][j] == Polje::Prazno) s = Status::KrajPobjeda;
		   	  }
		   }
    
    if (s == Status::KrajPoraz)
    {
    	for (int i = 0; i &lt; polja.size(); i++)
    	{
    		for (int j = 0; j &lt; polja[i].size(); j++)
    		{
    			polja[i][j] = Polje::Prazno;
    		}
    	}
    }
	
	return s;
}

Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if (novi_x &gt; polja.size() || novi_y &gt; polja[0].size()) throw std::out_of_range("Izlazak van igrace table");
	if (polja[novi_x][novi_y] == Polje::BlokiranoPrazno) throw std::domain_error ("Blokirano polje");
	
	Status s = Status::NijeKraj;
	polja[x][y] == Polje::Posjeceno;
	for (int i = 0; i &lt; polja.size(); i++)
	{
		for (int j = 0; j &lt; polja[i].size(); j++)
		{
			x = novi_x;
			y = novi_y;
			polja[x][y] = Polje::Posjeceno;
			if (polja[x][y] == Polje::Mina) 
			{
				s = Status::KrajPoraz;
				break;
			}
		}
	}
	
	for (int i = 0; i &lt; polja.size(); i++)
	{
		for (int j = 0; j &lt; polja[i].size(); j++)
		{
			if (polja[i][j] == Polje::Posjeceno) s = Status::KrajPobjeda;
		}
	}
    
    if (s == Status::KrajPoraz)
    {
    	for (int i = 0; i &lt; polja.size(); i++)
    	{
    		for (int j = 0; j &lt; polja[i].size(); j++)
    		{
    			polja[i][j] = Polje::Prazno;
    		}
    	}
    }
	
	return s;
	
}

enum class KodoviGresaka {PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};

void PrijaviGresku (KodoviGresaka greska)
{
	if (greska == KodoviGresaka::PogresnaKomanda) std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl;
	if (greska == KodoviGresaka::NedostajeParametar) std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
	if (greska == KodoviGresaka::NeispravanParametar) std::cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; std::endl;
	if (greska == KodoviGresaka::SuvisanParametar) std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt; std::endl;
}

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

bool UnosKomande (Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	bool komanda1(false);
	std::string s;
	std::cout &lt;&lt; "Unesite komandu: ";
	std::getline(std::cin, s);
	for (int i = 0; i &lt; s.length(); i++)
	{
		if (s[i] == 'K')komanda1 = true;
	}
}







void ispisiTablu(std::vector&lt;std::vector&lt;Polje&gt;&gt; polja){
   for(int i = 0; i &lt; polja.size(); i++) {
          for(int j = 0; j &lt; polja[i].size(); j++) std::cout &lt;&lt; int(polja[i][j]) &lt;&lt; " ";
          std::cout &lt;&lt; std::endl;
        }
}


int main ()
{
	  int x = 0, y = 0;
    std::vector&lt;std::vector&lt;int&gt;&gt; mine = {{0,2}, {1,0}, {1,1}, {1,2}, {2,0}, {2,1}, {2,2}};
    std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla = KreirajIgru(3, mine);
   try{
     Idi(tabla, x, y, Smjerovi::Lijevo);
   }
   catch(std::out_of_range e){
     std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
   }
   BlokirajPolje(tabla, 0, 1);
   try{
     Idi(tabla, x, y, Smjerovi::Desno);
   }
   catch(std::logic_error e){
     std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
</font>   }
	return 0;
}</pre>
</body>
</html>
