<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student1390.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z1/student4934.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

<a name="1"></a><font color="#00FF00"><a href="match53-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_21.gif"/></a>

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

Tabla KreirajIgru(int n, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){

	for(int i(0); i &lt; mine.size()-1; i++){
		if(mine.at(i).size() != mine.at(i+1).size()) throw std::domain_error("Ilegalan format zadavanja mina");
		
	}
	if(n &lt;= 0) throw std::domain_error("Ilegalna velicina");
	
	for(int i(0); i &lt; mine.size(); i++){
		for(int j(0); j &lt; mine.at(i).size(); j++){
			if(mine.at(i).at(j) &lt; 0 || mine.at(i).at(j) &gt; n) throw std::domain_error("Ilegalne pozicije mina");
		}
	}
	
	
	Tabla tablica(n,std::vector&lt;Polje&gt; (n));
	
	for(int i(0); i &lt; n; i++){
		for(int j(0); j &lt; n; j++){
			for(int k(0); k &lt; mine.size(); k++){
				if(i == mine.at(k).at(0) &amp;&amp; j == mine.at(k).at(1)){
					Polje mina;
					mina = Polje::Mina;
					tablica.at(i).at(j) = mina;
					break;
				}
				if(i != mine.at(k).at(0) || j != mine.at(k).at(1)){
					Polje prazno;
					prazno = Polje::Prazno;
					tablica.at(i).at(j) = prazno;
				}
					
			}
		}
	
	}

	return tablica;
}

int broji(const Tabla &amp;polja, int x, int y){
	int brojac(0);
	for(int i(x-1); i &lt;= x+1; i++){
		if(i &lt; 0 || i &gt; polja.size()) continue;
		for(int j(y-1); j &lt;= y+1; j++){
			//if(x &lt; 0 || x &gt; polja.size() || y &lt; 0 || y &gt; polja[0].size()) continue;
			if(j &lt; 0 || j &gt; polja[0].size()) continue;
			//if(polja[x][y] == Polje::Mina) ;
			if(polja[i][j] == Polje::Mina){
				brojac++;
				if(i == x &amp;&amp; j == y) brojac--;
			}
		}
	}
	return brojac;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	std::vector&lt;std::vector&lt;int&gt;&gt; Matrica(3, std::vector&lt;int&gt; (3));
	int red(0), kolona(0);
	if((x &lt; 0 || x &gt; polja.size()) ||(y &lt; 0 || y &gt; polja.at(0).size())) throw std::domain_error("Polje (x, y) ne postoji");
	
	for(int i(x-1); i &lt;= x+1; i++){
		for(int j(y-1); j &lt;= y+1; j++){
			Matrica[red][kolona] = broji(polja, i, j);
			kolona++;
		}
		kolona = 0;
		red++;
	}
	return Matrica;
}

void BlokirajPolje (Tabla &amp;polja, int x, int y){
	if((x &lt; 0 || x &gt; polja.size()) || (y &lt; 0 || y &gt; polja[0].size())) throw std::domain_error("Polje (x,y) ne postoji");
	if(polja.at(x).at(y) == Polje::BlokiranoPosjeceno || polja.at(x).at(y) == Polje::BlokiranoPrazno || polja.at(x).at(y) == Polje::BlokiranoMina);// break;
	else if(polja.at(x).at(y) == Polje::Prazno) polja.at(x).at(y) = Polje::BlokiranoPrazno;
</font>	else if(polja.at(x).at(y) == Polje::Posjeceno) polja.at(x).at(y) = Polje::BlokiranoPosjeceno;
<a name="2"></a><font color="#0000FF"><a href="match53-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

	else if(polja.at(x).at(y) == Polje::Mina) polja.at(x).at(y) = Polje::BlokiranoMina;
}

void DeblokirajPolje (Tabla &amp;polja, int x, int y){
	if((x &lt; 0 || x &gt; polja.size()) || (y &lt; 0 || y &gt; polja[0].size())) throw std::domain_error("Polje (x,y) ne postoji");
	if(polja.at(x).at(y) == Polje::Posjeceno || polja.at(x).at(y) == Polje::Prazno || polja.at(x).at(y) == Polje::Mina);
	else if(polja.at(x).at(y) == Polje::BlokiranoPrazno) polja.at(x).at(y) = Polje::Prazno;
</font>	else if(polja.at(x).at(y) == Polje::BlokiranoPosjeceno) polja.at(x).at(y) = Polje::Posjeceno;
<a name="0"></a><font color="#FF0000"><a href="match53-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_71.gif"/></a>

	else if(polja.at(x).at(y) == Polje::BlokiranoMina) polja.at(x).at(y) = Polje::Mina;
}

void gore(Tabla &amp;tabla, int &amp;x, int &amp;y){
	tabla[x][y] = Polje::Posjeceno;
	x--;
	if(tabla[x][y] == Polje::BlokiranoPosjeceno || tabla[x][y] == Polje::BlokiranoPrazno || tabla[x][y] == Polje::BlokiranoMina)
	throw std::logic_error("Blokirano polje");
}

void dolje(Tabla &amp;tabla, int &amp;x, int &amp;y){
	tabla[x][y] = Polje::Posjeceno;
	x++;
	if(tabla[x][y] == Polje::BlokiranoPosjeceno || tabla[x][y] == Polje::BlokiranoPrazno || tabla[x][y] == Polje::BlokiranoMina)
	throw std::logic_error("Blokirano polje");
}

void gorelijevo(Tabla &amp;tabla, int &amp;x, int &amp;y){
	tabla[x][y] = Polje::Posjeceno;
	x--; y--;
	if(tabla[x][y] == Polje::BlokiranoPosjeceno || tabla[x][y] == Polje::BlokiranoPrazno || tabla[x][y] == Polje::BlokiranoMina)
	throw std::logic_error("Blokirano polje");
}

void goredesno(Tabla &amp;tabla, int &amp;x, int &amp;y){
	tabla[x][y] = Polje::Posjeceno;
	x--; y++;
	if(tabla[x][y] == Polje::BlokiranoPosjeceno || tabla[x][y] == Polje::BlokiranoPrazno || tabla[x][y] == Polje::BlokiranoMina)
	throw std::logic_error("Blokirano polje");
}

void desno(Tabla &amp;tabla, int &amp;x, int &amp;y){
	tabla[x][y] = Polje::Posjeceno;
	y++;
	if(tabla[x][y] == Polje::BlokiranoPosjeceno || tabla[x][y] == Polje::BlokiranoPrazno || tabla[x][y] == Polje::BlokiranoMina)
	throw std::logic_error("Blokirano polje");
}

void lijevo(Tabla &amp;tabla, int &amp;x, int &amp;y){
	tabla[x][y] = Polje::Posjeceno;
	y--;
	if(tabla[x][y] == Polje::BlokiranoPosjeceno || tabla[x][y] == Polje::BlokiranoPrazno || tabla[x][y] == Polje::BlokiranoMina)
	throw std::logic_error("Blokirano polje");
}

void doljelijevo(Tabla &amp;tabla, int &amp;x, int &amp;y){
	tabla[x][y] = Polje::Posjeceno;
	y--; x++;
	if(tabla[x][y] == Polje::BlokiranoPosjeceno || tabla[x][y] == Polje::BlokiranoPrazno || tabla[x][y] == Polje::BlokiranoMina)
	throw std::logic_error("Blokirano polje");
}

void doljedesno(Tabla &amp;tabla, int &amp;x, int &amp;y){
	tabla[x][y] = Polje::Posjeceno;
	y++; x++;
	if(tabla[x][y] == Polje::BlokiranoPosjeceno || tabla[x][y] == Polje::BlokiranoPrazno || tabla[x][y] == Polje::BlokiranoMina)
	throw std::logic_error("Blokirano polje");
}


Status Idi(Tabla &amp;tabla, int &amp;x, int &amp;y, Smjerovi smjer){

	void (*npf[8])(Tabla&amp;,int&amp;,int&amp;) = {gorelijevo, gore, goredesno, desno, doljedesno, dolje, doljelijevo, lijevo};
	int broj;
	for(int i(0); i &lt; 8; i++){
		if(smjer == Smjerovi(i)){
			broj = i;
			break;
		}
	}
	try{
	npf[broj](tabla,x,y);
	}
	catch(std::logic_error){
		throw;
	}
	if(x &lt; 0 || x &gt; tabla.size() || y &lt; 0 || y &gt; tabla[0].size()) throw std::out_of_range("Izlazak van igrace table");
	if(tabla[x][y] == Polje::Mina){
		for(int i(0); i &lt; tabla.size(); i++){
			for(int j(0); j &lt; tabla.at(i).size(); j++){
				tabla[i][j] = Polje::Prazno;
			}
		}
		 return Status::KrajPoraz;
	}
	
	for(int i(0); i &lt; tabla.size(); i++){
		for(int j(0); j &lt; tabla.at(i).size(); j++){
			if(tabla[i][j] == Polje::Posjeceno || tabla[i][j] == Polje::Mina) return Status::KrajPobjeda;
		}
	}
	
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;tabla, int &amp;x, int &amp;y, int NoviX, int NoviY){

	if(NoviX &lt; 0 || NoviX &gt; tabla.size()) throw std::out_of_range("Izlazak van igrace table");
	if(NoviY &lt; 0 || NoviY &gt; tabla[0].size()) throw std::out_of_range("Izlazak van igrace table");
	
	x = NoviX;
	y = NoviY;
	
	if(tabla[x][y] == Polje::BlokiranoPosjeceno || tabla[x][y] == Polje::BlokiranoPrazno || tabla[x][y] == Polje::BlokiranoMina)
	throw std::logic_error("Blokirano polje");
	
	if(tabla[x][y] == Polje::Mina){
		for(int i(0); i &lt; tabla.size(); i++){
			for(int j(0); j &lt; tabla.at(i).size(); j++){
				tabla[i][j] = Polje::Prazno;
			}
		}
		 return Status::KrajPoraz;
	}
	
	for(int i(0); i &lt; tabla.size(); i++){
		for(int j(0); j &lt; tabla.at(i).size(); j++){
			if(tabla[i][j] == Polje::Posjeceno || tabla[i][j] == Polje::Mina) return Status::KrajPobjeda;
		}
	}
	
	return Status::NijeKraj;
	
}

void PrijaviGresku(KodoviGresaka greska){
	std::string NizStringova[4] = {"Nerazumljiva Komanda", "Komanda trazi parametar koji nije naveden!", "Parametar komande nije ispravan!", "Zadan je suvisan parametar nakon komande!"};
	for(int i(0); i &lt; 4; i++){
		if(greska == KodoviGresaka(i)){
			 std::cout&lt;&lt;NizStringova[i];
			 break;
		}
	}
}

int BROJACRIJECI(std::string s){
	int razmak(1), BrojRijeci(0);
	for(int i(0); i &lt; s.length(); i++){
		if(s.at(i) == ' '){
			razmak = 1;
		}
		else if(razmak){
			BrojRijeci++;
			razmak = 0;
		}
	}
	return BrojRijeci;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	std::string komand;
	std::cout&lt;&lt;"Unesite komandu: "&lt;&lt;std::endl;
	std::getline(std::cin,komand);
	int Rijeci(BROJACRIJECI(komand));
	if(Rijeci == 0 || Rijeci){
		greska = KodoviGresaka::PogresnaKomanda;
		return false;
	}
	//std::string ValidneKomande[7] = {"P1","P&gt;","B","D","PO","Z","K"};
	
	/*if(Rijeci &gt; 3){
		greska = KodoviGresaka::SuvisanParametar;
		return false;
	}*/
	std::string pomocni;
	std::string pomocnadruga;
	std::string pomocnatreca;
	int razmak(1), BrojRijeci(0),brojac_komandi(0),indexKomande(0),brojac_parametra(0);
	std::string ValidneKomande[7] = {"P1","P&gt;","B","D","PO","Z","K"};
	for(int i(0); i &lt; komand.length(); i++){
		if(komand.at(i) == ' '){
			razmak = 1;
		}
		else if(razmak){
			BrojRijeci++;
			razmak = 0;
			if(BrojRijeci == 1){
				for(int j(i); komand[j] != ' ' &amp;&amp; j &lt; komand.length(); j++){
					pomocni.push_back(komand[j]);
				}
				for(int k(0); k &lt; 7; k++){
					if(pomocni == ValidneKomande[k]){
					 	indexKomande = k;
					 	break;
					}
					brojac_komandi++;
				}
				if(brojac_komandi == 7){
					greska = KodoviGresaka::PogresnaKomanda;
					return false;
				}
				for(int p(4); p &lt;= 6; p++){
					if(pomocni == ValidneKomande[p] &amp;&amp; Rijeci &gt; 1){
						greska = KodoviGresaka::SuvisanParametar;
						return false;
					}
				}
				if(pomocni == ValidneKomande[0] &amp;&amp; Rijeci &gt; 2){
					greska = KodoviGresaka::SuvisanParametar;
					return false;
				}
				for(int q(1); q &lt;= 3; q++){
					if(pomocni == ValidneKomande[q] &amp;&amp; (Rijeci &gt; 3)){
						greska = KodoviGresaka::SuvisanParametar;
						return false;
					}
					if(pomocni == ValidneKomande[q] &amp;&amp; Rijeci &lt; 3){
						greska = KodoviGresaka::NedostajeParametar;
						return false;
					}
				}
			}
			if(BrojRijeci == 2){
				/*for(int i(4); i &lt;= 6; i++){
					if(komanda == ValidneKomande[i]) greska = KodoviGresaka::SuvisanParametar;
				}*/
				//std::string pomocnadruga;
				for(int j(i); komand[j] != ' ' &amp;&amp; j &lt; komand.length(); j++){
					pomocnadruga.push_back(komand[j]);
				}
				if(pomocni != ValidneKomande[0]){
					for(int j(0); j &lt; pomocnadruga.length(); j++){
						if(pomocnadruga[j] &lt; '0' || pomocnadruga[j] &gt; '9'){
							greska = KodoviGresaka::SuvisanParametar;
							return false;
						}
					}
					x = std::stoi(pomocnadruga);
				}
				if(pomocni == ValidneKomande[0]){
					std::string ValidniParametar[8] = {"GL","G","GD","D","DoD","Do","DoL","L"};
					for(int j(0); j &lt; 8; j++){
						if(pomocnadruga == ValidniParametar[j]){
							smjer = Smjerovi(j);
							break;
						}
						brojac_parametra++;
					}
					if(brojac_parametra == 8){
						greska = KodoviGresaka::SuvisanParametar;
						return false;
					}
				}
				
			}
			if(BrojRijeci == 3){
				for(int j(i); komand[j] != ' ' &amp;&amp; j &lt; komand.length(); j++){
					pomocnatreca.push_back(komand[j]);
				}
				for(int j(0); j &lt; pomocnatreca.length(); j++){
					if(pomocnatreca[j] &lt; '0' || pomocnatreca[j] &gt; '9'){
						greska = KodoviGresaka::SuvisanParametar;
						return false;
					}
				}
				y = std::stoi(pomocnatreca);
			}
		}
	}
		/*for(int i(0); i &lt; 7; i++){
			if(pomocni == ValidneKomande[i]){
				komanda = Komande(i);
				break;
			}
		}*/
		komanda = Komande(indexKomande);
		
		return true;
}

void IzvrsiKomandu(Komande komanda,Tabla &amp;polja, int &amp;x, int &amp;y,Smjerovi p_smjer = Smjerovi::Gore,int p_x = 0, int p_y = 0){
	double BrojPolja(0);
	if(komanda == Komande(0)){
		try{
		Status RezIdi(Idi(polja,x,y,p_smjer));
		if(RezIdi == Status::NijeKraj) std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;", "&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
		else if(RezIdi == Status::KrajPoraz) std::cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;std::endl;
		else if(RezIdi == Status::KrajPobjeda) std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;std::endl;
		}
		catch(std::out_of_range izuzetak){
			std::cout&lt;&lt;izuzetak.what();
		}
		catch(std::logic_error izuzetak){
			std::cout&lt;&lt;izuzetak.what();
		}
	}
	if(komanda == Komande(1)){
		try{
		Status RezIdi(Idi(polja,x,y,p_x,p_y));
		if(RezIdi == Status::NijeKraj) std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;", "&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
		else if(RezIdi == Status::KrajPoraz){
			 std::cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;std::endl;
			 komanda = Komande(5);
		}
		else if(RezIdi == Status::KrajPobjeda){
			std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;std::endl;
			komanda = Komande(5);
		}
		}
		catch(std::out_of_range izuzetak){
			std::cout&lt;&lt;izuzetak.what();
		}
		catch(std::logic_error izuzetak){
			std::cout&lt;&lt;izuzetak.what();
		}
	}
	
	if(komanda == Komande(2)){
		try{
			BlokirajPolje(polja,x,y);
		}
		catch(std::domain_error izuzetak){
			std::cout&lt;&lt;izuzetak.what();
		}
	}
	if(komanda == Komande(3)){
		try{
			DeblokirajPolje(polja,x,y);
		}
		catch(std::domain_error izuzetak){
			std::cout&lt;&lt;izuzetak.what();
		}
	}
	if(komanda == Komande(4)){
		try{
		std::vector&lt;std::vector&lt;int&gt;&gt; matrica(PrikaziOkolinu(polja,x,y));
		for(int i(0); i &lt; matrica.size(); i++){
			for(int j(0); j &lt; matrica[0].size(); j++){
				std::cout&lt;&lt;matrica.at(i).at(j)&lt;&lt;" ";
			}
			std::cout&lt;&lt;std::endl;
		}
		}
		catch(std::domain_error izuzetak){
			std::cout&lt;&lt;izuzetak.what();
		}
	}
	
	if(komanda == Komande(5)){
		for(int i(0); i &lt; polja.size(); i++){
			for(int j(0); j &lt; polja[0].size(); j++){
				polja[i][j] = Polje::Prazno;
			}
		}
		throw std::runtime_error("Igra zavrsena");
	}
	
	if(komanda == Komande(6)){
		do{
		std::cout&lt;&lt;"Unesite broj polja: ";
		std::cin&gt;&gt;BrojPolja;
		if(BrojPolja &lt;= 0 || BrojPolja != (int)BrojPolja || std::cin){
			std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
		}
		}
		while(BrojPolja &lt;= 0 || BrojPolja != (int)BrojPolja || std::cin);
	}
	
	
	
}

int main ()
</font>{
	/*int broj;
	std::cout&lt;&lt;"Unesi broj: ";
	std::cin&gt;&gt;broj;
	std::vector&lt;std::vector&lt;int&gt;&gt; v{{0,0},{0,2},{1,3}};
	try{
	Tabla tabe(KreirajIgru(broj, v));
	try{
	BlokirajPolje(tabe,0,0);
	DeblokirajPolje(tabe,0,0);
	}
	catch(std::domain_error izuzetak){
		std::cout&lt;&lt;izuzetak.what();
		return 0;
	}
	for(int i(0); i &lt; tabe.size(); i++){
		for(int j(0); j &lt; tabe.at(i).size(); j++){
			std::cout&lt;&lt;(int)tabe.at(i).at(j);//&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	}
	catch(std::domain_error izuzetak){
		std::cout&lt;&lt;izuzetak.what();
	}*/
	/*Komande komanda;
	Sm
	if(UnosKomande)*/
	return 0;
}</pre>
</body>
</html>
