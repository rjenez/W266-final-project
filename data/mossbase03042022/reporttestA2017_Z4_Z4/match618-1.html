<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z4/Z4/student7193.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z4/Z4/student1246.c<p></p><pre>
#include &lt;stdio.h&gt;

int slovaJednaka(char a, char b){
    if(a &gt;= 'A' &amp;&amp; a &lt;= 'Z') a += 32;
    if(b &gt;= 'A' &amp;&amp; b &lt;= 'Z') b +=32;
    
    return a == b;
}

//Funkcija unesi, kopirana iz tut9 2. zad radi testiranja
void unesi(char niz[], int velicina) {
    char znak = getchar();
    if (znak == '\n') znak=getchar();
    int i = 0;
    while (i &lt; velicina-1 &amp;&amp; znak != '\n') {
        niz[i] = znak;
        i++;
        znak = getchar();
    }
    niz[i]='\0';
}

int provjeri(char *str){
    //s za string, p pomocni, pi pocetak intervala, a ki kraj intervala
    //po i ko su pocetak i kraj otvorenog taga, a pz i kz su pocetak i kraj zatvorenog taga
    //ppi i kpi su pocetak i kraj podintervala
<a name="0"></a><font color="#FF0000"><a href="match618-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    char *s, *p, *r, *pi, *ki, *pz, *kz, *po, *ko, *ppi, *kpi, *e;
</font><a name="0"></a><font color="#FF0000"><a href="match618-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    s = p = r = pi = ki = po = ko = pz = kz = ppi = kpi = e = str;
</font>    
    int postaviPocetniInterval = 1;
    int nemaTagova = 1;
    
    //Postavi pocetak intervala na kraj, pretpostavi ga takvog
    while(*pi != '\0') pi++;
    ppi = pi;
    e = pi-1;
    //Zanemari razmake na pocetku i kraju stringa
    while(*e == ' ') e--;
    while(*str == ' ') str++;
    
    //Kreni od drugog karaktera i trazi "&lt;/"
    s++;
    
    while(*s != '\0'){
        
        //Nadji pocetak zatvorenog taga
        if(*s == '/' &amp;&amp; *(s-1) == '&lt;'){
            //Ima tagova xaxa
            nemaTagova = 0;
            //Pocetak zatvorenog taga
            pz = s-1;
            
            //Ako karakter nakon &lt;/ nije slovo
            s++;
            if(*s &lt; 'A' || (*s &gt; 'Z' &amp;&amp; *s &lt; 'a') || *s &gt; 'z') return 0;
            
            //Pocetak naziva taga
            p = s;
            
            //Nadji '&gt;', ne prolazi interval
            while(*s != '&gt;' &amp;&amp; *s != '\0')
                s++;
            // ako '&lt;/' postoji, a nema '&gt;' =&gt; ne valja xaxa
            if(*s == '\0') return 0;
            
            //Kraj zatvorenog taga
            kz = s;
            
            s = pz-1;
            
            if(s &lt; str) return 0;
            
            //Vracaj se unazad i trazi prvi otvoreni tag, trazi '&lt;'
            while(s &gt;= str &amp;&amp; *s != '&lt;'){
                //Preskoci interval i podinterval
                if(s == kpi) s = ppi;
                if(s == ki) s = pi;
                
                s--;
            }
            
            //s je prosao string, a nije nasao '&lt;' =&gt; ne valja
            if(s &lt; str) return 0;
            
            //Pocetak otvorenog taga
            po = s;
            
            //Ako karakter nakon '&lt;' nije slovo =&gt; ne valja
            s++;
            if(*s &lt; 'A' || (*s &gt; 'Z' &amp;&amp; *s &lt; 'a') || *s &gt; 'z') return 0;
            
            //Pocetak naziva taga
            r = s;
            
            //Naci '&gt;' otvorenog taga, trazi do pocetka intervala
            while(*s != '&gt;' &amp;&amp; s != pi &amp;&amp; s != '\0'){
                s++;
            }
            //Nije nadjen '&gt;' za otvoreni tag
            if(s == pi || *s == '\0') return 0;
            
            //Kraj otvorenog taga
            ko = s;
            
            //Prolazi kroz karaktere naziva otvorenog i zatvorenog taga dok su jednaki i (slovo ili broj)
            while((*p != '\0' &amp;&amp; p != kz &amp;&amp; r != ko &amp;&amp; *r != ' ' &amp;&amp; *p != ' ') &amp;&amp; slovaJednaka(*p, *r)){
                //Funkcija slovaJednaka provjerava jednakost karaktera bez obzira bilo veliko ili malo slovo

                //Karakter nije ni slovo ni broj 
                //(prvi karakter naziva sigurno jeste slovo, provjereno ranije vec)
                if(*p &lt; '0' || (*p &gt; '9' &amp;&amp; *p &lt; 'A') || (*p &gt; 'Z' &amp;&amp; *p &lt; 'a') || *p &gt; 'z') return 0;
                if(*r &lt; '0' || (*r &gt; '9' &amp;&amp; *r &lt; 'A') || (*r &gt; 'Z' &amp;&amp; *r &lt; 'a') || *r &gt; 'z') return 0;
                
                p++;
                r++;
            }
            
            s = p;
            //Provjeriti razmake nakon naziva u zatvorenom tagu
            while(s &lt; kz &amp;&amp; *s == ' '){
                s++;
            }
            //Nisu sve razmaci u zatvorenom tagu nakon naziva
            if(s != kz) return 0;
            
            //Moraju nakon niza jednakih karaktera biti ili razmak ili '&gt;' (posto smiju biti razmaci, ali samo razmaci
            //nakon naziva u zatvorenom tagu, dok u otvorenom moze biti atributa raznih, oni me ne zanimaju
            //tako da moze biti tehnicki bilo sta nakon naziva i razmaka u otvorenom tagu),
            //u suprotnom to znaci da nazivi ne odgovaraju
            if(!( (*r == ' ' || *r == '&gt;') &amp;&amp; (*p == '&gt;' || *p == ' ') ) ) return 0;
            

            //Pocetni slucaj, potrebno postaviti osnovni interval na pocetku
            if(postaviPocetniInterval){
                pi = po;
                ki = kz;
                
                postaviPocetniInterval = 0;
            }else{
                
                if(po &gt; ki){
                    if(po &lt; ppi)
                        ppi = po;
                    kpi = kz;
                }else if(po &lt; pi){
                    pi = po;
                    ki = kz;
                }
                
                
            }
            
            //s nastavlja nakon intervalaa
            if(ki &gt;= kpi) s = ki;
            else s = kpi;
        }
        
        s++;
    }
    
    //Ostalo gluposti nakon zatvorenog intervala
    if(!nemaTagova &amp;&amp; ( (pi != str &amp;&amp; ppi != str) || (ki != e &amp;&amp; kpi != e) )) return 0;
    
    //Nema zatvorenih, vidi jel' ima otvorenih
    s = str;
    if(nemaTagova){
        while(*s != '\0'){
            if(*s == '&lt;' || *s == '&gt;'){
                return 0;
            }
            
            s++;
        }
    }
    
    //Sve oke
    return 1;
}

int main() {
	char html[1000];
	unesi(html, 1000);
	
	printf("Oke: %d", provjeri(html));
	
	return 0;
}


/*int provjeri(char *str){
    //s za string, p pomocni, pi pocetak intervala, a ki kraj intervala
    //po i ko su pocetak i kraj otvorenog taga, a pz i kz su pocetak i kraj zatvorenog taga
    char *s, *p, *r, *pi, *ki, *pz, *kz, *po, *ko;
    s = p = r = pi = ki = po = ko = pz = kz = str;
    
    while(*pi != '\0') pi++;

    //Kreni od drugog karaktera i trazi &lt;/
    s++;
    
    while(*s != '\0'){
        
        //Nadji pocetak zatvorenog taga
        if(*s == '/' &amp;&amp; *(s-1) == '&lt;'){
            //Pocetak zatvorenog taga
            pz = s-1;
            
            //Ako karakter nakon &lt;/ nije slovo
            s++;
            if(*s &lt; 'A' || (*s &gt; 'Z' &amp;&amp; *s &lt; 'a') || *s &gt; 'z') return 0;
            
            //Pocetak naziva taga
            p = s;
            
            //Nadji '&gt;', ne prolazi interval
            while(*s != '&gt;' &amp;&amp; *s != '\0')
                s++;
            // ako '&lt;/' postoji, a nema '&gt;' =&gt; ne valja xaxa
            if(*s == '\0') return 0;
            
            //Kraj zatvorenog taga
            kz = s;
            
            s = pz-1;
            
            if(s &lt; str) return 0;
            
            //Vracaj se unazad i trazi prvi otvoreni tag, trazi '&lt;'
            while(s &gt;= str &amp;&amp; *s != '&lt;'){
                //Preskoci interval
                if(s == ki) s = pi;
                
                s--;
            }
            
            //s je prosao string, a nije nasao '&lt;' =&gt; ne valja
            if(s &lt; str) return 0;
            
            //Pocetak otvorenog taga
            po = s;
            
            //Ako karakter nakon '&lt;' nije slovo =&gt; ne valja
            s++;
            if(*s &lt; 'A' || (*s &gt; 'Z' &amp;&amp; *s &lt; 'a') || *s &gt; 'z') return 0;
            
            //Pocetak naziva taga
            r = s;
            
            //Naci '&gt;' otvorenog taga, trazi do pocetka intervala
            while(*s != '&gt;' &amp;&amp; s != pi &amp;&amp; s != '\0'){
                s++;
            }
            //Nije nadjen '&gt;' za otvoreni tag
            if(s == pi || *s == '\0') return 0;
            
            //Kraj otvorenog taga
            ko = s;
            
            //Prolazi kroz karaktere naziva otvorenog i zatvorenog taga dok su jednaki i (slovo ili broj)
            while((*p != '\0' &amp;&amp; p != kz &amp;&amp; r != ko &amp;&amp; *r != ' ' &amp;&amp; *p != ' ') &amp;&amp; slovaJednaka(*p, *r)){
                //Funkcija slovaJednaka provjerava jednakost karaktera bez obzira bilo veliko ili malo slovo

                //Karakter nije ni slovo ni broj 
                //(prvi karakter naziva sigurno jeste slovo, provjereno ranije vec)
                if(*p &lt; '0' || (*p &gt; '9' &amp;&amp; *p &lt; 'A') || (*p &gt; 'Z' &amp;&amp; *p &lt; 'a') || *p &gt; 'z') return 0;
                if(*r &lt; '0' || (*r &gt; '9' &amp;&amp; *r &lt; 'A') || (*r &gt; 'Z' &amp;&amp; *r &lt; 'a') || *r &gt; 'z') return 0;
                
                p++;
                r++;
            }
            
            s = p;
            //Provjeriti razmake nakon naziva u zatvorenom tagu
            while(s &lt; kz &amp;&amp; *s == ' '){
                s++;
            }
            //Nisu sve razmaci u zatvorenom tagu nakon naziva
            if(s != kz) return 0;
            
            //Moraju nakon niza jednakih karaktera biti ili razmak ili '&gt;' (posto smiju biti razmaci, ali samo razmaci
            //nakon naziva u zatvorenom tagu, dok u otvorenom moze biti atributa raznih, oni me ne zanimaju
            //tako da moze biti tehnicki bilo sta nakon naziva i razmaka u otvorenom tagu),
            //u suprotnom to znaci da nazivi ne odgovaraju
            if(!( (*r == ' ' || *r == '&gt;') &amp;&amp; (*p == '&gt;' || *p == ' ') ) ) return 0;
            
            //Prosle su sve provjere za validnost taga, otvoren je i zatvoren
            //Sada je kljucna stvar postaviti interval koji se vise ne pregleda, jer je validan
            //Kraj intervala je jednak kraju zatvorenog taga
            ki = kz;
            //Pocetak intervala je jednak pocetku otvorenog taga
            if(po &lt; pi)
                pi = po;
            
            //s je bitno postaviti na kraj intervala, jer sljedeci zatvoreni tag je sigurno nekad nakon
            //prethodnog
            s = ki;
        }
        
        s++;
    }
    
    //Ostalo gluposti nakon zatvorenog intervala
    if(ki &lt; s) return 0;
    
    //Sve oke
    return 1;
}
*/</pre>
</body>
</html>
