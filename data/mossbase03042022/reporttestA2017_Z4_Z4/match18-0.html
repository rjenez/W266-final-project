<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z4/Z4/student2922.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z4/Z4/student2922.c<p></p><pre>
#include &lt;stdio.h&gt;

<a name="0"></a><font color="#FF0000"><a href="match18-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

int provjeri (const char *s)
{
	int i,j,k=0,brojac=0,br_vracanja=0,br=0,duzina=0,m=0,T=0,br1=0,br2=0,d=0,pon=0,n=0;
	char tag[1000],niz[1000]="\0";
	/*trazenje broja char-ova datog stringa u oznaci "d"*/
	while(s[k]!='\0') {
		d++;
		k++;
	}
	/*vraćanje indeksa "k" */
	for(i=0; i&lt;d; i++)
		k--;
	/*brojanje znakova "&lt;" i "&gt;" */
	while(s[k]!='\0') {
		if(s[k]=='&lt;') br1++;
		if(s[k]=='&gt;') br2++;
		k++;
	}
	/*jedan od uslova*/
	if(br1!=br2) return 0;
	br1=0;
	br2=0;
	/*vraćanje indeksa "k"*/
	for(i=0; i&lt;d; i++)
		k--;
		/*početak "glavnog" dijela programa*/
	while(s[k]!='\0') {
		/*traženje "zatvaranja" tag-a*/
		/*duzina-duzina rijeci i/ili brojeva unutar &lt;/...&gt;*/
		while(k&lt;d) {
			if(s[k]=='&lt;' &amp;&amp; s[k+1]=='/') {
				k+=2;
				for(j=0; j&lt;d; j++) {
					if(s[k]=='&gt;' &amp;&amp; s[k-1]=='/') return 0;
					if(s[k]=='&gt;') break;
					if(s[k]==' ' &amp;&amp; duzina==0) return 0;
					if(s[k]&lt;' ' || (s[k]&gt;' ' &amp;&amp; s[k]&lt;'0') || (s[k]&gt;'9' &amp;&amp; s[k]&lt;'A') || (s[k]&gt;'Z' &amp;&amp; s[k]&lt;'a') || s[k]&gt;'z') return 0;
					tag[j]=s[k];
					duzina++;
					k++;
				}
			}
			if(duzina&gt;0) break;
			k++;
		}
		/*Da li je preostalo otvorenih tagova? (blok ispod)*/
		for(i=0; i&lt;m; i++) {
			br1=0;
			br2=0;
			if(s[i]!='&lt;') T=0;
			if(s[i]=='&lt;') {
				i++;
				while(s[i]!='&gt;' &amp;&amp; i&lt;m) {
					if((s[i]&gt;='A' &amp;&amp; s[i]&lt;='Z') || (s[i]&gt;='a' &amp;&amp; s[i]&lt;='z') || (s[i]&gt;='0' &amp;&amp; s[i]&lt;='9')) br1++;
					if(s[i]&lt;'0' || (s[i]&gt;'9' &amp;&amp; s[i]&lt;'A') || (s[i]&gt;'Z' &amp;&amp; s[i]&lt;'a') || s[i]&gt;'z') break;
					if(s[i]==' ' &amp;&amp; br1&gt;0) {
						while(s[i]!='&gt;' &amp;&amp; i&lt;m) {
							br2++;
							i++;
						}
						i--;
					} else if(s[i]==' ' &amp;&amp; br1==0) break;
					i++;
				}
				if(s[i]!='&gt;' &amp;&amp; i!=m) T=0;
				if(i==m &amp;&amp; s[i]!='&gt;') T=0;
				if(s[i]=='&gt;' &amp;&amp; br1==0) T=0;
				if((s[i]=='&gt;' &amp;&amp; br1&gt;0 &amp;&amp; br2==0) || (s[i]=='&gt;' &amp;&amp; br2&gt;1)) T=1;
			}
			if(T==1) break;
		}
		/*ako je indeks posmatranog stringa dosao do kraja, a ostalo je (ili nije) otvorenih tagova*/
		if(k==d &amp;&amp; T==1) return 0;
		if(k==d &amp;&amp; T==0) return 1;
		/*izbacivanje nepotrebnih razmaka*/
		for(i=0; i&lt;duzina; i++) {
			if(tag[i]==' ') {
				tag[i]=tag[i+1];
				i--;
				duzina--;
			}
		}
		br1=0;
		br2=0;
		j=0;
		/*dio koda koji provjerava koliko puta je neki tag zatvoren na isti nacin (sa istim char-ovima)*/
		for(i=0; i&lt;n; i++) {
			while(j&lt;duzina &amp;&amp; niz[i]!=' ') {
				if(niz[i]==tag[j]) br1++;
				i++;
				j++;
			}
			if(j==duzina &amp;&amp; niz[i]!=' ') {
				while(niz[i]!=' ')
					i++;
			}
			j=0;
			if(br1==duzina) pon++;
			br1=0;
		}
		/*dodavanje u niz char-ove kojima se zatvara tag (kojeg trenutno posmatramo) - sluzi za prethodni dio koda*/
		for(i=0; i&lt;duzina; i++) {
			niz[n]=tag[i];
			n++;
		}
		niz[n]=' ';
		n++;
		if(pon%2!=0) brojac++; /*brojac-broji neodgovarajuca otvaranja tagova; ukoliko postoji istih otvaranja/zatvaranja, potrebno je preskociti vec koristeno otvaranje pri trazenju odgovarajuceg*/
		/*trazenje odgovarajuce otvaranje taga uz prethodno nadjeno zatvaranje*/
		for(i=0; i&lt;d; i++) {
			if(s[k]=='&lt;') {
				for(j=0; j&lt;duzina; j++) {
					if(tag[j]&gt;='A' &amp;&amp; tag[j]&lt;='Z') {
						if((s[k+j+1]==tag[j]) || (s[k+j+1]==(tag[j]+32))) br++;
					} else if(tag[j]&gt;='a' &amp;&amp; tag[j]&lt;='z') {
						if((s[k+j+1]==tag[j]) || (s[k+j+1]==(tag[j]-32))) br++;
					} else {
						if(s[k+j+1]==tag[j]) br++;
					}
				}
				if(br!=j) brojac++; /*povecati broj neodgovarajucih otvaranja se odgovarajuci char-ovi ne poklapaju*/
				else if(br==j &amp;&amp; pon&gt;0) {
					pon--;
					br=0;
					k--;
					continue; /*preskakanje identicnog otvaranja taga, ali ipak neodgovarajuceg*/
				} else if(br==j &amp;&amp; brojac%2!=0) break; /*pronađen odgovarajuce otvaranje*/
				else if(br==j &amp;&amp; brojac%2==0) return 0; 
			}
			k--;
			br=0;
		}
		if(i==d) return 0; /*ako je program dosao do zadnjeg indeksa, prekida se*/
		brojac=0;
		br_vracanja=i;
		m=k-1;
		duzina=0;
		pon=0;
		/*vracanje indeksa "k" na vrijednost (+1) koja je bila pri pronalasku zatvaranja tag-a*/
		for(i=0; i&lt;br_vracanja+1; i++)
			k++;
	}
	/*ukoliko je sve uredu, ispisuje 1*/
	return 1;
}
int main()
{
	return 0;
</font>}</pre>
</body>
</html>
