<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z4/Z4/student6462.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z4/Z4/student4559.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

/* Rad sa Stackom - prototipi */
<a name="0"></a><font color="#FF0000"><a href="match86-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

struct stack_entry {
	char *data;
	struct stack_entry *next;
};

struct Stack {
	struct stack_entry *top;
	int size;
};

/* Pseudo konstruktor */
struct Stack* newStack();
/* kreira string u memoriji i vraca pokazivac na taj string */
char *cpystr(char*);
/* dodaje novi clan na stack */
int push(struct Stack*, char*);
/* vraca string koji se nalazi na vrhu stack-a */
char *top(struct Stack*);
/* brise clan na vrhu stack-a */
void pop(struct Stack*);
/* provjerava da li je stack prazan */
int empty(struct Stack*);
/* ispraznjava stack */
void clear(struct Stack*);
/* brise stack iz memorije */
void destroy(struct Stack*);
/* end Stack */

/* Prototipi funkcija za zadatak */
int provjeri(char*);

int main() {
	
	return 0;
}

/* provjeri - IMPLEMENTACIJA */
int provjeri(char *s) {
	struct Stack *checker = newStack();
	char *ctrlPtr, *lastOpened, *tmp;
	int currTagLen, i;
	
	while(*s != '\0') {
		if (*s == '&lt;' &amp;&amp; *(s + 1) == '/') {
			s += 2;
			
			lastOpened = top(checker);
			//printf("\\%s\n", lastOpened);
			if (lastOpened == NULL) {
				destroy(checker);
				return 0;
			}
				
			while(isalnum(*s) &amp;&amp; *lastOpened != '\0')
				if (tolower(*s++) != *lastOpened++) {
					//printf("Pada na %c != %c\n", *s, *lastOpened);
					destroy(checker);
					return 0;
				}
					
			if (isalnum(*s) || *lastOpened != '\0') {
				destroy(checker);
				return 0;
			}
			
			pop(checker);
		}
		else if (*s == '&lt;') {
			s++;
			
			ctrlPtr = s;
			currTagLen = 0;
			
			while(isalnum(*ctrlPtr++))
				currTagLen++;
				
			if (currTagLen == 0) {
				destroy(checker);
				return 0;
			}
				
			tmp = malloc(currTagLen + 1);
			if (tmp == NULL) {
				destroy(checker);
				return -1; /*fail*/
			}
				
			for(i = 0; i &lt; currTagLen; i++, s++)
				tmp[i] = tolower(*s);
			tmp[currTagLen] = '\0';
			
			//printf("%s\n", tmp);
			push(checker, tmp);
			free(tmp);
		}
		
		s++;
	}
	//printf("\n");
	
	if (!empty(checker)) {
		destroy(checker);
		return 0;
	}
	
	destroy(checker);
	return 1;
}
/* END provjeri */

/* Stack "metode" - IMPLEMENTACIJA */
/* Ako na ovo sumnjate, branit cu slobodno... ali mi je stvarno mrsko pisati
   dokumentaciju za ovakvo nesto, previse je standardno, obicna linked lista
   koja ima uvijek pokazivac na posljednji element */
struct Stack* newStack() {
	struct Stack *tmp = malloc(sizeof *tmp);
	
	if (tmp != NULL) {
		tmp-&gt;top = NULL;
		tmp-&gt;size = 0;
	}
	
	return tmp;
}

char *cpystr(char* value) {
	char *tmp = malloc(strlen(value) + 1);
	if (tmp != NULL)
		strcpy(tmp, value);
		
	return tmp;
}

int push(struct Stack *S, char *newEntry) {
	struct stack_entry *tmp = malloc(sizeof *tmp);
	
	if (tmp != NULL) {
		tmp-&gt;data = cpystr(newEntry);
		tmp-&gt;next = S-&gt;top;
		S-&gt;top = tmp;
		S-&gt;size++;
		
		return 1;
	}
	
	return 0;
}

char *top(struct Stack *S) {
	if (!empty(S))
		return S-&gt;top-&gt;data;
		
	return NULL;
}

void pop(struct Stack *S) {
	if (!empty(S)) {
		struct stack_entry *tmp = S-&gt;top;
		S-&gt;top = S-&gt;top-&gt;next;
		
		free(tmp-&gt;data);
		free(tmp);
		
		S-&gt;size--;
	}
}

int empty(struct Stack *S) {
	if (S != NULL &amp;&amp; S-&gt;top != NULL &amp;&amp; S-&gt;size != 0)
		return 0;
		
	return 1;
}

void clear(struct Stack *S) {
	while (!empty(S))
		pop(S);
}

void destroy(struct Stack *S) {
	clear(S);
</font>	free(S);
}</pre>
</body>
</html>
