<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3732.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5744.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

<a name="2"></a><font color="#0000FF"><a href="match382-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

template &lt;typename Tip&gt;
class GMatrica
{
    int n,m;
    Tip mat[4][4];
public:
    GMatrica();
    GMatrica(int sir,int duz,Tip el=Tip{});
    template&lt;typename Tip1&gt;
    GMatrica(const GMatrica&lt;Tip1&gt; &amp;g):n(g.DajBrojRedova()), m(g.DajBrojKolona())
</font><a name="4"></a><font color="#FF00FF"><a href="match382-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    {
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++) mat[i][j]=g(i+1,j+1);
</font>    }
    template&lt;typename Tip2&gt;
        GMatrica(Tip2 niz[]);
    template&lt;typename Tip2&gt;
        GMatrica(std::vector&lt;std::vector&lt;Tip2&gt;&gt; vek);
    template&lt;typename Tip2&gt;
<a name="0"></a><font color="#FF0000"><a href="match382-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

        GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip2&gt;&gt; t);
    int DajBrojRedova()const{return n;}
    int DajBrojKolona()const{return m;}
    template&lt;typename Tip1,typename Tip2&gt;
        friend auto operator+(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt;;
    template&lt;typename Tip1,typename Tip2&gt;
        friend auto operator-(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt;;
</font><a name="14"></a><font color="#FF00FF"><a href="match382-0.html#14" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    template&lt;typename Tip1,typename Tip2&gt;
        friend auto operator*(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt;;
</font>    Tip* operator[](int i){return mat[i];}
    Tip* operator[](int i)const{static Tip t[4];for(int j=0;j&lt;m;j++) t[j] = mat[i][j];return t;}
    template &lt;typename Tip1&gt;
        friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip1&gt; &amp;r);
    Tip operator()(int i,int j)const {if(i&gt;n || j&gt;m || j&lt;1 || i&lt;1) throw std::range_error("Nedozvoljen indeks");return mat[i-1][j-1];}
    Tip &amp;operator()(int i,int j){if(i&gt;n || j&gt;m || j&lt;1 || i&lt;1) throw std::range_error("Nedozvoljen indeks");return mat[i-1][j-1];}
<a name="10"></a><font color="#FF0000"><a href="match382-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    template&lt;typename Tip1,typename Tip2&gt;
        friend auto operator*(const GMatrica&lt;Tip1&gt; &amp;m1,Tip2 s)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+s)&gt;;
</font><a name="1"></a><font color="#00FF00"><a href="match382-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    template&lt;typename Tip1,typename Tip2&gt;
        friend bool operator==(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2);
    template&lt;typename Tip1,typename Tip2&gt;
        friend bool operator!=(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2);
</font><a name="5"></a><font color="#FF0000"><a href="match382-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    template&lt;typename Tip1,typename Tip2&gt;
        friend auto operator*(Tip2 s,const GMatrica&lt;Tip1&gt; &amp;m1)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+s)&gt;;
</font>    template&lt;typename Tip2&gt;
        GMatrica&lt;Tip&gt; operator+=(const GMatrica&lt;Tip2&gt; &amp;m2);
    template&lt;typename Tip2&gt;
        GMatrica&lt;Tip&gt; operator-=(const GMatrica&lt;Tip2&gt; &amp;m2);
    template&lt;typename Tip2&gt;
        GMatrica&lt;Tip&gt; operator*=(const GMatrica&lt;Tip2&gt; &amp;m2);
     template&lt;typename Tip2&gt;
        GMatrica&lt;Tip&gt; operator*=(Tip2 s);
    template &lt;typename Tip1&gt;
        friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;r);
};

int main()
{  
    int niz[4][4];
    GMatrica&lt;int&gt; a(2,3,4),b8({{1,2},{2,1}}),c(3,2,10);
    const GMatrica&lt;double&gt; s(2,3,1);
    GMatrica&lt;double&gt; p;
    a(2,2)=s[1][1];
    std::cout &lt;&lt; a;
    std::cin &gt;&gt; a;
    if(!std::cin) std::cout &lt;&lt; "lblal";
    std::cout &lt;&lt; "sve u redu\n";
    GMatrica&lt;double&gt; b(b8);
    std::cout &lt;&lt;std::setw(5) &lt;&lt;  a;
	return 0;
}
template&lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;::GMatrica()
    {
        n=0,m=0;
    }
template&lt;typename Tip&gt;   
    GMatrica&lt;Tip&gt;::GMatrica(int sir,int duz,Tip el)
    {
        if(sir&lt;0 || duz&lt;0 || duz&gt;4 || sir&gt;4) throw  std::logic_error("Ilegalan format matrice");
        n=sir;
        m=duz;
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++) mat[i][j]=el;
    }
template&lt;typename Tip&gt;
    template&lt;typename Tip2&gt;
        GMatrica&lt;Tip&gt;::GMatrica(Tip2 niz[])
        {
            n=4,m=4;
            for(int i=0;i&lt;4;i++)
                for(int j=0;j&lt;4;j++) mat[i][j]=niz[i][j];
        }
        
template&lt;typename Tip&gt;
    template&lt;typename Tip2&gt;
        GMatrica&lt;Tip&gt;::GMatrica(std::vector&lt;std::vector&lt;Tip2&gt;&gt; vek)
        {
            if(vek.size()&gt;4) throw  std::logic_error("Ilegalan format matrice");
            for(int i=0;i&lt;vek.size();i++) if(vek[i].size()&gt;4 || vek[i].size()!=vek[0].size()) throw  std::logic_error("Ilegalan format matrice");
            n=vek.size();
            if(n) m=vek[0].size();
            else m=0;
            for(int i=0;i&lt;n;i++)
                for(int j=0;j&lt;m;j++) mat[i][j]=vek[i][j];
        }
template&lt;typename Tip&gt;
    template&lt;typename Tip2&gt;
        GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip2&gt;&gt; t)
        {
            
            int i=0,j;
            for(auto x:t)
            {
                j=0;
                for(auto y:x) mat[i][j++]=y;
                i++;
            }
            n=i;
            m=j;
        }
template&lt;typename Tip1,typename Tip2&gt;
        auto operator+(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt;
        {
            if(m1.m!=m2.m || m1.n!=m2.n) throw std::domain_error("Nedozvoljena operacija");
<a name="11"></a><font color="#00FF00"><a href="match382-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

            GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt; m(m1.n,m1.m);
            for(int i=0;i&lt;m1.n;i++)
</font>                for(int j=0;j&lt;m2.m;j++)  m.mat[i][j]=m1.mat[i][j]+m2.mat[i][j];
<a name="18"></a><font color="#00FFFF"><a href="match382-0.html#18" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

            return m;
        }
template &lt;typename Tip1&gt;
    std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip1&gt; &amp;r)
</font>    {
        int a=tok.width();
        for(int i=0;i&lt;r.n;i++)
        {
            for(int j=0;j&lt;r.m;j++)
                tok &lt;&lt; std::setw(std::max(a,6)) &lt;&lt; r.mat[i][j];
            tok &lt;&lt; "\n";
        }
        return tok;
    }
template&lt;typename Tip1,typename Tip2&gt;
        auto operator-(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt;
        {
            if(m1.m!=m2.m || m1.n!=m2.n) throw std::domain_error("Nedozvoljena operacija");
<a name="12"></a><font color="#0000FF"><a href="match382-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

            GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt; m(m1.n,m2.m);
            for(int i=0;i&lt;m1.n;i++)
</font>                for(int j=0;j&lt;m2.m;j++)  m.mat[i][j]=m1.mat[i][j]-m2.mat[i][j];
            return m;
        }
template&lt;typename Tip1,typename Tip2&gt;
<a name="3"></a><font color="#00FFFF"><a href="match382-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        auto operator*(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt;
        {
            if(m1.m!=m2.n) throw std::domain_error("Nedozvoljena operacija");
            GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt; m(m1.n,m2.m);
</font>            decltype(m1.mat[0][0]+m2.mat[0][0]) suma{};
            for(int i=0;i&lt;m1.n;i++)
                for(int j=0;j&lt;m2.m;j++)
                {
                    for(int k=0;k&lt;m1.m;k++)
                        suma+=m1.mat[i][k]*m2.mat[k][j];
                    m.mat[i][j]=suma;
                }
            return m;
        }
<a name="8"></a><font color="#00FFFF"><a href="match382-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

template&lt;typename Tip1,typename Tip2&gt;
        auto operator*(const GMatrica&lt;Tip1&gt; &amp;m1,Tip2 s)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+s)&gt;
</font>        {
            GMatrica&lt;decltype(m1.mat[0][0]+s)&gt; m(m1.n,m1.m);
            for(int i=0;i&lt;m1.n;i++)
                for(int j=0;j&lt;m1.m;j++)  m.mat[i][j]=m1.mat[i][j]*s;
            return m;
        }
<a name="17"></a><font color="#0000FF"><a href="match382-0.html#17" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

template&lt;typename Tip1, typename Tip2&gt; 
    bool operator==(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)
    {
        if(m1.n!=m2.n || m1.m!=m2.m) return false;
</font>        for(int i=0;i&lt;m1.n;i++)
<a name="7"></a><font color="#0000FF"><a href="match382-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

            for(int j=0;j&lt;m1.m;j++) if(m1.mat[i][j]!=m2.mat[i][j]) return false;
        return true;
    }
template&lt;typename Tip1, typename Tip2&gt; 
    bool operator!=(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)
</font>    {
        if(m1.n!=m2.n || m1.m!=m2.m) return true;
        for(int i=0;i&lt;m1.n;i++)
            for(int j=0;j&lt;m1.m;j++) if(m1.mat[i][j]!=m2.mat[i][j]) return true;
        return false;
    }
<a name="6"></a><font color="#00FF00"><a href="match382-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

template&lt;typename Tip1,typename Tip2&gt;
        auto operator*(Tip2 s,const GMatrica&lt;Tip1&gt; &amp;m1)-&gt;GMatrica&lt;decltype(m1.mat[0][0]+s)&gt;
</font>        {
            GMatrica&lt;decltype(m1.mat[0][0]+s)&gt; m(m1.n,m1.m);
            for(int i=0;i&lt;m1.n;i++)
                for(int j=0;j&lt;m1.m;j++)  m.mat[i][j]=m1.mat[i][j]*s;
            return m;
        }
template&lt;typename Tip1&gt;
    template&lt;typename Tip2&gt;
<a name="16"></a><font color="#00FF00"><a href="match382-0.html#16" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

        GMatrica&lt;Tip1&gt; GMatrica&lt;Tip1&gt;::operator-=(const GMatrica&lt;Tip2&gt; &amp;m2)
        {
            if(m!=m2.DajBrojKolona()|| n!=m2.DajBrojRedova()) throw std::domain_error("Nedozvoljena operacija");
</font>            for(int i=0;i&lt;n;i++)
                for(int j=0;j&lt;m;j++)  mat[i][j]-=m2(i+1,j+1);
            return *this;
        }
template&lt;typename Tip1&gt;
    template&lt;typename Tip2&gt;
<a name="15"></a><font color="#FF0000"><a href="match382-0.html#15" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

        GMatrica&lt;Tip1&gt; GMatrica&lt;Tip1&gt;::operator+=(const GMatrica&lt;Tip2&gt; &amp;m2)
        {
            if(m!=m2.DajBrojKolona()|| n!=m2.DajBrojRedova()) throw std::domain_error("Nedozvoljena operacija");
</font>            for(int i=0;i&lt;n;i++)
                for(int j=0;j&lt;m;j++)  mat[i][j]+=m2(i+1,j+1);
            return *this;
        }
template&lt;typename Tip1&gt;
    template&lt;typename Tip2&gt;
<a name="13"></a><font color="#00FFFF"><a href="match382-0.html#13" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

        GMatrica&lt;Tip1&gt; GMatrica&lt;Tip1&gt;::operator*=(const GMatrica&lt;Tip2&gt; &amp;m2)
        {
            if(m!=m2.DajBrojRedova()) throw std::domain_error("Nedozvoljena operacija");
            GMatrica&lt;Tip1&gt; m(*this);
</font>            Tip1 suma{};
            this-&gt;m=m2.m;
            for(int i=0;i&lt;m.n;i++)
                for(int j=0;j&lt;m2.DajBrojKolona();j++)
                {
                    for(int k=0;k&lt;m.m;k++)
                        suma+=m.mat[i][k]*m2(k+1,j+1);
                    mat[i][j]=suma;
                }
            return *this;
        }
template&lt;typename Tip1&gt;
    template&lt;typename Tip2&gt;
<a name="9"></a><font color="#FF00FF"><a href="match382-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        GMatrica&lt;Tip1&gt; GMatrica&lt;Tip1&gt;::operator*=(Tip2 s)
        {
            for(int i=0;i&lt;n;i++)
                for(int j=0;j&lt;m;j++) mat[i][j]*=s;
</font>            return *this;
        }
template &lt;typename Tip1&gt;
    std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;r)
    {
        std::vector&lt;std::vector&lt;Tip1&gt;&gt; v;
        char p;
        tok &gt;&gt; p;
        if(p!='[') 
        {
            tok.setstate(std::basic_ios&lt;char&gt;::failbit);
            return tok;
        }
        Tip1 pom;
        for(int i=0;i&lt;4;i++)
        {
            std::vector&lt;Tip1&gt; pv;
            for(int j=0;j&lt;4;j++)
            {
                tok &gt;&gt; pom;
                pv.push_back(pom);
                while(tok.peek()==' ' || tok.peek()=='\t' || tok.peek()=='\r' || tok.peek()=='\f' || tok.peek()=='\v') tok.get(p);
                if(tok.peek()==';' || tok.peek()==']'){ tok &gt;&gt; p;break;}
                if(tok.peek()!=','){ std::cout &lt;&lt; (char)tok.peek();tok.setstate(std::basic_ios&lt;char&gt;::failbit);}
                else tok &gt;&gt; p;
            }
            v.push_back(pv);
            if(p==']') break;
        }
        if(p!=']') tok.setstate(std::basic_ios&lt;char&gt;::failbit);
        try
        {
            r=GMatrica&lt;Tip1&gt;(v);
        }
        catch(...)
        {
            tok.setstate(std::basic_ios&lt;char&gt;::failbit);
        }
        return tok;
    }</pre>
</body>
</html>
