<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6824.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6824.cpp<p></p><pre>
<a name="2"></a><font color="#0000FF"><a href="match68-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_25.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
template &lt;typename NekiTip&gt;
class GMatrica{
 NekiTip matrica[4][4];
 int red, kolona;
  public:
  GMatrica(){red=0; kolona=0;}
  GMatrica(int m, int n, NekiTip p);
  template&lt;typename NekiTip1&gt;
  GMatrica(GMatrica&lt;NekiTip1&gt; &amp;m);
  template &lt;typename NekiTip1&gt;
  GMatrica(NekiTip1 niz[][4]);
  GMatrica(std::vector&lt;std::vector&lt;NekiTip&gt;&gt;v);
  GMatrica(std::initializer_list&lt;std::initializer_list&lt;NekiTip&gt;&gt; m);
  int DajBrojRedova() const{return red;}
  int DajBrojKolona() const{return kolona;}
  template&lt;typename NekiTip1, typename NekiTip2&gt;
  friend auto operator +(const GMatrica&lt;NekiTip1&gt; &amp;m1, const GMatrica&lt;NekiTip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt;const;
  template&lt;typename NekiTip1, typename NekiTip2&gt;
  friend auto operator -(const GMatrica&lt;NekiTip1&gt; &amp;m1, const GMatrica&lt;NekiTip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt;const;
  template&lt;typename NekiTip1, typename NekiTip2&gt;
  friend auto operator *(const GMatrica&lt;NekiTip1&gt; &amp;m1, const GMatrica&lt;NekiTip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt;const;
  GMatrica&lt;NekiTip&gt; &amp;operator +=(const GMatrica&lt;NekiTip&gt; &amp;m1);
  GMatrica&lt;NekiTip&gt; &amp;operator -=(const GMatrica&lt;NekiTip&gt; &amp;m1);
  GMatrica&lt;NekiTip&gt; &amp;operator *=(const GMatrica&lt;NekiTip&gt; &amp;m1);
  template&lt;typename NekiTip1, typename NekiTip2&gt;
  friend GMatrica&lt;NekiTip1&gt; operator *(NekiTip2 k, const GMatrica&lt;NekiTip1&gt; &amp;m);
  template&lt;typename NekiTip1, typename NekiTip2&gt;
  friend GMatrica&lt;NekiTip1&gt; operator *(const GMatrica&lt;NekiTip1&gt; &amp;m, NekiTip2 k);
  template &lt;typename NekiTip1&gt;
  friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;NekiTip1&gt; &amp;m);
};
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt;::GMatrica(int m, int n, NekiTip p){
    if(m&lt;0 || m&gt;4 || n&lt;0 || n&gt;4) throw std::logic_error("Ilegalan format matrice");
    red=m;
    kolona=n;
    for(int i=0; i&lt;m; i++){
        for(int j=0; j&lt;n; j++){
            matrica[i][j]=p;
        }
    }
}
template &lt;typename NekiTip&gt;
template &lt;typename NekiTip1&gt;
GMatrica&lt;NekiTip&gt;::GMatrica(NekiTip1 niz[][4]){
    red=4;
    kolona=4;
    for(int i=0; i&lt;4; i++){
        for(int j=0; j&lt;4; j++){
            matrica[i][j]=niz[i][j];
</font>        }
    }
}
template &lt;typename NekiTip&gt;
<a name="1"></a><font color="#00FF00"><a href="match68-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_27.gif"/></a>

GMatrica&lt;NekiTip&gt;::GMatrica(std::vector&lt;std::vector&lt;NekiTip&gt;&gt;v){
    if(v.size()&lt;0 || v.size()&gt;4) throw std::logic_error("Ilegalan format matrice");
    red=v.size();
    kolona=v[0].size();
    for(int i=0; i&lt;v.size(); i++){
        if(v[0].size()!=v[i].size() || v[i].size()&lt;0 || v[i].size()&gt;4) throw std::logic_error("Ilegalan format matrice");
        for(int j=0; j&lt;v[i].size(); j++){
            matrica[i][j]=v[i][j];
        }
    }
}
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;NekiTip&gt;&gt; m){
    if(m.size()&lt;0 || m.size()&gt;4) throw std::logic_error("Ilegalan format matrice");
    typename std::initializer_list&lt;std::initializer_list&lt;NekiTip&gt;&gt;::iterator it1{m.begin()}, it2{m.begin()};
    for(it2=m.begin(); it2!=m.end(); it2++){
        if(it1-&gt;size()!=it2-&gt;size()) throw std::logic_error("Ilegalan format matrice");
    }
    red=m.size();
    it2=m.begin();
    for(int i=0; i&lt;m.size(); i++){kolona=it2-&gt;size(); it2++;}
    for(int i=0; i&lt;m.size(); i++){
        auto it3=it1-&gt;begin();
        for(int j=0; j&lt;kolona; j++){
            matrica[i][j]=*it3;
            it3++;
        }
        it1++;
    }
}
template &lt;typename NekiTip&gt;
template &lt;typename NekiTip1&gt;
GMatrica &lt;NekiTip&gt;::GMatrica(GMatrica &lt;NekiTip1&gt; &amp;m){
    NekiTip1 mat[4][4];
   int red1{m.DajBrojRedova()}, kolona1{m.DajBrojKolona()};
   red=red1; kolona=kolona1;
    for(int i=0; i&lt;red; i++){
        for(int j=0; j&lt;kolona; j++){
           matrica[i][j]=mat[i][j];
        }
    }
}
template &lt;typename NekiTip1, typename NekiTip2&gt;
auto operator +(const GMatrica&lt;NekiTip1&gt; &amp;m1, const GMatrica&lt;NekiTip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt; const{
    int j{0};
    if(m1.red!=m2.red || m1.kolona!=m2.kolona) throw std::domain_error("Nedozvoljena operacija");
    int red{m1.DajBrojRedova()}, kolona{m1.DajBrojKolona()};
    decltype(m1.matrica[0][0]+m2.matrica[0][0]) mat[4][4]{};
    for(int i=0; i&lt;red; i++){
        for(j=0; j&lt;kolona; j++){
            mat[i][j]=m1.matrica[i][j]+m2.matrica[i][j];
        }
    }
    return mat;
}
template&lt;typename NekiTip1, typename NekiTip2&gt;
auto operator -(const GMatrica&lt;NekiTip1&gt; &amp;m1, const GMatrica&lt;NekiTip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt; const{
</font><a name="3"></a><font color="#00FFFF"><a href="match68-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

    int j{0};
    if(m1.red!=m2.red || m1.kolona!=m2.kolona) throw std::domain_error("Nedozvoljena operacija");
    int red{m1.DajBrojRedova()}, kolona{m1.DajBrojKolona()};
    decltype(m1.matrica[0][0]+m2.matrica[0][0]) mat[4][4]{};
    for(int i=0; i&lt;red; i++){
        for(j=0; j&lt;kolona; j++){
            mat[i][j]=m1.matrica[i][j]-m2.matrica[i][j];
</font>        }
    }
    return mat;
}
template&lt;typename NekiTip1, typename NekiTip2&gt;
<a name="0"></a><font color="#FF0000"><a href="match68-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_35.gif"/></a>

auto operator *(const GMatrica&lt;NekiTip1&gt; &amp;m1, const GMatrica&lt;NekiTip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt; const{
    int j{0};
    if(m1.kolona!=m2.red) throw std::domain_error("Nedozvoljena operacija");
    int red{m1.DajBrojRedova()}, kolona{m1.DajBrojKolona()}, red1{m2.DajBrojRedova()};
    decltype(m1.matrica[0][0]+m2.matrica[0][0]) mat[4][4]{};
    for(int i=0; i&lt;red; i++){
        for(j=0; j&lt;kolona; j++){
            double suma{0};
            for(int k=0; k&lt;red1; k++){
                suma=suma+m1.matrica[i][k]*m2.matrica[k][j];
            }
                mat[i][j]=suma;
        }
    }
    return mat;
}
template&lt;typename NekiTip1, typename NekiTip2&gt;
GMatrica&lt;NekiTip1&gt; operator *(NekiTip2 k, const GMatrica&lt;NekiTip1&gt; &amp;m){
    decltype(m.matrica[0][0]*k) mat[4][4]{};
    int red{m.DajBrojRedova()}, kolona{m.DajBrojKolona()};
    for(int i=0; i&lt;red; i++){
        for(int j=0; j&lt;kolona; j++){
            mat[i][j]=k*m.matrica[i][j];
        }
    }
  return mat;
}
template&lt;typename NekiTip1, typename NekiTip2&gt;
GMatrica&lt;NekiTip1&gt; operator *(const GMatrica&lt;NekiTip1&gt; &amp;m, NekiTip2 k){
    decltype(m.matrica[0][0]*k) mat[4][4]{};
    int red{m.DajBrojRedova()}, kolona{m.DajBrojKolona()};
    for(int i=0; i&lt;red; i++){
        for(int j=0; j&lt;kolona; j++){
            mat[i][j]=m.matrica[i][j]*k;
        }
    }
    return mat;
}
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt; &amp;GMatrica&lt;NekiTip&gt;::operator +=(const GMatrica&lt;NekiTip&gt; &amp;m1){
  int red{m1.DajBrojRedova()}, kolona{m1.DajBrojKolona()}; 
 //if(this-&gt;red!=m1.red || this-&gt;kolona!=m1.kolona) throw std::domain_error("Nedozvoljena operacija");
 for(int i=0; i&lt;red; i++){
    for(int j=0; j&lt;kolona; j++){
        this-&gt;matrica[i][j]+=m1.matrica[i][j];
     }
 }
 return *this;
}
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt; &amp;GMatrica&lt;NekiTip&gt;::operator -=(const GMatrica&lt;NekiTip&gt; &amp;m1){
    int red{m1.DajBrojRedova()}, kolona{m1.DajBrojKolona()};
    for(int i=0; i&lt;red; i++){
        for(int j=0; j&lt;kolona; j++){
            this-&gt;matrica[i][j]-=m1.matrica[i][j];
        }
    }
    return *this;
}
/*GMatrica&lt;NekiTip&gt; &amp;GMatrica&lt;NekiTip&gt;::operator *=(const GMatrica&lt;NekiTip&gt; &amp;m1){
    int red{m1.DajBrojRedova()}, kolona{m1.DajBrojKolona()};
    for(int i=0; i&lt;red; i++){
        for(int j=0; j&lt;kolona; j++)
    }
}*/
template &lt;typename NekiTip1&gt;
std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;NekiTip1&gt; &amp;m){
    int x(tok.width());
    int red{m.DajBrojRedova()}, kolona{m.DajBrojKolona()};
    for(int i=0; i&lt;red; i++){
        for(int j=0; j&lt;kolona; j++){
         //   std::cout &lt;&lt;m.matrica[i][j];
          //  if(m.matrica[i][j]=='A'){ }
          /* else*/ tok &lt;&lt;std::setw(x)&lt;&lt;m.matrica[i][j];
        }
        tok &lt;&lt;std::endl;
    }
    tok &lt;&lt;std::endl;
    return tok;
}
int main (){
    try{
  //  double niz[4][4]{{1,2,5,2},{3,1,2,1},{2,5,1,2},{1,2,3,4}};
  // GMatrica&lt;int&gt; matrica(niz);
 //  std::cout&lt;&lt;matrica.DajBrojRedova()&lt;&lt;" "&lt;&lt;matrica.DajBrojKolona();
 //  std::vector&lt;std::vector&lt;int&gt;&gt; v{{1,2,5,2},{2,5,1,2},{1,2,3,4}};
  //  GMatrica&lt;int&gt; matrica(v);
 //   std::cout &lt;&lt;matrica.DajBrojRedova()&lt;&lt;" "&lt;&lt;matrica.DajBrojKolona();
  //    GMatrica&lt;int&gt; matrica{{1,2,5,2},{3,1,2,1},{2,5,1,2},{1,2,3,4}};
 //     std::cout &lt;&lt;matrica.DajBrojRedova()&lt;&lt;" "&lt;&lt;matrica.DajBrojKolona();
    GMatrica&lt;int&gt; matrica1({{1,2,5},{3,1,2},{2,5,1}});   
    GMatrica&lt;double&gt; matrica2({{1,2,5},{3,1,2},{2,5,1}});
  // std::cout &lt;&lt;std::setw(10)&lt;&lt;matrica1+matrica2&lt;&lt;std::setw(10)&lt;&lt;matrica1-matrica2&lt;&lt;std::setw(10)&lt;&lt;matrica1*matrica2;
   // std::cout &lt;&lt;std::setw(10)&lt;&lt;3*matrica1;
    //std::cout&lt;&lt;std::setw(10)&lt;&lt;matrica2*3;
    matrica1+=matrica2;
    std::cout &lt;&lt;std::setw(10)&lt;&lt;matrica1;
    matrica1-=matrica2;
    std::cout &lt;&lt;std::setw(10)&lt;&lt;matrica1;
   //  GMatrica&lt;int&gt; matrica(2,2,2);
  //  GMatrica&lt;int&gt; matrica1(2,2,2);
  // GMatrica&lt;double&gt; matrica(matrica1);
 //   std::cout &lt;&lt;matrica1.DajBrojKolona()&lt;&lt;" "&lt;&lt;matrica1.DajBrojRedova();
   // matrica=static_cast&lt;double&gt;(matrica1);
//    GMatrica&lt;double&gt; matrica{{1,2,5},{3,1,2},{2,5,1}};
    }
    catch(std::logic_error izuzetak1){
        std::cout &lt;&lt;izuzetak1.what()&lt;&lt;std::endl;
    }
    catch(std::domain_error izuzetak2){
        std::cout &lt;&lt;izuzetak2.what()&lt;&lt;std::endl;
    }
	return 0;
</font>}</pre>
</body>
</html>
