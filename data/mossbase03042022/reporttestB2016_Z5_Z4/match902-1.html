<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5744.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student7392.cpp<p></p><pre>
<a name="4"></a><font color="#FF00FF"><a href="match902-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;initializer_list&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

template&lt;typename tip&gt;
    class GMatrica{
    int m, n;
    tip matrica[4][4];
public:
    GMatrica();
  template&lt;typename tip2&gt;
</font>    GMatrica(const GMatrica&lt;tip2&gt; &amp;mat);
    GMatrica(int n, int m, tip t=tip{});
  template&lt;typename tip2&gt;
    GMatrica(tip2 ma[][4]);
    GMatrica(std::vector&lt;std::vector&lt;tip&gt;&gt; v);
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt; v);
    int DajBrojRedova() const{return n;}
    int DajBrojKolona() const{return m;}
  template&lt;typename tip1&gt;
    friend GMatrica&lt;double&gt; operator*(const GMatrica&lt;tip1&gt; &amp;, double);
  template&lt;typename tip1&gt;
    friend GMatrica&lt;double&gt; operator*(double, const GMatrica&lt;tip1&gt; &amp;);
<a name="2"></a><font color="#0000FF"><a href="match902-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

  template&lt;typename tip1, typename tip2&gt;
    friend auto operator+(const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt;;
  template&lt;typename tip1, typename tip2&gt;
    friend auto operator-(const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]-m2.matrica[0][0])&gt;;
</font><a name="9"></a><font color="#FF00FF"><a href="match902-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

  template&lt;typename tip1, typename tip2&gt;
    friend auto operator*(const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]*m2.matrica[0][0])&gt;;
</font>  template&lt;typename tip2&gt;
    GMatrica&amp; operator+=(const GMatrica&lt;tip2&gt; &amp;m1);
  template&lt;typename tip2&gt;
    GMatrica&amp; operator-=(const GMatrica&lt;tip2&gt; &amp;m1);
  template&lt;typename tip2&gt;
    GMatrica&amp; operator*=(const GMatrica&lt;tip2&gt; &amp;m1);
    GMatrica&amp; operator*=(double x);
  template&lt;typename tip2&gt;
    bool operator ==(const GMatrica&lt;tip2&gt; &amp;m1) const;
  template&lt;typename tip2&gt;
    bool operator !=(const GMatrica&lt;tip2&gt; &amp;m1) const;
    tip&amp; operator ()(int x, int y);
    tip operator ()(int x, int y) const;
    tip* operator [](int x);
    const tip* operator [](int x) const;
  template&lt;typename tip1&gt;
    friend std::ostream&amp; operator &lt;&lt;(std::ostream &amp;fout, const GMatrica&lt;tip1&gt; &amp;m1);
  template&lt;typename tip1&gt;
    friend std::istream&amp; operator &gt;&gt;(std::istream &amp;fin, GMatrica&lt;tip1&gt; &amp;m1);
};

template&lt;typename tip1&gt;
    std::ostream&amp; operator &lt;&lt;(std::ostream &amp;fout, const GMatrica&lt;tip1&gt; &amp;m1){
        int sirina=fout.width();
        if(sirina&lt;6)sirina=6;
        for(int i=0;i&lt;m1.n;i++){
            for(int j=0;j&lt;m1.m;j++){
                fout&lt;&lt;std::setw(sirina)&lt;&lt;m1.matrica[i][j];
            }
            fout&lt;&lt;"\n";
        }
        return fout;
    }
template&lt;typename tip1&gt;
    std::istream&amp; operator &gt;&gt;(std::istream &amp;fin, GMatrica&lt;tip1&gt; &amp;m1){
        char c;
        tip1 a;
        fin&gt;&gt;c;
        std::vector&lt;std::vector&lt;tip1&gt;&gt; v{{}};
        if(c!='[')fin.setstate(std::ios::failbit);
        do{
            if(!fin)break;
            fin&gt;&gt;a&gt;&gt;c;
            if(!fin)break;
            v[v.size()-1].push_back(a);
            if(c==',')continue;
            if(c==';'){
                v.push_back({});
                continue;
            }
            if(c==']')break;
            fin.setstate(std::ios::failbit);
            break;
        }while(true);
        if(fin){
            try{
                m1=GMatrica&lt;tip1&gt;(v);
            }
            catch(...){
                fin.setstate(std::ios::failbit);
            }
        }
        return fin;
    }
template&lt;typename tip&gt;
    template&lt;typename tip2&gt;
    bool GMatrica&lt;tip&gt;::operator ==(const GMatrica&lt;tip2&gt; &amp;m1) const{
        if(n!=m1.DajBrojRedova() || m!=m1.DajBrojKolona())return false;
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++)
                if(matrica[i][j]!=m1(i+1, j+1))return false;
        return true;
    }
template&lt;typename tip&gt;
    template&lt;typename tip2&gt;
    bool GMatrica&lt;tip&gt;::operator !=(const GMatrica&lt;tip2&gt; &amp;m1) const{
        return !((*this)==m1);
    }
template&lt;typename tip&gt;
    tip&amp; GMatrica&lt;tip&gt;::operator ()(int x, int y){
        if(x&lt;1 || y&lt;1 || x&gt;n || y&gt;m)throw std::range_error("Nedozvoljen indeks");
        return matrica[x-1][y-1];
    }
template&lt;typename tip&gt;
    tip GMatrica&lt;tip&gt;::operator ()(int x, int y) const{
        if(x&lt;1 || y&lt;1 || x&gt;n || y&gt;m)throw std::range_error("Nedozvoljen indeks");
        return matrica[x-1][y-1];
    }
template&lt;typename tip&gt;
    tip* GMatrica&lt;tip&gt;::operator [](int x){
        if(x&lt;0 || x&gt;=n)throw std::range_error("Nedozvoljen indeks");
        return matrica[x];
    }
template&lt;typename tip&gt;
    const tip* GMatrica&lt;tip&gt;::operator [](int x) const{
        if(x&lt;0 || x&gt;=n)throw std::range_error("Nedozvoljen indeks");
        return matrica[x];
    }
template&lt;typename tip&gt;
    GMatrica&lt;tip&gt;::GMatrica():m(0), n(0){}
template&lt;typename tip&gt;
    GMatrica&lt;tip&gt;::GMatrica(int n, int m, tip t):m(m),n(n){
        if(n&gt;4 || m&gt;4 || m&lt;0 || n&lt;0)throw std::logic_error("Ilegalan format matrice");
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++)
                matrica[i][j]=t;
    }
template&lt;typename tip&gt; 
    template&lt;typename tip2&gt;
    GMatrica&lt;tip&gt;::GMatrica(const GMatrica&lt;tip2&gt; &amp;mat){
        n=mat.DajBrojRedova();
        m=mat.DajBrojKolona();
<a name="5"></a><font color="#FF0000"><a href="match902-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++)
                matrica[i][j]=mat(i+1, j+1);
    }
template&lt;typename tip&gt; 
    template&lt;typename tip2&gt;
</font>    GMatrica&lt;tip&gt;::GMatrica(tip2 ma[][4]){
        n=4;
        m=4;
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++)
                matrica[i][j]=ma[i][j];
    }
template&lt;typename tip&gt;
    GMatrica&lt;tip&gt;::GMatrica(std::vector&lt;std::vector&lt;tip&gt;&gt; v){
        n=v.size();
        if(n&gt;4)throw std::logic_error("Ilegalan format matrice");
        for(int i=0;i&lt;n;i++){
            m=v[i].size();
            if(n!=m || m&gt;4)throw std::logic_error("Ilegalan format matrice");
        }
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++)
                matrica[i][j]=v[i][j];
    }
template&lt;typename tip&gt;
    GMatrica&lt;tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt; v){
        n=v.size();
        if(n&gt;4)throw std::logic_error("Ilegalan format matrice");
        for(auto i:v){
            m=i.size();
            if(n!=m || m&gt;4)throw std::logic_error("Ilegalan format matrice");
        }
        int x=0, y;
        for(auto i:v){
            y=0;
            for(auto j:i){
                matrica[x][y]=j;
                y++;
            }
            x++;
        }
    }
template&lt;typename tip1, typename tip2&gt;
    auto operator+(const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt;{
        if(m1.n!=m2.n || m1.m!=m2.m)throw std::domain_error("Nedozvoljena operacija");
<a name="7"></a><font color="#0000FF"><a href="match902-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

        GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt; nova(m1.n, m1.m);
        for(int i=0;i&lt;m1.n;i++)
</font>            for(int j=0;j&lt;m1.m;j++)
<a name="8"></a><font color="#00FFFF"><a href="match902-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

                nova.matrica[i][j]=m1.matrica[i][j]+m2.matrica[i][j];
        return nova;
    }
template&lt;typename tip&gt;
    template&lt;typename tip2&gt;
</font><a name="0"></a><font color="#FF0000"><a href="match902-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    GMatrica&lt;tip&gt;&amp; GMatrica&lt;tip&gt;::operator +=(const GMatrica&lt;tip2&gt; &amp;m1){
        if(n!=m1.DajBrojRedova() || m!=m1.DajBrojKolona())throw std::domain_error("Nedozvoljena operacija");
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++)
                matrica[i][j]+=m1(i+1, j+1);
        return *this;
    }
template&lt;typename tip1, typename tip2&gt;
</font>    auto operator-(const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]-m2.matrica[0][0])&gt;{
        if(m1.n!=m2.n || m1.m!=m2.m)throw std::domain_error("Nedozvoljena operacija");
        GMatrica&lt;decltype(m1.matrica[0][0]-m2.matrica[0][0])&gt; nova(m1.n, m1.m);
        for(int i=0;i&lt;m1.n;i++)
            for(int j=0;j&lt;m1.m;j++)
                nova.matrica[i][j]=m1.matrica[i][j]-m2.matrica[i][j];
        return nova;
    }
template&lt;typename tip&gt;
    template&lt;typename tip2&gt;
<a name="1"></a><font color="#00FF00"><a href="match902-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    GMatrica&lt;tip&gt;&amp; GMatrica&lt;tip&gt;::operator -=(const GMatrica&lt;tip2&gt; &amp;m1){
        if(n!=m1.DajBrojRedova() || m!=m1.DajBrojKolona())throw std::domain_error("Nedozvoljena operacija");
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++)
                matrica[i][j]-=m1(i+1, j+1);
        return *this;
    }
template&lt;typename tip1, typename tip2&gt;
</font><a name="6"></a><font color="#00FF00"><a href="match902-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    auto operator*(const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]*m2.matrica[0][0])&gt;{
        if(m1.m!=m2.n)throw std::domain_error("Nedozvoljena operacija");
        GMatrica&lt;decltype(m1.matrica[0][0]*m2.matrica[0][0])&gt; nova(m1.n, m2.m);
</font>        for(int i=0;i&lt;m1.n;i++)
            for(int j=0;j&lt;m2.m;j++){
                decltype(m1.matrica[0][0]*m2.matrica[0][0]) a{};
<a name="3"></a><font color="#00FFFF"><a href="match902-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

                for(int k=0;k&lt;m1.m;k++)
                    a+=m1.matrica[i][k]*m2.matrica[k][j];
                nova.matrica[i][j]=a;
            }
        return nova;
    }
template&lt;typename tip&gt;
</font>    template&lt;typename tip2&gt;
<a name="10"></a><font color="#FF0000"><a href="match902-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    GMatrica&lt;tip&gt;&amp; GMatrica&lt;tip&gt;::operator *=(const GMatrica&lt;tip2&gt; &amp;m1){
        if(m!=m1.DajBrojRedova())throw std::domain_error("Nedozvoljena operacija");
        GMatrica&lt;decltype(matrica[0][0]*m1(1, 1))&gt; nova(n, m1.DajBrojKolona());
</font>        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m1.DajBrojKolona();j++){
                decltype(matrica[0][0]*m1(1, 1)) a{};
                for(int k=0;k&lt;m;k++)
                    a+=matrica[i][k]*m1(k+1, j+1);
                nova[i][j]=a;
            }
        m=m1.DajBrojKolona();
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++)
                matrica[i][j]=nova[i][j];
        return *this;
    }
template&lt;typename tip&gt;
    GMatrica&lt;tip&gt;&amp; GMatrica&lt;tip&gt;::operator *=(double x){
        for(int i=0;i&lt;n;i++)
<a name="11"></a><font color="#00FF00"><a href="match902-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

            for(int j=0;j&lt;m;j++)
                matrica[i][j]*=x;
        return *this;
    }
template&lt;typename tip1&gt;
</font>    GMatrica&lt;double&gt; operator*(const GMatrica&lt;tip1&gt; &amp;m1, double x){
        GMatrica&lt;decltype(m1.matrica[0][0]*x)&gt; nova(m1.n, m1.m);
        for(int i=0;i&lt;m1.n;i++)
            for(int j=0;j&lt;m1.m;j++)
                    nova.matrica[i][j]=m1.matrica[i][j]*x;
        return nova;
    }
template&lt;typename tip1&gt;
    GMatrica&lt;double&gt; operator*(double x, const GMatrica&lt;tip1&gt; &amp;m1){
        return m1*x;
    }


int main ()
{
    GMatrica&lt;int&gt; a;
    GMatrica&lt;double&gt; b(a);
    GMatrica&lt;int&gt; c{{1,1},{1,1}};
    std::vector&lt;std::vector&lt;double&gt;&gt; v{{1,1},{1,1}};
    GMatrica&lt;double&gt; d(v);
    double gg[4][4]={{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};
    GMatrica&lt;int&gt; e(gg);
    std::cout&lt;&lt;a&lt;&lt;"g\n"&lt;&lt;b&lt;&lt;"g\n"&lt;&lt;c&lt;&lt;"g\n"&lt;&lt;d;
    std::cout&lt;&lt;e.DajBrojRedova()&lt;&lt;"x"&lt;&lt;e.DajBrojKolona()&lt;&lt;"\n"&lt;&lt;e;
    std::cout&lt;&lt;c+d&lt;&lt;c-d&lt;&lt;d*c&lt;&lt;3*d&lt;&lt;d*3;
    c+=d;
    d-=c;
    d*=c;
    try{
        e+=d;
    }
    catch(std::domain_error gg){
        std::cout&lt;&lt;gg.what()&lt;&lt;"\n";
    }
    std::cout&lt;&lt;d;
    d*=4;
    std::cout&lt;&lt;d;
    std::cout&lt;&lt;(d==c);
    d=c;
    std::cout&lt;&lt;" "&lt;&lt;(d==c)&lt;&lt;"\n";
    std::cout&lt;&lt;c(1,1);
    std::cin&gt;&gt;b;
    if(!std::cin)std::cout&lt;&lt;"nije fino unijeto"; else std::cout&lt;&lt;b;
	return 0;
}</pre>
</body>
</html>
