<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5939.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5939.cpp<p></p><pre>
/B16/17 (Zadaća 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;initializer_list&gt;

template &lt;typename TipEl&gt;
class GMatrica{
    TipEl mat[4][4];
    int br_kolona,br_redova;
    void Test(int br_red,int br_kol){
        
        if(br_red&lt;0 || br_red&gt;4 || br_kol&lt;0 || br_kol&gt;4)throw std::logic_error("Ilegalan format matrice");
    }
    
    public:
    GMatrica(); //konst bez parametara
    GMatrica(int br_red,int br_kol, TipEl pocv=TipEl());
     
    template &lt;typename Tip2&gt;
    GMatrica(const GMatrica&lt;Tip2&gt; &amp;m);
   
    template &lt;typename Tip2&gt;
    GMatrica(Tip2 m[4][4]);
      
    GMatrica(const std::vector&lt;std::vector&lt;TipEl&gt;&gt; &amp;v);

    GMatrica(const std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; &amp;v);
   
<a name="0"></a><font color="#FF0000"><a href="match797-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

    int DajBrojRedova()const {return br_redova;}
    int DajBrojKolona()const {return br_kolona;}
   
    template &lt;typename TipEl1,typename TipEl2&gt;         //BINARNI PLUS
        friend auto operator+(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt;GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt;;
    
    template &lt;typename TipEl1,typename TipEl2&gt;         //BINARNI MINUS
        friend auto operator-(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt;GMatrica&lt;decltype(m1.mat[0][0]-m2.mat[0][0])&gt;;
        
    template &lt;typename TipEl1,typename TipEl2&gt;         //BINARNO MNOZENJE
        friend auto operator*(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt;GMatrica&lt;decltype(m1.mat[0][0]*m2.mat[0][0])&gt;;
        
        //+=    -=   *=   kao fje clanice 
    template &lt;typename TipEl2&gt;         //   +=
</font>        GMatrica&lt;TipEl&gt; &amp;operator+=(const GMatrica&lt;TipEl2&gt; &amp;m2);
     
    template &lt;typename TipEl2&gt;         //   -=
        GMatrica&lt;TipEl&gt; &amp;operator-=(const GMatrica&lt;TipEl2&gt; &amp;m2);
        
    template &lt;typename TipEl2&gt;         //   *=
<a name="2"></a><font color="#0000FF"><a href="match797-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        GMatrica&lt;TipEl&gt; &amp;operator*=(const GMatrica&lt;TipEl2&gt; &amp;m2);
    
    //OPERATORI ==   !=
    template &lt;typename TipEl1,typename TipEl2&gt;         //==
        friend bool operator ==(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2); 
    
    template &lt;typename TipEl1,typename TipEl2&gt;         //!=
        friend bool operator !=(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2);    
</font>    
    //OPERATORI ()  []  izvedeni kao fje clanice (POVRATNI TIP MORA BITI JEDNAK TIPU KLASE !!!!!!!!!!!!!!!!)
    TipEl &amp;operator ()(int indeks1, int indeks2){Test(indeks1-1,indeks2-1); return mat[indeks1-1][indeks2-1];}          //ne konstantna verzija operatora ()
    TipEl operator ()(int indeks1, int indeks2)const{Test(indeks1-1,indeks2-1); return mat[indeks1-1][indeks2-1];} ;
    
    TipEl *operator [](int indeks1){return mat[indeks1];};           //ne konstantna verzija operatora []
    const TipEl *operator [](int indeks1)const {return mat[indeks1];}; //konstatna verzija!!!
    
    //operator *za mnozenje matrice skalarom
    template &lt;typename Tip1,typename Tip2&gt;
        friend auto operator *(GMatrica&lt;Tip2&gt; m,Tip1 broj)-&gt;GMatrica&lt;decltype(broj*m.mat[0][0])&gt;;
    
    template &lt;typename Tip1,typename Tip2&gt;
        friend auto operator *(Tip1 broj,GMatrica&lt;Tip2&gt; m)-&gt;GMatrica&lt;decltype(broj*m.mat[0][0])&gt;;
     
    //da li treba ovo implementirati !!!
    //operatori *= za mnozenje skalara i matrice izvedeni kao fje clanice 
    //kada mnozimo matrica * skalar tada mozemo koristit fju clanicicuž
    //kada mnozimo sklara* matrica ne moze fja clanica jer je prvi operator skalar a treba matrica
    
    template &lt;typename TipEl2&gt;         //   *=
    GMatrica&lt;TipEl&gt; &amp;operator*=(TipEl2 broj);
    
    template &lt;typename Tip1,typename Tip2&gt;
    friend GMatrica&lt;Tip1&gt; &amp;operator *=(Tip1 broj,GMatrica&lt;Tip2&gt; &amp;m);       //DA LI TREBA OVO IMPLEMENTIRATI !!!
    
 
    
    //fja za ispis i upis
    template &lt;typename Tip2&gt;
    friend std::ostream &amp;operator&lt;&lt; (std::ostream &amp;tok,const GMatrica&lt;Tip2&gt; &amp;v);
    
    template &lt;typename Tip2&gt;
    friend std::istream &amp;operator&gt;&gt; (std::istream &amp;tok, GMatrica&lt;Tip2&gt; &amp;v);
    
};

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica():br_kolona(0),br_redova(0){              //prvi konstr
    for(auto &amp;red: mat){
        for (auto &amp;i : red) {
            i=TipEl();
        }
    }
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(int br_red,int br_kol, TipEl pocv){   //drugi konstr

    Test(br_red,br_kol);
    for(auto &amp;red: mat){
        for (auto &amp;i : red) {
            i=pocv;
        }
    }
    
    br_kolona=br_kol;
    br_redova=br_red;
}

template &lt;typename TipEl&gt;
template &lt;typename Tip2&gt;                                         //treci konstr
GMatrica&lt;TipEl&gt;::GMatrica(Tip2 m[4][4]){
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; i++) {
            mat[i][j] = m[i][j];
        }
    }
    br_kolona=4;
    br_redova=4;
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(const std::vector&lt;std::vector&lt;TipEl&gt;&gt; &amp;v){                         //cetvrti konstruktor
    if(v.size() &lt; 0 || v.size() &gt;4)throw std::logic_error("Ilegalan format matrice");
    int br_kol(v.at(0).size());
    for(auto &amp;red: v){
        if(red.size() != br_kol)throw std::logic_error("Ilegalan format matrice");
    }
    
    for(int i=0;i&lt; v.size(); i++){
        for(int j=0;j&lt;br_kol;j++){
            mat[i][j]=v[i][j];
        }
    }
    br_redova=v.size();
    br_kolona=br_kol;
}



template &lt;typename TipEl&gt;
template &lt;typename Tip2&gt;
GMatrica&lt;TipEl&gt;::GMatrica(const GMatrica&lt;Tip2&gt; &amp;m){       //peti konstruktor
    br_kolona=m.br_kolona;
    br_redova=m.br_redova;
    //std::swap(mat,m); //swap ce imati nezeljeni efekat dobit cemo npr matricu double i ako je trebala biti int
    for (int i = 0; i &lt; m.br_redova; i++) {
        for (int j = 0; j &lt; m.br_kolona ; j++) {
            mat[i][j] = m.mat[i][j]; 
        }
    }
}

template &lt;typename TipEl&gt;                                                              //sesti konsturkotr
GMatrica&lt;TipEl&gt;::GMatrica(const std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; &amp;v){
    if(v.size() &lt; 0 || v.size() &gt;4)throw std::logic_error("Ilegalan format matrice");
    int br_kol(v.begin()-&gt;size());
   
    for(auto &amp;red: v){
        if(red.size() != br_kol)throw std::logic_error("Ilegalan format matrice");
    }
    
    int i=0,j=0;
    for(auto it=v.begin(); it != v.end(); it++){
        j=0;
        for(auto it2=it-&gt;begin(); it2 != it-&gt;end(); it2++){
            mat[i][j]=*it2;
            j++;
        }
        i++;
    }
  
    br_redova=v.size();
    br_kolona=br_kol;
}

    
    

 //fja za mnozenje
template &lt;typename TipEl1,typename TipEl2&gt;         //BINARNO MNOZENJE
<a name="7"></a><font color="#0000FF"><a href="match797-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

auto operator*(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt;GMatrica&lt;decltype(m1.mat[0][0]*m2.mat[0][0])&gt;{
    
    
    if(m1.br_kolona != m2.br_redova)throw std::domain_error("Nedozvoljena operacija");
</font>    
<a name="6"></a><font color="#00FF00"><a href="match797-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    GMatrica&lt;decltype(m1.mat[0][0]*m2.mat[0][0])&gt; m3(m1.br_redova,m1.br_kolona)  ;                                      
</font>    decltype(m1.mat[0][0]*m2.mat[0][0]) sum;
    for(int i=0;i&lt;m1.br_redova;i++){
        for(int j=0;j&lt;m2.br_kolona;j++){
            sum = decltype(m1.mat[0][0]*m2.mat[0][0])();
<a name="4"></a><font color="#FF00FF"><a href="match797-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

            for(int k=0;k&lt;m1.br_kolona;k++)sum+=(m1.mat[i][k]*m2.mat[k][j]);
            m3.mat[i][j] = sum;
        }
    }
    return m3;
</font>}


//fja za oduzimanje
template &lt;typename TipEl1,typename TipEl2&gt;         //BINARNO oduzimanje
<a name="1"></a><font color="#00FF00"><a href="match797-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

auto operator-(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt;GMatrica&lt;decltype(m1.mat[0][0]-m2.mat[0][0])&gt;{
   if((m1.br_redova != m2.br_redova )||( m1.br_kolona != m2.br_kolona))throw std::domain_error("Nedozvoljena operacija");
     GMatrica&lt;decltype(m1.mat[0][0]-m2.mat[0][0])&gt; m3(m1.br_redova,m1.br_kolona)  ;                                          //da li hvatat izuzetak
</font>    
    for(int i=0;i&lt;m1.br_redova;i++){
        for(int j=0;j&lt;m1.br_kolona;j++){
          
            m3.mat[i][j] =m1.mat[i][j]-m2.mat[i][j] ;
        }
    }
<a name="8"></a><font color="#00FFFF"><a href="match797-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    return m3;
 
}


//fja za sabiranje
template &lt;typename TipEl1,typename TipEl2&gt;         //BINARNO sabiranje
auto operator+(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt;GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt;{
</font>   if((m1.br_redova != m2.br_redova )||( m1.br_kolona != m2.br_kolona))throw std::domain_error("Nedozvoljena operacija");
   
     GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt; m3(m1.br_redova,m1.br_kolona,decltype(m1.mat[0][0]+m2.mat[0][0])())  ;                                          //da li hvatat izuzetak
    
    for(int i=0;i&lt;m1.br_redova;i++){
        for(int j=0;j&lt;m1.br_kolona;j++){
          
            m3.mat[i][j] =m1.mat[i][j]+m2.mat[i][j] ;
        }
    }
    
    return m3;
 
}
 
template &lt;typename TipEl&gt;
template &lt;typename TipEl2&gt;         //   +=
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator+=(const GMatrica&lt;TipEl2&gt; &amp;m2){
    if((br_redova != m2.br_redova )||( br_kolona != m2.br_kolona))throw std::domain_error("Nedozvoljena operacija");
    
    for(int i=0;i&lt;br_redova;i++){
        for(int j=0;j&lt;br_kolona;j++){
          
            mat[i][j] +=m2.mat[i][j] ;
        }
    }
    return *this;
}

template &lt;typename TipEl&gt;
template &lt;typename TipEl2&gt;         //   -=
<a name="9"></a><font color="#FF00FF"><a href="match797-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator-=(const GMatrica&lt;TipEl2&gt; &amp;m2){
    if((br_redova != m2.br_redova )||( br_kolona != m2.br_kolona))throw std::domain_error("Nedozvoljena operacija");
</font>    
    for(int i=0;i&lt;br_redova;i++){
        for(int j=0;j&lt;br_kolona;j++){
          
            mat[i][j] -=m2.mat[i][j] ;
        }
    }
    return *this;
}
 
template &lt;typename TipEl&gt;  
template &lt;typename TipEl2&gt;         //   *=
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator*=(const GMatrica&lt;TipEl2&gt; &amp;m2){
    if(br_kolona != m2.br_redova)throw std::domain_error("Nedozvoljena operacija");
    
    TipEl sum;
    for(int i=0;i&lt;br_redova;i++){
        for(int j=0;j&lt;m2.br_kolona;j++){
            sum = decltype(mat[0][0]*m2.mat[0][0])();
            for(int k=0;k&lt;br_kolona;k++)sum+=(mat[i][k]*m2.mat[k][j]);
            mat[i][j] = sum;
        }
    }
<a name="5"></a><font color="#FF0000"><a href="match797-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    return *this;
}


//OPERATORI ==   !=
template &lt;typename TipEl1,typename TipEl2&gt;         //==
bool operator ==(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2){
    if((m1.br_redova != m2.br_redova) || (m1.br_kolona != m2.br_kolona))return false;
</font>
    for (int i = 0; i &lt; m1.br_redova; i++) {
        for (int j = 0; j &lt; m1.br_kolona; j++) {
<a name="3"></a><font color="#00FFFF"><a href="match797-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

            if(m1.mat[i][j] != m2.mat[i][j])return false;
        }
    }
    
    return true;
}

template &lt;typename TipEl1,typename TipEl2&gt;         //!=
bool operator !=(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2){
</font>    return !(m1==m2);
}
        

//fja za Ispis
template &lt;typename Tip2&gt;
std::ostream &amp;operator&lt;&lt; (std::ostream &amp;tok, const GMatrica&lt;Tip2&gt; &amp;v) {
     int sirina_ispisa=tok.width();
     if(sirina_ispisa&lt;6)sirina_ispisa=6;
      for(int i = 0; i &lt;v. br_redova; i++) {
         for(int j = 0; j &lt; v.br_kolona; j++)
         std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; v.mat[i][j];
         std::cout &lt;&lt; std::endl;
    }
return tok;
}

template &lt;typename Tip1,typename Tip2&gt;
auto operator *(GMatrica&lt;Tip2&gt; m,Tip1 broj)-&gt;GMatrica&lt;decltype(broj*m.mat[0][0])&gt;{
    GMatrica&lt;decltype(m.mat[0][0]*m.mat[0][0])&gt; m3(m)  ;                                          //da li hvatat izuzetak
    
    for(int i=0;i&lt;m.br_redova;i++){
        for(int j=0;j&lt;m.br_kolona;j++){
          
            m3.mat[i][j] *=broj ;
        }
    }
    
    return m3;
}
    
template &lt;typename Tip1,typename Tip2&gt;
auto operator *(Tip1 broj,GMatrica&lt;Tip2&gt; m)-&gt;GMatrica&lt;decltype(broj*m.mat[0][0])&gt;{
    return m*broj;
}

template &lt;typename TipEl&gt;
template &lt;typename TipEl2&gt;         //   *=
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator*=(TipEl2 broj){
    for(int i=0;i&lt;br_redova;i++){
        for(int j=0;j&lt;br_kolona;j++){
          
            mat[i][j] *=broj ;
        }
    }
    
    return *this;
}

template &lt;typename Tip1,typename Tip2&gt;
GMatrica&lt;Tip2&gt; &amp;operator *=(Tip1 broj,GMatrica&lt;Tip2&gt; &amp;m){
    
    return m*broj;
}


//fja za upis
template &lt;typename Tip2&gt;
std::istream &amp;operator&gt;&gt; (std::istream &amp;tok, GMatrica&lt;Tip2&gt; &amp;v){
    
    tok&gt;&gt;std::ws;
    char znak;
    tok&gt;&gt;znak;
    Tip2 broj;
    bool flag(false);
    if(znak != '['){tok.setstate(std::ios::failbit); return tok;}
    
    for (int i = 0; ; i++) {
        if(flag)break;
        
        v.br_redova = i+1;
        for (int j = 0;  ;j++) {
            if(j&gt;3){tok.setstate(std::ios::failbit);flag=true;break;}
            tok&gt;&gt;std::ws;
            znak = tok.peek();
            if(znak&lt;='0' || znak&gt;='9'){tok.setstate(std::ios::failbit);flag=true;break;}
            tok&gt;&gt;broj;
            if(!tok){tok.setstate(std::ios::failbit);flag=true;break;}
            v.mat[i][j] = broj;
            v.br_kolona =  j+1;
            tok&gt;&gt;std::ws;
            
            znak = tok.peek();
            if(znak == ','){tok.get();continue;}
            else if(znak == ';'){
                if(j&lt;1){tok.setstate(std::ios::failbit);flag=true;break;}
                tok.get();
                break;
            }else if(znak == ']'){
                flag = true;
                break;
            }else {tok.setstate(std::ios::failbit);flag=true;break;}
        }
    }
    
    return tok;
}








int main ()
{
    GMatrica&lt;int&gt; v;
    std::cin&gt;&gt;v;
    if(!std::cin)std::cout&lt;&lt;"NE VALJA UNOS";
    else std::cout&lt;&lt;v;
    
	return 0;
}</pre>
</body>
</html>
