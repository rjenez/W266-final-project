<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1336.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1336.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match88-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_68.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;type_traits&gt;

template&lt;typename Tip&gt;
    class GMatrica{
        Tip mat[4][4];
        int br_redova, br_kolona;
        
        public:
        GMatrica(): br_redova(0), br_kolona(0){};
        GMatrica(int br_redova, int br_kolona, Tip vrijednost=Tip {});
        template &lt;typename Tip1, template Tip2&gt;
        GMatrica&lt;Tip1&gt; (Gmatrica&lt;Tip2&gt; *g);
        GMatrica(Tip **cniz);
        GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; v);
        GMatrica(std::initializer_list&lt;std::initalizer_list&lt;Tip&gt;&gt; lista);
        
        int DajBrojRedova(){return br_redova;}
        int DajBrojKolona(){return br_kolona;}
        
        template &lt;typename Tip1, typename Tip2&gt;
        friend auto operator +(const GMatrica&lt;Tip1&gt; &amp;g1, const GMatrica&lt;Tip2&gt; &amp;g2) std::remove_reference&lt;decltype(GMatrcia(1,1,g1[0][0]+g2[0][0]))&gt;::type;
        
        template &lt;typename Tip1, typename Tip2&gt;
        friend auto operator -(const GMatrica&lt;Tip1&gt; &amp;g1, const GMatrica&lt;Tip2&gt; &amp;g2) std::remove_reference&lt;decltype(GMatrica(1,1,g1[0][0]-g2[0][0]))&gt;::type;
        
        template &lt;typename Tip1, typename Tip2&gt;
        friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;g1, const GMatrica&lt;Tip2&gt; &amp;g2) std::remove_reference&lt;decltype(GMatrica(1,1,g1[0][0]*g2[0][0]))&gt;::type;
        
        template &lt;typename Tip1, typename Tip2&gt;
        friend auto operator *(Tip1 varijabla, const GMatrica&lt;Tip2&gt; &amp;g) std::remove_reference&lt;decltype(GMatrica(1,1,g1[0][0]*varijabla))&gt;::type;
        
        template &lt;typename Tip1, typename Tip2&gt;
        friend auto operator *(const GMatrica&lt;Tip2&gt; &amp;g, Tip1 varijabla) std::remove_reference&lt;decltype(GMatrica(1,1,g[0][0]*varijavla))&gt;type;
        
        
        
        GMatrica&lt;Tip&gt; &amp;(int i, int j);
        
        
    };
    
    
template&lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;::GMatrica(int br_redova, int br_kolona, Tip vrijednost=Tip{}): br_redova(br_redova), br_kolona(br_kolona){
        if(br_redova&lt;0 || br_redova&gt;4 || br_kolona&lt;0 || br_kolona&gt;4) throw std::logic_error("Ilegalan format matrice");
        for(int i(0); i&lt;br_redova; i++){
            for(int j(0); j&lt;br_redova; j++){
                niz[i][j]=vrijednost;
            }
        }
    }
    
template&lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;::GMatrica(Tip **cniz){
        for(int i(0); i&lt;4; i++){
            for(int j(0); j&lt;4; j++){
                niz[i][j]=cniz[i][j];
            }
        }
        br_redova=4; br_kolona=4;
    }
    
template&lt;typename Tip&gt;
     GMatrica&lt;Tip&gt;::GMatrica(std::vector&lt;std::vector&lt;Tip&gt; v){
         if(int(v.size())&gt;4) throw std::logic_error("Ilegalan format matrice");
         if(int(v.size())!=0){
             int vk(int(v.at(0).size()));
             if(vk&gt;4) throw std::logic_error("Ilegalan format matrice");
             for(int i(1); i&lt;int(v.size()); i++){
                 if(int(v.at(i).size())!=vk) throw std::logic_error("Ilegalan format matrice");
             }
             br_kolona=vk;
         }
         for(int i(0); i&lt;int(v.size(0)); i++){
             for(int j(0); j&lt;int(v..at(i).size()); j++ ){
                 niz[i][j]=v.at(i).at(j);
             }
         }
         br_redova=int(v.size()); 
         if(br_redova==0) br_kolona=0;
     }

template&lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; lista){
        if(int(lista.size())&gt;4) throw std::domain_error("Ilegalan format matrice");
        if(int(lista.size())!=0){
            auto kolona(lista.begin());
            int lk(int((*kolona).size()));
            if(lk&gt;4) throw std::domain_error("Ilegalan format matrice");
            while(kolona!=lista.end()){
                if(int((*kolona).size())!=lk) throw std::domain_error("Ilegalan format matrice");
                kolona++;
            }
            br_kolona=lk;
        }
        auto trenutnir(lista.begin());
        int i(0);
        while(trenutnir!=lista.end()){
            auto trenutnak(trenutnir-&gt;begin());
            int j(0);
            while(trenutnak!=trenutnir-&gt;end()){
                niz[i][j]=*trenutnak;
                j++; trenutnak++;
            }
            i++;
        }
        br_redova=int(lista.size());
        if(br_redova=0) br_kolona=0;
    }
    
    

template&lt;typename Tip1, typename Tip2&gt;
    auto operator +(const GMatrica&lt;Tip1&gt; &amp;g1, const GMatrica&lt;Tip2&gt; &amp;g2) std::remove_reference&lt;decltype(GMatrica(1,1,g1[0][0]+g2[0][0]))&gt;::type{
        if(g1.DajBrojRedova()!=g2.DajBrojRedova() || g1.DajBrojKolona()!=g2.DajBrojKolona()) throw std::domain_error("Nedozvoljena operacija");
        
        GMatrica&lt;std::remove_reference&lt;decltype(g1[0][0]+g2[0][0])&gt;::type&gt; mat(g1.DajBrojRedova(), g1.DajBrojKolona());
        for(int i(0); i&lt;g1.DajBrojRedova(); i++){
            for(int j(0); j&lt;g2.DajBrojKolona(); j++){
                mat.niz[i][j]=g1.niz[i][j]+g2.niz[i][j];
            }
        }
        return mat;
    }
    
template&lt;typename Tip1, typename Tip2&gt;
    auto operator -(const GMatrica&lt;Tip1&gt; &amp;g1, const GMatrica&lt;Tip2&gt; &amp;g2) std::remove_reference&lt;decltype(GMatrica(1,1,g1[0][0]-g2[0][0]))&gt;::type{
        if(g1.br_redova!=g2.br_redova || g1.br_kolona!=g2.br_kolona) throw std::domain_error("Nedozvoljena operacija");
        
        GMatrica &lt;std::remove_reference&lt;decltype(g1[0][0]+g2[0][0])&gt;::type&gt; mat(g1.br_redova, g1.br_kolona);
        for(int i(0); i&lt;mat.br_redova; i++){
            for(int j(0); j&lt;mat.br_kolona; j++){
                mat.niz[i][j]=g1.niz[i][j]-g2.niz[i][j];
</font>            }
        }
        return mat;
    }
    
<a name="1"></a><font color="#00FF00"><a href="match88-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_28.gif"/></a>

template&lt;typename Tip1, typename Tip2&gt;
    auto operator *(const GMatrica&lt;Tip1&gt; &amp;g1, const GMatrica&lt;Tip2&gt; &amp;g2) std::remove_referecne&lt;decltype(GMatrica(1,1,g1[0][0]*g2[0][0]))&gt;::type{
        if(g1.br_kolona!=g2.br_redova) throw std::domain_error ("Nedozvoljena operacija");
        
        GMatrica&lt;std::remove_reference&lt;decltype(g1[0][0]*g2[0][0])&gt;::type&gt; mat(g1.br_redova, g2.br_kolona);
        for(int i(0); i&lt;g1.br_redova; i++){
            for(int i(0); i&lt;g2.br_kolona; j++){
                mat.niz[i][j]+=g1.niz[i][k]*g2.niz[k][j];
            }
        }
        return mat;
    }
    
template&lt;typename Tip1, typename Tip2&gt;
    auto operator *(Tip1 varijabla, const GMatrica&lt;Tip2&gt; &amp;g) std::remove_reference&lt;decltype(GMatrica(1,1,g[0][0]*varijabla))&gt;::type{
        GMatrica&lt;std::remove_reference&lt;decltype(g[0][0]*varijabla)&gt;::type&gt; mat(g.br_redova, g.br_kolona);
        for(int i(0); i&lt;g.br_redova; i++){
            for(int j(0); j&lt;g.br_kolona; j++){
                mat.niz[i][j]=g.niz[i][j]*varijabla;
            }
        }
        return mat;
    }
    
template&lt;typename Tip1, typename Tip2&gt;
    auto operator *(const GMatrica&lt;Tip1&gt; &amp;g, Tip1 varijabla) std::remove_reference&lt;decltype(GMatrica(1,1,g[0][0]*varijabla))&gt;::type{
        GMatrica&lt;std::remove_reference&lt;decltype(g[0][0]*varijabla)&gt;::type&gt; mat(g.br_redova, g.br_redova);
        for(int i(0); i&lt;g.br_redova; i++){
            for(int j(0); j&lt;g.br_kolona; j++){
                mat.niz[i][j]=g.niz[i][j]*varijabla;
            }
        }
        return mat;
    }
    
template&lt;typename Tip1&gt;
    GMatrica&lt;Tip1&gt;:: (int red, int kolona){
        if(red&lt;1 || red&gt;br_redova || kolona&lt;1 || kolona&gt;br_kolona) throw std::range_error("Nedozvoljen indeks");
        int i(0), k;
        for(; i&lt;br_redova; i++){
            for(int j(0); j&lt;br_kolona; j++){
                if(i+1==red &amp;&amp; j+1==kolona) {
                    k=j; break;
                }
            }
        }
        return
</font>    }


int main ()
{
    
	return 0;
}</pre>
</body>
</html>
