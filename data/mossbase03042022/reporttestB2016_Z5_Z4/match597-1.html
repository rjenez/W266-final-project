<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6705.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1833.cpp<p></p><pre>
/B16/17 (Zadaća 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;iomanip&gt;
#include &lt;cctype&gt;

template &lt;typename Tip&gt;
class GMatrica
{
    Tip Mat[4][4];
    int br_redova,br_kolona;
public:
    GMatrica(): br_redova(0),br_kolona(0) {}
    GMatrica(int redovi,int kolone,Tip M);
    template &lt;typename Tip2&gt;
    GMatrica(const GMatrica&lt;Tip2&gt; &amp;G);
    GMatrica&lt;Tip&gt;(const GMatrica&lt;Tip&gt; &amp;G);
    GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; V);
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; lista);
    int DajBrojRedova() {
        return br_redova;
    }
    int DajBrojKolona() {
        return br_kolona;
    }
<a name="0"></a><font color="#FF0000"><a href="match597-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

    template &lt;typename TipEl1,typename TipEl2&gt;
    friend auto operator +(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2)-&gt; GMatrica&lt;decltype(m1.Mat[0][0]+m2.Mat[0][0])&gt;;

    template &lt;typename TipEl1,typename TipEl2&gt;
    friend auto operator -(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2)-&gt; GMatrica&lt;decltype(m1.Mat[0][0]-m2.Mat[0][0])&gt;;
    template &lt;typename TipEl1,typename TipEl2&gt;
    friend auto operator *(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2)-&gt; GMatrica&lt;decltype(m1.Mat[0][0]*m2.Mat[0][0])&gt;;
    template &lt;typename Tip1,typename Tip2&gt;
</font>
<a name="1"></a><font color="#00FF00"><a href="match597-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    friend GMatrica&lt;Tip1&gt; operator *(const GMatrica&lt;Tip1&gt; &amp;m1,Tip2 d);

    template &lt;typename TipEl2&gt;
    GMatrica&lt;Tip&gt; &amp;operator +=(const GMatrica&lt;TipEl2&gt; &amp;m2);

    template &lt;typename TipEl2&gt;
    GMatrica&lt;Tip&gt; &amp;operator -=(const GMatrica&lt;TipEl2&gt; &amp;m2);

    template &lt;typename TipEl2&gt;
    GMatrica&lt;Tip&gt; &amp;operator *=(const GMatrica&lt;TipEl2&gt; &amp;m2);
    template &lt;typename TipEl2&gt;
    GMatrica&lt;Tip&gt; &amp;operator *=(TipEl2 d);
</font>    auto operator[](int i)-&gt; decltype(Mat[0]) {
        
        return Mat[i];
    }

    auto operator[](int i) const -&gt; decltype(Mat[0]) {
        return Mat[i];
    }
    Tip &amp;operator()(int i,int j) {
        if(i &lt; 1 || i &gt; br_redova || j &lt; 1 || j &gt; br_kolona)
            throw std::range_error("Nedozvoljen indeks");
        return Mat[i-1][j-1];
    }
    const Tip operator ()(int i,int j)const {
        if(i &lt; 1 || i &gt; br_redova || j &lt; 1 || j &gt; br_kolona)
            throw std::range_error("Nedozvoljen indeks");
        return Mat[i-1][j-1];
    }
    template&lt;typename Tip1&gt;
    friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok,const GMatrica&lt;Tip1&gt; &amp;m);
    bool operator== ( const GMatrica&lt;Tip&gt; &amp;B);
    bool operator!= ( const GMatrica&lt;Tip&gt; &amp;B);
    template&lt;typename Tip1&gt;
    friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;m);
};
template &lt;typename TipEl1,typename TipEl2&gt;
auto operator +(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2)-&gt; GMatrica&lt;decltype(m1.Mat[0][0]+m2.Mat[0][0])&gt; {
    GMatrica&lt;decltype(m1.Mat[0][0]+m2.Mat[0][0])&gt; m3(m1.br_redova, m1.br_kolona,5);
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona || m1.br_redova&gt;4 || m2.br_kolona&gt;4)
        throw std::domain_error("“Nedozvoljena operacij");
    for(int i = 0; i &lt; m1.br_redova; i++)
        for(int j = 0; j &lt; m1.br_kolona; j++)
            m3.Mat[i][j] = m1.Mat[i][j] + m2.Mat[i][j];
<a name="7"></a><font color="#0000FF"><a href="match597-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    return m3;
}
template &lt;typename TipEl1&gt; template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl1&gt; &amp;GMatrica&lt;TipEl1&gt;::operator +=(const GMatrica&lt;TipEl2&gt; &amp;m2)
</font>{
    if(br_redova != m2.br_redova || br_kolona != m2.br_kolona || br_redova&gt;4 || m2.br_kolona&gt;4)
        throw std::domain_error("“Nedozvoljena operacij");
    for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; br_kolona; j++)
            Mat[i][j] += m2.Mat[i][j];
    return *this;
}
<a name="11"></a><font color="#00FF00"><a href="match597-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

template &lt;typename TipEl1&gt;template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl1&gt; &amp;GMatrica&lt;TipEl1&gt;::operator *=(TipEl2 d)
{
    for(int i = 0; i &lt; br_redova; i++)
</font>        for(int j = 0; j &lt; br_kolona; j++)
            Mat[i][j] *=d;
<a name="8"></a><font color="#00FFFF"><a href="match597-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    return *this;
}
template &lt;typename TipEl1&gt; template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl1&gt; &amp;GMatrica&lt;TipEl1&gt;::operator -=(const GMatrica&lt;TipEl2&gt; &amp;m2)
</font>{
    if(br_redova != m2.br_redova || br_kolona != m2.br_kolona || br_redova&gt;4 || m2.br_kolona&gt;4)
        throw std::domain_error("“Nedozvoljena operacij");
    for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; br_kolona; j++)
<a name="2"></a><font color="#0000FF"><a href="match597-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

            Mat[i][j] -= m2.Mat[i][j];
    return *this;
}
template &lt;typename TipEl1&gt; template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl1&gt; &amp;GMatrica&lt;TipEl1&gt;::operator *=(const GMatrica&lt;TipEl2&gt; &amp;m2)
</font>{
    if(br_kolona != m2.br_redova || br_redova&gt;4 || br_kolona&gt;4 || m2.br_redova&gt;4 || m2.br_kolona&gt;4)
        throw std::domain_error("Nedozvoljena operacij");
    GMatrica&lt;TipEl1&gt; m3(br_redova, br_kolona,5);
    for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; m2.br_kolona; j++) {
            m3.Mat[i][j] = 0;
            for(int k = 0; k &lt; br_kolona; k++)
                m3.Mat[i][j] += Mat[i][k] * m2.Mat[k][j];
        }
    *this=m3;
    return *this;
}
template &lt;typename TipEl1,typename TipEl2&gt;
auto operator -(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2)-&gt; GMatrica&lt;decltype(m1.Mat[0][0]-m2.Mat[0][0])&gt; {
    GMatrica&lt;decltype(m1.Mat[0][0]-m2.Mat[0][0])&gt; m3(m1.br_redova, m1.br_kolona,5);
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona || m1.br_redova&gt;4 || m1.br_kolona&gt;4)
        throw std::domain_error("“Nedozvoljena operacij");
    for(int i = 0; i &lt; m1.br_redova; i++)
        for(int j = 0; j &lt; m1.br_kolona; j++)
            m3.Mat[i][j] = m1.Mat[i][j] - m2.Mat[i][j];
    return m3;
}


template &lt;typename TipEl1,typename TipEl2&gt;
<a name="5"></a><font color="#FF0000"><a href="match597-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

auto operator *(const GMatrica&lt;TipEl1&gt; &amp;m1,const GMatrica&lt;TipEl2&gt; &amp;m2)-&gt; GMatrica&lt;decltype(m1.Mat[0][0]*m2.Mat[0][0])&gt; {
    if(m1.br_kolona != m2.br_redova || m1.br_redova&gt;4 || m1.br_kolona&gt;4 || m2.br_redova&gt;4 || m2.br_kolona&gt;4)
</font><a name="6"></a><font color="#00FF00"><a href="match597-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        throw std::domain_error("Nedozvoljena operacij");
    GMatrica&lt;decltype(m1.Mat[0][0]*m2.Mat[0][0])&gt; m3(m1.br_redova, m1.br_kolona,5);
</font>    for(int i = 0; i &lt; m1.br_redova; i++)
        for(int j = 0; j &lt; m2.br_kolona; j++) {
            m3.Mat[i][j] = 0;
            for(int k = 0; k &lt; m1.br_kolona; k++)
                m3.Mat[i][j] += m1.Mat[i][k] * m2.Mat[k][j];
        }
    return m3;
}
template &lt;typename TipEl,typename Tip2&gt;
GMatrica&lt;TipEl&gt; operator *(const GMatrica&lt;TipEl&gt; &amp;m, Tip2 d)
{
    GMatrica&lt;TipEl&gt; m2(m.br_redova, m.br_kolona,d);
    for(int i = 0; i &lt; m.br_redova; i++)
        for(int j = 0; j &lt; m.br_kolona; j++)
            m2.Mat[i][j] = m.Mat[i][j] * d;
    return m2;
}
template &lt;typename TipEl,typename Tip2&gt;
inline GMatrica&lt;TipEl&gt; operator *(Tip2 d, const GMatrica&lt;TipEl&gt; &amp;m)
{
    return m*d;
}
<a name="4"></a><font color="#FF00FF"><a href="match597-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; lista)
{
    br_redova=(lista.size());
    br_kolona=lista.begin()-&gt;size() ;
</font>    if(br_redova&gt;4) throw std::logic_error ("Ilegalan format matrice");
    auto it(lista.begin());
    while(it!=lista.end()) {
        if(br_redova!=it-&gt;size())
            throw std::logic_error ("Ilegalan format matrice");
        it++;
    }
    int i(0),j(0);
    for(auto it1=lista.begin(); it1!=lista.end(); it1++) {
        j=0;
        for(auto it2=it1-&gt;begin(); it2!=it1-&gt;end(); it2++) {
            Mat[i][j]=*it2;
            j++;
        }
        i++;
    }

}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int redovi,int kolone,Tip M): br_kolona(kolone),br_redova(redovi)
{
    if(redovi&lt;0 || redovi&gt;4 || kolone&lt;0 || kolone&gt;4) throw std::logic_error ("Ilegalan format matrice");
    for(int i=0; i&lt;br_redova; i++)
        for(int j=0; j&lt;br_kolona; j++)
<a name="10"></a><font color="#FF0000"><a href="match597-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

            Mat[i][j]=M;
}

template &lt;typename Tip&gt; template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;Tip2&gt; &amp;G):br_kolona(G.br_kolona),br_redova(G.br_redova)
</font>{
    for(int i=0; i&lt;br_redova; i++)
<a name="3"></a><font color="#00FFFF"><a href="match597-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        for(int j=0; j&lt;br_kolona; j++)
            Mat[i][j]=G.Mat[i][j];
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;Tip&gt; &amp;G):br_kolona(4),br_redova(4)
</font>{
    for(int i=0; i&lt;4; i++)
        for(int j=0; j&lt;4; j++)
            Mat[i][j]=G.Mat[i][j];
}
template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; V):br_redova(V.size()), br_kolona(V[0].size())
{
    if(br_redova&gt;4) throw std::logic_error ("Ilegalan format matrice");
    for(int i=0; i&lt;br_redova; i++) {
        if(br_redova!=V[i].size())
            throw std::logic_error ("Ilegalan format matrice");
    }
    for(int i=0; i&lt;br_redova; i++)
        for(int j=0; j&lt;br_redova; j++)
            Mat[i][j]=V[i][j];
}
template &lt;typename Tip2&gt;
std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok,const GMatrica&lt;Tip2&gt; &amp;m)
{
    int sirina_ispisa(tok.width());
    if(sirina_ispisa&lt;6)
        sirina_ispisa=6;
    for(int i = 0; i &lt; m.br_redova; i++) {
<a name="9"></a><font color="#FF00FF"><a href="match597-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        for(int j = 0; j &lt; m.br_kolona; j++) {
            tok&lt;&lt;std::setw(sirina_ispisa)&lt;&lt;m.Mat[i][j];
        }
        tok&lt;&lt;std::endl;
    }
    return tok;
}
template &lt;typename Tip1&gt;
</font>bool GMatrica&lt;Tip1&gt;::operator== (const GMatrica&lt;Tip1&gt; &amp;B)
{
    if(br_kolona!=B.br_kolona || br_redova!=B.br_redova)
        return false;
    for(int i=0; i&lt;br_redova; i++)
        for(int j=0; j&lt;br_kolona; j++)
            if(Mat[i][j]!=B.Mat[i][j])
                return false;
    return true;
}
template &lt;typename Tip2&gt;
std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip2&gt; &amp;m)
{
    GMatrica&lt;Tip2&gt; unos;
    
    if(tok.peek() != '[')//ako nije otvorena zagrada
    {
        tok.setstate(std::ios::failbit);
        return tok;
    }
    
    tok.get();
    int red{0}, kolona{0};
    while(true)
    {
        if(red &gt; 4) //matrica smije imati najvise cetiri elementa u redu
        {
            tok.setstate(std::ios::failbit);
            break;
        }
        
        kolona = 0;
        while(std::isdigit(tok.peek()))
        {
            if(kolona &gt; 4) //matrica smije imati najvise cetiri elementa u koloni
            {
                tok.setstate(std::ios::failbit);
                break;
            }
            
            tok &gt;&gt; unos.Mat[red][kolona++]; //uzima broj
            
            if(tok.peek() == ',') 
            {
                tok.get();
                if(!std::isdigit(tok.peek())) 
                {
                    //ako poslije zareza nije cifra ne valja
                    tok.setstate(std::ios::failbit);
                    break;
                }
            }
            else if(tok.peek() == ';')
            { 
                tok.get();
                if(!unos.br_kolona) unos.br_kolona = kolona;//prvi red setuje broj kolona 
                if(unos.br_kolona &amp;&amp; kolona != unos.br_kolona) tok.setstate(std::ios::failbit);//ako je bilo koji sljedeci red razlicit po broju kolona
                break;
            }
            else if((tok.peek() == ']' &amp;&amp; kolona == unos.br_kolona) || (tok.peek() == ']' &amp;&amp; kolona &gt; 0 &amp;&amp; kolona &lt; 5 &amp;&amp; tok))  //ako je zadnji red i broj kolona odgovara prvom redu
            {
                if(tok)
                {
                    if(!unos.br_kolona) unos.br_kolona = kolona;
                    unos.br_redova = red + 1;
                    m = unos;
                }
                return tok;
            }
            else tok.setstate(std::ios::failbit);//ako nije neki od navedenih znakova ne valja
        }
        if(!tok) break;
        if(!unos.br_kolona) tok.setstate(std::ios::failbit);//ako ima neki znak na pocetku koji nije broj
        red++;
    }

    return tok;
}
template &lt;typename Tip1&gt;
bool GMatrica&lt;Tip1&gt;::operator!= ( const GMatrica&lt;Tip1&gt;&amp; B)
{
    return !(*this == B);

}
int main ()
{
    GMatrica&lt;int&gt; a{{1,2,3},{4,5,6},{7,8,9}}, b{{3,2,1},{6,5,4},{9,8,7}}, c;
	std::cout &lt;&lt; "Zbir ove dvije matrice je:\n";
	std::cout &lt;&lt; std::setw(7) &lt;&lt; a + b;
	a+=b;
	std::cout &lt;&lt; "Razlika ove dvije matrice je: \n"&lt;&lt;std::setw(7)&lt;&lt;a-b &lt;&lt; std::endl;
	a-=b;
	std::cout &lt;&lt; "Proizvod je: \n" &lt;&lt; a * b;
	std::cout &lt;&lt; "Matrica pomnozena sa 4 : \n" &lt;&lt; std::endl;
	a*=4;
	std::cout &lt;&lt; a;
	a*=b;
	std::cout &lt;&lt; "Proizod matrice A i B: \n" &lt;&lt; a &lt;&lt; std::endl;
	std::cout &lt;&lt; "Unesi matricu c: ";
	std::cin &gt;&gt; c;
	std::cout &lt;&lt; c &lt;&lt; std::endl;
<a name="12"></a><font color="#0000FF"><a href="match597-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

	if(a == c) std::cout &lt;&lt; "Matrice a i c su iste." &lt;&lt; std::endl;
	if(a != c) std::cout &lt;&lt; "Matrice a i c nisu iste." &lt;&lt; std::endl;
</font>}</pre>
</body>
</html>
