<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3807.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3807.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;stdexcept&gt;

<a name="2"></a><font color="#0000FF"><a href="match381-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

template &lt;typename TipEl&gt;
  class GMatrica {
    int br_redova, br_kolona;
    TipEl elementi[4][4];
  public:
    GMatrica();
    GMatrica(int brr, int brk, TipEl pvrijednost = TipEl());
    template &lt;typename DrugiTip&gt;
      GMatrica(const GMatrica&lt;DrugiTip&gt; &amp;m);
</font>    template &lt;typename DrugiTip&gt;
      GMatrica(DrugiTip m[4][4]);
    GMatrica(const std::vector&lt;std::vector&lt;TipEl&gt;&gt; v);
<a name="0"></a><font color="#FF0000"><a href="match381-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; l);
    int DajBrojRedova() const { return br_redova; }
    int DajBrojKolona() const { return br_kolona; }
    template &lt;typename Tip1, typename Tip2&gt;
      friend auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
        -&gt; GMatrica&lt;decltype(m1.elementi[0][0] + m2.elementi[0][0])&gt;;
    template &lt;typename Tip1, typename Tip2&gt;
      friend auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
</font><a name="14"></a><font color="#FF00FF"><a href="match381-1.html#14" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

        -&gt; GMatrica&lt;decltype(m1.elementi[0][0] - m2.elementi[0][0])&gt;;
    template &lt;typename Tip1, typename Tip2&gt;
      friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
</font>        -&gt; GMatrica&lt;decltype(m1.elementi[0][0] * m2.elementi[0][0])&gt;;
<a name="10"></a><font color="#FF0000"><a href="match381-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    template &lt;typename Tip1, typename Tip2&gt;
      friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, Tip2 broj)
        -&gt; GMatrica&lt;decltype(m.elementi[0][0] * broj)&gt;;
</font><a name="5"></a><font color="#FF0000"><a href="match381-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    template &lt;typename Tip1, typename Tip2&gt;
      friend auto operator *(Tip1 broj, const GMatrica&lt;Tip2&gt; &amp;m)
        -&gt; GMatrica&lt;decltype(m.elementi[0][0] * broj)&gt;;
</font>    template &lt;typename Tip2&gt;
      GMatrica &amp;operator +=(const GMatrica&lt;Tip2&gt; &amp;m);
    template &lt;typename Tip2&gt;
      GMatrica &amp;operator -=(const GMatrica&lt;Tip2&gt; &amp;m);
    template &lt;typename Tip2&gt;
      GMatrica &amp;operator *=(const GMatrica&lt;Tip2&gt; &amp;m);
    template &lt;typename Tip2&gt;
      GMatrica &amp;operator *=(Tip2 broj);
<a name="1"></a><font color="#00FF00"><a href="match381-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    template &lt;typename Tip1, typename Tip2&gt;
      friend bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
    template &lt;typename Tip1, typename Tip2&gt;
      friend bool operator !=(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
</font>    TipEl *operator[](int i) { return elementi[i]; }
    const TipEl *operator[](int i) const { return elementi[i]; }
    TipEl &amp;operator()(int i, int j);
    TipEl operator()(int i, int j) const;
    template &lt;typename Tip2&gt;
      friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip2&gt; &amp;m);
    template &lt;typename Tip2&gt;
      friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip2&gt; &amp;m);
    template &lt;typename DrugiTip&gt;
      friend class GMatrica;
  };

template &lt;typename TipEl&gt;
  GMatrica&lt;TipEl&gt;::GMatrica() : br_redova(0), br_kolona(0) {}

template &lt;typename TipEl&gt;
  GMatrica&lt;TipEl&gt;::GMatrica(int brr, int brk, TipEl pvrijednost) :
    br_redova(brr), br_kolona(brk) {
      if(brr &lt; 0 || brr &gt; 4 || brk &lt; 0 || brk &gt; 4)
        throw std::logic_error("Ilegalan format matrice");
      for(int i = 0; i &lt; brr; i++)
        for(int j = 0; j &lt; brk; j++) elementi[i][j] = pvrijednost;
  }

template &lt;typename TipEl&gt;
  template &lt;typename DrugiTip&gt;
    GMatrica&lt;TipEl&gt;::GMatrica(const GMatrica&lt;DrugiTip&gt; &amp;m) :
<a name="4"></a><font color="#FF00FF"><a href="match381-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

      br_redova(m.br_redova), br_kolona(m.br_kolona) {
        for(int i = 0; i &lt; br_redova; i++)
          for(int j = 0; j &lt; br_kolona; j++) elementi[i][j] = m.elementi[i][j];
</font>    }

template &lt;typename TipEl&gt;
  template &lt;typename DrugiTip&gt;
    GMatrica&lt;TipEl&gt;::GMatrica(DrugiTip m[4][4]) : br_redova(4), br_kolona(4) {
      for(int i = 0; i &lt; 4; i++)
        for(int j = 0; j &lt; 4; j++) elementi[i][j] = m[i][j];
    }

template &lt;typename TipEl&gt;
  GMatrica&lt;TipEl&gt;::GMatrica(const std::vector&lt;std::vector&lt;TipEl&gt;&gt; v) :
    br_redova(v.size()), br_kolona(0) {
      if(br_redova != 0) br_kolona = v[0].size();
      if(br_redova &gt; 4 || br_kolona &gt; 4)
        throw std::logic_error("Ilegalan format matrice");
      for(int i = 0; i &lt; br_redova; i++) {
        if(v[i].size != br_kolona)
          throw std::logic_error("Ilegalan format matrice");
        for(int j = 0; j &lt; br_kolona; j++) elementi[i][j] = v[i][j];
      }
  }

template &lt;typename TipEl&gt;
  GMatrica&lt;TipEl&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; l) :
    br_redova(l.size()), br_kolona(0) {
      if(br_redova != 0) br_kolona = l.begin()[0].size();
      if(br_redova &gt; 4 || br_kolona &gt; 4)
        throw std::logic_error("Ilegalan format matrice");
      for(int i = 0; i &lt; br_redova; i++) {
        if(l.begin()[i].size() != br_kolona)
          throw std::logic_error("Ilegalan format matrice");
        for(int j = 0; j &lt; br_kolona; j++)
          elementi[i][j] = l.begin()[i].begin()[j];
      }
  }

template &lt;typename Tip1, typename Tip2&gt;
  auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
    -&gt; GMatrica&lt;decltype(m1.elementi[0][0] + m2.elementi[0][0])&gt; {
      if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
<a name="11"></a><font color="#00FF00"><a href="match381-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

      GMatrica&lt;decltype(m1.elementi[0][0] + m2.elementi[0][0])&gt;
        m3(m1.br_redova, m1.br_kolona);
      for(int i = 0; i &lt; m1.br_redova; i++)
</font>        for(int j = 0; j &lt; m1.br_kolona; j++)
          m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
      return m3;
  }

template &lt;typename Tip1, typename Tip2&gt;
  auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
    -&gt; GMatrica&lt;decltype(m1.elementi[0][0] - m2.elementi[0][0])&gt; {
      if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
<a name="12"></a><font color="#0000FF"><a href="match381-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

      GMatrica&lt;decltype(m1.elementi[0][0] + m2.elementi[0][0])&gt;
        m3(m1.br_redova, m1.br_kolona);
      for(int i = 0; i &lt; m1.br_redova; i++)
</font>        for(int j = 0; j &lt; m1.br_kolona; j++)
          m3.elementi[i][j] = m1.elementi[i][j] - m2.elementi[i][j];
      return m3;
  }

template &lt;typename Tip1, typename Tip2&gt;
  auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
<a name="3"></a><font color="#00FFFF"><a href="match381-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    -&gt; GMatrica&lt;decltype(m1.elementi[0][0] * m2.elementi[0][0])&gt; {
      if(m1.br_kolona != m2.br_redova)
        throw std::domain_error("Nedozvoljena operacija");
      GMatrica&lt;decltype(m1.elementi[0][0] + m2.elementi[0][0])&gt;
</font>        m3(m1.br_redova, m2.br_kolona);
      for(int i = 0; i &lt; m1.br_redova; i++)
        for(int j = 0; j &lt; m2.br_kolona; j++) {
          m3.elementi[i][j] = 0;
          for(int k = 0; k &lt; m1.br_kolona; k++)
            m3.elementi[i][j] += m1.elementi[i][k] * m2.elementi[k][j];
        }
      return m3;
  }

<a name="8"></a><font color="#00FFFF"><a href="match381-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

template &lt;typename Tip1, typename Tip2&gt;
  auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, Tip2 broj)
    -&gt; GMatrica&lt;decltype(m.elementi[0][0] * broj)&gt; {
</font>      GMatrica&lt;decltype(m.elementi[0][0] * broj)&gt; m2(m.br_redova, m.br_kolona);
      for(int i = 0; i &lt; m.br_redova; i++)
        for(int j = 0; j &lt; m.br_kolona; j++)
          m2.elementi[i][j] = m.elementi[i][j] * broj;
      return m2;
  }

<a name="6"></a><font color="#00FF00"><a href="match381-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

template &lt;typename Tip1, typename Tip2&gt;
  auto operator *(Tip1 broj, const GMatrica&lt;Tip2&gt; &amp;m)
    -&gt; GMatrica&lt;decltype(m.elementi[0][0] * broj)&gt; {
</font>      return m * broj;
  }

template &lt;typename TipEl&gt;
  template &lt;typename Tip2&gt;
<a name="15"></a><font color="#FF0000"><a href="match381-1.html#15" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator +=(const GMatrica&lt;Tip2&gt; &amp;m) {
      if(br_redova != m.br_redova || br_kolona != m.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
</font>      for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; br_kolona; j++)
          elementi[i][j] += m.elementi[i][j];
      return *this;
    }

template &lt;typename TipEl&gt;
  template &lt;typename Tip2&gt;
<a name="16"></a><font color="#00FF00"><a href="match381-1.html#16" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator -=(const GMatrica&lt;Tip2&gt; &amp;m) {
      if(br_redova != m.br_redova || br_kolona != m.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
</font>      for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; br_kolona; j++)
          elementi[i][j] -= m.elementi[i][j];
      return *this;
    }

template &lt;typename TipEl&gt;
  template &lt;typename Tip2&gt;
<a name="13"></a><font color="#00FFFF"><a href="match381-1.html#13" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator *=(const GMatrica&lt;Tip2&gt; &amp;m) {
      if(br_kolona != m.br_redova)
        throw std::domain_error("Nedozvoljena operacija");
      GMatrica&lt;TipEl&gt; m1(*this);
</font>      for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; m.br_kolona; j++) {
          elementi[i][j] = 0;
          for(int k = 0; k &lt; br_kolona; k++)
            elementi[i][j] += m1.elementi[i][k] * m.elementi[k][j];
        }
      return *this;
    }

template &lt;typename TipEl&gt;
  template &lt;typename Tip2&gt;
<a name="9"></a><font color="#FF00FF"><a href="match381-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator *=(Tip2 broj) {
      for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; br_kolona; j++)
          elementi[i][j] *= broj;
</font>      return *this;
    }

<a name="17"></a><font color="#0000FF"><a href="match381-1.html#17" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

template &lt;typename Tip1, typename Tip2&gt;
  bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) {
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
</font>      return false;
    for(int i = 0; i &lt; m1.br_redova; i++)
      for(int j = 0; j &lt; m1.br_kolona; j++)
<a name="7"></a><font color="#0000FF"><a href="match381-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

        if(m1[i][j] != m2[i][j]) return false;
    return true;
  }

template &lt;typename Tip1, typename Tip2&gt;
  bool operator !=(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) {
</font>    return !(m1 == m2);
  }

template &lt;typename TipEl&gt;
  TipEl &amp;GMatrica&lt;TipEl&gt;::operator()(int i, int j) {
    if(i &lt; 1 || i &gt; br_redova || j &lt; 1 || j &gt; br_kolona)
      throw std::range_error("Nedozvoljen indeks");
    return elementi[i - 1][j - 1];
  }

template &lt;typename TipEl&gt;
  TipEl GMatrica&lt;TipEl&gt;::operator()(int i, int j) const {
    if(i &lt; 1 || i &gt; br_redova || j &lt; 1 || j &gt; br_kolona)
      throw std::range_error("Nedozvoljen indeks");
    return elementi[i - 1][j - 1];
  }

template &lt;typename TipEl&gt;
  std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;TipEl&gt; &amp;m) {
    char znak;
    tok &gt;&gt; znak;
    if(znak != '[') tok.setstate(std::ios::failbit);
    for(int i = 0; i &lt; m.br_redova; i++) {
      for(int j = 0; j &lt; m.br_kolona; j++) {
        tok &gt;&gt; m.elementi[i][j];
        if(j != m.br_kolona - 1) {
          tok &gt;&gt; znak;
          if(znak != ',') tok.setstate(std::ios::failbit);
        }
      }
      if(i != m.br_redova - 1) {
        tok &gt;&gt; znak;
        if(znak != ';') tok.setstate(std::ios::failbit);
      }
    }
    tok &gt;&gt; znak;
    if(znak != ']') tok.setstate(std::ios::failbit);
<a name="18"></a><font color="#00FFFF"><a href="match381-1.html#18" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    return tok;
  }

template &lt;typename TipEl&gt;
  std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;TipEl&gt; &amp;m) {
</font>    int sirina_ispisa(tok.width());
    if(sirina_ispisa &lt; 6) sirina_ispisa = 6;
    for(int i = 0; i &lt; m.br_redova; i++) {
      for(int j = 0; j &lt; m.br_kolona; j++)
        std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; m.elementi[i][j];
      std::cout &lt;&lt; std::endl;
    }
    return tok;
  }

class Fudo {
public:
  operator GMatrica&lt;int&gt;() { return GMatrica&lt;int&gt;{{1, 1}, {1, 1}}; }
};

#define TestirajIzuzetak(izuzetak, tijelo) \
  try tijelo catch(izuzetak e) { std::cout &lt;&lt; e.what() &lt;&lt; std::endl; }


int main(){
//AT25
  GMatrica&lt;int&gt; a(3,3);
  std::cin &gt;&gt; a;
  std::cout &lt;&lt; std::setw(3) &lt;&lt; a &lt;&lt;std::endl;
  std::cout &lt;&lt; std::setw(12) &lt;&lt; a &lt;&lt; std::endl;
  
  
 

  
}


int _main() {
{
  GMatrica&lt;int&gt; m1;
  std::cout &lt;&lt; m1.DajBrojRedova() &lt;&lt; " " &lt;&lt; m1.DajBrojKolona() &lt;&lt; std::endl;
  GMatrica&lt;int&gt; m2(2, 3);
  std::cout &lt;&lt; m2 &lt;&lt; std::endl;
  std::cout &lt;&lt; m2.DajBrojRedova() &lt;&lt; " " &lt;&lt; m2.DajBrojKolona() &lt;&lt; std::endl;
  GMatrica&lt;int&gt; m3(2, 3, 10);
  std::cout &lt;&lt; m3 &lt;&lt; std::endl;
  TestirajIzuzetak(std::logic_error, { GMatrica&lt;int&gt; m(1, 5); });
  TestirajIzuzetak(std::logic_error, { GMatrica&lt;int&gt; m(5, 1); });
  TestirajIzuzetak(std::logic_error, { GMatrica&lt;int&gt; m(1, -1); });
  TestirajIzuzetak(std::logic_error, { GMatrica&lt;int&gt; m(-1, 1); });
  
  
  GMatrica&lt;double&gt; m4(m3);
  std::cout &lt;&lt; m4 &lt;&lt; std::endl;
  m4 = m3;                          // Test radi li dodjela izmedju razlicitih tipova
  std::cout &lt;&lt; m4 &lt;&lt; std::endl;
  
  
  int cmat[4][4]{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1, 2}, {3, 4, 5, 6}};
  GMatrica&lt;int&gt; m5(cmat);
  std::cout &lt;&lt; m5 &lt;&lt; std::endl;
  GMatrica&lt;double&gt; m6(cmat);
  std::cout &lt;&lt; m6 &lt;&lt; std::endl;
  GMatrica&lt;int&gt; m7({{1, 2, 3}, {4, 5, 6}});
  std::cout &lt;&lt; m7 &lt;&lt; std::endl;
  
  
  TestirajIzuzetak(std::logic_error, {
    GMatrica&lt;int&gt; m({{1, 2, 3, 4, 5}, {1, 2, 3, 4, 5}});
  });
  TestirajIzuzetak(std::logic_error, {
    GMatrica&lt;int&gt; m({{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}});
  });
  TestirajIzuzetak(std::logic_error, {
    GMatrica&lt;int&gt; m({{1}, {1, 2}});
  });

  
  
  GMatrica&lt;int&gt; m8({});                 // Rubni slucaj: matrica 0x0
  std::cout &lt;&lt; m8 &lt;&lt; std::endl;
  std::cout &lt;&lt; m8.DajBrojRedova() &lt;&lt; " " &lt;&lt; m8.DajBrojKolona() &lt;&lt; std::endl;
  GMatrica&lt;int&gt; m9({{}, {}});           // Rubni slucaj: matrica 2x0
  std::cout &lt;&lt; m9 &lt;&lt; std::endl;
  std::cout &lt;&lt; m9.DajBrojRedova() &lt;&lt; " " &lt;&lt; m9.DajBrojKolona() &lt;&lt; std::endl;
  
  
  GMatrica&lt;int&gt; m10{{1, 2, 3}, {4, 5, 6}};
  std::cout &lt;&lt; m10 &lt;&lt; std::endl;
  try {                                                    // Zbog nekog razloga, makro TestirajIzuzetak
    GMatrica&lt;int&gt; m{{1, 2, 3, 4, 5}, {1, 2, 3, 4, 5}};     // ovdje nece da radi...
  }
  catch(std::logic_error e) {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }
  try {
    GMatrica&lt;int&gt; m{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
  }
  catch(std::logic_error e) {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }
  try {
    GMatrica&lt;int&gt; m{{1}, {1, 2}};
  }
  catch(std::logic_error e) {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }
  



  GMatrica&lt;int&gt; m11({});               // Rubni slucaj: matrica 0x0
  std::cout &lt;&lt; m11 &lt;&lt; std::endl;
  std::cout &lt;&lt; m11.DajBrojRedova() &lt;&lt; " " &lt;&lt; m11.DajBrojKolona() &lt;&lt; std::endl;
  GMatrica&lt;int&gt; m12{{}, {}};           // Rubni slucaj: matrica 2x0
  std::cout &lt;&lt; m12 &lt;&lt; std::endl;
  std::cout &lt;&lt; m12.DajBrojRedova() &lt;&lt; " " &lt;&lt; m12.DajBrojKolona() &lt;&lt; std::endl;
  m12 = {{1, 2}, {3, 4}};              // I ovo treba da radi...
  std::cout &lt;&lt; m12 &lt;&lt; std::endl;
}
  // Većina dalje stvari ocekuje da sekvencijski konstruktor radi dobro... da li tako raditi
  // u autotestovima, ili ne, ne znam... Ili se možda osloniti na konstruktor za vektor


  GMatrica&lt;int&gt; a{{1, 2}, {3, 4}}, b{{5, 7}, {8, 6}};
  GMatrica&lt;int&gt; c{{1, 2, 3}, {4, 5, 6}}, d{{1, 2}, {3, 4}, {5, 6}};

  std::cout &lt;&lt; a + b &lt;&lt; std::endl;
  std::cout &lt;&lt; a - b &lt;&lt; std::endl;
  std::cout &lt;&lt; a * b &lt;&lt; std::endl;
  std::cout &lt;&lt; b * a &lt;&lt; std::endl;
  //std::cout &lt;&lt; a * 3 &lt;&lt; std::endl;
  //std::cout &lt;&lt; 3 * a &lt;&lt; std::endl;
  //std::cout &lt;&lt; a * 3.5 &lt;&lt; std::endl;                // Razliciti tipovi
 // std::cout &lt;&lt; 3.5 * a &lt;&lt; std::endl;
  std::cout &lt;&lt; c * d &lt;&lt; std::endl;
  std::cout &lt;&lt; d * c &lt;&lt; std::endl;
  GMatrica&lt;double&gt; e{{1.2, 3.4}, {5.6, 7.8}};
  std::cout &lt;&lt; a + e &lt;&lt; std::endl;                  // Razliciti tipovi
  std::cout &lt;&lt; a - e &lt;&lt; std::endl;
  std::cout &lt;&lt; a * e &lt;&lt; std::endl;
  std::cout &lt;&lt; a * e &lt;&lt; std::endl;
  
  
  TestirajIzuzetak(std::domain_error, { a + c; });  // Možda dodati još koju varijantu neslaganja formata
  TestirajIzuzetak(std::domain_error, { a - c; });
  TestirajIzuzetak(std::domain_error, { c * a; });
  
  
  GMatrica&lt;int&gt; a1(a), a2(a), a3(a), a4(a), a5(a), a6(a), a7(a), a8(a);
  GMatrica&lt;double&gt; e1(e), e2(e), e3(e), e4(e);
  a1 += b;
  a2 -= b;
  a3 *= b;
  a4 *= 3;
  std::cout &lt;&lt; a1 &lt;&lt; std::endl;
  std::cout &lt;&lt; a2 &lt;&lt; std::endl;
  std::cout &lt;&lt; a3 &lt;&lt; std::endl;
  std::cout &lt;&lt; a4 &lt;&lt; std::endl;
  a5 += e;                              // Mora biti sasjeceno na int...
  a6 -= e;
  a7 *= e;
  a8 *= 3.5;
  std::cout &lt;&lt; a5 &lt;&lt; std::endl;
  std::cout &lt;&lt; a6 &lt;&lt; std::endl;
  std::cout &lt;&lt; a7 &lt;&lt; std::endl;
  std::cout &lt;&lt; a8 &lt;&lt; std::endl;
  e1 += a;                              // Ali ovdje ne...
  e2 -= a;
  e3 *= a;
  e4 *= 3;
  std::cout &lt;&lt; e1 &lt;&lt; std::endl;
  std::cout &lt;&lt; e2 &lt;&lt; std::endl;
  std::cout &lt;&lt; e3 &lt;&lt; std::endl;
  std::cout &lt;&lt; e4 &lt;&lt; std::endl;
  
  
  TestirajIzuzetak(std::domain_error, { a += c; });  // Možda dodati još koju varijantu neslaganja formata
  TestirajIzuzetak(std::domain_error, { a -= c; });
  TestirajIzuzetak(std::domain_error, { c *= a; });
  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; (a == a) &lt;&lt; " " &lt;&lt; (a == b) &lt;&lt; " " &lt;&lt; (a == c) &lt;&lt; std::endl;
  std::cout &lt;&lt; (a != a) &lt;&lt; " " &lt;&lt; (a != b) &lt;&lt; " " &lt;&lt; (a != c) &lt;&lt; std::endl;
  std::cout &lt;&lt; (a == e) &lt;&lt; " " &lt;&lt; (a != e) &lt;&lt; std::endl;                        // Razliciti tipovi
  GMatrica&lt;double&gt; adouble(a);
  std::cout &lt;&lt; (a == adouble) &lt;&lt; " " &lt;&lt; (a != adouble) &lt;&lt; std::endl;            // Razliciti tipovi, jednaki sadrzaji

  // Još malo testova operatora () i [] uključujući test izuzetaka...
  // Obavezno testirati radi li a(1, 1) = ... i a[1][1] = ...
  //   i napraviti jednu const kopiju, tipa const GMatrica&lt;int&gt; aa;
  //   pa vidjeti rade li () i [] sa tom kopijom

}

</pre>
</body>
</html>
