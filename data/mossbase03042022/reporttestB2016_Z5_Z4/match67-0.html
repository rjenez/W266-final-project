<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1547.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1547.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match67-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_29.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

template &lt;typename TipEl&gt;
class GMatrica{
    TipEl elementi[4][4];
    int br_redova, br_kolona;
    public:
    int DajBrojKolona() const { return br_kolona;}
    int DajBrojRedova() const { return br_redova;}
    GMatrica(): br_kolona(0), br_redova(0){};
    GMatrica(int brkolona, int brredova, TipEl vrijednost);
    GMatrica(const GMatrica&lt;TipEl&gt;&amp; m);
    GMatrica&lt;TipEl&gt;(TipEl** n);
    GMatrica&lt;TipEl&gt;(std::vector&lt;std::vector&lt;TipEl&gt;&gt; v);
    GMatrica&lt;TipEl&gt;(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; lista);
    
    template&lt;typename TipEl1, typename TipEl2&gt;
    friend GMatrica&lt;TipEl1&gt; operator + (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2); //-&gt; decltype(m1.elementi[0][0]+m2.elementi[0][0]);
    
    template&lt;typename TipEl1&gt;
	auto operator +=(GMatrica&lt;TipEl1&gt; &amp;m2)-&gt; decltype(elementi[0][0]+m2.elementi[0][0]);
	
	template&lt;typename TipEl1, typename TipEl2&gt;
	friend GMatrica&lt;TipEl1&gt; operator - (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2); // -&gt; decltype(m1.elementi[0][0]-m2.elementi[0][0]);
	
	template&lt;typename TipEl1&gt;
	auto operator -=(GMatrica&lt;TipEl1&gt; &amp;m2)-&gt; decltype(elementi[0][0]-m2.elementi[0][0]);
	
	template&lt;typename TipEl1, typename TipEl2&gt;
	friend auto operator * (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt; decltype(m1.elementi[0][0]*m2.elementi[0][0]);
	
	template&lt;typename TipEl1&gt;
	auto operator *=(GMatrica&lt;TipEl1&gt; &amp;m2)-&gt; decltype(elementi[0][0]*m2.elementi[0][0]);
	
	template&lt;typename TipEl1, typename TipEl2&gt;
	friend bool operator == (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2);
	
	template&lt;typename TipEl1, typename TipEl2&gt;
	friend bool operator != (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2);
	
	TipEl &amp;operator ()(int i, int j);
	template &lt;typename TipEl1&gt;
    friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;TipEl1&gt; &amp;m);
	template &lt;typename TipEl1&gt;
    friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok,  GMatrica&lt;TipEl1&gt; &amp;m);
	TipEl* operator [](int index1) const;
	TipEl* operator [](int index1);
};

template&lt;typename TipEl&gt;
    GMatrica&lt;TipEl&gt;::GMatrica(int brkolona, int brredova, TipEl vrijednost){
        if(brkolona&lt;0 or brkolona&gt;4 or brredova&lt;0 or brredova&gt;4) throw std::logic_error ("Ilegalan format matrice");
        br_kolona=brkolona;
        br_redova=brredova;
        for(int i=0; i&lt;br_redova; i++){
            for(int j=0; i&lt;br_kolona; j++){
                elementi[i][j]=vrijednost;
            }
        }
    }

template&lt; typename TipEl&gt;
    GMatrica&lt;TipEl&gt;::GMatrica(const GMatrica&lt;TipEl&gt;&amp; m){
        for(int i=0; i&lt;m.br_redova; i++){
            for(int j=0; j&lt;m.br_kolona; j++){
                elementi[i][j]=m.elementi[i][j];
            }
        }
        br_kolona=m.br_kolona; br_redova=m.br_redova;
    }
template &lt;typename TipEl&gt;
    GMatrica&lt;TipEl&gt;::GMatrica(TipEl** n){
        br_kolona=4;
        br_redova=4;
        for(int i=0; i&lt;4; i++){
            for(int j=0; j&lt;4; j++){
                elementi[i][j]=n[i][j];
</font>            }
        }
    }
template&lt;typename TipEl&gt;
<a name="4"></a><font color="#FF00FF"><a href="match67-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

    GMatrica&lt;TipEl&gt;::GMatrica(std::vector&lt;std::vector&lt;TipEl&gt;&gt; v){
        if(v.size()&gt;4) throw std::logic_error("Ilegalan format matrice");
        for(int i=0; i&lt;v.size(); i++){
            if(v[i].size()!=v[0].size()) throw std::logic_error("Ilegalan format matrice");
        }
        br_kolona=v[0].size(); br_redova=v.size();
        for(int i=0; i&lt;br_redova; i++){
            for(int j=0; j&lt;br_kolona; j++){
</font>                elementi[i][j]=v[i][j];
            }
        }
    }
template &lt;typename TipEl&gt;
<a name="3"></a><font color="#00FFFF"><a href="match67-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_9.gif"/></a>

    GMatrica&lt;TipEl&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; lista){
        if(lista.size()&gt;4) throw std::logic_error("Ilegalan format matrice");
        int x=lista.begin()-&gt;size();
        for(auto i=lista.begin(); i!=lista.end(); i++){
            if(i-&gt;size()!=x) throw std::logic_error("Ilegalan format matrice");
        }
        br_kolona=x;
        br_redova=lista.size();
        int y(0); x=0;
        for(auto it=lista.begin(); it!=lista.end(); it++){
            y=0;
            for(auto itt=it-&gt;begin(); itt!=it-&gt;end(); itt++){
                elementi[x][y]=*itt;
                y++;
            }
            x++;
        }
    }
template&lt;typename TipEl1, typename TipEl2&gt;
    GMatrica&lt;TipEl1&gt; operator + (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2) /*-&gt; decltype(GMatrica&lt;(decltype(m1.elementi[0][0]+m2.elementi[0][0]))&gt;)*/{
        if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona) throw std::domain_error("Nedozvoljena operacija");
	GMatrica&lt;TipEl1&gt; m(m1.br_redova, m2.br_kolona, 0);
	m.br_redova=m1.br_redova;
	m.br_kolona=m1.br_kolona;
	for(int i = 0; i &lt; m1.br_redova; i++)
</font>		for(int j = 0; j &lt; m1.br_kolona; j++)
<a name="6"></a><font color="#00FF00"><a href="match67-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

			m.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
	    return m;
    }
   // template&lt;typename TipEl&gt;
	//auto GMatrica&lt;TipEl&gt;::operator +=(GMatrica&lt;TipEl&gt; &amp;m2)-&gt; decltype(elementi[0][0]+m2.elementi[0][0]);
template&lt;typename TipEl1, typename TipEl2&gt;
    GMatrica&lt;TipEl1&gt; operator - (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2)/* -&gt; decltype(m1.elementi[0][0]-m2.elementi[0][0])*/{
	    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona) throw std::domain_error("Nedozvoljena operacija");
</font><a name="7"></a><font color="#0000FF"><a href="match67-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

    	GMatrica&lt;decltype(m1.elementi[0][0]+m2.elementi[0][0])&gt; m3(m1.br_redova, m1.br_kolona, 0);
    	m3.br_redova=m1.br_redova;
    	m3.br_kolona=m1.br_kolona;
	    for(int i = 0; i &lt; m1.br_redova; i++)
</font>		    for(int j = 0; j &lt; m1.br_kolona; j++)
<a name="2"></a><font color="#0000FF"><a href="match67-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

			    m3.elementi[i][j] = m1.elementi[i][j] - m2.elementi[i][j];
	    return m3;
	 }
	//template&lt;typename TipEl1&gt;
	//auto GMatrica&lt;TipEl&gt;::operator -=(GMatrica&lt;TipEl1&gt; &amp;m2)-&gt; decltype(elementi[0][0]-m2.elementi[0][0]);
template&lt;typename TipEl1, typename TipEl2&gt;
    GMatrica&lt;TipEl2&gt; operator * (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2){ //-&gt; decltype(m1.elementi[0][0]*m2.elementi[0][0]){
	    if(m1.br_kolona != m2.br_redova) throw std::domain_error("Nedozvoljena operacija");
    	GMatrica&lt;decltype(m1.elementi[0][0]*m2.elementi[0][0])&gt; m3(m1.br_redova, m2.br_kolona, 0);
    	m3.br_redova=m1.br_redova;
    	m3.br_kolona=m2.br_kolona;
	    for(int i=0; i&lt;m1.br_redova; i++) {
		    for(int j=0; j&lt;m2.br_kolona; j++) {
			    m3.elementi[i][j]=0;
		    	for(int k=0; k&lt;m1.br_kolona; k++) {
			    	m3.elementi[i][j]+=m1.elementi[i][k]*m2.elementi[k][j];
			    }
		    }
	    }
	    return m3;
    }
template&lt;typename TipEl1&gt;
	GMatrica&lt;TipEl1&gt; operator * (const GMatrica&lt;TipEl1&gt; &amp;m1, double x){
	    GMatrica&lt;TipEl1&gt; m3(m1.br_redova, m1.br_kolona, 0);
    	m3.br_redova=m1.br_redova;
    	m3.br_kolona=m1.br_kolona;
	    for(int i=0; i&lt;m1.br_redova; i++) {
</font>		    for(int j=0; j&lt;m1.br_kolona; j++) {
<a name="5"></a><font color="#FF0000"><a href="match67-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

			    m3.elementi[i][j]=m1.elementi[i][j]*x;
		    }
	    }
	    return m3;
	}
template&lt;typename TipEl1&gt;
	GMatrica&lt;TipEl1&gt; operator * (double x,const GMatrica&lt;TipEl1&gt; &amp;m1){
	    GMatrica&lt;TipEl1&gt; m3(m1.br_redova, m1.br_kolona, 0);
    	m3.br_redova=m1.br_redova;
    	m3.br_kolona=m1.br_kolona;
	    for(int i=0; i&lt;m1.br_redova; i++) {
</font>		    for(int j=0; j&lt;m1.br_kolona; j++) {
<a name="8"></a><font color="#00FFFF"><a href="match67-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

			    m3.elementi[i][j]=m1.elementi[i][j]*x;
		    }
	    }
	    return m3;
	}
//template&lt;typename TipEl1, typename TipEl&gt;
//	 GMatrica&lt;TipEl&gt; GMatrica&lt;TipEl&gt;::operator *=(GMatrica&lt;TipEl1&gt; &amp;m2)
	 
template&lt;typename TipEl1, typename TipEl2&gt;
	bool operator == (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2){
	    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona) return false;
</font>	    for(int i=0; i&lt;m1.br_redova; i++){
	        for(int j=0; j&lt;m1.br_kolona; j++){
<a name="1"></a><font color="#00FF00"><a href="match67-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_24.gif"/></a>

	            if(m1.elementi[i][j]!=m2.elementi[i][j]) return false;
	        }
	    }
	    return true;
	}
template&lt;typename TipEl1, typename TipEl2&gt;
	bool operator != (const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2){
	    return !(m1==m2);
	}
template &lt;typename TipEl&gt;
    TipEl &amp;GMatrica&lt;TipEl&gt;::operator ()(int i, int j){
        if(i&gt;br_redova or i&lt;1 or j&lt;1 or j&gt;br_kolona) throw std::range_error("Nedozvoljen indeks");
        return elementi[i-1][j-1];
    }
template &lt;typename TipEl&gt;
    TipEl* GMatrica&lt;TipEl&gt;::operator [](int index1){
    	return elementi[index1];
    }
template &lt;typename TipEl&gt;
    TipEl* GMatrica&lt;TipEl&gt;::operator [](int index1) const{
    	return elementi[index1];
}
template &lt;typename TipEl1&gt;
    std::ostream &amp;operator &lt;&lt; (std::ostream &amp;tok, const GMatrica&lt;TipEl1&gt; &amp;m){
        int x(tok.width());
        if(x&lt;6) x=6;
        for(int i=0; i&lt;m.br_redova; i++){
            for(int j=0; j&lt;m.br_kolona; j++){
                tok &lt;&lt; std::setw(x) &lt;&lt;m.elementi[i][j];
            }
            tok &lt;&lt; std::endl;
        }
        return tok;
    }
template &lt;typename TipEl1&gt;
    std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;TipEl1&gt; &amp;m){
        std::string s;
        std::getline(std::cin, s);
        if(s[0]!='[') tok.setstate(std::ios::failbit);
        int i=1;
        int x(0), y(0);
        while(s[i]!=']'){
            y=0;
            while(s[i]!=';' and s[i]!=']'){
               m.elementi[x][y]=s[i]-'0';

               y++;
               if(s[i+1]!=',' or s[i+1]!=';' or s[i+1]!=']')  tok.setstate(std::ios::failbit);
               i++;
               if(s[i]==']') break;
               if(s[i]==',') i++;
            }
            if(s[i]==']') break;
            i++;
            x++;
        }
        m.br_kolona=y;
        m.br_redova=x+1;
        return tok;
    }
using std::cout;
using std::cin;

int main ()
{
    GMatrica&lt;double&gt; m1, m2;
    cout &lt;&lt; "Unesite prvu matricu: ";
    cin &gt;&gt; m1;
    cin &gt;&gt; m2;
    cout &lt;&lt; "Matrice ";
    if(m1==m2) cout &lt;&lt; "su iste";
    else cout &lt;&lt; "nisu iste";
    cout &lt;&lt; "Matrice ";
    if(m1!=m2) cout &lt;&lt; "su razlicite";
    else cout &lt;&lt; "nisu razlicite";
    int x,y;
    cout &lt;&lt; "Koji element prve matice zelite procitati: ";
    cin &gt;&gt; x&gt;&gt; y;
    cout &lt;&lt; m1[x][y];
     cout &lt;&lt; "Koji element druge matice zelite procitati: ";
    cin &gt;&gt; x&gt;&gt; y;
    cout &lt;&lt; m2[x][y];
</font>	return 0;
}</pre>
</body>
</html>
