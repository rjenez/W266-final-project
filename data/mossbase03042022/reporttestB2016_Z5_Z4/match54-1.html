<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3116.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1013.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match54-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_52.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

using namespace std;

template&lt;typename Tip&gt;
class GMatrica
{
    Tip Mat[4][4];
    int brR,brK;
    
    public:
    GMatrica(int r=0,int k=0,Tip n=0);//
    GMatrica(GMatrica &amp;g);//
    GMatrica(GMatrica &amp;&amp;g);//
    GMatrica(const vector&lt;vector&lt;Tip&gt;&gt;&amp;v);//
    GMatrica(const initializer_list&lt;initializer_list&lt;Tip&gt;&gt;&amp;l);//
    GMatrica(Tip &amp;n)
    {
        brR=4;brK=4;
        for(int i=0;i&lt;4;i++)
            for(int j=0;j&lt;4;j++)
                Mat[i][j]=n;
    }
   
    int DajBrojRedova()const{return brR;}
    int DajBrojKolona()const{return brK;}
    
    template&lt;typename Tip1,typename Tip2&gt;
    friend GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator+(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2);//
    template&lt;typename Tip1,typename Tip2&gt;
    friend GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator-(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2);//
    template&lt;typename Tip1,typename Tip2&gt;
    friend GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator*(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2);//
    template&lt;typename Tip1,typename Tip2&gt;
    friend GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator*(GMatrica&lt;Tip1&gt;&amp;g1,const Tip2 &amp;n);//
    template&lt;typename Tip1,typename Tip2&gt;
    friend GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator*(const Tip1 &amp;n,GMatrica&lt;Tip2&gt;&amp;g1);//
   
    GMatrica &amp;operator+=(GMatrica&lt;Tip&gt; &amp;g);
    GMatrica &amp;operator-=(GMatrica&lt;Tip&gt; &amp;g);
    GMatrica &amp;operator*=(GMatrica&lt;Tip&gt; &amp;g);
    GMatrica &amp;operator*=(const Tip &amp;n);
    
    
    template&lt;typename Tip1,typename Tip2&gt;
    friend bool operator==(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2);//
    template&lt;typename Tip1,typename Tip2&gt;
    friend bool operator!=(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2);//
   
    Tip operator()(int i,int j) const
    {
        if(i&lt;=0 || j&lt;=0) throw range_error("Nedozvoljen indeks");
        return Mat[i-1][j-1];
    }
    Tip &amp;operator()(int i,int j)
    {
        if(i&lt;=0 || j&lt;=0) throw range_error("Nedozvoljen indeks");
        return Mat[i-1][j-1];
    }
    
    Tip *operator[](const int &amp;i) const
    {
        return Mat[i];
    }
    Tip *operator[](const int &amp;i)
    {
        return Mat[i];
    }
    
    friend ostream &amp;operator&lt;&lt;(ostream &amp;izso,GMatrica&lt;Tip&gt; g)
    {   
        streamsize n;        
        if(cout.width()==0) n=6;
        else  n=cout.width();
        
        for(int i=0;i&lt;g.DajBrojRedova();i++)
        {
            for(int j=0;j&lt;g.DajBrojKolona();j++)
                izso&lt;&lt;setw(n)&lt;&lt;g.Mat[i][j];
            izso&lt;&lt;endl;
        }        
        return izso;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;uso,GMatrica&lt;Tip&gt; &amp;g)
    {
        int m=0;int n=0;
        char c;
        uso&gt;&gt;c;
        if(c=='[')
            while(c!=']')
            {   
                uso&gt;&gt;g.Mat[m][n]&gt;&gt;c;
                if(c==',')n++;
                else if(c==';'){m++;n=0;}
                else break;
            }
        g.brR=m+1;g.brK=n+1;
        
        return uso;
    }
    
};


template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt;::GMatrica(int r,int k,Tip1 n)
    {
        if(r&lt;0 || r&gt;4 || k&lt;0 || k&gt;4) throw logic_error("Ilegalan format matrice");
        brR=r;brK=k;
        for(int i=0;i&lt;r;i++)
            for(int j=0;j&lt;k;j++)
                Mat[i][j]=n;
    
    }
template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt;::GMatrica(GMatrica&lt;Tip1&gt; &amp;g)
    {
        GMatrica::brR=g.brR;
        GMatrica::brK=g.brK;
        
        for(int i=0;i&lt;brR;i++)
            for(int j=0;j&lt;brK;j++)
                GMatrica::Mat[i][j]=g.Mat[i][j];
    }
    

template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt;::GMatrica(GMatrica&lt;Tip1&gt; &amp;&amp;g)
    {
        GMatrica::brR=g.brR;
        GMatrica::brK=g.brK;
        
        for(int i=0;i&lt;brR;i++)
            for(int j=0;j&lt;brK;j++)
                GMatrica::Mat[i][j]=g.Mat[i][j];
    }
template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt;::GMatrica(const vector&lt;vector&lt;Tip1&gt;&gt; &amp;v)
{       
        if(v.size()&gt;4) throw logic_error("Ilegalan format matrice");
    for(int i=0; i&lt;v.size(); i++) if(v[i].size()!=v[0].size()) throw logic_error("Ilegalan format matrice");
    for(auto i:v) if(i.size()&gt;4) throw logic_error("Ilegalan format matrice");
        GMatrica::brR=v.size();
        GMatrica::brK=v[0].size();
    
        for(int i=0;i&lt;brR;i++)
            for(int j=0;j&lt;brK;j++)
                GMatrica::Mat[i][j]=v[i][j];
}
template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt;::GMatrica(const initializer_list&lt;initializer_list&lt;Tip1&gt;&gt; &amp;l)
{       
        
        int br=0, br1=0;
    for(auto x=l.begin(); x!=l.end(); x++)
    {
        br++; br1=0;
        for(auto y=x-&gt;begin();y!=x-&gt;end();y++) br1++;
        if(br&gt;4) throw logic_error("Ilegalan format matrice");
    }
    
    if(br&gt;4)throw logic_error("Ilegalan format matrice");
        auto it=l.begin();
        GMatrica::brR=l.begin()-&gt;size();
        GMatrica::brK=it-&gt;size();
        
        int p=0;
        for(auto i=l.begin();i!=l.end();i++,p++)
        {   
            int q=0;
            for(auto j=i-&gt;begin();j!=i-&gt;end();j++,q++)
            {
                 Mat[p][q]=*j;
            }
        }
        
}

template&lt;typename Tip1,typename Tip2&gt;
GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator+(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2)
{   
    if(g1.DajBrojKolona()!=g2.DajBrojKolona() || g1.DajBrojRedova()!=g2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(Tip1()+Tip2())&gt; g(g1.DajBrojRedova(),g1.DajBrojKolona());
    for(int i=0;i&lt;g.DajBrojRedova();i++)
        for(int j=0;j&lt;g.DajBrojKolona();j++)
</font><a name="3"></a><font color="#00FFFF"><a href="match54-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

            g.Mat[i][j]=g1.Mat[i][j]+g2.Mat[i][j];
  
    return g;
}    


template&lt;typename Tip1,typename Tip2&gt;
GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator-(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2)
{
   if(g1.DajBrojKolona()!=g2.DajBrojKolona() || g1.DajBrojRedova()!=g2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(Tip1()+Tip2())&gt; g(g1.DajBrojRedova(),g1.DajBrojKolona());
    for(int i=0;i&lt;g.DajBrojRedova();i++)
        for(int j=0;j&lt;g.DajBrojKolona();j++)
</font><a name="2"></a><font color="#0000FF"><a href="match54-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

            g.Mat[i][j]=g1.Mat[i][j]-g2.Mat[i][j];
            
    return g;
}    


template&lt;typename Tip1,typename Tip2&gt;
GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator*(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2)
{
    if(g1.DajBrojKolona()!=g2.DajBrojRedova() || g1.DajBrojRedova()!=g2.DajBrojKolona()) throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(Tip1()+Tip2())&gt; g(g1.DajBrojRedova(),g1.DajBrojKolona());
    for(int i=0;i&lt;g.DajBrojRedova();i++)
        for(int j=0;j&lt;g.DajBrojKolona();j++)
        {   g.Mat[i][j]=0;
            for(int k=0;k&lt;g.DajBrojKolona();k++)
              g.Mat[i][j]+=g1.Mat[i][k]*g2.Mat[k][j];
        }
    return g;
}    

template&lt;typename Tip1,typename Tip2&gt;
GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator*(GMatrica&lt;Tip1&gt;&amp;g1,const Tip2 &amp;n)
{
   GMatrica&lt;decltype(Tip1()+Tip2())&gt; g(g1.DajBrojRedova(),g1.DajBrojKolona());
    for(int i=0;i&lt;g.DajBrojRedova();i++)
        for(int j=0;j&lt;g.DajBrojKolona();j++)
</font><a name="4"></a><font color="#FF00FF"><a href="match54-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

            g.Mat[i][j]=g1.Mat[i][j]*n;
    return g;
}
template&lt;typename Tip1,typename Tip2&gt;
GMatrica&lt;decltype(Tip1()+Tip2())&gt;operator*(const Tip1 &amp;n,GMatrica&lt;Tip2&gt;&amp;g1)
{
    GMatrica&lt;decltype(Tip1()+Tip2())&gt; g(g1.DajBrojRedova(),g1.DajBrojKolona());
    for(int i=0;i&lt;g.DajBrojRedova();i++)
        for(int j=0;j&lt;g.DajBrojKolona();j++)
</font><a name="6"></a><font color="#00FF00"><a href="match54-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

            g.Mat[i][j]=g1.Mat[i][j]*n;
    return g;
}

 template&lt;typename Tip1,typename Tip2&gt;
 bool operator==(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2)
 {
     for(int i=0;i&lt;g1.DajBrojRedova();i++)
        for(int j=0;j&lt;g1.DajBrojKolona();j++)
</font><a name="5"></a><font color="#FF0000"><a href="match54-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

            if(g1.Mat[i][j]!=g2.Mat[i][j]) return false;
        return true;
 }
template&lt;typename Tip1,typename Tip2&gt;
bool operator!=(GMatrica&lt;Tip1&gt;&amp;g1,GMatrica&lt;Tip2&gt;&amp;g2)
{
    for(int i=0;i&lt;g1.DajBrojRedova();i++)
        for(int j=0;j&lt;g1.DajBrojKolona();j++)
</font><a name="1"></a><font color="#00FF00"><a href="match54-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_19.gif"/></a>

            if(g1.Mat[i][j]!=g2.Mat[i][j]) return true;
        return false;
}

template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt; &amp;GMatrica&lt;Tip1&gt;::operator+=(GMatrica&lt;Tip1&gt; &amp;g)
{
    if(g.DajBrojKolona()!=DajBrojKolona() || g.DajBrojRedova()!=DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    for(int i=0;i&lt;g.DajBrojRedova();i++)
        for(int j=0;j&lt;g.DajBrojKolona();j++)
            Mat[i][j]=Mat[i][j]+g.Mat[i][j];
    
    return *this;
}
template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt; &amp;GMatrica&lt;Tip1&gt;::operator-=(GMatrica&lt;Tip1&gt; &amp;g)
{
    
    if(g.DajBrojKolona()!=DajBrojKolona() || g.DajBrojRedova()!=DajBrojRedova()) throw domain_error("Nedozvoljena operacija");for(int i=0;i&lt;g.DajBrojRedova();i++)
        for(int j=0;j&lt;g.DajBrojKolona();j++)
            Mat[i][j]=Mat[i][j]-g.Mat[i][j];
        
    return *this;
}
template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt; &amp;GMatrica&lt;Tip1&gt;::operator*=(GMatrica&lt;Tip1&gt; &amp;g)
{
    
    if(DajBrojKolona()!=g.DajBrojRedova() || DajBrojRedova()!=g.DajBrojKolona()) throw domain_error("Nedozvoljena operacija");for(int i=0;i&lt;g.DajBrojRedova();i++)
        for(int j=0;j&lt;g.DajBrojKolona();j++)
        {   Mat[i][j]=0;
            for(int k=0;k&lt;g.DajBrojKolona();k++)
                Mat[i][j]+=Mat[i][k]*g.Mat[k][j];
        }
    return *this;
}
template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt; &amp;GMatrica&lt;Tip1&gt;::operator*=(const Tip1 &amp;n)
{
  for(int i=0;i&lt;DajBrojRedova();i++)
    for(int j=0;j&lt;DajBrojKolona();j++)
        Mat[i][j]=Mat[i][j]*n;
    return *this;
}
int main ()
{  
   
   
    GMatrica&lt;double&gt; m1({{1, 2}, {3, 4}});
   GMatrica&lt;double&gt; m2({{1, 2}, {3, 4}});
   auto m3 = m1 + m2;
   std::cout &lt;&lt; m3 &lt;&lt; std::endl;
   GMatrica&lt;double&gt; m4({{1, 2}, {3, 4}});
   auto m5 = m3-m4;
   std::cout &lt;&lt; m5 &lt;&lt; std::endl;
</font>  
	return 0;
}</pre>
</body>
</html>
