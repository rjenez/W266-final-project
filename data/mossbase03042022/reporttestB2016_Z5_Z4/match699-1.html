<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4415.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6874.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;iomanip&gt;

template &lt;typename TipEl&gt;
class GMatrica{
    TipEl matrica[4][4];
    int br_redova, br_kolona;
    public:
     GMatrica() : br_redova(0), br_kolona(0){}
     GMatrica(int br_redova, int br_kolona, TipEl inicijalna_vrijednost = TipEl());
     GMatrica(TipEl klasicni_niz[4][4]);
     GMatrica(const std::vector&lt;std::vector&lt;TipEl&gt;&gt; &amp;v);
     GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; lista);
     template &lt;typename tip2&gt;
      GMatrica&lt;TipEl&gt;(const GMatrica&lt;tip2&gt; &amp;gm);
    int DajBrojRedova() const {return br_redova;}
    int DajBrojKolona() const {return br_kolona;}
    template &lt;typename tip1, typename tip2&gt;
<a name="1"></a><font color="#00FF00"><a href="match699-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

     friend GMatrica&lt;decltype(tip1() + tip2())&gt; operator+ (const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2);
    template &lt;typename tip1, typename tip2&gt;
      friend GMatrica&lt;decltype(tip1() + tip2())&gt; operator- (const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2);
    template &lt;typename tip1, typename tip2&gt;
     friend GMatrica&lt;decltype(tip1() * tip2())&gt; operator* (const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2);
    template &lt;typename tip1, typename tip2&gt;
      friend GMatrica&lt;decltype(tip1() + tip2())&gt; operator* (tip1 broj, const GMatrica&lt;tip2&gt; &amp;m);
</font>    template &lt;typename tip1e, typename tip2e&gt;
      friend GMatrica&lt;decltype(tip1e() + tip2e())&gt; operator* (const GMatrica&lt;tip1e&gt; &amp;m, tip2e broj);
    
    template &lt;typename tip2&gt;
      GMatrica&lt;decltype(TipEl() + tip2())&gt; &amp;operator+=(const GMatrica&lt;tip2&gt; &amp;m);
    template &lt;typename tip2&gt;
      GMatrica&lt;decltype(TipEl() - tip2())&gt; &amp;operator-=(const GMatrica&lt;tip2&gt; &amp;m);
    template &lt;typename tip1, typename tip2&gt;
      friend GMatrica&lt;decltype(tip1() + tip2())&gt; &amp;operator*= (GMatrica&lt;tip1&gt; &amp;m, tip2 broj); 
    template &lt;typename tip1, typename tip2&gt;
      friend GMatrica&lt;decltype(tip1() + tip2())&gt; &amp;operator*= (tip1 broj, GMatrica&lt;tip2&gt; &amp;m);
  
    template &lt;typename tip2&gt;
      GMatrica&lt;decltype(TipEl() + tip2())&gt; &amp;operator*=(const GMatrica&lt;tip2&gt; &amp;m);
    template &lt;typename tip2&gt;
    friend bool operator == (const GMatrica&lt;tip2&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2);
    template &lt;typename tip2&gt;
    friend bool operator!= (const GMatrica&lt;tip2&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2);
    TipEl operator() (int red, int kolona) const;
    TipEl &amp;operator() (int red, int kolona);
    TipEl *operator[] (int red) const;
    TipEl *operator[] (int red);
    template &lt;typename tip2&gt;
    friend std::ostream &amp;operator&lt;&lt; (std::ostream &amp;tok, const GMatrica&lt;tip2&gt; &amp;m);
    template &lt;typename tip2&gt;
    friend std::istream &amp;operator&gt;&gt; (std::istream &amp;tok, GMatrica&lt;tip2&gt; &amp;m);
};

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(int br_redova, int br_kolona, TipEl inicijalna_vrijednost){
    if(br_redova&gt;4 || br_redova&lt;0 || br_kolona&gt;4 || br_kolona&lt;0)
      throw std::logic_error("Ilegalan format matrice");
    GMatrica&lt;TipEl&gt;::br_redova = br_redova;
    GMatrica&lt;TipEl&gt;::br_kolona = br_kolona;
    for(int i=0; i&lt;br_redova; i++)
     for(int j=0; j&lt;br_kolona; j++)
       matrica[i][j] = inicijalna_vrijednost;
}



/*template &lt;typename TipEl&gt;
template &lt;typename tip2&gt;
GMatrica&lt;TipEl&gt;::GMatrica(const GMatrica&lt;tip2&gt; &amp;gm){
    br_redova = gm.br_redova;
    br_kolona = gm.br_kolona;
    for(int i=0; i&lt;br_redova; i++)
     for(int j=0; j&lt;br_kolona; j++)
       matrica[i][j] = gm.matrica[i][j];
}*/

template &lt;typename tip1&gt;
template &lt;typename tip2&gt;
<a name="7"></a><font color="#0000FF"><a href="match699-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

GMatrica&lt;tip1&gt;::GMatrica(const GMatrica&lt;tip2&gt; &amp;gm){
    br_kolona = gm.DajBrojKolona();
    br_redova = gm.DajBrojRedova();
    for(int i=0; i&lt;br_redova; i++)
      for(int j=0; j&lt;br_kolona; j++)
</font>       matrica[i][j] = gm(i+1, j+1);
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(TipEl klasicni_niz[4][4]){
    br_redova = 4;
    br_kolona = 4;
    for(int i=0; i&lt;4; i++)
     for(int j=0; j&lt;4; j++)
      matrica[i][j] = klasicni_niz[i][j];
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(const std::vector&lt;std::vector&lt;TipEl&gt;&gt; &amp;v){
    if(v.size()&gt;4)
      throw std::logic_error("Ilegalan format matrice");
    for(int i=0; i&lt;v.size(); i++)
      if(v[i].size()!=v[0].size() || v[i].size()&gt;4)
        throw std::logic_error("Ilegalan format matrice");
   br_redova = v.size();
   br_kolona = v[0].size();
   for(int i=0; i&lt;br_redova; i++)
     for(int j=0; j&lt;br_kolona; j++)
       matrica[i][j] = v[i][j];
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; lista){
    if(lista.size()&gt;4)
      throw std::logic_error("Ilegalan format matrice");
     int kol(0);
    for(auto it=lista.begin(); it!=lista.end(); it++){
        if(it-&gt;size()!=lista.begin()-&gt;size() || it-&gt;size()&gt;4)
          throw std::logic_error("Ilegalan format matrice");
          kol = it-&gt;size();
    }
    br_redova = lista.size();
    br_kolona = kol;
    int i(0);
   for(auto it=lista.begin(); it!=lista.end(); it++){
       int j(0);
       for(auto it1=it-&gt;begin(); it1!=it-&gt;end(); it1++){
         matrica[i][j] = *it1;
         j++;
       }
       i++;
   }   
}
<a name="2"></a><font color="#0000FF"><a href="match699-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

template &lt;typename tip1, typename tip2&gt;
GMatrica&lt;decltype(tip1() + tip2())&gt;  operator+ (const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2){
    if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona)
      throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(tip1() + tip2())&gt; m3(m1.br_redova, m1.br_kolona);
    for(int i=0; i&lt;m3.br_redova; i++)
      for(int j=0; j&lt;m3.br_kolona; j++)
</font><a name="4"></a><font color="#FF00FF"><a href="match699-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        m3.matrica[i][j] = m1.matrica[i][j] + m2.matrica[i][j];
    return m3;
}

template &lt;typename tip1, typename tip2&gt;
GMatrica&lt;decltype(tip1() + tip2())&gt; operator- (const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2){
    if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona)
</font>      throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(tip1() + tip2())&gt; m3(m1.br_redova, m1.br_kolona);
    for(int i=0; i&lt;m3.br_redova; i++)
      for(int j=0; j&lt;m3.br_kolona; j++)
<a name="0"></a><font color="#FF0000"><a href="match699-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

        m3.matrica[i][j] = m1.matrica[i][j] - m2.matrica[i][j];
    return m3;
}

template &lt;typename tip1, typename tip2&gt;
GMatrica&lt;decltype(tip1()*tip2())&gt; operator* (const GMatrica&lt;tip1&gt; &amp;m1, const GMatrica&lt;tip2&gt; &amp;m2){
    if(m1.br_kolona!=m2.br_redova)
      throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(tip1() * tip2())&gt; m3(m1.br_redova, m2.br_kolona);
    for(int i=0; i&lt;m1.br_redova; i++)
      for(int j=0; j&lt;m2.br_kolona; j++){
          decltype(tip1() * tip2()) suma(m1.matrica[0][0] - m1.matrica[0][0]);
</font><a name="6"></a><font color="#00FF00"><a href="match699-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

          for(int k=0; k&lt;m2.br_redova; k++) 
            suma+= m1.matrica[i][k] * m2.matrica[k][j];
          m3.matrica[i][j] = suma;
      }
      return m3;
</font>}

template &lt;typename TipEl&gt;
template &lt;typename tip2&gt;
GMatrica&lt;decltype(TipEl() + tip2())&gt; &amp;GMatrica&lt;TipEl&gt;::operator+=(const GMatrica&lt;tip2&gt; &amp;m){
    if(br_redova!=m.DajBrojRedova() || br_kolona!=m.DajBrojKolona())
      throw std::domain_error("Nedozvoljena operacija");
    for(int i=0; i&lt;br_redova; i++)
      for(int j=0; j&lt;br_kolona; j++)
        matrica[i][j] += m(i+1, j+1);
    return *this;
}

template &lt;typename TipEl&gt;
template &lt;typename tip2&gt;
<a name="8"></a><font color="#00FFFF"><a href="match699-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

GMatrica&lt;decltype(TipEl() - tip2())&gt; &amp;GMatrica&lt;TipEl&gt;::operator-=(const GMatrica&lt;tip2&gt; &amp;m){
    if(br_redova!=m.DajBrojRedova() || br_kolona!=m.DajBrojKolona())
      throw std::domain_error("Nedozvoljena operacija");
</font>    for(int i=0; i&lt;br_redova; i++){
     for(int j=0; j&lt;br_kolona; j++){
       matrica[i][j] -= m(i+1, j+1);
     }
    }
    return *this;
}

template &lt;typename TipEl&gt;
template &lt;typename tip2&gt;
GMatrica&lt;decltype(TipEl() + tip2())&gt; &amp;GMatrica&lt;TipEl&gt;::operator*=(const GMatrica&lt;tip2&gt; &amp;m2){
    if(br_kolona!=m2.DajBrojRedova())
      throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;TipEl&gt; m1(*this);
    br_redova = m1.DajBrojRedova();
    br_kolona = m2.DajBrojKolona();
    for(int i=0; i&lt;m1.DajBrojRedova(); i++){
    for(int j=0; j&lt;m2.DajBrojKolona(); j++){
        decltype(TipEl() * tip2()) suma(m1.matrica[0][0] - m1.matrica[0][0]);
        
        for(int k=0; k&lt;m2.DajBrojRedova(); k++){suma+=(m1(i+1, k+1) * m2(k+1, j+1)); }
        
        matrica[i][j] = suma;
    }
    }
    return *this;
    
}

template &lt;typename TipEl&gt;
bool operator == (const GMatrica&lt;TipEl&gt; &amp;m1, const GMatrica&lt;TipEl&gt; &amp;m2){
    if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona)
     return false;
    for(int i=0; i&lt;m1.br_redova; i++)
     for(int j=0; j&lt;m1.br_kolona; j++)
       if(m1.matrica[i][j]!=m2.matrica[i][j])
         return false;
    return true;
}

template &lt;typename TipEl&gt;
bool operator!= (const GMatrica&lt;TipEl&gt; &amp;m1, const GMatrica&lt;TipEl&gt; &amp;m2){
    return !(m1==m2);
}

template &lt;typename TipEl&gt;
TipEl GMatrica&lt;TipEl&gt;::operator() (int red, int kolona) const{
    if(red&lt;1 || red&gt;br_redova || kolona&lt;1 || kolona&gt;br_kolona){
      //std::cout&lt;&lt;red&lt;&lt;" "&lt;&lt;kolona&lt;&lt;std::endl;
      throw std::range_error("Nedozvoljen indeks");
    }
    return matrica[red - 1][kolona - 1];
}

template &lt;typename TipEl&gt;
TipEl &amp;GMatrica&lt;TipEl&gt;::operator() (int red, int kolona){
    if(red&lt;1 || red&gt;br_redova || kolona&lt;1 || kolona&gt;br_kolona)
      throw std::range_error("Nedozvoljen indeks");
    return matrica[red - 1][kolona - 1];
}

template &lt;typename TipEl&gt;
TipEl *GMatrica&lt;TipEl&gt;::operator[] (int red) const{
    return matrica[red];
}
template &lt;typename TipEl&gt;
TipEl *GMatrica&lt;TipEl&gt;::operator[] (int red){
    return matrica[red];
}

template &lt;typename TipEl&gt;
std::ostream &amp;operator&lt;&lt; (std::ostream &amp;tok, const GMatrica&lt;TipEl&gt; &amp;m){
    int sirina(tok.width());
    if(sirina&lt;6)
      sirina = 6;
    for(int i=0; i&lt;m.br_redova; i++){
<a name="3"></a><font color="#00FFFF"><a href="match699-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

      for(int j=0; j&lt;m.br_kolona; j++)
        tok&lt;&lt;std::setw(sirina)&lt;&lt;m.matrica[i][j];
    
    tok&lt;&lt;std::endl;    
    }
    return tok;
}

template &lt;typename TipEl&gt;
std::istream &amp;operator&gt;&gt; (std::istream &amp;tok, GMatrica&lt;TipEl&gt; &amp;m){
    char znak;
    tok&gt;&gt;znak;
</font>    if(znak!='[')
      tok.setstate(std::ios::failbit);
    
    m.br_redova = 4; 
    m.br_kolona = 4;
    
    int i(0);
    bool kraj(false);
    while(true){
        char znak1;
        int k = 0;
    
        while(true){
            //std::cout&lt;&lt;"\n i = "&lt;&lt;i&lt;&lt;"\n k = "&lt;&lt;k&lt;&lt;"\n";
            TipEl broj;
            tok&gt;&gt;broj;
            if(!tok){
              //tok.setstate(std::ios::failbit);
              //kraj = true;
              break;
                
            }
           
            m.matrica[i][k] = broj;
           
            k++;
            tok&gt;&gt;znak1;
            
            
            
            if(znak1 != ',' &amp;&amp; znak1!=';' &amp;&amp; znak1!=']'){
             tok.setstate(std::ios::failbit);
             kraj = true;
             break;
            }
            if((znak1==';') &amp;&amp; i==0){
                m.br_kolona = k ;
                break;
            }
            if(znak1==']' &amp;&amp; i==0){
                m.br_kolona = k;
                kraj = true;
                break;
            }
            /*if(i!=0 &amp;&amp; (znak1==';' || znak1==']')  &amp;&amp; k!=m.br_kolona - 1){
                tok.setstate(std::ios::failbit);
            }*/
            if(znak1==';')
              break;
            if(znak1==']'){
             kraj = true;
             break;
            }
            if(k&gt;=4){
                tok.setstate(std::ios::failbit);
                kraj = true;
                break;
                
            }
        }
        i++;
        if(kraj){
            m.br_redova = i ;
            break;
        }
        
        if(i&gt;=4){
            tok.setstate(std::ios::failbit);
            break;
        }
    }
   //std::cout&lt;&lt;"\nbr_redova = "&lt;&lt;m.br_redova&lt;&lt;"\nbr_kolona = "&lt;&lt;m.br_kolona&lt;&lt;"\n";

    
  return tok;    
}

template &lt;typename tip1, typename tip2&gt;
<a name="5"></a><font color="#FF0000"><a href="match699-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

GMatrica&lt;decltype(tip1() + tip2())&gt; operator* (tip1 broj, const GMatrica&lt;tip2&gt; &amp;m){
    GMatrica&lt;decltype(tip1() * tip2())&gt; m2(m.br_redova, m.br_kolona);
    for(int i=0; i&lt;m2.br_redova; i++)
     for(int j=0; j&lt;m2.br_kolona; j++)
</font>       m2.matrica[i][j]= m.matrica[i][j] * broj;
    return m2;
}

template &lt;typename tip1e, typename tip2e&gt;
inline GMatrica&lt;decltype(tip1e() + tip2e())&gt; operator* (const GMatrica&lt;tip1e&gt; &amp;m, tip2e broj){
   GMatrica&lt;decltype(tip1e() + tip2e())&gt; m2(m.br_redova, m.br_kolona);
    for(int i=0; i&lt;m2.br_redova; i++)
      for(int j=0; j&lt;m2.br_kolona; j++)
        m2.matrica[i][j]= m.matrica[i][j] * broj;
    return broj * m;
}

template &lt;typename tip1, typename tip2&gt;
GMatrica&lt;decltype(tip1() + tip2())&gt; &amp;operator*= (GMatrica&lt;tip1&gt; &amp;m, tip2 broj){
    for(int i=0; i&lt;m.br_redova; i++)
    for(int j=0; j&lt;m.br_kolona; j++)
      m.matrica[i][j]*=broj;
    return m;
}

template &lt;typename tip1, typename tip2&gt;
inline GMatrica&lt;decltype(tip1() + tip2())&gt; &amp;operator*= (tip1 broj, GMatrica&lt;tip2&gt; &amp;m){
    return m*=broj;
}


int main ()
{
  try{
   GMatrica&lt;int&gt; m1, m2;
   std::cout&lt;&lt;"Unesi matrice m1 i m2: \n";
   std::cin &gt;&gt; m1&gt;&gt;m2;
   std::cout &lt;&lt; m1 &lt;&lt; std::endl;
   std::cout&lt;&lt;"\n"&lt;&lt;m2&lt;&lt;std::endl;
   std::cout&lt;&lt;"\n"&lt;&lt;m1 + m2&lt;&lt;std::endl;
   std::cout&lt;&lt; (3*m1)&lt;&lt;std::endl;
   GMatrica&lt;double&gt; m3({{1,2},{3,4}}),m4({{1, 2}, {3, 4}});
   auto m5 = m3-m4;
   std::cout &lt;&lt; m5 &lt;&lt; std::endl;
   if(m1==m2)
     std::cout&lt;&lt;"Matrice m1 i m2 su jednake."&lt;&lt;std::endl;
   std::cout&lt;&lt;m4[1][1]&lt;&lt;std::endl;
   std::cout&lt;&lt;m3(1,1)&lt;&lt;std::endl;
   m5+=m3;
   m5*=10;
   std::cout&lt;&lt;m5&lt;&lt;std::endl;
   GMatrica&lt;double&gt; m6(2,2, 0.8);
   std::cout&lt;&lt;m6&lt;&lt;std::endl;
   GMatrica&lt;double&gt; m7(m1);
   std::cout&lt;&lt;m7&lt;&lt;std::endl;
   m7+=m1;
   std::cout&lt;&lt;m7&lt;&lt;std::endl;
   m7-=m1;
   std::cout&lt;&lt;m7&lt;&lt;std::endl;
   std::cout&lt;&lt;m1[0][0] + m2[0][0]&lt;&lt;std::endl;
   GMatrica&lt;int&gt; m8(2,3,1), m9(3,2,2);
   m8*=m9;
   std::cout&lt;&lt;m8&lt;&lt;std::endl;
   GMatrica&lt;int&gt; m10({{1, 2}, {3, 4}});
   std::cout&lt;&lt;m10&lt;&lt;std::endl;
   GMatrica&lt;int&gt; m11{{1,2}, {3,4}};
   std::cout&lt;&lt;m11&lt;&lt;std::endl;
  }
  catch(std::range_error e){
      std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
  }
  catch(std::logic_error e){
      std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
  }
   return 0;
}</pre>
</body>
</html>
