<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4273.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4273.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match408-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B16/17 (Zadaća 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;

using std::cin; using std::cout; using std::endl;

template &lt;typename NekiTip&gt;
class GMatrica {
    NekiTip gmat[4][4];
    int br_redova, br_kolona;
    public:
    //Konstruktori
    GMatrica(); 
    GMatrica(int br_redova, int br_kolona, int inic_vr=NekiTip()); 
    /*template &lt;typename Tip1&gt;
    GMatrica(GMatrica&lt;Tip1&gt; mat);
    template &lt;typename Tip2&gt;
    GMatrica(Tip2 niz); */
    GMatrica(std::vector&lt;std::vector&lt;NekiTip&gt;&gt; vek); 
    //Sekvencijski konstruktor
    int DajBrojRedova() { return br_redova; };
    int DajBrojKolona() { return br_kolona; };
    //Operatori
    template &lt;typename Tip&gt;
    friend GMatrica&lt;Tip&gt; operator+(const GMatrica &amp;m1, const GMatrica &amp;m2);
    template &lt;typename Tip&gt;
    friend GMatrica&lt;Tip&gt; operator-(const GMatrica &amp;m1, const GMatrica &amp;m2);
    template &lt;typename Tip&gt;
    friend GMatrica&lt;Tip&gt; operator*(const GMatrica &amp;m1, const GMatrica &amp;m2);
    template &lt;typename Tip&gt;
    friend GMatrica&lt;Tip&gt; operator*(const GMatrica &amp;m, int broj);
    template &lt;typename Tip&gt;
    friend GMatrica&lt;Tip&gt; operator*(int broj, const GMatrica &amp;m);
    //Operator “*” također treba da podržava množenje broja sa matricom odnosno matrice sa brojem
    //Odgovarajuće operatorske funkcije ne treba da budu funkcije članice i obavezno ih treba implementirati izvan deklaracije klase
};

//Konstruktori
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt;::GMatrica() : br_redova(0), br_kolona(0) { 
    for (int i=0; i&lt;4; i++) {
        for (int j=0; j&lt;4; j++) {
            gmat[i][j]=NekiTip();
        }
    }
}
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt;::GMatrica(int br_redova, int br_kolona, int inic_vr) {
    if (br_redova&lt;0 || br_redova &gt;4 || br_kolona&lt;0 || br_kolona&gt;4) throw std::logic_error ("Ilegalan format matrice");
    GMatrica::br_redova(br_redova), GMatrica::br_kolona(br_kolona);
    for (int i=0; i&lt;4; i++) {
        for (int j=0; j&lt;4; j++) {
            gmat[i][j]=NekiTip(inic_vr);
        }
    }
}
/*
template &lt;typename Tip, typename Tip1&gt; //, typename Tip1&gt;
GMatrica&lt;Tip&gt;::GMatrica(GMatrica&lt;Tip1&gt; mat) {}

template &lt;typename NekiTip, typename Tip2&gt;
GMatrica&lt;NekiTip&gt;::GMatrica(Tip2 niz) {
    br_kolona=4; br_redova=4;
    for (int i=0; i&lt;4; i++) {
        for (int j=0; j&lt;4; j++) {
            gmat[i][j]=NekiTip(niz[i][j]); //niz pok?
        }
    }
}*/

template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt;::GMatrica(std::vector&lt;std::vector&lt;NekiTip&gt;&gt; vek) {
     //Provjeri je li prazan!
    if (vek.size()&lt;0 || vek.size()&gt;4 || vek[0].size()&lt;0 || vek[0].size()&gt;4) throw std::logic_error ("Ilegalan format matrice");
    br_redova=vek.size();
    br_kolona=vek[0].size(); 
    for (int i=0; i&lt;br_redova; i++) {
        for (int j=0; j&lt;br_kolona; j++) {
            gmat[i][j]=vek[i][j];
        }
    }
}
 
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt; operator+(const GMatrica&lt;NekiTip&gt; &amp;m1, const GMatrica&lt;NekiTip&gt; &amp;m2) {
    if (m1.DajBrojRedova()!=m2.DajBrojRedova() || m1.DajBrojKolona()!=m2.DajBrojKolona()) throw std::domain_error ("Nedozvoljena operacija");
    
    return m1;
}
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt; operator-(const GMatrica&lt;NekiTip&gt; &amp;m1, const GMatrica&lt;NekiTip&gt; &amp;m2) {
    if (m1.DajBrojRedova()!=m2.DajBrojRedova() || m1.DajBrojKolona()!=m2.DajBrojKolona()) throw std::domain_error ("Nedozvoljena operacija");

    return m1;
}
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt; operator*(const GMatrica&lt;NekiTip&gt; &amp;m1, const GMatrica&lt;NekiTip&gt; &amp;m2) {
    if (m1.DajBrojRedova()!=m2.DajBrojKolona() || m1.DajBrojKolona()!=m2.DajBrojRedova()) throw std::domain_error ("Nedozvoljena operacija");
    
    return m1;
}

 template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt; operator*(const GMatrica&lt;NekiTip&gt; &amp;m, int broj) {
    return m;
}
template &lt;typename NekiTip&gt;
GMatrica&lt;NekiTip&gt; operator*(int broj, const GMatrica&lt;NekiTip&gt; &amp;m) {
    return m;
}

int main ()
{
    cout &lt;&lt; "Sto nece da se kompajlira?" &lt;&lt; endl;
    GMatrica&lt;int&gt; mat;
    cout &lt;&lt; mat.DajBrojRedova() &lt;&lt; " " &lt;&lt; mat.DajBrojKolona() &lt;&lt; endl;
	return 0;
</font>}</pre>
</body>
</html>
