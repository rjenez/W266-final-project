<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1938.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1938.cpp<p></p><pre>
<a name="10"></a><font color="#FF0000"><a href="match449-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;type_traits&gt;

template &lt;typename tip&gt;
class GMatrica{
        tip m[4][4];
        int row, col;
    public:
    GMatrica();
    GMatrica(int row, int col, tip val = tip());
</font>    template&lt;typename blah&gt;
    GMatrica(const GMatrica&lt;blah&gt; &amp;m2);
    template&lt;typename tip2&gt;
    GMatrica(const tip2 mat[4][4]);
    GMatrica(const std::vector&lt;std::vector&lt;tip&gt;&gt; &amp;v);
    GMatrica(const std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt; &amp;l);
    tip DajBrojRedova()const{ return row; }
    tip DajBrojKolona()const{ return col; }
    template&lt;typename tip1,typename tip2&gt;
    friend auto operator+(const GMatrica&lt;tip1&gt; &amp;m1,const GMatrica&lt;tip2&gt; &amp;m2)-&gt;
     GMatrica&lt;typename std::remove_reference&lt;decltype(m2.m[0][0] +m1.m[0][0])&gt;::type&gt;;
     
    template&lt;typename tip1,typename tip2&gt;
    friend auto operator-(const GMatrica&lt;tip1&gt; &amp;m1,const GMatrica&lt;tip2&gt; &amp;m2)-&gt;
    GMatrica&lt;typename std::remove_reference&lt;decltype(m2.m[0][0]-m1.m[0][0])&gt;::type&gt;;
    
    template&lt;typename tip1,typename tip2&gt;
    friend auto operator*(const GMatrica&lt;tip1&gt; &amp;m1,const GMatrica&lt;tip2&gt; &amp;m2)-&gt;
    GMatrica&lt;typename std::remove_reference&lt;decltype(m2.m[0][0]*m1.m[0][0])&gt;::type&gt;;
    
    template&lt;typename tip1,typename tip2&gt;
    friend auto operator*( GMatrica&lt;tip1&gt; m1, tip2 n)-&gt;
    GMatrica&lt;typename std::remove_reference&lt;decltype(m1.m[0][0]*n)&gt;::type&gt;;
    
    template&lt;typename tip1, typename tip2&gt;
    friend auto operator*(tip2 n,  GMatrica&lt;tip1&gt; m1)-&gt;
    GMatrica&lt;typename std::remove_reference&lt;decltype(m1.m[0][0]*n)&gt;::type&gt;;
    //////
    template&lt;typename tip1&gt;
    GMatrica &amp;operator*=(const GMatrica&lt;tip1&gt; &amp;m1);
    
    template&lt;typename tip1&gt;
    GMatrica &amp;operator*=(tip1 x);
    
    template&lt;typename tip1&gt;
    GMatrica &amp;operator-=(const GMatrica&lt;tip1&gt; &amp;m1);
    
    template&lt;typename tip1&gt;
    GMatrica &amp;operator+=(const GMatrica&lt;tip1&gt; &amp;m1);
    
    template&lt;typename tip1&gt;
    bool operator==(const GMatrica&lt;tip1&gt; &amp;m1)const;
    
    template&lt;typename tip1&gt;
    bool operator!=(const GMatrica&lt;tip1&gt; &amp;m1)const;
    
    tip operator()(int x, int y)const;
    tip &amp;operator()(int x, int y);
    
    const tip* operator[](int x)const;
    tip* operator[](int x);
    
    template&lt;typename tip1&gt;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;tip1&gt; &amp;m);
    
    template&lt;typename tip1&gt;
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;tok, GMatrica&lt;tip1&gt; &amp;m1);
};
bool white(char c){
    return (c == ' ' || c == '\n' || c == '\f' || c == '\v' || c == '\t' || c == '\r');
}
<a name="8"></a><font color="#00FFFF"><a href="match449-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

template&lt;typename tip1&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;tok, GMatrica&lt;tip1&gt; &amp;m1){
    std::vector&lt;std::vector&lt;tip1&gt;&gt; v;
    char b, e;
</font>    tok &gt;&gt; b;
    if(b != '[' ){ tok.setstate(std::ios::failbit); return tok; }
    if(tok.peek() != ']') b = ';'; int red(0);
    
    while(b == ';'){
        red++; v.resize(red);
        int kol(0);
        do{
            kol++; v[red-1].resize(kol);
            tok &gt;&gt; v[red-1][kol-1];
            tok&gt;&gt; e;
        }while(e != ';' &amp;&amp; e != EOF &amp;&amp; e != ']');
        b = e;
    }
    if(b != ']' || (tok.peek() != EOF &amp;&amp; !white(tok.peek()) )){
        tok.setstate(std::ios::failbit); return tok; 
    }
    m1.row = v.size(); //m1.col = v[0].size();
    m1.col = 0;
    if(v.size()) m1.col = v[0].size();
    if(v.size() &gt; 4) { tok.setstate(std::ios::failbit); return tok; }
    for(int i = 1; i &lt; v.size(); i++){
            if(v[i-1].size() != v[i].size())
                {tok.setstate(std::ios::failbit); return tok; }
    }
<a name="6"></a><font color="#00FF00"><a href="match449-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    for(int i = 0; i &lt; v.size(); i++){
        for(int j = 0; j &lt; v[i].size(); j++)
            m1.m[i][j] = v[i][j];
</font>    }
    return tok;
}
<a name="4"></a><font color="#FF00FF"><a href="match449-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

template&lt;typename tip&gt; 
template&lt;typename tip1&gt;
GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator*=(tip1 x){
    for(int i = 0; i &lt; row; i++)
        for(int j = 0; j &lt; col; j++) m[i][j] *= x;
</font>    return *this;
}
template&lt;typename tip1&gt;
<a name="3"></a><font color="#00FFFF"><a href="match449-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;tip1&gt; &amp;m1){
    int sirina = tok.width();
    if(sirina &lt; 6) sirina = 6;
    for(int i = 0; i &lt; m1.row; i++){
        for(int j = 0; j &lt; m1.col; j++){
</font>            tok.width(sirina);
            tok &lt;&lt; m1[i][j];
        }
        tok &lt;&lt; std::endl;
    }
    return tok;
}
<a name="2"></a><font color="#0000FF"><a href="match449-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

template&lt;typename tip&gt;
tip* GMatrica&lt;tip&gt;::operator[](int x){
    return m[x];
}
template&lt;typename tip&gt;
const tip* GMatrica&lt;tip&gt;::operator[](int x)const{
    return m[x];
}
template&lt;typename tip&gt;
tip &amp;GMatrica&lt;tip&gt;::operator()(int x, int y){
    if(x &lt; 1 || x &gt; row || y &lt; 1 || y &gt; col)
</font><a name="7"></a><font color="#0000FF"><a href="match449-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        throw std::range_error("Nedozvoljen indeks");
    return m[x-1][y-1];
}
template&lt;typename tip&gt;
tip GMatrica&lt;tip&gt;::operator()(int x, int y)const{
    if(x &lt; 1 || x &gt; row || y &lt; 1 || y &gt; col)
</font>        throw std::range_error("Nedozvoljen indeks");
    return m[x-1][y-1];
}
template&lt;typename tip&gt;
template&lt;typename tip1&gt;
bool GMatrica&lt;tip&gt;::operator!=(const GMatrica&lt;tip1&gt; &amp;m1)const{
    return !(*this == m1);
}
template&lt;typename tip&gt;
template&lt;typename tip1&gt;
bool GMatrica&lt;tip&gt;::operator==(const GMatrica&lt;tip1&gt; &amp;m1)const{
    bool isti = true;
    if(row != m1.row || col != m1.col) return false;
    for(int i = 0; i &lt; row; i++)
        for(int j = 0; j &lt; col; j++)
            if(m[i][j] != m1.m[i][j]){ isti = false; break; }
<a name="0"></a><font color="#FF0000"><a href="match449-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

    return isti;
}
template&lt;typename tip&gt;
template&lt;typename tip1&gt;
GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator-=(const GMatrica&lt;tip1&gt; &amp;m1){
    if(row != m1.row || col != m1.col) throw std::domain_error("Nedozvoljena operacija");
    for(int i = 0; i &lt; row; i++)
        for(int j = 0; j &lt; col; j++) m[i][j] -= m1.m[i][j];
    return *this;
}

template&lt;typename tip&gt;
template&lt;typename tip1&gt;
</font><a name="1"></a><font color="#00FF00"><a href="match449-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator+=(const GMatrica&lt;tip1&gt; &amp;m1){
    if(row != m1.row || col != m1.col) throw std::domain_error("Nedozvoljena operacija");
    for(int i = 0; i &lt; row; i++)
        for(int j = 0; j &lt; col; j++) m[i][j] += m1.m[i][j];
    return *this;
</font>}

template&lt;typename tip&gt;
template&lt;typename tip1&gt;
GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator*=(const GMatrica&lt;tip1&gt; &amp;m1){
    if(col != m1.row) throw std::domain_error("Nedozvoljena operaacija");
    GMatrica&lt;tip&gt; ret(row,col,tip());
    for(int i = 0; i &lt; row; i++)
        for(int j = 0; j &lt; col; j++) ret.m[i][j] = m[i][j];
    col = m1.col;
    
    for(int i = 0; i &lt; row; i++)
        for(int j = 0; j &lt; col; j++) m[i][j] = tip();
        
<a name="12"></a><font color="#0000FF"><a href="match449-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    for(int i = 0; i &lt; row; i++)
        for(int j = 0; j &lt; m1.col; j++)
            for(int k = 0; k &lt; m1.row; k++)
</font>                m[i][j] += ret.m[i][k] * m1.m[k][j];
    return *this;
}


template&lt;typename tip1, typename tip2&gt;
 auto operator*(tip2 n, GMatrica&lt;tip1&gt; m1)-&gt;
GMatrica&lt;typename std::remove_reference&lt;decltype(m1.m[0][0]*n)&gt;::type&gt;{
    return m1 * n;
}

template&lt;typename tip1,typename tip2&gt;
auto operator*(GMatrica&lt;tip1&gt; m1, tip2 n)-&gt;
GMatrica&lt;typename std::remove_reference&lt;decltype(m1.m[0][0]*n)&gt;::type&gt;{
    for(int i = 0; i &lt; m1.row; i++)
        for(int j = 0; j &lt; m1.col; j++) m1.m[i][j] *= n;
    return m1;
}

template&lt;typename tip1,typename tip2&gt;
auto operator*(const GMatrica&lt;tip1&gt; &amp;m1,const GMatrica&lt;tip2&gt; &amp;m2)-&gt;
GMatrica&lt;typename std::remove_reference&lt;decltype(m2.m[0][0]*m1.m[0][0])&gt;::type&gt;{
    if(m1.col != m2.row) throw std::domain_error("Nedozvoljena operacija");
    typedef typename std::remove_reference&lt;decltype(m2.m[0][0]*m1.m[0][0])&gt;::type novi;
    GMatrica&lt;novi&gt; ret(m1.row,m2.col,novi());
    for(int i = 0; i &lt; m1.row; i++)
        for(int j = 0; j &lt; m2.col; j++)
            for(int k = 0; k &lt; m2.row; k++)
<a name="13"></a><font color="#00FFFF"><a href="match449-1.html#13" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

                ret.m[i][j] += m1.m[i][k] * m2.m[k][j];
    return ret;
}
template&lt;typename tip1,typename tip2&gt;
auto operator-(const GMatrica&lt;tip1&gt; &amp;m1,const GMatrica&lt;tip2&gt; &amp;m2)-&gt;
</font>GMatrica&lt;typename std::remove_reference&lt;decltype(m2.m[0][0]-m1.m[0][0])&gt;::type&gt;{
    typedef typename std::remove_reference&lt;decltype(m2.m[0][0]-m1.m[0][0])&gt;::type novi;
    GMatrica&lt;novi&gt; ret(m1.row,m1.col,novi());
    for(int i = 0; i &lt; m2.row; i++)
        for(int j = 0; j &lt; m2.col; j++) ret.m[i][j] = -m2.m[i][j];
    return m1+ret;
}
template&lt;typename tip1, typename tip2&gt;
auto operator+(const GMatrica&lt;tip1&gt; &amp;m1,const GMatrica&lt;tip2&gt; &amp;m2)-&gt;
 GMatrica&lt;typename std::remove_reference&lt;decltype(m2.m[0][0] + m1.m[0][0])&gt;::type&gt;{
    if(m2.row != m1.row || m2.col != m1.col)
        throw std::domain_error("Nedozvoljena operacija");
    typedef typename std::remove_reference&lt;decltype(m2.m[0][0]*m1.m[0][0])&gt;::type novi;
    GMatrica&lt;novi&gt; ret(m1.row,m1.col, novi()); 
    for(int i = 0; i &lt; m1.row; i++)
        for(int j = 0; j &lt; m1.col; j++)
            ret.m[i][j] = m1.m[i][j] + m2.m[i][j];
    return ret;
}
    

template&lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica(const std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt; &amp;l){
    int i(0),j(0);
    for(auto &amp;p:l){
        for(auto &amp;q:p) m[i][j++] = q;
        i++; col = j; j = 0;
    }
    row = i;
}
template&lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica(const std::vector&lt;std::vector&lt;tip&gt;&gt; &amp;v){
    for(int i = 1; i &lt; v.size(); i++)
        if(v[i].size() != v[i-1].size() || v[i].size() &lt; 0 || v[i].size() &gt; 4)
            throw std::logic_error("Ilegalan format matrice");
    row = v.size();
    col = 0; if(row) col = v[0].size();
    for(int i = 0; i &lt; row; i++)
<a name="9"></a><font color="#FF00FF"><a href="match449-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        for(int j = 0; j &lt; col; j++) m[i][j] = v[i][j];
}
template&lt;typename tip&gt;
template&lt;typename tip2&gt;
GMatrica&lt;tip&gt;::GMatrica(const tip2 mat[4][4]):row(4),col(4){
</font>    for(int i = 0; i &lt; 4; i++)
        for(int j = 0; j &lt; 4; j++) m[i][j] = mat[i][j];
}

template&lt;typename tip&gt;
template&lt;typename blah&gt;
GMatrica&lt;tip&gt;::GMatrica(const GMatrica&lt;blah&gt; &amp;m2):row(m2.row),col(m2.col){
    for(int i = 0; i &lt; row; i++)
        for(int j = 0; j &lt; col; j++) m[i][j] = m2[i][j];
}

<a name="11"></a><font color="#00FF00"><a href="match449-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

template&lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica():row(0),col(0){ }

template&lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica(int row, int col, tip val):row(row),col(col){
</font>    if(row &gt; 4 || row &lt; 0 || col &gt; 4 || col &lt; 0)
        throw std::logic_error("Ilegalan format matrice");
    for(int i = 0; i &lt; row; i++)
        for(int j = 0; j &lt; col; j++) m[i][j] = val;
}


int main () {
    //operator+ i operator- i &lt;&lt;
   {
   GMatrica&lt;double&gt; m1({{1, 2}, {3, 4}});
   GMatrica&lt;double&gt; m2({{1, 2}, {3, 4}});
   auto m3 = m1 + m2;
   std::cout &lt;&lt; m3 &lt;&lt; std::endl;
   GMatrica&lt;double&gt; m4({{1, 2}, {3, 4}});
   auto m5 = m3-m4;
   std::cout &lt;&lt; m5 &lt;&lt; std::endl;
   //operator* i &lt;&lt;
   }
   {
   GMatrica&lt;int&gt; m1({{1, 2}, {3, 4}});
   //GMatrica&lt;int&gt; m2 = m1 * 2;
   //GMatrica&lt;int&gt; m3 = 2 * m1;  
   //std::cout &lt;&lt;  m2 &lt;&lt; std::endl;
   //std::cout &lt;&lt; m3 &lt;&lt; std::endl;
   //binarni operatori += -= *=
   }
   {
   GMatrica&lt;int&gt; m1({{1, 2}, {3, 4}});
   GMatrica&lt;int&gt; m2({{1, 2}, {3, 4}});
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
   m1 += m2;
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
   m1 -= m2;
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
   m1 *= 2;
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
   //operatori == i !=
   }
   {
   GMatrica&lt;int&gt; m1({{1, 2}, {3, 4}});
   GMatrica&lt;int&gt; m2({{1, 2}, {3, 4}});
   GMatrica&lt;int&gt; m3({{1, 2}, {3, 5}});
   if(m1 == m2 &amp;&amp; m1 != m3 &amp;&amp; !(m1 != m2) &amp;&amp; !(m1 != m2)) std::cout &lt;&lt; "OK" &lt;&lt; std::endl;
   else std::cout &lt;&lt; "NOK" &lt;&lt; std::endl;
    //operatori {} i []
   }
   {
<a name="5"></a><font color="#FF0000"><a href="match449-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

   GMatrica&lt;int&gt; m1({{1, 2}, {3, 4}});
   std::cout &lt;&lt; m1(1,1) &lt;&lt; std::endl;
   std::cout &lt;&lt; m1[1][1] &lt;&lt; std::endl;
   //operatori &lt;&lt; i &gt;&gt;
   }
   {
   GMatrica&lt;int&gt; m1;
</font>   std::cin &gt;&gt; m1;
   std::cout &lt;&lt; m1 &lt;&lt; std::endl;
   //konstruktori, DajBrojKolona, DajBrojRedova
    }
    {
   GMatrica&lt;int&gt; m1;
   std::cout &lt;&lt; m1.DajBrojKolona() &lt;&lt;"," &lt;&lt;m1.DajBrojRedova() &lt;&lt; std::endl;
   
   
   GMatrica&lt;int&gt; m2({{1, 2}, {3, 4}});
   std::cout &lt;&lt; m2.DajBrojKolona() &lt;&lt;"," &lt;&lt;m2.DajBrojRedova() &lt;&lt; std::endl;
   
   GMatrica&lt;int&gt; m3{{1, 2}, {3, 4}};
   std::cout &lt;&lt; m3.DajBrojKolona() &lt;&lt;"," &lt;&lt;m3.DajBrojRedova() &lt;&lt; std::endl;
    }
	return 0;
}</pre>
</body>
</html>
