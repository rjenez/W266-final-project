<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4163.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4163.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;iomanip&gt;

<a name="6"></a><font color="#00FF00"><a href="match750-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

template &lt;typename TipEl&gt;
class GMatrica {
    
    TipEl matrica[4][4];
    int br_redova, br_kolona;
    
    public:
    
    GMatrica();
    GMatrica(int br_redova, int br_kolonam, TipEl vrijednost = TipEl() );
</font>    template&lt;typename TipEl2&gt;
    GMatrica( GMatrica&lt;TipEl2&gt; m);
    GMatrica(TipEl niz[4][4]);
    GMatrica(std::vector&lt;std::vector&lt;TipEl&gt;&gt; &amp;m);
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt;  lista);
    
    int DajBrojRedova() const { return br_redova; }
    int DajBrojKolona() const { return br_kolona; }
    
    TipEl &amp;operator () (int i, int j);
    TipEl const operator () (int i, int j) const;
    TipEl *operator[](int indeks);
    TipEl const *operator[](int indeks) const;
    template&lt;typename TipEl2, typename TipEl3&gt;
    friend auto operator+(GMatrica&lt;TipEl3&gt; m1, const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0]+0)&gt;;
    template&lt;typename TipEl2, typename TipEl3&gt;
    friend auto operator-(GMatrica&lt;TipEl3&gt; m1, const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]-m2.matrica[0][0]+0)&gt;;
    template&lt;typename TipEl2, typename TipEl3&gt;
    friend auto operator*(GMatrica&lt;TipEl2&gt; m1, const GMatrica&lt;TipEl3&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]*m2.matrica[0][0]+0)&gt;;
    template&lt;typename TipEl2, typename TipEl3&gt;
    friend GMatrica&lt;TipEl3&gt; operator*(TipEl2 broj, GMatrica&lt;TipEl3&gt; m);
    template&lt;typename TipEl3, typename TipEl2&gt;
    friend GMatrica&lt;TipEl3&gt; operator*(GMatrica&lt;TipEl3&gt; m, TipEl2 broj);
<a name="1"></a><font color="#00FF00"><a href="match750-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    template&lt;typename TipEl2&gt;
    GMatrica&lt;TipEl&gt; &amp;operator+=(const GMatrica&lt;TipEl2&gt; &amp;m1);
    template&lt;typename TipEl2&gt;
    GMatrica&lt;TipEl&gt; &amp;operator-=(const GMatrica&lt;TipEl2&gt; &amp;m1);
    template&lt;typename TipEl2&gt;
    GMatrica&lt;TipEl&gt; &amp;operator*=(const GMatrica&lt;TipEl2&gt; &amp;m1);
    template&lt;typename TipEl2&gt;
    GMatrica&lt;TipEl&gt; &amp;operator*=(TipEl2 broj);
    template&lt;typename TipEl2&gt;
</font>    friend bool operator==(const GMatrica&lt;TipEl2&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2);
    template&lt;typename TipEl2&gt;
    friend bool operator!=(const GMatrica&lt;TipEl2&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2);
    template&lt;typename TipEl2&gt;
    friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;TipEl2&gt; &amp;m);
    template&lt;typename TipEl2&gt;
<a name="0"></a><font color="#FF0000"><a href="match750-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    friend std::istream&amp; operator&gt;&gt;(std::istream &amp;tok, GMatrica&lt;TipEl2&gt; &amp;m);
};

//KONSTRUKTORI
template&lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica() : br_redova(0), br_kolona(0) {}

template&lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(int r, int k, TipEl vrijednost) {
    if(r&lt;0 || k&lt;0 || r&gt;4 || k&gt;4) throw std::logic_error ("Ilegalan format matrice");
    br_redova=r; br_kolona=k;
    for(int i=0; i&lt;r; i++) {
        for(int j=0; j&lt;k; j++)
</font>            matrica[i][j]=vrijednost;
    }
}

template&lt;typename TipEl&gt;
template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl&gt;::GMatrica(GMatrica&lt;TipEl2&gt; m) {
    br_redova=m.DajBrojRedova(); br_kolona=m.DajBrojKolona();
    for(int i=0; i&lt;br_redova; ++i) {
        for(int j=0; j&lt;br_kolona; ++j)
            matrica[i][j]=m(i+1,j+1);
    }
}

<a name="12"></a><font color="#0000FF"><a href="match750-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

template&lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(TipEl niz[4][4]) {
    br_redova=4; br_kolona=4;
    for(int i=0; i&lt;br_redova; ++i) {
</font>        for(int j=0; j&lt;br_kolona; ++j)
            matrica[i][j]=niz[i][j];
    }
}

template&lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(std::vector&lt;std::vector&lt;TipEl&gt;&gt; &amp;m) {
    if(m.size()&lt;0 || m.size()&gt;4) throw std::logic_error ("Ilegalan format matrice");
    for(int i=0; i&lt;m.size(); ++i) {
<a name="4"></a><font color="#FF00FF"><a href="match750-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        if(m[i].size()!=m[0].size() || m[i].size()&gt;4) throw std::logic_error ("Ilegalan format matrice");
    }
    br_redova=m.size(); br_kolona=m[0].size();
    for(int i=0; i&lt;m.size(); ++i) {
</font>        for(int j=0; j&lt;m[0].size(); ++j)
            matrica[i][j]=m[i][j]; 
    }
}

template&lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; lista) {
    if(lista.size()&lt;0 || lista.size()&gt;4) throw std::logic_error ("Ilegalan format matrice");
    auto it(lista.begin());
    br_redova=lista.size(); br_kolona=lista.begin()-&gt;size();
    for(int i=0; i&lt;lista.size(); ++i) {
        if(it-&gt;size()!=lista.begin()-&gt;size() || it-&gt;size()&gt;4) throw std::logic_error ("Ilegalan format matrice");
        it++;
    }
    
    for(int i=0; i&lt;lista.size(); i++) {
        auto it2=(lista.begin()+i)-&gt;begin();
        for(int j=0; j&lt;lista.begin()-&gt;size(); j++)  {
            matrica[i][j]=*it2;
            it2++;
    }
    }
    
}

//OPERATORI
template&lt;typename TipEl&gt;
TipEl &amp;GMatrica&lt;TipEl&gt;::operator () (int i, int j) {
<a name="7"></a><font color="#0000FF"><a href="match750-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        if(i&lt;1 || j&lt;1 || i&gt;4 || j&gt;4) throw std::range_error ("Nedozvoljen indeks");
    return matrica[i-1][j-1];
    }

template&lt;typename TipEl&gt;
</font>TipEl const GMatrica&lt;TipEl&gt;::operator () (int i, int j) const {
<a name="8"></a><font color="#00FFFF"><a href="match750-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        if(i&lt;1 || j&lt;1 || i&gt;4 || j&gt;4) throw std::range_error ("Nedozvoljen indeks");
    return matrica[i-1][j-1];
    }
    
template&lt;typename TipEl&gt;
</font>TipEl *GMatrica&lt;TipEl&gt;::operator[](int indeks) {
    return &amp;matrica[indeks][0];
}

template&lt;typename TipEl&gt;
TipEl const *GMatrica&lt;TipEl&gt;::operator[](int indeks) const {
    return &amp;matrica[indeks][0];
}
    
template&lt;typename TipEl2, typename TipEl&gt;
auto operator+(GMatrica&lt;TipEl&gt; m1, const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0]+0)&gt; {
    if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona) throw std::domain_error ("Nedozvoljena operacija");
    return m1+=m2;
}

template&lt;typename TipEl2, typename TipEl&gt;
auto operator-(GMatrica&lt;TipEl&gt; m1, const GMatrica&lt;TipEl2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]-m2.matrica[0][0]+0)&gt; {
    if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona) throw std::domain_error ("Nedozvoljena operacija");
    return m1-=m2;
}

template&lt;typename TipEl2, typename TipEl&gt;
auto operator*(GMatrica&lt;TipEl2&gt; m1, const GMatrica&lt;TipEl&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]*m2.matrica[0][0]+0)&gt; {
    if(m1.br_kolona!=m2.br_redova) throw std::domain_error ("Nedozvoljena operacija");
    return m1*=m2;
}

template&lt;typename TipEl2, typename TipEl&gt;
GMatrica&lt;TipEl&gt; operator*(TipEl2 broj, GMatrica&lt;TipEl&gt; m) {
     
     return m*=broj;
}

template&lt;typename TipEl2, typename TipEl&gt;
GMatrica&lt;TipEl2&gt; operator*(GMatrica&lt;TipEl2&gt; m, TipEl broj) {
<a name="5"></a><font color="#FF0000"><a href="match750-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    return m*=broj;
}

template&lt;typename TipEl&gt;
template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator+=(const GMatrica&lt;TipEl2&gt; &amp;m1){
</font>    if(this-&gt;br_redova!=m1.br_redova || this-&gt;br_kolona!=m1.br_kolona) throw std::domain_error ("Nedozvoljena operacija");
    for(int i=0; i&lt;this-&gt;br_redova; ++i) {
        for(int j=0; j&lt;m1.br_kolona; ++j)
<a name="3"></a><font color="#00FFFF"><a href="match750-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

            this-&gt;matrica[i][j]+=m1.matrica[i][j];
    }
    return *this;
}

template&lt;typename TipEl&gt;
template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator-=(const GMatrica&lt;TipEl2&gt; &amp;m1){
</font>    if(this-&gt;br_redova!=m1.br_redova || this-&gt;br_kolona!=m1.br_kolona) throw std::domain_error ("Nedozvoljena operacija");
    for(int i=0; i&lt;this-&gt;br_redova; ++i) {
        for(int j=0; j&lt;m1.br_kolona; ++j)
<a name="2"></a><font color="#0000FF"><a href="match750-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

            this-&gt;matrica[i][j]-=m1.matrica[i][j];
    }
    return *this;
}

template&lt;typename TipEl&gt;
template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator*=(const GMatrica&lt;TipEl2&gt; &amp;m1) {
</font>    if(this-&gt;br_kolona!=m1.br_redova) throw std::domain_error ("Nedozvoljena operacija");
    GMatrica&lt;TipEl&gt; nova(*this);
    for(int i=0; i&lt;this-&gt;br_redova; ++i) {
        for(int j=0; j&lt;m1.br_kolona; ++j) {
           double suma(0);
           for(int k=0; k&lt;m1.br_redova; ++k)
                suma+=nova.matrica[i][k]*m1.matrica[k][j];
            this-&gt;matrica[i][j]=suma;
        }
    }
    return *this;
}

<a name="9"></a><font color="#FF00FF"><a href="match750-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

template&lt;typename TipEl&gt;
template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator*=(TipEl2 broj) {
    for(int i=0; i&lt;this-&gt;br_redova; ++i) {
</font>         for(int j=0; j&lt;this-&gt;br_kolona; ++j)
            this-&gt;matrica[i][j]*=broj;
     }
     return *this;
}

template&lt;typename TipEl&gt;
bool operator==(const GMatrica&lt;TipEl&gt; &amp;m1, const GMatrica&lt;TipEl&gt; &amp;m2) {
    if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona) throw std::domain_error ("Nedozvoljena operacija");
    for(int i=0; i&lt;m1.br_redova; ++i) {
        for(int j=0; j&lt;m1.br_kolona; ++j) {
            if(m1.matrica[i][j]!=m2.matrica[i][j]) return false;
        }
    }
    return true;
}

template&lt;typename TipEl&gt;
<a name="10"></a><font color="#FF0000"><a href="match750-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

bool operator!=(const GMatrica&lt;TipEl&gt; &amp;m1, const GMatrica&lt;TipEl&gt; &amp;m2) {
    return !(m1==m2);
}

template&lt;typename TipEl&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;TipEl&gt; &amp;m) {
</font>    int sirina(tok.width());
    if(sirina&lt;6) sirina=6;
    for(int i=0; i&lt;m.br_redova; ++i) {
        for(int j=0; j&lt;m.br_kolona; ++j)
<a name="11"></a><font color="#00FF00"><a href="match750-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

            tok&lt;&lt;std::setw(sirina)&lt;&lt;m.matrica[i][j];
        tok&lt;&lt;std::endl;
    }
    return tok;
}

template&lt;typename TipEl&gt;
std::istream&amp; operator&gt;&gt;(std::istream &amp;tok, GMatrica&lt;TipEl&gt; &amp;m) {
</font>    char znak;
    std::vector&lt;std::vector&lt;TipEl&gt;&gt; pom(4, std::vector&lt;TipEl&gt; (4));
    tok&gt;&gt;std::ws;
    tok&gt;&gt;znak;
    int i(0), j(0);
    if(znak=='[') {
        for(;;) {
            if(i&gt;4 || j&gt;=4) { tok.setstate(std::ios::failbit); break; }
            tok&gt;&gt;m.matrica[i][j]&gt;&gt;znak;
            j++;
            if(znak==']') {  break; }
            if(znak==';') { i++; j=0; continue; }
            if(znak!=',') { tok.setstate(std::ios::failbit); break; }
            
        }
    }
    
    else tok.setstate(std::ios::failbit);
    if(tok)
        m.br_redova=i+1; m.br_kolona=j;
    return tok;
}



int main () {
GMatrica&lt;int&gt; m1({{2,2},{4,5}}) ;
GMatrica&lt;int&gt; m2({{1,1},{4,6}})   ;
m1=m1*m2;
std::cout&lt;&lt;m1;
	return 0;
}</pre>
</body>
</html>
