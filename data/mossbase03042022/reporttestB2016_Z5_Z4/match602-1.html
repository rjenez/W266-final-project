<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1976.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8580.cpp<p></p><pre>
<a name="4"></a><font color="#FF00FF"><a href="match602-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;iomanip&gt;


template &lt;typename Tip&gt;
class GMatrica {
    Tip matrica[4][4];
    int redovi, kolone;
public:
    GMatrica();
    GMatrica(int r, int k, Tip vrijednost = 0);
    template&lt;typename T&gt;
    GMatrica(const GMatrica&lt;T&gt; &amp;m);
</font>    template&lt;typename T&gt;
<a name="6"></a><font color="#00FF00"><a href="match602-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    GMatrica(T m[4][4]);
    GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; v);
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; lista);
    int DajBrojRedova() const { return redovi; }
</font>    int DajBrojKolona() const { return kolone; }
    template&lt;typename T1, typename T2&gt;
    friend auto operator+(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] + m2.matrica[0][0])&gt;;
    template&lt;typename T1, typename T2&gt;
    friend auto operator-(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] - m2.matrica[0][0])&gt;;
    
    template&lt;typename T1, typename T2&gt;
    friend auto operator*(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] * m2.matrica[0][0])&gt;;
    
    template&lt;typename T1&gt;
    friend auto operator*(const GMatrica&lt;T1&gt; &amp;m1, double broj) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] * broj)&gt;;
    
    template&lt;typename T2&gt;
    friend auto operator*(double broj, const GMatrica&lt;T2&gt; &amp;m1) -&gt; GMatrica&lt;decltype(broj*m1.matrica[0][0])&gt;;
    
    template&lt;typename T&gt;
    GMatrica&lt;Tip&gt; &amp;operator+=(const GMatrica&lt;T&gt; &amp;m2);
    template&lt;typename T&gt;
    GMatrica&lt;Tip&gt; &amp;operator-=(const GMatrica&lt;T&gt; &amp;m2);
    template&lt;typename T&gt;
    GMatrica&lt;Tip&gt; &amp;operator*=(const GMatrica&lt;T&gt; &amp;m2);
    template&lt;typename T&gt;
    GMatrica&lt;Tip&gt; &amp;operator*=(T broj);
    template&lt;typename T1, typename T2&gt;
    friend bool operator==(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2);
    template&lt;typename T1, typename T2&gt;
    friend inline bool operator!=(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2);
    Tip* operator[](int i);
    const Tip* operator[](int i) const;
    Tip &amp;operator()(int i, int j);
    Tip operator()(int i, int j) const;
    template&lt;typename T&gt;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;T&gt; &amp;m);
    template&lt;typename T&gt;
<a name="11"></a><font color="#00FF00"><a href="match602-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;tok, GMatrica&lt;T&gt; &amp;m);
};

template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica() : redovi(0), kolone(0) {}
</font><a name="2"></a><font color="#0000FF"><a href="match602-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int r, int k, Tip vrijednost) {
    if(r &lt; 0 || r &gt; 4 || k &lt; 0 || k &gt; 4) throw std::logic_error("Ilegalan format matrice");
    redovi = r;
    kolone = k;
    for(int i = 0; i &lt; r; i++) {
        for(int j = 0; j &lt; k; j++)
</font>            matrica[i][j] = vrijednost;
    }
}

template&lt;typename Tip&gt;
template &lt;typename T&gt;
GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;T&gt; &amp;m) {
    redovi = m.DajBrojRedova();
    kolone = m.DajBrojKolona();
    for(int i = 0; i &lt; redovi; i++) {
        for(int j = 0; j &lt; kolone; j++) {
            matrica[i][j] = m[i][j];
        }
    }
}

template &lt;typename Tip&gt;
template &lt;typename T&gt;
GMatrica&lt;Tip&gt;::GMatrica(T m[4][4]) {
    redovi = 4;
<a name="12"></a><font color="#0000FF"><a href="match602-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    kolone = 4;
    for(int i = 0; i &lt; 4; i++) {
        for(int j = 0; j &lt; 4; j++)
            matrica[i][j] = m[i][j];
</font>    }
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; v) {
    if(v.size() &gt; 4) throw std::logic_error("Ilegalan format matrice");
    for(int i = 0; i &lt; v.size(); i++) {
        for(int j = 0; j &lt; v.size(); j++) {
            if(i == j) continue;
            if(v[i].size() != v[j].size() || v[i].size() &gt; 4) throw std::logic_error("Ilegalan format zadavanja matrice");
        }
    }
    
    redovi = v.size();
    kolone = v[0].size();
    for(int i = 0; i &lt; v.size(); i++) {
        for(int j = 0; j &lt; v[i].size(); j++)
            matrica[i][j] = v[i][j];
    }
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; lista) {
    if(lista.size() &gt; 4) throw std::logic_error("Ilegalan format matrice");
    for(auto i = lista.begin(); i != lista.end(); i++) {
        if(std::distance(i -&gt; begin(), i -&gt; end()) &gt; 4) throw std::logic_error("Ilegalan format matrice");
    }
    
    redovi = lista.size();
    auto it = lista.begin();
    kolone = std::distance(it -&gt; begin(), it -&gt; end());
    int i = 0, j = 0;
    while(it != lista.end()) {
        auto k = it -&gt; begin();
        while(k != it -&gt; end()) {
            matrica[i][j] = *k;
            k++;
            j++;
        }
        i++;
        j = 0;
        it++;
    }
}

template&lt;typename T1, typename T2&gt;
auto operator+(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] + m2.matrica[0][0])&gt; {
    if(m1.DajBrojKolona() != m2.DajBrojKolona() || m1.DajBrojRedova() != m2.DajBrojRedova())
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1.matrica[0][0] + m2.matrica[0][0])&gt; nova(m1.DajBrojRedova(),m2.DajBrojKolona(),0);
    for(int i = 0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j = 0; j &lt; m1.DajBrojKolona(); j++) 
            nova.matrica[i][j] = m1.matrica[i][j] + m2.matrica[i][j];
    }
    return nova;
}

template&lt;typename T1, typename T2&gt;
auto operator-(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] - m2.matrica[0][0])&gt; {
    if(m1.DajBrojKolona() != m2.DajBrojKolona() || m1.DajBrojRedova() != m2.DajBrojRedova())
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1.matrica[0][0] - m2.matrica[0][0])&gt; nova(m1.DajBrojRedova(), m1.DajBrojKolona(), 0);
    for(int i = 0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j = 0; j &lt; m1.DajBrojKolona(); j++) 
            nova.matrica[i][j] = m1.matrica[i][j] - m2.matrica[i][j];
    }
    return nova;
}

template&lt;typename T1, typename T2&gt;
auto operator*(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] * m2.matrica[0][0])&gt; {
    if(m1.DajBrojKolona() != m2.DajBrojRedova())
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1.matrica[0][0] * m2.matrica[0][0])&gt; nova(m1.DajBrojRedova(), m2.DajBrojKolona(), 0);
    decltype(m1.matrica[0][0] * m2.matrica[0][0]) p = 0, q = 0;
    for(int i = 0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j = 0; j &lt; m2.DajBrojKolona(); j++) {
            for(int k = 0; k &lt; m1.DajBrojKolona(); k++) {
                p = m1.matrica[i][k];
                q = m2.matrica[k][j];
                nova.matrica[i][j] += p*q;
            }
        }
    }
    return nova;
}

template&lt;typename T1&gt;
auto operator*(const GMatrica&lt;T1&gt; &amp;m1, double broj) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] * broj)&gt; {
    GMatrica&lt;decltype(m1.matrica[0][0] * broj)&gt; nova(m1.DajBrojRedova(), m1.DajBrojKolona(), 0);
    for(int i = 0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j = 0; j &lt; m1.DajBrojKolona(); j++)
            nova.matrica[i][j] = m1.matrica[i][j] * broj;
    }
    return nova;
}

template&lt;typename T2&gt;
auto operator*(double broj, const GMatrica&lt;T2&gt; &amp;m1) -&gt; GMatrica&lt;decltype(broj * m1.matrica[0][0])&gt; {
    GMatrica&lt;decltype(m1.matrica[0][0] * broj)&gt; nova(m1.DajBrojRedova(), m1.DajBrojKolona(), 0);
    for(int i = 0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j = 0; j &lt; m1.DajBrojKolona(); j++)
<a name="13"></a><font color="#00FFFF"><a href="match602-0.html#13" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

            nova.matrica[i][j] = m1.matrica[i][j] * broj;
    }
    return nova;
}

template&lt;typename Tip&gt;
template&lt;typename T&gt;
</font><a name="0"></a><font color="#FF0000"><a href="match602-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator+=(const GMatrica&lt;T&gt; &amp;m2) {
    if(redovi != m2.redovi || kolone != m2.kolone) throw std::domain_error("Nedozvoljena operacija");
    for(int i = 0; i &lt; redovi; i++) {
        for(int j = 0; j &lt; kolone; j++) 
            matrica[i][j] += m2.matrica[i][j];
    }
    return *this;
</font>}

template&lt;typename Tip&gt;
<a name="1"></a><font color="#00FF00"><a href="match602-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

template&lt;typename T&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator-=(const GMatrica&lt;T&gt; &amp;m2) {
    if(redovi != m2.redovi || kolone != m2.kolone) throw std::domain_error("Nedozvoljena operacija");
    for(int i = 0; i &lt; redovi; i++) {
        for(int j = 0; j &lt; kolone; j++)
            matrica[i][j] -= m2.matrica[i][j];
    }
    return *this;
</font>}

template&lt;typename Tip&gt;
template&lt;typename T&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator*=(const GMatrica&lt;T&gt; &amp;m2) {
    if(kolone != m2.redovi) throw std::domain_error("Nedozvoljena operacija");
    Tip p = 0, q = 0;
    GMatrica&lt;Tip&gt; nova(*this);
    for(int i = 0; i &lt; redovi; i++)
        for(int j = 0; j &lt; kolone; j++) matrica[i][j] = 0;
    for(int i = 0; i &lt; redovi; i++) {
        for(int j = 0; j &lt; m2.kolone; j++) {
            for(int k = 0; k &lt; kolone; k++) {
                p = nova.matrica[i][k];
                q = m2.matrica[k][j];
                matrica[i][j] += p*q;
            }
        }
    }
    return *this;
}

template&lt;typename Tip&gt;
<a name="5"></a><font color="#FF0000"><a href="match602-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

template&lt;typename T&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator*=(T broj) {
    for(int i = 0; i &lt; redovi; i++) {
        for(int j = 0; j &lt; kolone; j++)
            matrica[i][j] *= broj;
</font>    }
    return *this;
}

template&lt;typename T1, typename T2&gt;
bool operator==(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) {
    if(m1.DajBrojKolona() != m2.DajBrojKolona() || m1.DajBrojRedova() != m2.DajBrojRedova()) return false;
    for(int i = 0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j = 0; j &lt; m1.DajBrojKolona(); j++) {
            if(m1.matrica[i][j] != m2.matrica[i][j]) return false;
        }
    }
    return true;
}
template&lt;typename T1, typename T2&gt;
<a name="8"></a><font color="#00FFFF"><a href="match602-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

bool operator!=(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) {
    return !(m1 == m2);
}

template&lt;typename Tip&gt;
Tip* GMatrica&lt;Tip&gt;::operator[](int i) {
</font>    return matrica[i];
}

template&lt;typename Tip&gt;
const Tip * GMatrica&lt;Tip&gt;::operator[](int i) const{
    return matrica[i];
}

template&lt;typename Tip&gt;
Tip &amp;GMatrica&lt;Tip&gt;::operator()(int i, int j) {
<a name="10"></a><font color="#FF0000"><a href="match602-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    if(i &gt; redovi || j &gt; kolone || i &lt;= 0 || j &lt;= 0) throw std::range_error("Nedozvoljen indeks");
    return matrica[i-1][j-1];
}

template&lt;typename Tip&gt;
Tip GMatrica&lt;Tip&gt;::operator()(int i, int j) const {
</font>    if(i &gt; redovi || j &gt; kolone || i &lt;= 0 || j &lt;= 0) throw std::range_error("Nedozvoljen indeks");
    return matrica[i-1][j-1];
}

template&lt;typename T&gt;
<a name="3"></a><font color="#00FFFF"><a href="match602-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;T&gt; &amp;m) {
    int sirina = tok.width();
    if(sirina &lt; 6) sirina = 6;
    for(int i = 0; i &lt; m.DajBrojRedova(); i++) {
        for(int j = 0; j &lt; m.DajBrojKolona(); j++) {
</font><a name="9"></a><font color="#FF00FF"><a href="match602-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

            tok &lt;&lt; std::setw(sirina) &lt;&lt; m[i][j];
        }
        tok &lt;&lt; std::endl;
    }
    return tok;
}

template&lt;typename T&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;tok, GMatrica&lt;T&gt; &amp;m) {
</font>    std::vector&lt;std::vector&lt;T&gt;&gt; nova;
    char znak;
   // int c;
    //T broj;
    bool minus = false;
    tok &gt;&gt; znak;
    if(znak != '[') tok.setstate(std::ios::failbit);
   // int prethodni;
    for(int i = 0; i &lt; 4; i++) {
        std::vector&lt;T&gt; pomocni;
        for(int j = 0; j &lt; 4; j++)  { 
            T broj;
            int c = tok.peek(); 
            if(c == '-') { minus = true; tok &gt;&gt; znak; }
            else if(!std::isdigit(c)) tok.setstate(std::ios::failbit);
            tok &gt;&gt; broj;
            if(minus) { broj *= -1; minus = false; }
            pomocni.push_back(broj);
            tok &gt;&gt; znak;
            /*
            if( (znak == ';' &amp;&amp; j &lt; m.kolone-1) || 
                (znak == ',' &amp;&amp; j == m.kolone-1) ||
                (znak != ']' &amp;&amp; i == m.redovi - 1 &amp;&amp; j == m.kolone-1)) tok.setstate(std::ios::failbit);*/
            if(znak == ';' || znak == ']') break;
            if(znak != ',') tok.setstate(std::ios::failbit);
        }
        nova.push_back(pomocni);
        if(znak == ']') break;
    }
    for(int i = 0; i &lt; nova.size(); i++) {
        for(int j = 0; j &lt; nova.size(); j++) {
            if(i == j) continue;
            if(nova[i].size() != nova[j].size()) {
                tok.setstate(std::ios::failbit);
                return tok;
            }
        }
    }
    if(m.redovi != 0 &amp;&amp; m.redovi != nova.size()) tok.setstate(std::ios::failbit);
    if(m.kolone != 0 &amp;&amp; m.kolone != nova[0].size()) tok.setstate(std::ios::failbit);
    else {
        m.redovi = nova.size();
        m.kolone = nova[0].size();
<a name="7"></a><font color="#0000FF"><a href="match602-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

        for(int i = 0; i &lt; nova.size(); i++) {
            for(int j = 0; j &lt; nova[i].size(); j++) {
                m.matrica[i][j] = nova[i][j];
</font>            }
        }
    }
   /* int r = 0, k = 0;
    int prethodni = k;
    while(1) {
        c = tok.peek();
        if(c == '-') { minus = true; tok &gt;&gt; znak; }
        if(!std::isdigit(c)) tok.setstate(std::ios::failbit);
        tok &gt;&gt; broj;
        if(minus) { broj *= -1; minus = false; }
        m.matrica[r][k] = broj;
        k++;
        c = tok.peek();
        if(c )
        if(c != ',')
    }*/
    return tok;
} 

int main ()
{
    GMatrica&lt;int&gt; m1({{1,2}, {3,4}});
    std::cout &lt;&lt; m1(1,1) &lt;&lt; std::endl;
    std::cout &lt;&lt; m1[1][1] &lt;&lt; std::endl;
    
    //GMatrica&lt;int&gt; a({{1,2}, {3,4}});
   // GMatrica&lt;int&gt; b(3,3,1);
    /*GMatrica&lt;int&gt; c({{1,2}, {3,5}});*/
    //std::cout  &lt;&lt; "sta.. " &lt;&lt; std::endl;
 //   GMatrica&lt;int&gt; a({{1,2}, {3,4}});
   // std::cout &lt;&lt; "Unesi: ";
    //std::cin &gt;&gt; a;
  //  std::cout &lt;&lt; a.DajBrojRedova() &lt;&lt; ", " &lt;&lt; a.DajBrojKolona();
    //GMatrica&lt;double&gt; c;
   // a += b;
 //   GMatrica&lt;int&gt; nova = a*2;
    //nova = a*2;
   // std::cout &lt;&lt; a;
  //  std::cout &lt;&lt; nova;
    //auto nova(a+b);
    /*
    if(a == b &amp;&amp; a != c &amp;&amp; !(a != b) &amp;&amp; !(a != b)) std::cout &lt;&lt; "ok";
    else std::cout &lt;&lt; "nije ok";
    *//*
    for(int i = 0; i &lt; 3; i++) {
        for(int j = 0; j &lt; 3; j++)
            std::cout &lt;&lt; a[i][j] &lt;&lt; " ";
        std::cout &lt;&lt; std::endl;
    }*/
	return 0;
}</pre>
</body>
</html>
