<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5562.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5562.cpp<p></p><pre>
<a name="2"></a><font color="#0000FF"><a href="match50-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_19.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;iomanip&gt;

template &lt;typename Tip&gt;
    class GMatrica
    {
        Tip elementi[4][4];
        int br_redova, br_kolona;
    public:
        GMatrica():br_redova(0), br_kolona(0){}
        GMatrica(int br_redova, int br_kolona, Tip vrijednost = Tip());
        template &lt;typename Tip2&gt;
            GMatrica(const GMatrica&lt;Tip2&gt; &amp;m);
        template &lt;typename Tip2&gt;
            GMatrica(Tip2** elementi);
        GMatrica(const std::vector&lt;std::vector&lt;Tip&gt;&gt; &amp;m);
        GMatrica(const std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; &amp;lista);
        int DajBrojRedova()const{ return br_redova;}
        int DajBrojKolona()const{ return br_kolona;}
        template &lt;typename Tip1, typename Tip2&gt;
            friend GMatrica&lt;decltype(Tip1() + Tip2())&gt; operator+(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
        template &lt;typename Tip1, typename Tip2&gt;
            friend GMatrica&lt;decltype (Tip1() - Tip2())&gt; operator-(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
        template &lt;typename Tip1, typename Tip2&gt;
            friend GMatrica&lt;decltype (Tip1() * Tip2())&gt; operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
        template &lt;typename Tip1&gt;
            friend GMatrica&lt;Tip1&gt; operator *(const GMatrica&lt;Tip1&gt; &amp;m, double x);
        template &lt;typename Tip1&gt;
            inline friend GMatrica&lt;Tip1&gt; operator*(double x, const GMatrica&lt;Tip1&gt; &amp;m){return m*x;}
        template &lt;typename Tip1&gt;
            GMatrica&lt;decltype(Tip() + Tip1())&gt;&amp; operator +=(const GMatrica&lt;Tip1&gt; &amp;m);
        GMatrica&amp; operator += (double x);
        template &lt;typename Tip1&gt;
            GMatrica&lt;decltype(Tip() - Tip1())&gt;&amp; operator -=(const GMatrica&lt;Tip1&gt; &amp;m);
        GMatrica&amp; operator -= (double x);
        template &lt;typename Tip1&gt;
            GMatrica&amp; operator*=(const GMatrica&lt;Tip1&gt; &amp;m); 
        GMatrica &amp;operator *=(double x);
        template &lt;typename Tip1&gt;
            friend bool operator == (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip1&gt; &amp;m2);
        template &lt;typename Tip1&gt;
            inline friend bool operator != (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip1&gt; &amp;m2){ return !(m1 == m2);}
        Tip&amp; operator()(int i, int j);
        Tip operator()(int i, int j)const;
        Tip* operator[](int i){ return elementi[i];}
        Tip* operator[](int i)const{return elementi[i];}
        template&lt;typename Tip1&gt;
            friend std::ostream &amp;operator &lt;&lt; (std::ostream &amp;tok, const GMatrica&lt;Tip1&gt; &amp;m);
</font>        template&lt;typename Tip1&gt;
<a name="1"></a><font color="#00FF00"><a href="match50-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_22.gif"/></a>

            friend std::istream &amp;operator &gt;&gt; (std::istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;m);
    };

template &lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;::GMatrica(int br_redova, int br_kolona, Tip vrijednost)
    {
        if (br_redova &lt; 0 || br_redova &gt; 4 || br_kolona &lt; 0 || br_kolona &gt; 4)
            throw std::logic_error("Ilegalan format matrice");
        GMatrica::br_redova = br_redova; GMatrica::br_kolona = br_kolona;
        for (int i = 0; i &lt; br_redova; i++)
            for (int j = 0; j&lt; br_kolona; j++)
                elementi[i][j] = vrijednost;
    }
template&lt;typename Tip&gt;
    template &lt;typename Tip2&gt;
        GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;Tip2&gt; &amp;m)
        {
            for (int i = 0; i &lt; m.br_redova; i++)
                std::copy(m.elementi[i], m.elementi[i] + m.br_kolona, elementi[i]);
            br_redova = m.br_redova; br_kolona = m.br_kolona;
        }
template &lt;typename Tip&gt;
    template &lt;typename Tip2&gt;
        GMatrica&lt;Tip&gt;::GMatrica(Tip2** elementi)
        {
            for (int i = 0; i &lt; 4; i++)
                std::copy(elementi[i], elementi[i] + 4, GMatrica::elementi);
            br_kolona = br_redova = 4;
        }
template &lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;::GMatrica(const std::vector&lt;std::vector&lt;Tip&gt;&gt; &amp;m)
    {
        if (m.size() &gt; 4)
            throw std::logic_error("Ilegalan format matrice");
        for (int i = 0; i &lt; m.size(); i++)
            if (m[i].size() &gt; 4 || m[i].size() != m[0].size())
                throw std::logic_error("Ilegalan format matrice");
        for (int i = 0; i &lt; m.size(); i++)
            std::copy(m[i].begin(), m[i].end(), elementi[i]);
        br_redova = m.size();
        br_kolona = m[0].size();
    }
template &lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;::GMatrica(const std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; &amp;lista)
    {
        if (lista.size() &gt; 4)
            throw std::logic_error("Ilegalan format matrice");
        for (auto lista2:lista)
            if (lista2.size() &gt; 4 || lista2.size() != lista.begin()-&gt;size())
                throw std::logic_error("Ilegalan format matrice");
        int i(0);
        for (auto l:lista)
            std::copy(l.begin(),  l.end(), elementi[i++]);
        br_redova = lista.size();
        br_kolona = lista.begin()-&gt;size();
    }
template &lt;typename Tip1, typename Tip2&gt;
    GMatrica&lt;decltype (Tip1() + Tip2())&gt; operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
    {
        if (m1.br_kolona != m1.br_kolona || m1.br_redova != m2.br_redova)
            throw std::domain_error("Nedozvoljena operacija");
        typedef decltype (Tip1() + Tip2()) Tip3;
        GMatrica&lt;Tip3&gt; zbir(m1.br_redova, m1.br_kolona);
        for (int i = 0; i &lt; m1.br_redova; i++)
</font>            for (int j = 0; j &lt; m1.br_kolona; j++)
<a name="4"></a><font color="#FF00FF"><a href="match50-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

                zbir.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
        return zbir;
    }
template &lt;typename Tip1, typename Tip2&gt;
    GMatrica&lt;decltype (Tip1() - Tip2())&gt; operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
    {
        if (m1.br_kolona != m1.br_kolona || m1.br_redova != m2.br_redova)
            throw std::domain_error("Nedozvoljena operacija");
        typedef decltype (Tip1() - Tip2()) Tip3;
        GMatrica&lt;Tip3&gt; razlika(m1.br_redova, m1.br_kolona);
        for (int i = 0; i &lt; m1.br_redova; i++)
            for (int j = 0; j &lt; m1.br_kolona; j++)
</font><a name="3"></a><font color="#00FFFF"><a href="match50-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

                razlika.elementi[i][j] = m1.elementi[i][j] - m2.elementi[i][j];
        return razlika;
    }
template &lt;typename Tip1, typename Tip2&gt;
    GMatrica&lt;decltype (Tip1() * Tip2())&gt; operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
    {
        if (m1.br_kolona != m2.br_redova)
            throw std::domain_error("Nedozvoljena operacija");
        typedef decltype (Tip1() * Tip2()) Tip3;
        GMatrica&lt;Tip3&gt; produkt(m1.br_redova, m2.br_kolona);
        for (int i = 0; i &lt; m1.br_redova; i++)
            for (int j = 0; j &lt; m2.br_kolona; j++)
                for (int k = 0; k &lt; m2.br_redova; i++)
</font><a name="5"></a><font color="#FF0000"><a href="match50-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

                    produkt.elementi[i][j] += m1.elementi[i][k]*m2.elementi[k][j];
        return produkt;
        
    }
template &lt;typename Tip1&gt;
    GMatrica&lt;Tip1&gt; operator *(const GMatrica&lt;Tip1&gt; &amp;m, double x)
    {
        GMatrica&lt;Tip1&gt; produkt(m.br_redova, m.br_kolona);
        for (int i = 0; i &lt; m.br_redova; i++)
</font>            for (int j = 0; j &lt; m.br_kolona; j++)
<a name="0"></a><font color="#FF0000"><a href="match50-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_40.gif"/></a>

                produkt.elementi[i][j] = m.elementi[i][j]*x;
        return produkt;
    }
template &lt;typename Tip&gt;
    template &lt;typename Tip1&gt;
        GMatrica&lt;decltype(Tip() + Tip1())&gt;&amp; GMatrica&lt;Tip&gt;::operator +=(const GMatrica&lt;Tip1&gt; &amp;m)
        {
            if (br_kolona != m.br_kolona || br_redova != m.br_redova)
                throw std::domain_error("Nedozvoljena operacija");
            for (int i = 0; i &lt; br_redova; i++)
                for (int j = 0; j &lt; br_kolona; j++)
                    elementi[i][j] += m.elementi[i][j];
            return *this;
        }
template&lt;typename Tip&gt;
    template &lt;typename Tip1&gt;
        GMatrica&lt;decltype(Tip() - Tip1())&gt;&amp; GMatrica&lt;Tip&gt;::operator -=(const GMatrica&lt;Tip1&gt; &amp;m)
        {
            if (br_kolona != m.br_kolona || br_redova != m.br_redova)
                throw std::domain_error("Nedozvoljena operacija");
            for (int i = 0; i &lt; br_redova; i++)
                for (int j = 0; j&lt; br_kolona; j++)
                    elementi[i][j] -= m.elementi[i][j];
            return *this;
        }
template&lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;&amp; GMatrica&lt;Tip&gt;::operator +=(double x) 
    {
        for (int i = 0; i &lt; br_redova; i++)
            for (int j = 0; j &lt; br_kolona; j++)
                elementi[i][j] += x;
        return *this;
    }
template&lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;&amp; GMatrica&lt;Tip&gt;::operator -=(double x)
    {
        for (int i = 0; i &lt; br_redova; i++)
            for (int j = 0; j&lt; br_kolona; j++)
                elementi[i][j] -= x;
        return *this;
    }
template&lt;typename Tip&gt;
    template &lt;typename Tip1&gt;
        GMatrica&lt;Tip&gt;&amp; GMatrica&lt;Tip&gt;::operator*=(const GMatrica&lt;Tip1&gt; &amp;m)
        {
            if (br_kolona != m.br_redova)
                throw std::domain_error("Nedozvoljena operacija");
            typedef decltype(Tip() * Tip1()) Tip3;
            GMatrica&lt;Tip3&gt; produkt(br_redova, m.br_kolona);
            for (int i = 0; i &lt; br_redova; i++)
                for (int j = 0; j &lt; m.br_kolona; j++)
                    for (int k = 0; k &lt; m.br_redova; k++)
                        produkt.elementi[i][j] += elementi[i][k]*m.elementi[k][j];
        *this = produkt;
        return *this;
        }
template&lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;&amp; GMatrica&lt;Tip&gt;::operator*=(double x)
    {
        for (int i = 0; i &lt; br_redova; i++)
            for (int j = 0; j &lt; br_redova; j++)
                elementi[i][j] *= x;
        return *this;
    }
template&lt;typename Tip&gt;
    bool operator == (const GMatrica&lt;Tip&gt; &amp;m1, const GMatrica&lt;Tip&gt; &amp;m2)
    {
        if (m1.br_kolona != m2.br_kolona || m1.br_redova != m2.br_redova)
            return false;
        for (int i = 0; i &lt; m1.br_redova; i++)
            if (!std::equal(m1.elementi[i], m1.elementi[i] + m1.br_kolona, m2.elementi[i]))
                return false;
        return true;
    }
template &lt;typename Tip&gt;
    Tip&amp; GMatrica&lt;Tip&gt;::operator()(int i, int j)
    {
        if (i &lt; 1 || i &gt; br_redova || j &lt; 1 || j &gt; br_kolona)
            throw std::range_error("Nedozvoljen indeks");
        return elementi[i - 1][j - 1];
    }
template &lt;typename Tip&gt;
    Tip GMatrica&lt;Tip&gt;::operator()(int i, int j)const
    {
        if (i &lt; 1 || i &gt; br_redova || j &lt; 1 || j &gt; br_kolona)
            throw std::range_error("Nedozvoljen indeks");
        return elementi[i - 1][j - 1];
    }
template &lt;typename Tip&gt;
    std::ostream &amp;operator &lt;&lt; (std::ostream &amp;tok, const GMatrica&lt;Tip&gt; &amp;m)
    {
        int sirina;
        if (tok.width() &lt; 6) sirina = 6;
        else sirina = tok.width();
        for (int i = 0; i &lt; m.br_redova; i++)
        {
            for (int j = 0; j &lt; m.br_kolona; j++)
                tok &lt;&lt; std::setw(sirina) &lt;&lt; m.elementi[i][j];
            tok &lt;&lt; std::endl;
        }
        return tok;
    }
template &lt;typename Tip&gt;
    std::istream &amp;operator &gt;&gt; (std::istream &amp;tok, GMatrica&lt;Tip&gt; &amp;m)
    {
        GMatrica&lt;Tip&gt; pomocna;
        bool greska(false);
        if (tok.peek() != '[') greska = true;
        else
        {
            tok.get();
            int i(0), j(0);
            for (;;)
            {
                char z(tok.peek());
                if (!(z &gt;= '0' &amp;&amp; z &lt;= '9')){greska = true; break;}
                tok &gt;&gt; pomocna.elementi[i][j++];
                if (tok.peek() == ';'){
                    if (i &gt; 0 &amp;&amp; j != pomocna.br_kolona){greska = true; break;}
                    pomocna.br_kolona = j; j = 0; i++;
                }
                else if (tok.peek() == ']'){
                    if (i &gt; 0 &amp;&amp; j != pomocna.br_kolona) 
                        greska = true; break;
                }
                else if (tok.peek() != ','){
                    greska = true; break; 
                }
                tok.get();
            }
        }
        pomocna.br_kolona = 2; pomocna.br_redova = 2;
        if (greska) tok.setstate(std::ios::failbit);
        else m = pomocna;
        return tok;
</font>    }
    
int main ()
{
    return 0;
}</pre>
</body>
</html>
