<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student7320.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student7320.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

template&lt;typename T&gt;
class GMatrica {
  T mat[4][4];
  int br_red, br_kol;
public:
  GMatrica();
  GMatrica(int red, int kol, T val);
  template&lt;typename T2&gt;
  GMatrica(GMatrica&lt;T2&gt; &amp;matrix) {
    for (int i = 0; i &lt; matrix.br_red; i++) for (int j = 0; j &lt; matrix.br_kol; j++) mat[i][j] = matrix.mat[i][j];
  }
  template&lt;typename T2&gt;
  GMatrica(std::vector&lt;std::vector&lt;T2&gt; &gt; vect) {
    if (vect.size() &gt; 4) throw std::logic_error("Ilegalan format matrice");
    for (int i = 0; i &lt; vect.size(); i++) 
      if (vect[i].size() != vect[0].size()) throw std::logic_error("Ilegalan format matrice");
    for (int i = 0; i &lt; vect.size(); i++)
<a name="7"></a><font color="#0000FF"><a href="match753-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

      for (int j = 0; j &lt; vect.at(0).size(); j++)
        mat[i][j] = vect[i][j];
  }
  GMatrica(std::initializer_list&lt;std::initializer_list&lt;T&gt; &gt; lista) {
</font>    br_red = lista.size();
    int i = 0, j = 0;
    for (auto x = lista.begin(); x != lista.end(); x++) {
      br_kol = x -&gt; size();
      for (auto y = x-&gt;begin(); y != x-&gt;end(); y++)
        mat[i][j++] = *y;
      j = 0;
      i++;
    }
  }
  int DajBrojRedova() { return br_red; }
<a name="3"></a><font color="#00FFFF"><a href="match753-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

  int DajBrojKolona() { return br_kol; }
  template&lt;typename T2&gt;
  friend GMatrica&lt;T2&gt; operator + (const GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2);
  template&lt;typename T2&gt;
  friend GMatrica&lt;T2&gt; operator - (const GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2);
  template&lt;typename T2&gt;
</font>  friend GMatrica&lt;T2&gt; operator * (const GMatrica&lt;T2&gt; &amp;g1, const T2 &amp;val);
  template&lt;typename T2&gt;
  friend GMatrica&lt;T2&gt; operator * (const T2 &amp;val, const GMatrica&lt;T2&gt; &amp;g1);
  template&lt;typename T2&gt;
  friend GMatrica&lt;T2&gt; operator += (GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2);
  template&lt;typename T2&gt;
  friend GMatrica&lt;T2&gt; operator -= (GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2);
  template&lt;typename T2&gt;
  friend GMatrica&lt;T2&gt; operator *= (GMatrica&lt;T2&gt; &amp;g1, const T2 &amp;val);
<a name="6"></a><font color="#00FF00"><a href="match753-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

  template&lt;typename T2&gt;
  friend bool operator == (const GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2);
  template&lt;typename T2&gt;
  friend bool operator != (const GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2);
  template &lt;typename T2&gt;
</font>  friend std::ostream &amp;operator &lt;&lt; (std::ostream &amp;tok, const GMatrica&lt;T2&gt; &amp;x);
  template &lt;typename T2&gt;
  friend std::istream &amp;operator &gt;&gt; (std::istream &amp;tok, GMatrica&lt;T2&gt; &amp;x);
  
  class Red {
		friend class GMatrica;
		public: 
			T &amp;operator[](int col) const {
				return parent.mat[red][col];
			}
		private:
			Red(GMatrica &amp;parent_, int red_) : parent(parent_), red(red_) {}
			GMatrica &amp;parent;
			int red;
	};
  Red operator[](int red) { return Red(*this, red); }
	T &amp;operator ()(int jedan, int dva) { return mat[jedan - 1][dva - 1]; }
	T operator ()(int jedan, int dva) const { return mat[jedan - 1][dva - 1]; }
};
template&lt;typename T&gt;
GMatrica&lt;T&gt;::GMatrica() { br_red = br_kol = 0; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) mat[i][j] = 0; }
template&lt;typename T&gt;
GMatrica&lt;T&gt;::GMatrica(int red, int kol, T val) {
  if (red &gt; 4 || kol &gt; 4 || red &lt; 0 || kol &lt; 0) throw std::logic_error("Ilegalan format matrice");
  br_red = red; br_kol = kol;
  for (int i = 0; i &lt; br_red; i++) for (int j = 0; j &lt; br_kol; j++) mat[i][j] = val;
}
/*template&lt;typename T2&gt;
GMatrica&lt;T2&gt;::GMatrica(GMatrica&lt;T2&gt; &amp;matrix) {
  for (int i = 0; i &lt; matrix.br_red; i++) for (int j = 0; j &lt; matrix.br_kol; j++) mat[i][j] = matrix.mat[i][j];
}*/

<a name="5"></a><font color="#FF0000"><a href="match753-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

template&lt;typename T2&gt;
GMatrica&lt;T2&gt; operator + (const GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2) {
  if (g1.br_red != g2.br_red || g1.br_kol != g2.br_kol) throw std::domain_error("Nedozvoljena operacija");
  GMatrica&lt;T2&gt; ret (g1.br_red, g1.br_kol, 0);
</font>  for (int i = 0; i &lt; ret.br_red; i++)
    for (int j = 0; j &lt; ret.br_kol; j++)
      ret.mat[i][j] = g1.mat[i][j] + g2.mat[i][j];
  return ret;
}
<a name="4"></a><font color="#FF00FF"><a href="match753-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

template&lt;typename T2&gt;
GMatrica&lt;T2&gt; operator - (const GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2) {
  if (g1.br_red != g2.br_red || g1.br_kol != g2.br_kol) throw std::domain_error("Nedozvoljena operacija");
  GMatrica&lt;T2&gt; ret (g1.br_red, g1.br_kol, 0);
</font>  for (int i = 0; i &lt; ret.br_red; i++)
    for (int j = 0; j &lt; ret.br_kol; j++)
<a name="8"></a><font color="#00FFFF"><a href="match753-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

      ret.mat[i][j] = g1.mat[i][j] - g2.mat[i][j];
  return ret;
}
template &lt;typename T2&gt;
std::ostream &amp;operator &lt;&lt; (std::ostream &amp;tok, const GMatrica&lt;T2&gt; &amp;x) {
</font><a name="2"></a><font color="#0000FF"><a href="match753-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

	int e = tok.width();
	if (e &lt; 6) e = 6;
	for(int i = 0; i &lt; x.br_red; i++) {
		for(int j = 0; j &lt; x.br_kol; j++) {
			tok &lt;&lt; std::setw(e) &lt;&lt; x.mat[i][j];
		}
		tok &lt;&lt; std::endl;
	}
	return tok;
}
template &lt;typename T2&gt;
</font>std::istream &amp;operator &gt;&gt; (std::istream &amp;tok, GMatrica&lt;T2&gt; &amp;x) {
  char c = 'a';
  int brojacRedova = 0, brojacKolona = 0;
  std::vector&lt;int&gt; glbrkol;
  tok &gt;&gt; c;
  while (1) {
    if (c == ']') break;
    //c = tok.peek();
    if (c == ';') {
      brojacRedova++;
      glbrkol.push_back(brojacKolona);
      brojacKolona = 0;
    }
    {
      tok &gt;&gt; x.mat[brojacRedova][brojacKolona];
      //std::cout &lt;&lt; "Element (" &lt;&lt; brojacRedova + 1 &lt;&lt; "," &lt;&lt; brojacKolona + 1 &lt;&lt; ") = " &lt;&lt; x.mat[brojacRedova][brojacKolona] &lt;&lt; "\n";
      brojacKolona++;
    }
    tok &gt;&gt; c;
  }
  for (int i = 0; i &lt; glbrkol.size(); i++)
    if (glbrkol[i] != glbrkol[0]) tok.setstate(std::ios::failbit);
  brojacKolona = glbrkol[0];
  x.br_kol = brojacKolona;
  x.br_red = brojacRedova + 1;
  return tok; 
}
template&lt;typename T2&gt;
GMatrica&lt;T2&gt; operator * (const GMatrica&lt;T2&gt; &amp;g1, const T2 &amp;val) {
  GMatrica&lt;T2&gt; ret(g1);
  for (int i = 0; i &lt; ret.br_red; i++) for (int j = 0; j &lt; ret.br_kol; j++) ret.mat[i][j] *= val;
  return ret;
}
template&lt;typename T2&gt;
GMatrica&lt;T2&gt; operator * (const T2 &amp;val, const GMatrica&lt;T2&gt; &amp;g1) {
  GMatrica&lt;T2&gt; ret(g1);
  for (int i = 0; i &lt; ret.br_red; i++) for (int j = 0; j &lt; ret.br_kol; j++) ret.mat[i][j] *= val;
  return ret;
}
template&lt;typename T2&gt;
<a name="0"></a><font color="#FF0000"><a href="match753-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

GMatrica&lt;T2&gt; operator += (GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2) {
  if (g1.br_red != g2.br_red || g1.br_kol != g2.br_kol) throw std::domain_error("Nedozvoljena operacija");
  for (int i = 0; i &lt; g1.br_red; i++) for (int j = 0; j &lt; g1.br_kol; j++) g1.mat[i][j] += g2.mat[i][j];
  return g1;
}
template&lt;typename T2&gt;
</font><a name="1"></a><font color="#00FF00"><a href="match753-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

GMatrica&lt;T2&gt; operator -= (GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2) {
  if (g1.br_red != g2.br_red || g1.br_kol != g2.br_kol) throw std::domain_error("Nedozvoljena operacija");
  for (int i = 0; i &lt; g1.br_red; i++) for (int j = 0; j &lt; g1.br_kol; j++) g1.mat[i][j] -= g2.mat[i][j];
  return g1;
}
template&lt;typename T2&gt;
</font>GMatrica&lt;T2&gt; operator *= (GMatrica&lt;T2&gt; &amp;g1, const T2 &amp;val) {
  for (int i = 0; i &lt; g1.br_red; i++) for (int j = 0; j &lt; g1.br_kol; j++) g1.mat[i][j] *= val;
  return g1;
}
<a name="9"></a><font color="#FF00FF"><a href="match753-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

template&lt;typename T2&gt;
bool operator == (const GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2) {
  if (g1.br_red != g2.br_red || g1.br_kol != g2.br_kol) return 0;
</font>  for (int i = 0;i &lt; g1.br_red; i++)
    for (int j = 0; j &lt; g1.br_kol; j++)
      if (g1.mat[i][j] != g2.mat[i][j]) return 0;
  return 1;
}
template&lt;typename T2&gt;
bool operator != (const GMatrica&lt;T2&gt; &amp;g1, const GMatrica&lt;T2&gt; &amp;g2) {
  return !(g1 == g2);
}
int main() {
  GMatrica&lt;int&gt; m1({{1, 2}, {3, 4}});
   std::cout &lt;&lt; m1(1,1) &lt;&lt; std::endl;
   std::cout &lt;&lt; m1[1][1] &lt;&lt; std::endl;
	return 0;
}</pre>
</body>
</html>
