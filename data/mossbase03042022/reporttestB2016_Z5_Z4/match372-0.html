<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student9325.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student9325.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;type_traits&gt;

<a name="10"></a><font color="#FF0000"><a href="match372-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

template&lt;typename Tip&gt; 
class GMatrica {
    Tip mat[4][4];
    int br_redova, br_kolona;
public:
    GMatrica() : br_redova(0), br_kolona(0) {}
    GMatrica(int br_redova, int br_kolona, Tip vrijednost = Tip());
</font>    
    template&lt;typename T&gt; 
    GMatrica(const GMatrica&lt;T&gt; &amp;GM);
    
    template &lt;typename T&gt;
    GMatrica(T mat[4][4]);

    GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; v);
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; l);
    
<a name="5"></a><font color="#FF0000"><a href="match372-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    int DajBrojRedova() const { return br_redova; }
    int DajBrojKolona() const { return br_kolona; }
    
    // Operatori sabiranja
    template&lt;typename T1, typename T2&gt;
    friend auto operator +(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2)
        -&gt; GMatrica&lt;decltype(m1.mat[0][0] + m2.mat[0][0])&gt;;
</font>        
    template&lt;typename T&gt;
    auto operator +=(const GMatrica&lt;T&gt; &amp;mat2)
        -&gt; GMatrica&lt;decltype(mat[0][0] + mat2.mat[0][0])&gt;&amp;;
    
    // Operatori oduzimanja
        
    template&lt;typename T1, typename T2&gt;
    friend auto operator -(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) 
        -&gt; GMatrica&lt;decltype(m1.mat[0][0] + m2.mat[0][0])&gt;;
        
    template&lt;typename T&gt;
    auto operator -=(const GMatrica&lt;T&gt; &amp;m)
        -&gt; GMatrica&lt;decltype(mat[0][0] + m.mat[0][0])&gt;&amp;;
        
    // Operatori mnozenja
    
    template&lt;typename T1, typename T2&gt;
    friend auto operator *(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) 
<a name="0"></a><font color="#FF0000"><a href="match372-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

        -&gt; GMatrica&lt;decltype(m1.mat[0][0] + m2.mat[0][0])&gt;;
        
    template&lt;typename T1, typename T2&gt;
    friend auto operator *(const GMatrica&lt;T1&gt; &amp;m, T2 broj)
        -&gt; GMatrica&lt;decltype(m.mat[0][0] + broj)&gt;;
        
    template&lt;typename T1, typename T2&gt;
    friend auto operator *(T1 broj, const GMatrica&lt;T2&gt; &amp;m)
        -&gt; GMatrica&lt;decltype(m.mat[0][0] + broj)&gt;;
</font>        
    template&lt;typename T&gt;
    auto operator *=(const GMatrica&lt;T&gt; &amp;mat2)
        -&gt; GMatrica&lt;decltype(mat[0][0] + mat2.mat[0][0])&gt;&amp;;
        
    template&lt;typename T&gt;
    auto operator *=(T broj)
        -&gt; GMatrica&lt;decltype(mat[0][0] + broj)&gt;&amp;;
        
    // Logicki operatori 
    
<a name="2"></a><font color="#0000FF"><a href="match372-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    template&lt;typename T1, typename T2&gt;
    friend bool operator ==(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2);
        
    template&lt;typename T1, typename T2&gt;
    friend bool operator !=(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2);
</font>    
    // ulazni i izlazni operatori
    
    template&lt;typename T&gt;
    friend std::ostream&amp; operator &lt;&lt;(std::ostream&amp; tok, const GMatrica&lt;T&gt; &amp;m);
    
    template&lt;typename T&gt;
<a name="14"></a><font color="#FF00FF"><a href="match372-1.html#14" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    friend std::istream&amp; operator &gt;&gt;(std::istream&amp; tok, GMatrica&lt;T&gt; &amp;m);
    
    // ostali operatori
    
    Tip&amp; operator ()(int a, int b);
    Tip operator ()(int a, int b) const;
    Tip* operator [](int a); 
};

// KONSTRUKTORI

template&lt;typename Tip&gt; 
</font>GMatrica&lt;Tip&gt;::GMatrica(int br_redova, int br_kolona, Tip vrijednost) {
    if(br_redova &lt; 0 || br_redova &gt; 4 || br_kolona &lt; 0 || br_kolona &gt; 4)
        throw std::logic_error("Ilegalan format matrice");
    GMatrica::br_redova = br_redova;
    GMatrica::br_kolona = br_kolona;
    for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; br_kolona; j++) 
<a name="15"></a><font color="#FF0000"><a href="match372-1.html#15" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

            mat[i][j] = vrijednost;
}

template&lt;typename Tip&gt;
template&lt;typename T&gt;
GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;T&gt; &amp;GM) {
</font>    br_redova = GM.br_redova;
    br_kolona = GM.br_kolona;
<a name="8"></a><font color="#00FFFF"><a href="match372-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; br_kolona; j++) 
            mat[i][j] = GM.mat[i][j];
}

template&lt;typename Tip&gt;
template&lt;typename T&gt;
</font>GMatrica&lt;Tip&gt;::GMatrica(T mat[4][4]) : br_redova(4), br_kolona(4) {
    for(int i = 0; i &lt; br_redova; i++) 
        for(int j = 0; j &lt; br_kolona; j++) 
            GMatrica::mat[i][j] = mat[i][j];
}

template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; v) {
    if(v.size() &gt; 4 || v[0].size() &gt; 4) throw std::logic_error("Ilegalan format matrice");
    
    for(int i = 0; i &lt; v.size(); i++) 
        if(v[0].size() != v[i].size()) 
            throw std::logic_error("Ilegalan format matrice");     

    br_redova = v.size(); br_kolona = v[0].size();
    for(int i = 0; i &lt; br_redova; i++)
        for(int j = 0; j &lt; br_kolona; j++) 
            mat[i][j] = v[i][j];
}

template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; l) {
    if(l.size() &gt; 4) throw std::logic_error("Ilegalan format matrice");
    
    for(auto x = l.begin(); x != l.end(); x++)
        if(l.begin()-&gt;size() != x-&gt;size())
            throw std::logic_error("Ilegalan format matrice");

    br_redova = l.size(); br_kolona = l.begin()-&gt;size();
    int i = 0, j = 0;
    for(auto x = l.begin(); x != l.end(); x++, i++) {
        j = 0;
<a name="7"></a><font color="#0000FF"><a href="match372-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        for(auto y = x-&gt;begin(); y != x-&gt;end(); y++, j++) {
            mat[i][j] = *y;
        }
    }
}

// Operatori sabiranja

template&lt;typename T1, typename T2&gt;
auto operator +(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2)
</font>    -&gt; GMatrica&lt;decltype(m1.mat[0][0] + m2.mat[0][0])&gt; {
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
    
<a name="12"></a><font color="#0000FF"><a href="match372-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt; m3(m1.br_redova, m2.br_kolona);
        
    for(int i = 0; i &lt; m1.br_redova; i++) 
</font>        for(int j = 0; j &lt; m2.br_kolona; j++) 
            m3.mat[i][j] = m1.mat[i][j] + m2.mat[i][j];
    return m3;
}

template&lt;typename Tip&gt;
template&lt;typename T2&gt;
auto GMatrica&lt;Tip&gt;::operator +=(const GMatrica&lt;T2&gt; &amp;mat2)
    -&gt; GMatrica&lt;decltype(mat[0][0] + mat2.mat[0][0])&gt;&amp; {
    if(br_redova != mat2.br_redova || br_kolona != mat2.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
        
    for(int i = 0; i &lt; br_redova; i++) 
        for(int j = 0; j &lt; mat2.br_kolona; j++) 
            mat[i][j] += mat2.mat[i][j];
    return *this;
}

// Operatori oduzimanja

template&lt;typename T1, typename T2&gt;
auto operator -(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2)
    -&gt; GMatrica&lt;decltype(m1.mat[0][0] + m2.mat[0][0])&gt; {
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
    
    GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt; m3(m1.br_redova, m2.br_kolona);
        
    for(int i = 0; i &lt; m1.br_redova; i++) 
        for(int j = 0; j &lt; m2.br_kolona; j++) 
            m3.mat[i][j] = m1.mat[i][j] - m2.mat[i][j];
    return m3;
}

template&lt;typename Tip&gt;
template&lt;typename T&gt;
auto GMatrica&lt;Tip&gt;::operator -=(const GMatrica&lt;T&gt; &amp;m)
    -&gt; GMatrica&lt;decltype(mat[0][0] + m.mat[0][0])&gt;&amp; {
    if(br_redova != m.br_redova || br_kolona != m.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
        
    for(int i = 0; i &lt; br_redova; i++) 
        for(int j = 0; j &lt; m.br_kolona; j++) 
            mat[i][j] -= m.mat[i][j];
    return *this;
            
}

// Operatori mnozenja

template&lt;typename T1, typename T2&gt;
auto operator *(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) 
<a name="11"></a><font color="#00FF00"><a href="match372-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    -&gt; GMatrica&lt;decltype(m1.mat[0][0] + m2.mat[0][0])&gt; {
    if(m1.br_kolona != m2.br_redova)    
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1.mat[0][0]+m2.mat[0][0])&gt; mat3(m1.br_redova, m2.br_kolona);
</font>    for(int i = 0; i &lt; m1.br_redova; i++) {
        for(int j = 0; j &lt; m2.br_kolona; j++) {
            mat3.mat[i][j] = 0;
            for(int k = 0; k &lt; m1.br_kolona; k++) {
<a name="1"></a><font color="#00FF00"><a href="match372-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

                mat3.mat[i][j] += m1.mat[i][k] * m2.mat[k][j];
            }
        }
    }
    return mat3;
}

template&lt;typename T1, typename T2&gt;
auto operator *(const GMatrica&lt;T1&gt; &amp;m, T2 broj)
    -&gt; GMatrica&lt;decltype(m.mat[0][0] + broj)&gt; {
</font>    GMatrica&lt;decltype(m.mat[0][0]+broj)&gt; mat3(m.br_redova, m.br_kolona);
    for(int i = 0; i &lt; m.br_redova; i++) {
        for(int j = 0; j &lt; m.br_kolona; j++) {
<a name="4"></a><font color="#FF00FF"><a href="match372-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

            mat3.mat[i][j] += m.mat[i][j] * broj;
        }
    }
    return mat3;  
}

template&lt;typename T1, typename T2&gt;
auto operator *(T1 broj, const GMatrica&lt;T2&gt; &amp;m)
    -&gt; GMatrica&lt;decltype(m.mat[0][0] + broj)&gt; {
</font>    GMatrica&lt;decltype(m.mat[0][0]+broj)&gt; mat3(m.br_redova, m.br_kolona);
    for(int i = 0; i &lt; m.br_redova; i++) {
        for(int j = 0; j &lt; m.br_kolona; j++) {
            mat3.mat[i][j] += m.mat[i][j] * broj;
        }
    }
    return mat3;  
}

template&lt;typename Tip&gt;
template&lt;typename T&gt;
auto GMatrica&lt;Tip&gt;::operator *=(const GMatrica&lt;T&gt; &amp;mat2)
    -&gt; GMatrica&lt;decltype(mat[0][0] + mat2.mat[0][0])&gt;&amp; {
    if(br_kolona != mat2.br_redova)    
        throw std::domain_error("Nedozvoljena operacija");
    
    GMatrica&lt;decltype(mat[0][0]+mat2.mat[0][0])&gt; mat3(br_redova, mat2.br_kolona, 0);
    
    for(int i = 0; i &lt; br_redova; i++) {
        for(int j = 0; j &lt; mat2.br_kolona; j++) {
            mat3.mat[i][j] = 0;
            for(int k = 0; k &lt; br_kolona; k++) {
                mat3.mat[i][j] += mat[i][k] * mat2.mat[k][j];
            }
        }
    }
    *this = mat3;
    return *this;
}

template&lt;typename Tip&gt;
template&lt;typename T&gt;
auto GMatrica&lt;Tip&gt;::operator *=(T broj) 
    -&gt; GMatrica&lt;decltype(mat[0][0] + broj)&gt;&amp; {
    for(int i = 0; i &lt; br_redova; i++) {
<a name="3"></a><font color="#00FFFF"><a href="match372-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        for(int j = 0; j &lt; br_kolona; j++) {
            mat[i][j] *= broj;
        }
    }
    return *this;  
}

// Logicki operatori

template&lt;typename T1, typename T2&gt;
bool operator ==(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) {
    if(m1.br_redova != m2.br_redova || m2.br_kolona != m2.br_kolona)
</font>        return false;
    for(int i = 0; i &lt; m1.br_redova; i++) {
        for(int j = 0; j &lt; m1.br_kolona; j++) {
<a name="6"></a><font color="#00FF00"><a href="match372-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

            if(m1.mat[i][j] != m2.mat[i][j]) return false;
        }
    }
    return true;
}

template&lt;typename T1, typename T2&gt;
bool operator !=(const GMatrica&lt;T1&gt; &amp;m1, const GMatrica&lt;T2&gt; &amp;m2) {
</font>    if(m1.br_redova != m2.br_redova || m2.br_kolona != m2.br_kolona)
        return true;
    for(int i = 0; i &lt; m1.br_redova; i++) {
        for(int j = 0; j &lt; m1.br_kolona; j++) {
            if(m1.mat[i][j] != m2.mat[i][j]) 
                return true;
        }
    }
    return false;
}

// Ulazni/izlazni operatori

template&lt;typename T&gt;
<a name="13"></a><font color="#00FFFF"><a href="match372-1.html#13" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

std::ostream&amp; operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;T&gt; &amp;m) {
    int sirina = tok.width();
    if(sirina &lt; 6) {
</font>        for(int i = 0; i &lt; m.br_redova; i++) {
            for(int j = 0; j &lt; m.br_kolona; j++) {
                tok &lt;&lt; std::setw(6) &lt;&lt; m.mat[i][j];
            }
            tok &lt;&lt; std::endl;
        }
    }
    else {
        for(int i = 0; i &lt; m.br_redova; i++) {
            for(int j = 0; j &lt; m.br_kolona; j++) {
                tok &lt;&lt; std::setw(sirina) &lt;&lt; m.mat[i][j];
            }
            tok &lt;&lt; std::endl;
        }  
    }
    return tok;
}

template&lt;typename T&gt;
std::istream&amp; operator &gt;&gt;(std::istream&amp; tok, GMatrica&lt;T&gt; &amp;m) {
    std::vector&lt;std::vector&lt;T&gt;&gt; mtr;
    std::vector&lt;T&gt; pomocni, prazan;
    char znak;
    tok &gt;&gt; znak;
    if(znak != '[') {
        tok.setstate(std::ios::failbit);
        return tok;
    }
    while(true) {
        T temp;
        tok &gt;&gt; temp &gt;&gt; znak;
        pomocni.push_back(temp);
        if(znak == ',') continue; 
        else if(znak == ';') {
            mtr.push_back(pomocni);
            pomocni = prazan;
        }
        else if(znak == ']') {
            mtr.push_back(pomocni);
            break;
        }
        else {
            tok.setstate(std::ios::failbit);
            return tok;
        }
    }
    // provjera ispravnosti redova i kolona
    if(mtr[0].size() &gt; 4 || mtr.size() &gt; 4) {
        tok.setstate(std::ios::failbit);
        return tok;
    }
    int vel = mtr[0].size();
    for(auto &amp;x : mtr) {
        if(x.size() != vel) {
            tok.setstate(std::ios::failbit);
            return tok;
        }
    }
    // kopiranje vectora mtr u glavni 2D niz
    m.br_redova = mtr.size(); m.br_kolona = mtr[0].size();
    for(int i = 0; i &lt; m.br_redova; i++) {
        for(int j = 0; j &lt; m.br_kolona; j++) {
            m.mat[i][j] = mtr[i][j];
        }
    }
    return tok;
}

// Ostali operatori

template&lt;typename Tip&gt;
Tip&amp; GMatrica&lt;Tip&gt;::operator ()(int i, int j) {
    if(i &gt; br_redova  || j &gt; br_kolona || i &lt; 1 || j &lt; 1)
<a name="9"></a><font color="#FF00FF"><a href="match372-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        throw std::range_error("Nedozvoljen indeks");
    return mat[i-1][j-1];
}

template&lt;typename Tip&gt;
Tip GMatrica&lt;Tip&gt;::operator ()(int i, int j) const {
    if(i &gt; br_redova  || j &gt; br_kolona || i &lt; 1 || j &lt; 1)
</font>        throw std::range_error("Nedozvoljen indeks");
    return mat[i-1][j-1];
}

template&lt;typename Tip&gt;
Tip* GMatrica&lt;Tip&gt;::operator [](int i) {
    return mat[i];
}

int main() {
    GMatrica&lt;int&gt; m1, m2;
    std::cout &lt;&lt; "Unesite 1. matricu: "; std::cin &gt;&gt; m1;
    std::cout &lt;&lt; "Unesite 2. matricu: "; std::cin &gt;&gt; m2;
    
    std::cout &lt;&lt; "operator + \n" &lt;&lt; m1 + m2;
    std::cout &lt;&lt; "operator - \n" &lt;&lt; m1 - m2;
    std::cout &lt;&lt; "operator * \n" &lt;&lt; m1 * m2;
    
    std::cout &lt;&lt; "Matrice pomnozene sa 2\n";
    std::cout &lt;&lt; "mat1 * 2\n" &lt;&lt; m1 * 2;
    std::cout &lt;&lt; "2 * mat2\n" &lt;&lt; 2 * m2;
    
    std::cout &lt;&lt; "operator += \n";
    m1 += m2;
    std::cout &lt;&lt; m1;
    std::cout &lt;&lt; "operator -= \n";
    m1 -= m2;
    std::cout &lt;&lt; m1;
    std::cout &lt;&lt; "operator *= \n";
    m1 *= m2;
    std::cout &lt;&lt; m1;
    
    std::cout &lt;&lt; "operator == : " &lt;&lt; std::boolalpha &lt;&lt; (m1 == m2) &lt;&lt; std::endl;
    std::cout &lt;&lt; "operator != : " &lt;&lt; std::boolalpha &lt;&lt; (m1 != m2) &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "operator () (1,1)(mat1): " &lt;&lt; m1(1,1) &lt;&lt; std::endl;
    std::cout &lt;&lt; "operator [] [0][0](mat2): " &lt;&lt; m2[0][0] &lt;&lt; std::endl;
    return 0;
}</pre>
</body>
</html>
