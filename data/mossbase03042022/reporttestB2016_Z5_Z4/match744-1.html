<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3899.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4425.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;initializer_list&gt;
#include &lt;type_traits&gt;

template &lt;typename T&gt;
    class GMatrica {
        T matrica[4][4]{};
        int redova, kolona;
    public: 
        //konstruktori
        GMatrica();
        GMatrica (int redova, int kolona, T val = T());
        GMatrica (std::vector&lt;std::vector&lt;T&gt;&gt; v);
        template &lt;typename Tip&gt;
            GMatrica&lt;T&gt; (GMatrica&lt;Tip&gt; &amp;m);
        template &lt;typename Tip&gt;
            GMatrica&lt;T&gt; (Tip **niz);
        template &lt;typename Tip&gt;
            GMatrica&lt;T&gt; (std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; m);
            
        //metode //done
        int DajBrojRedova() const {return redova;}
        int DajBrojKolona() const {return kolona;}
        
        //operatori
        template &lt;typename Tip1&gt;
            friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip1&gt; &amp;m);
        template &lt;typename Tip1&gt; 
            friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;m);
            
<a name="0"></a><font color="#FF0000"><a href="match744-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        template &lt;typename Tip1, typename Tip2&gt; //done
            friend auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) 
                -&gt; GMatrica&lt;decltype(m1.matrica[0][0] + m2.matrica[0][0])&gt;;
        template &lt;typename Tip1, typename Tip2&gt; //done
            friend auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) 
                -&gt; GMatrica&lt;decltype(m1.matrica[0][0] - m2.matrica[0][0])&gt;;
        template &lt;typename Tip1, typename Tip2&gt; //done
            friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) 
                -&gt; GMatrica&lt;decltype(m1.matrica[0][0] * m2.matrica[0][0])&gt;;
        template &lt;typename Tip1, typename Tip2&gt; //done
</font><a name="1"></a><font color="#00FF00"><a href="match744-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

            friend auto operator *(Tip1 skalar, const GMatrica&lt;Tip2&gt; &amp;m) 
                -&gt; GMatrica&lt;decltype(skalar * m.matrica[0][0])&gt;;
        template &lt;typename Tip1, typename Tip2&gt; //done
            friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, Tip2 skalar) 
                -&gt; GMatrica&lt;decltype(skalar * m.matrica[0][0])&gt;;
        
        template &lt;typename Tip1&gt; 
</font>            auto operator +=(const GMatrica&lt;Tip1&gt; &amp;m) 
                -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] + m.matrica[0][0])&gt;;
        template &lt;typename Tip1&gt;
            auto operator +=(Tip1 skalar) 
                -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] + skalar)&gt;;
        template &lt;typename Tip1&gt;
            auto operator -=(const GMatrica&lt;Tip1&gt; &amp;m) 
                -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] - m.matrica[0][0])&gt;;
        template &lt;typename Tip1&gt;
            auto operator -=(Tip1 skalar) 
                -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] - skalar)&gt;;
        template &lt;typename Tip1&gt;
            auto operator *=(const GMatrica&lt;Tip1&gt; &amp;m) 
                -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] * m.matrica[0][0])&gt;;
        template &lt;typename Tip1&gt;
            auto operator *=(Tip1 skalar) 
                -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] * skalar)&gt;;
        
        template &lt;typename Tip1, typename Tip2&gt;
<a name="3"></a><font color="#00FFFF"><a href="match744-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

            friend bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
        template &lt;typename Tip1, typename Tip2&gt;
            friend bool operator !=(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);

        // operator []
        auto operator [](int i) -&gt; typename std::add_lvalue_reference&lt;decltype(matrica[0])&gt;::type;
</font>        auto operator [] (int i) const -&gt; decltype(matrica[0]);
        
        //operator ()
        T operator ()(int i, int j) const;
        T &amp;operator ()(int i, int j);
    };

template &lt;typename Tip1&gt;
    std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;m) {
        char znak;
        int rows(0), cols(0);
        Tip1 unos;
        znak = tok.peek();
        //std::cout &lt;&lt; "1";
        if (znak != '[') {
            tok.setstate(std::ios::failbit);
            return tok;
            //std::cout &lt;&lt; "2";
        }
        tok &gt;&gt; znak;
        std::vector&lt;int&gt; v;
        while(1) {
            //std::cout &lt;&lt; "u petlji sam";
            tok &gt;&gt; unos;
            if (!tok) return tok;
            //std::cout &lt;&lt; "3";
            if (cols &gt; 3 || rows &gt; 3) {
                tok.setstate(std::ios::failbit);
                //std::cout &lt;&lt; "4";
                break;
            }
            m.matrica[rows][cols] = unos;
            //std::cout &lt;&lt;"5";
            znak = tok.peek();
            if (znak == ',') {
                //std::cout &lt;&lt;"6";
                tok &gt;&gt; znak;
                cols++;
                continue;
            } else if (znak == ';') {
                //std::cout &lt;&lt;"7";
                tok &gt;&gt; znak;
                v.push_back(cols);
                cols = 0;
                rows++;
                continue;
            } else if (znak == ']') {
                //std::cout &lt;&lt; "8";
                tok &gt;&gt; znak;
                v.push_back(cols);
                m.redova = rows + 1;
                m.kolona = cols + 1;
                bool a(false);
                for (auto x : v) if (x != v[0]) {a = true; break;}
                if (a) tok.setstate(std::ios::failbit);
                break;
            } else {
                //std::cout &lt;&lt; "9";
                tok.setstate(std::ios::failbit);
                break;
            }
        }
        //std::cout &lt;&lt; "10";
        return tok;
    }

template &lt;typename T&gt;
    auto GMatrica&lt;T&gt;::operator [] (int i) -&gt; typename std::add_lvalue_reference&lt;decltype(matrica[0])&gt;::type {
        return matrica[i];
    }

template &lt;typename T&gt; 
    auto GMatrica&lt;T&gt;::operator [](int i) const -&gt; decltype(matrica[0]) {
        return matrica[i];
    }

template &lt;typename T&gt;
    T &amp;GMatrica&lt;T&gt;::operator ()(int i, int j) {
        if (i &lt; 1 || j &lt; 1 || i &gt; this-&gt;redova || j &gt; this-&gt;redova)
            throw std::range_error("Nedozvoljen indeks");
        return this-&gt;matrica[i-1][j-1];
    } 
    
template &lt;typename T&gt;
    T GMatrica&lt;T&gt;::operator ()(int i, int j) const {
        if (i &lt; 1 || j &lt; 1 || i &gt; this-&gt;redova || j &gt; this-&gt;kolona)
            throw std::range_error("Nedozvoljen indeks");
        return this-&gt;matrica[i-1][j-1];
    }

template &lt;typename Tip1, typename Tip2&gt;
    bool operator !=(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) {
        if (m1 == m2) return false;
        return true;
    }

template &lt;typename Tip1, typename Tip2&gt;
    bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) {
        bool a(m1.redova == m2.redova &amp;&amp; m1.kolona == m2.kolona);
        if (!a) return false;
        a = true;
        for (int i = 0; i &lt; m1.redova; i++) for (int j = 0; j &lt; m1.kolona; j++) if (m1.matrica[i][j] != m2.matrica[i][j]) {a = false; break;}
        if (!a) return false;
        return true;
    }

template &lt;typename T&gt;
    template &lt;typename Tip1&gt;
        auto GMatrica&lt;T&gt;::operator -=(Tip1 skalar) -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] - skalar)&gt; {
            for (int i = 0; i &lt; this-&gt;redova; i++) for (int j = 0; j &lt; this-&gt;kolona; j++) this-&gt;matrica[i][j] -= skalar;
            return *this;
        }

template &lt;typename T&gt;
    template &lt;typename Tip1&gt;
        auto GMatrica&lt;T&gt;::operator +=(Tip1 skalar) -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] + skalar)&gt; {
            for (int i = 0; i &lt; this-&gt;redova; i++) for (int j = 0; j &lt; this-&gt;kolona; j++) this-&gt;matrica[i][j] += skalar;
            return *this;
        }

template &lt;typename T&gt;
    template &lt;typename Tip1&gt;
        auto GMatrica&lt;T&gt;::operator *= (const GMatrica&lt;Tip1&gt; &amp;m) -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] * m.matrica[0][0])&gt; {
            if (this-&gt;kolona != m.redova) throw std::domain_error("Nedozvoljena operacija");
            typedef decltype(this-&gt;matrica[0][0] * m.matrica[0][0]) ReturnTip;
            GMatrica&lt;ReturnTip&gt; proizvod(this-&gt;redova, m.kolona);
            for (int i = 0; i &lt; this-&gt;redova; i++) {
                for (int j = 0; j &lt; m.kolona; j++) {
                    proizvod.matrica[i][j] = 0;
                    for (int k = 0; k &lt; this-&gt;kolona; j++) 
                        proizvod.matrica[i][j] += this-&gt;matrica[i][k] * m.matrica[k][j];
                }
            }
            *this = proizvod;
            return *this;
        }

template &lt;typename T&gt;
    template &lt;typename Tip1&gt;
        auto GMatrica&lt;T&gt;::operator *=(Tip1 skalar) -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] * skalar)&gt; {
            for (int i = 0; i &lt; this-&gt;redova; i++) for (int j = 0; j &lt; this-&gt;kolona; j++) this-&gt;matrica[i][j] *= skalar;
            return *this;
        }

template &lt;typename T&gt;
    template &lt;typename Tip1&gt;
        auto GMatrica&lt;T&gt;::operator -=(const GMatrica&lt;Tip1&gt; &amp;m) -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] - m.matrica[0][0])&gt; {
            if (!(this-&gt;redova == m.redova &amp;&amp; this-&gt;kolona == m.kolona)) throw std::domain_error("Nedozvoljena operacija");
            for (int i = 0; i &lt; m.redova; i++) for (int j = 0; j &lt; m.kolona; j++) this-&gt;matrica[i][j] -= m.matrica[i][j];
            return *this;
        }

template &lt;typename T&gt;
    template &lt;typename Tip1&gt;
        auto GMatrica&lt;T&gt;::operator +=(const GMatrica&lt;Tip1&gt; &amp;m) -&gt; GMatrica&lt;decltype(this-&gt;matrica[0][0] + m.matrica[0][0])&gt; {
            if (!(this-&gt;redova == m.redova &amp;&amp; this-&gt;kolona == m.kolona)) throw std::domain_error("Nedozvoljena operacija");
            for (int i = 0; i &lt; m.redova; i++) for (int j = 0; j &lt; m.kolona; j++) this-&gt;matrica[i][j] += m.matrica[i][j];
<a name="2"></a><font color="#0000FF"><a href="match744-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

            return *this;
        }

template &lt;typename Tip1, typename Tip2&gt;
    auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] * m2.matrica[0][0])&gt; {
        if (m1.kolona != m2.redova) throw std::domain_error("Nedozvoljena operacija");
</font>        typedef decltype(m1.matrica[0][0] * m2.matrica[0][0]) ReturnTip;
        GMatrica&lt;ReturnTip&gt; proizvod(m1.redova, m2.kolona);
        for (int i = 0; i &lt; m1.redova; i++) {
            for (int j = 0; j &lt; m2.kolona; j++) {
                proizvod.matrica[i][j] = 0;
                for (int k = 0; k &lt; m1.kolona; k++)
                    proizvod.matrica[i][j] += m1.matrica[i][k] * m2.matrica[k][j]; 
            }
        }
        return proizvod;
    }

template &lt;typename Tip1, typename Tip2&gt;
    auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, Tip2 skalar) -&gt; GMatrica&lt;decltype(skalar * m.matrica[0][0])&gt; {
        typedef decltype(skalar * m.matrica[0][0]) ReturnTip;
        GMatrica&lt;ReturnTip&gt; proizvod(m.redova, m.kolona);
<a name="5"></a><font color="#FF0000"><a href="match744-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        for (int i = 0; i &lt; m.redova; i++) for (int j = 0; j &lt; m.kolona; j++) proizvod.matrica[i][j] = skalar * m.matrica[i][j];
        return proizvod;
    }

template &lt;typename Tip1, typename Tip2&gt;
    auto operator *(Tip1 skalar, const GMatrica&lt;Tip2&gt; &amp;m) -&gt; GMatrica&lt;decltype(skalar * m.matrica[0][0])&gt; {
</font>        typedef decltype(skalar * m.matrica[0][0]) ReturnTip;
        GMatrica&lt;ReturnTip&gt; proizvod(m.redova, m.kolona);
        for (int i = 0; i &lt; m.redova; i++) for (int j = 0; j &lt; m.kolona; j++) proizvod.matrica[i][j] = skalar * m.matrica[i][j];
        return proizvod;
    }

template &lt;typename Tip1&gt;
    std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip1&gt; &amp;m) {
        int sirina(tok.width());
        if (sirina &lt; 6) sirina = 6;
        for (int i = 0; i &lt; m.redova; i++) {
            for (int j = 0; j &lt; m.kolona; j++)
                tok &lt;&lt; std::setw(sirina) &lt;&lt; m.matrica[i][j];
            tok &lt;&lt; std::endl;
        }
        return tok;
    }

template &lt;typename Tip1, typename Tip2&gt;
    auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] + m2.matrica[0][0])&gt; {
        if (!(m1.redova == m2.redova &amp;&amp; m1.kolona == m2.kolona))
            throw std::domain_error("Nedozvoljena operacija");
        typedef decltype(m1.matrica[0][0] + m2.matrica[0][0]) ReturnTip;
        GMatrica&lt;ReturnTip&gt; zbir(m1.redova, m1.kolona);
        for (int i = 0; i &lt; zbir.redova; i++)
            for (int j = 0; j &lt; zbir.kolona; j++)
                zbir.matrica[i][j] = m1.matrica[i][j] + m2.matrica[i][j];
        return zbir;
    }

template &lt;typename Tip1, typename Tip2&gt;
<a name="8"></a><font color="#00FFFF"><a href="match744-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0] - m2.matrica[0][0])&gt; {
        if (!(m1.redova == m2.redova &amp;&amp; m1.kolona == m2.kolona))
</font>            throw std::domain_error("Nedozvoljena operacija");
        typedef decltype(m1.matrica[0][0] - m2.matrica[0][0]) ReturnTip;
        GMatrica&lt;ReturnTip&gt; razlika(m1.redova, m1.kolona);
        for (int i = 0; i &lt; razlika.redova; i++)
            for (int j = 0; j &lt; razlika.kolona; j++) 
                razlika.matrica[i][j] = m1.matrica[i][j] - m2.matrica[i][j];
        return razlika;
    }
    
<a name="6"></a><font color="#00FF00"><a href="match744-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

template &lt;typename T&gt;
    GMatrica&lt;T&gt;::GMatrica (std::vector&lt;std::vector&lt;T&gt;&gt; v) {
        int row(v.size());
</font>        if (row &lt; 0 || row &gt; 4) throw std::logic_error("Ilegalan format matrice");
<a name="4"></a><font color="#FF00FF"><a href="match744-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        int column(v[0].size());
        for (int i = 0; i &lt; row; i++) if (v[i].size != column) throw std::logic_error("Ilegalan format matrice");
        redova = row;
        kolona = column;
        for (int i = 0; i &lt; redova; i++) 
            for (int j = 0; j &lt; kolona; j++) 
</font>                matrica[i][j] = v[i][j];
    }

template &lt;typename T&gt;   
    GMatrica&lt;T&gt;::GMatrica() : redova(0), kolona(0) {}

template &lt;typename T&gt;
    GMatrica&lt;T&gt;::GMatrica (int redova, int kolona, T val) {
        if (redova &lt; 0 || redova &gt; 4 || kolona &lt; 0 || kolona &gt; 4)
            throw std::logic_error("Ilegalan format matrice");
        GMatrica&lt;T&gt;::redova = redova;
        GMatrica&lt;T&gt;::kolona = kolona;
        for (int i = 0; i &lt; redova; i++)
            for (int j = 0; j &lt; kolona; j++) 
                matrica[i][j] = val;
    }

template &lt;typename T&gt;
    template &lt;typename Tip&gt;
<a name="7"></a><font color="#0000FF"><a href="match744-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

        GMatrica&lt;T&gt;::GMatrica (GMatrica&lt;Tip&gt; &amp;m) {
            for (int i = 0; i &lt; m.redova; i++) 
                for (int j = 0; j &lt; m.kolona; j++) 
</font>                    GMatrica::matrica[i][j] = static_cast&lt;T&gt;(m.matrica[i][j]);
            GMatrica::redova = m.redova;
            GMatrica::kolona = m.kolona;
        }

template &lt;typename T&gt;
    template &lt;typename Tip&gt;
        GMatrica&lt;T&gt;::GMatrica (Tip **niz) {
            for (int i = 0; i &lt; 4; i++) 
                for (int j = 0; j &lt; 4; j++) 
                    GMatrica::matrica[i][j] = niz[i][j];
            GMatrica::redova = 4;
            GMatrica::kolona = 4;
        }

template &lt;typename T&gt;
    template &lt;typename Tip&gt;
        GMatrica&lt;T&gt;::GMatrica (std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; m) {
            for (auto p(m.begin()), q(m.begin()); q != m.end(); q++)
                if (p-&gt;size() != q-&gt;size())
                    throw std::logic_error("Ilegalan format matrice");
            auto p(m.begin());
            redova = m.size();
            kolona = p-&gt;size();
            for (int i = 0; i &lt; redova; i++, p++) {
                auto q(p-&gt;begin());
                for (int j = 0; j &lt; kolona; j++, q++)
                    matrica[i][j] = *q;
            }
        }


int main () {
    
   //operatori &lt;&lt; i &gt;&gt;
   
   GMatrica&lt;int&gt; m1;
   std::cin &gt;&gt; m1;
   std::cout &lt;&lt; m1 &lt;&lt; std::endl;
   return 0;
}</pre>
</body>
</html>
