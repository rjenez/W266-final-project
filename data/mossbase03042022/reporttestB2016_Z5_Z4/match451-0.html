<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8923.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8923.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;iomanip&gt;
using std::initializer_list;
using std::vector;
using std::cout;
using std::cin;
/*template &lt;typename Tip&gt;
class Niz
{
    private:
    vector&lt;Tip&gt; niz;
    int broj_redova;
    public:
    Niz():broj_redova(0){}
    Niz(Tip nniz[2]){niz.push_back(nniz[0]); niz.push_back(nniz[1]); broj_redova=2;}
    Tip &amp;operator [](int broj) {return niz[broj];}
};*/
template &lt;typename Tip&gt;
class GMatrica
{
    private:
    Tip matrica[4][4];
    int broj_redova;
    int broj_kolona;
    template &lt;typename Tip1,typename Tip2&gt;
    static bool SaglasneZaMnozenje(GMatrica&lt;Tip1&gt; mat1,GMatrica&lt;Tip2&gt; mat2);
    template &lt;typename Tip1,typename Tip2&gt;
    static bool SaglasneZaSabiranje(GMatrica&lt;Tip1&gt; mat1,GMatrica&lt;Tip2&gt; mat2);
    public:
<a name="11"></a><font color="#00FF00"><a href="match451-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    GMatrica();
    GMatrica(int broj_r,int broj_k,Tip vrijednost=Tip());
    template &lt;typename Tip1&gt;
    GMatrica(const GMatrica&lt;Tip1&gt; &amp;mat);
    GMatrica(Tip niz[4][4]);
</font>    GMatrica(vector&lt;vector&lt;Tip&gt;&gt; vektor);
    GMatrica(initializer_list&lt;initializer_list&lt;Tip&gt;&gt; lista);
    int DajBrojRedova() const {return broj_redova;}
    int DajBrojKolona() const {return broj_kolona;}
    template &lt;typename Tip1,typename Tip2&gt;
    friend bool operator ==(GMatrica&lt;Tip1&gt; mat1,GMatrica&lt;Tip2&gt; mat2);
    template &lt;typename Tip1,typename Tip2&gt;
    friend bool operator !=(GMatrica&lt;Tip1&gt; mat1,GMatrica&lt;Tip2&gt; mat2);
    Tip &amp;operator ()(int broj_reda,int broj_kolone);
    Tip operator ()(int broj_reda,int broj_kolone) const;
   // Niz&lt;Tip&gt; &amp;operator [](int broj) const;
    vector&lt;Tip&gt; operator [](int broj) const;
    template&lt;typename Tip1&gt;
    friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok,GMatrica&lt;Tip1&gt; &amp;mat);
    template&lt;typename Tip1&gt;
<a name="0"></a><font color="#FF0000"><a href="match451-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok,const GMatrica&lt;Tip1&gt; &amp;mat);
    
    template &lt;typename Tip1,typename Tip2&gt;
    friend auto operator +(const GMatrica&lt;Tip1&gt; &amp;mat1,const GMatrica&lt;Tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.matrica[0][0]*mat2.matrica[0][0])&gt;;
    template &lt;typename Tip1,typename Tip2&gt;
    friend auto operator -(const GMatrica&lt;Tip1&gt; &amp;mat1,const GMatrica&lt;Tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.matrica[0][0]*mat2.matrica[0][0])&gt;;
</font><a name="6"></a><font color="#00FF00"><a href="match451-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    template &lt;typename Tip1,typename Tip2&gt;
    friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;mat1, const GMatrica&lt;Tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.matrica[0][0]*mat2.matrica[0][0])&gt;;
</font><a name="1"></a><font color="#00FF00"><a href="match451-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    template &lt;typename Tip1,typename Tip2&gt;
    friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;mat,Tip2 a)-&gt;GMatrica&lt;decltype(mat.matrica[0][0]*a)&gt;;
    template &lt;typename Tip1,typename Tip2&gt;
    friend auto operator *(Tip1 a,GMatrica&lt;Tip2&gt; mat)-&gt;GMatrica&lt;decltype(mat.matrica[0][0]*a)&gt;;
</font>    
    
    template &lt;typename Tip1&gt;
    GMatrica&lt;Tip&gt; &amp;operator +=(const GMatrica&lt;Tip1&gt; &amp;mat2);
    template &lt;typename Tip1&gt;
    GMatrica&lt;Tip&gt; &amp;operator -=(const GMatrica&lt;Tip1&gt; &amp;mat2);
    template &lt;typename Tip1&gt;
    GMatrica&lt;Tip&gt; &amp;operator *=(const GMatrica&lt;Tip1&gt; &amp;mat2);
    template &lt;typename Tip1&gt;
<a name="3"></a><font color="#00FFFF"><a href="match451-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    GMatrica&lt;Tip&gt; &amp;operator *=(Tip1 a);
};
template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica ()
{
    broj_redova=0;
    broj_kolona=0;
}
template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int broj_r,int broj_k,Tip vrijednost)
{
    if(broj_r&lt;0 || broj_r&gt;4 || broj_k&lt;0 || broj_k&gt;4) throw std::logic_error("Ilegalan format matrice");
</font>    broj_redova=broj_r;
    broj_kolona=broj_k;
    for(int i=0;i&lt;broj_redova;i++)
    for(int j=0;j&lt;broj_kolona;j++)
    {
<a name="12"></a><font color="#0000FF"><a href="match451-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    GMatrica::matrica[i][j]=vrijednost;
    }
}
template &lt;typename Tip&gt;
template &lt;typename Tip1&gt;
GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;Tip1&gt; &amp;mat)
</font>{
    broj_redova=mat.DajBrojRedova();
    broj_kolona=mat.DajBrojKolona();
    for(int i=0;i&lt;mat.DajBrojRedova();i++)
    for(int j=0;j&lt;mat.DajBrojKolona();j++)
    matrica[i][j]=(mat[i][j]);
}
template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(Tip niz[4][4])
{
    broj_redova=4;
<a name="13"></a><font color="#00FFFF"><a href="match451-1.html#13" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    broj_kolona=4;
    for(int i=0;i&lt;4;i++)
    for(int j=0;j&lt;4;j++)
    matrica[i][j]=niz[i][j];
</font>}
template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(vector&lt;vector&lt;Tip&gt;&gt; vektor)
{
    if(vektor.size()&lt;0 || vektor.size()&gt;4) throw std::logic_error("Ilegalan format matrice");
    bool provjera(false);
    if(vektor.size()!=0)
    for(int i=0;i&lt;vektor.size();i++)
    {
        if(vektor[i].size()!=vektor[0].size() || vektor[i].size()&gt;4)
        provjera=true;
    }
    if(provjera) throw std::logic_error("Ilegalan format matrice");
    broj_redova=vektor.size();
    if(vektor.size()!=0)
    broj_kolona=vektor[0].size();
    else
    broj_kolona=0;
<a name="4"></a><font color="#FF00FF"><a href="match451-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    for(int i=0;i&lt;vektor.size();i++)
    for(int j=0;j&lt;vektor[0].size();j++)
    matrica[i][j]=vektor[i][j];
</font>}
template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(initializer_list&lt;initializer_list&lt;Tip&gt;&gt; lista)
{
    if(lista.size()&lt;0 || lista.size()&gt;4) throw std::logic_error("Ilegalan format matrice");
    bool provjera(false);
    if(lista.size()!=0)
    {
        for(auto it=lista.begin();it!=lista.end();it++)
        if(it-&gt;size()!=(lista.begin())-&gt;size() || it-&gt;size()&gt;4)
        provjera=true;
    }
    if(provjera) throw std::logic_error("Ilegalan format matrice");
    broj_redova=lista.size();
    if(lista.size()!=0)
    broj_kolona=(lista.begin())-&gt;size();
    else
    broj_kolona=0;
    int i(0),j(0);
    for(auto it1=lista.begin();it1!=lista.end();it1++)
    {
        j=0;
        for(auto it2=it1-&gt;begin();it2!=it1-&gt;end();it2++)
        {
            matrica[i][j]=*it2;
            j++;
        }
        i++;
    }
}
template&lt;typename Tip&gt;
template&lt;typename Tip1,typename Tip2&gt;
bool GMatrica&lt;Tip&gt;::SaglasneZaSabiranje(GMatrica&lt;Tip1&gt; mat1,GMatrica&lt;Tip2&gt; mat2)
{
    if(mat1.DajBrojRedova()==mat2.DajBrojRedova() &amp;&amp; mat1.DajBrojKolona()==mat2.DajBrojKolona()) return true;
    return false;
}
template&lt;typename Tip&gt;
template&lt;typename Tip1,typename Tip2&gt;
bool GMatrica&lt;Tip&gt;::SaglasneZaMnozenje(GMatrica&lt;Tip1&gt; mat1,GMatrica&lt;Tip2&gt; mat2)
{
    if(mat1.DajBrojKolona()==mat2.DajBrojRedova()) return true;
    return false;
}
template &lt;typename Tip1,typename Tip2&gt;
bool operator ==(GMatrica&lt;Tip1&gt; mat1,GMatrica&lt;Tip2&gt; mat2)
{
    if(!GMatrica&lt;Tip1&gt;::SaglasneZaSabiranje(mat1,mat2)) return false;
    for(int i=0;i&lt;mat1.broj_redova;i++)
    for(int j=0;j&lt;mat1.broj_kolona;j++)
    {
        if(mat1.matrica[i][j]!=mat2.matrica[i][j])
        return false;
    }
    return true;
}
template &lt;typename Tip1,typename Tip2&gt;
inline bool operator !=(GMatrica&lt;Tip1&gt; mat1,GMatrica&lt;Tip2&gt; mat2)
{
    return(!(mat1==mat2));
}
template &lt;typename Tip&gt;
Tip &amp;GMatrica&lt;Tip&gt;::operator ()(int broj_reda,int broj_kolone)
{
    broj_reda--;
    broj_kolone--;
    if(broj_reda&lt;0 || broj_reda&gt;=broj_redova || broj_kolone&lt;0 || broj_kolone&gt;=broj_kolona)
    throw std::range_error("Nedozvoljen indeks");
    return matrica[broj_reda][broj_kolone];
}
template &lt;typename Tip&gt;
Tip GMatrica&lt;Tip&gt;::operator ()(int broj_reda,int broj_kolone) const
{
    broj_reda--;
    broj_kolone--;
    if(broj_reda&lt;0 || broj_reda&gt;=broj_redova || broj_kolone&lt;0 || broj_kolone&gt;=broj_kolona)
    throw std::range_error("Nedozvoljen indeks");
    return matrica[broj_reda][broj_kolone];
}
template &lt;typename Tip&gt;
vector&lt;Tip&gt; GMatrica&lt;Tip&gt;::operator [] (int broj) const
{
    vector&lt;Tip&gt; vek;
    for(int i=0;i&lt;(this-&gt;broj_kolona);i++)
    vek.push_back(matrica[broj][i]);
<a name="14"></a><font color="#FF00FF"><a href="match451-1.html#14" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    return vek;
}
/*template &lt;typename Tip&gt;
Niz&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator [] (int broj) const
{
    return matrica[broj];
}*/
template &lt;typename Tip1,typename Tip2&gt;
auto operator +(const GMatrica&lt;Tip1&gt; &amp;mat1,const GMatrica&lt;Tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.matrica[0][0]*mat2.matrica[0][0])&gt;
</font><a name="15"></a><font color="#FF0000"><a href="match451-1.html#15" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

{
    if(!(GMatrica&lt;Tip1&gt;::SaglasneZaSabiranje(mat1,mat2))) throw std::domain_error("Nedozvoljena operacija");
</font>    if(mat1.broj_redova==0 || mat1.broj_kolona==0)
    return mat1;
    GMatrica&lt;decltype(mat1.matrica[0][0]*mat2.matrica[0][0])&gt; mat3(mat1);
    for(int i=0;i&lt;mat1.broj_redova;i++)
<a name="7"></a><font color="#0000FF"><a href="match451-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    for(int j=0;j&lt;mat1.broj_kolona;j++)
    {
        mat3.matrica[i][j]+=mat2.matrica[i][j];
    }
    return mat3;
}
template &lt;typename Tip1,typename Tip2&gt;
auto operator -(const GMatrica&lt;Tip1&gt; &amp;mat1,const GMatrica&lt;Tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.matrica[0][0]*mat2.matrica[0][0])&gt;
</font><a name="16"></a><font color="#00FF00"><a href="match451-1.html#16" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

{
    if(!(GMatrica&lt;Tip1&gt;::SaglasneZaSabiranje(mat1,mat2))) throw std::domain_error("Nedozvoljena operacija");
</font>    if(mat1.broj_redova==0 || mat1.broj_kolona==0)
    return mat1;
    GMatrica&lt;decltype(mat1.matrica[0][0]*mat2.matrica[0][0])&gt; mat3(mat1);
<a name="2"></a><font color="#0000FF"><a href="match451-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    for(int i=0;i&lt;mat1.broj_redova;i++)
    for(int j=0;j&lt;mat1.broj_kolona;j++)
    {
        mat3.matrica[i][j]-=mat2.matrica[i][j];
    }
    return mat3;
}
template &lt;typename Tip1,typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip1&gt; &amp;mat1,const GMatrica&lt;Tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.matrica[0][0]*mat2.matrica[0][0])&gt;
</font>{
<a name="8"></a><font color="#00FFFF"><a href="match451-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

   if(!(GMatrica&lt;Tip1&gt;::SaglasneZaMnozenje(mat1,mat2))) throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(mat1.matrica[0][0]*mat2.matrica[0][0])&gt; mat3(mat1.broj_redova,mat2.broj_kolona,0);
</font>    for(int i=0;i&lt;mat1.broj_redova;i++)
    {
        for(int j=0;j&lt;mat2.broj_kolona;j++)
        {
            decltype(mat1.matrica[0][0]*mat2.matrica[0][0]) suma=decltype(mat1.matrica[0][0]*mat2.matrica[0][0])();
            for(int k=0;k&lt;mat2.broj_redova;k++)
            {
                suma+=(mat1.matrica[i][k]*mat2.matrica[k][j]);
                mat3.matrica[i][j]=suma;
            }
        }
    }
    return mat3;
}
<a name="9"></a><font color="#FF00FF"><a href="match451-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

template &lt;typename Tip1,typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip1&gt; &amp;mat,Tip2 a)-&gt;GMatrica&lt;decltype(mat.matrica[0][0]*a)&gt;
</font>{
    if(mat.broj_redova==0 || mat.broj_kolona==0) return mat;
    GMatrica&lt;decltype(mat.matrica[0][0]*a)&gt; mat2(mat);
<a name="5"></a><font color="#FF0000"><a href="match451-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    for(int i=0;i&lt;mat.broj_redova;i++)
    {
        for(int j=0;j&lt;mat.broj_kolona;j++)
        mat2.matrica[i][j]*=a;
    }
    return mat2;
}
template &lt;typename Tip1,typename Tip2&gt;
auto operator *(Tip1 a,GMatrica&lt;Tip2&gt; mat)-&gt;GMatrica&lt;decltype(mat.matrica[0][0]*a)&gt;
</font>{
    if(mat.broj_redova==0 || mat.broj_kolona==0) return mat;
    GMatrica&lt;decltype(mat.matrica[0][0]*a)&gt; mat2(mat);
    for(int i=0;i&lt;mat.broj_redova;i++)
    {
        for(int j=0;j&lt;mat.broj_kolona;j++)
        mat2.matrica[i][j]*=a;
    }
    return mat2;
}

template &lt;typename Tip&gt;
template &lt;typename Tip1&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator +=(const GMatrica&lt;Tip1&gt; &amp;mat2)
{
    if(!(GMatrica&lt;Tip1&gt;::SaglasneZaSabiranje(*this,mat2))) throw std::domain_error("Nedozvoljena operacija");
    if(this-&gt;broj_redova==0 || this-&gt;broj_kolona==0)
    return *this;
    for(int i=0;i&lt;this-&gt;broj_redova;i++)
    for(int j=0;j&lt;this-&gt;broj_kolona;j++)
    this-&gt;matrica[i][j]+=mat2.matrica[i][j];
    return *this;
}
template &lt;typename Tip&gt;
template &lt;typename Tip1&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator -=(const GMatrica&lt;Tip1&gt; &amp;mat2)
{
    if(!(GMatrica&lt;Tip1&gt;::SaglasneZaSabiranje(*this,mat2))) throw std::domain_error("Nedozvoljena operacija");
    if(this-&gt;broj_redova==0 || this-&gt;broj_kolona==0)
    return *this;
    for(int i=0;i&lt;this-&gt;broj_redova;i++)
    for(int j=0;j&lt;this-&gt;broj_kolona;j++)
    this-&gt;matrica[i][j]-=mat2.matrica[i][j];
    return *this;
}
template &lt;typename Tip&gt;
template &lt;typename Tip1&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator *=(Tip1 a)
{
    if(this-&gt;broj_redova==0 || this-&gt;broj_kolona==0)
    return *this;
    for(int i=0;i&lt;this-&gt;broj_redova;i++)
    for(int j=0;j&lt;this-&gt;broj_kolona;j++)
    (this-&gt;matrica[i][j])*=a;
    return *this;
}
template &lt;typename Tip&gt;
template &lt;typename Tip1&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator *=(const GMatrica&lt;Tip1&gt; &amp;mat2)
{
    if(!(GMatrica&lt;Tip1&gt;::SaglasneZaMnozenje(*this,mat2))) throw std::domain_error("Nedozvoljena operacija");
    if(this-&gt;broj_redova==0 || this-&gt;broj_kolona==0)
    return *this;
    GMatrica&lt;Tip&gt; mat3(this-&gt;broj_redova,mat2.broj_kolona);
    for(int i=0;i&lt;this-&gt;broj_redova;i++)
    {
        for(int j=0;j&lt;mat2.broj_kolona;j++)
        {
            Tip suma=Tip();
            for(int k=0;k&lt;mat2.broj_redova;k++)
            {
                suma+=((this-&gt;matrica[i][k])*mat2.matrica[k][j]);
                mat3.matrica[i][j]=suma;
            }
        }
    }
    *this=mat3;
    return *this;
}
<a name="10"></a><font color="#FF0000"><a href="match451-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

template&lt;typename Tip&gt;
std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok,const GMatrica&lt;Tip&gt; &amp;mat)
{
    std::streamsize velicina(tok.width());
</font>    if(velicina&lt;6) velicina=6;
    for(int i=0;i&lt;mat.broj_redova;i++)
    {
        for(int j=0;j&lt;mat.broj_kolona;j++)
        {
            tok&lt;&lt;std::setw(velicina)&lt;&lt;mat.matrica[i][j];
        }
        tok&lt;&lt;'\n';
    }
    return tok;
}
template&lt;typename Tip&gt;
std::istream &amp;operator &gt;&gt;(std::istream &amp;tok,GMatrica&lt;Tip&gt; &amp;mat1)
{
    tok&gt;&gt;std::ws;
    vector&lt;vector&lt;Tip&gt;&gt; mat;
    vector&lt;Tip&gt; vek;
    char znak='w';
    tok&gt;&gt;znak;
    if(znak!='[')
    {
    tok.setstate(std::ios::failbit);
    return tok;
    }
    else
    {
        Tip broj;
        while(tok.peek()!=']')
        {
            tok&gt;&gt;broj&gt;&gt;znak;
            if(znak!=',' &amp;&amp; znak!=';' &amp;&amp; znak!=']')
            {
            tok.setstate(std::ios::failbit);
            return tok;
            }
            vek.push_back(broj);
            if(znak==';' || znak==']')
            {
            mat.push_back(vek);
            vek.resize(0);
            }
            if(znak==']' || znak=='\n')
            break;
        }
    }
    try
    {
        GMatrica&lt;Tip&gt; nova(mat);
        mat1=nova;
    }
    catch(...)
    {
       tok.setstate(std::ios::failbit);
       return tok; 
    }
    return tok;
}
int main()
{
vector&lt;vector&lt;double&gt;&gt; vek{{1.1,1,3,4},{2,3,5.1,6},{2,5,5,5},{4,4,4,4}};
int mat[4][4]={{1,2},{6,7},{},{}};
try
{
GMatrica&lt;int&gt; mat2(mat);
GMatrica&lt;double&gt; mat1(vek);
cout&lt;&lt;"broj redova: "&lt;&lt;mat1.DajBrojRedova()&lt;&lt;" "&lt;&lt;mat1.DajBrojRedova()&lt;&lt;" broj kolona: "&lt;&lt;mat1.DajBrojKolona()&lt;&lt;" "&lt;&lt;mat2.DajBrojKolona()&lt;&lt;std::endl;
cout&lt;&lt;"mat1 i mat2: "&lt;&lt;std::endl;
cout&lt;&lt;mat1&lt;&lt;std::endl&lt;&lt;mat2;
}
catch(...)
{
    cout&lt;&lt;"izuzetak";
}
    return 0;
}</pre>
</body>
</html>
