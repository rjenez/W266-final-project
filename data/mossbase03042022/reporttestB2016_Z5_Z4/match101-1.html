<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8055.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4082.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match101-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;iomanip&gt;
template&lt;typename Tip&gt;
class GMatrica{
    Tip matrica[4][4];
    int brredova;
    int brkolona;
    public:
    GMatrica();
    GMatrica(int x, int y, Tip el=Tip());
    template&lt;typename DrugiTip&gt;
    GMatrica(GMatrica&lt;DrugiTip&gt; mat);
    template&lt;typename DrugiTip&gt;
    GMatrica(DrugiTip** niz);
    GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; vek);
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; l);
    int DajBrojRedova() const{
        return brredova;
    }
    int DajBrojKolona() const{
        return brkolona;
    }
    template&lt;typename Tip1, typename Tip2&gt;
    friend auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(Tip1()+Tip2())&gt;;
    template&lt;typename Tip1, typename Tip2&gt;
    friend auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(Tip1()-Tip2())&gt;;
    template&lt;typename Tip1, typename Tip2&gt;
    friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(Tip1()*Tip2())&gt;;
    template&lt;typename Tip1, typename Tip2&gt;
    friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, const Tip2 a) -&gt; GMatrica&lt;decltype(a*Tip1())&gt;;
    
    
    
};
    template&lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;::GMatrica(){
        brredova=0;
        brkolona=0;
    }
    template&lt;typename Tip&gt;
    GMatrica&lt;Tip&gt;::GMatrica(int x, int y, Tip el){
        if(x&lt;0 || x&gt;4 || y&lt;0 || y&gt;4) throw std::logic_error("Ilegalan format matrice");
        for(int i(0); i&lt;x; i++){
            for(int j(0); j&lt;y; j++){
                matrica[i][j]=el;
            }
        }
        
    }
    template&lt;typename Tip&gt;
    template&lt;typename DrugiTip&gt;
    GMatrica&lt;Tip&gt;:: GMatrica(GMatrica&lt;DrugiTip&gt; mat){
        for(int i(0); i&lt;mat.brredova; i++){
            for(int j(0); j&lt;mat.brkolona; j++){
                matrica[i][j]=mat.matrica[i][j];
            }
        }
        brredova=mat.brredova;
        brkolona=mat.brkolona;
        
    }
    template&lt;typename Tip&gt;
    template&lt;typename DrugiTip&gt;
     GMatrica&lt;Tip&gt;::GMatrica(DrugiTip** niz){
          for(int i(0); i&lt;4; i++){
              for(int j(0); j&lt;4; j++){
                  matrica[i][j]=niz[i][j];
              }
          }
          brredova=4;
          brkolona=4;
      }
    template&lt;typename Tip&gt;
      GMatrica&lt;Tip&gt;::GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; vek){
          if(vek.size()&lt;0 || vek.size&gt;4 || vek[0].size()&lt;0 || vek[0].size()&gt;4) throw std::logic_error("Ilegalan format matrice");
          for(int i(1); i&lt;vek.size(); i++){
              if(vek[i].size()!=vek[0].size())  throw std::logic_error("Ilegalan format matrice");
          }
          for(int i(0); i&lt;vek.size(); i++ ){
              for(int j(0); j&lt;vek[i].size(); j++){
                  matrica[i][j]=vek[i][j];
              }
          }
          brredova=vek.size();
          brkolona=vek[0].size();
      }
    template&lt;typename Tip&gt;
      GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; l){
          if(l.size()&lt;0 || l.size&gt;4) throw std::logic_error("Ilegalan format matrice");
          if((*l.begin()).size()&lt;0 || (*l.begin()).size()&gt;4) throw std::logic_error("Ilegalan format matrice");
          for(auto it=l.begin(); it!=l.end(); it++){
              if((*it).size()!=(*l.begin()).size())  throw std::logic_error("Ilegalan format matrice");
          }
          int redovi(0);
          int kolone(0);
          for(auto it=l.begin(); it!=l.end(); it++){
              for( auto it1=(*it).begin(); it1!=(*it).end(); it1++){
                  matrica[redovi++][kolone++]=*it1;
              }
      }
      
      }
        
    template&lt;typename Tip1, typename Tip2&gt;
      auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(Tip1()+Tip2())&gt;{
          if(m1.brredova!=m2.brredova || m1.brkolona!=m2.brkolona) throw std::domain_error("Nedozvoljena operacija");
          GMatrica&lt;decltype(Tip1()+Tip2())&gt; rezultat;
          for(int i(0); i&lt;m1.brredova; i++){
              for(int j(0); j&lt;m1.brkolona; j++){
                  rezultat.matrica[i][j]=m1.matrica[i][j]+m2.matrica[i][j];
              }
          }
          rezultat.brredova=m1.brredova;
          rezultat.brkolona=m1.brkolona;
          return rezultat;
          
      }
    template&lt;typename Tip1, typename Tip2&gt;
      auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(Tip1()-Tip2())&gt;{
          if(m1.brredova!=m2.brredova || m1.brkolona!=m2.brkolona) throw std::domain_error("Nedozvoljena operacija");
          GMatrica&lt;decltype(Tip1()-Tip2())&gt; rezultat;
          for(int i(0); i&lt;m1.brredova; i++){
              for(int j(0); j&lt;m1.brkolona; j++){
                  rezultat.matrica[i][j]=m1.matrica[i][j]-m2.matrica[i][j];
              }
          }
          rezultat.brredova=m1.brredova;
          rezultat.brkolona=m1.brkolona;
          return rezultat;
          
      }
    template&lt;typename Tip1, typename Tip2&gt;
    auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(Tip1()*Tip2())&gt;{
        if(m1.brkolona!=m2.brredova) throw std::domain_error("Nedozvoljena operacija");
          GMatrica&lt;decltype(Tip1()*Tip2())&gt; rezultat(m1.brredova, m2.brkolona);
          for(int i(0); i&lt;m1.brredova; i++){
              for(int j(0); j&lt;m2.brkolona; j++){
                  decltype(Tip1()*Tip2()) suma(0);
                  for(int k(0); k&lt;m1.brkolona; k++){
                      suma+=m1.matrica[i][j]*m2.matrica[j][i];
                  }
                  
                  rezultat.matrica[i][j]=suma;
              }
          }
          
          return rezultat;
        
    }
    template&lt;typename Tip1, typename Tip2&gt;
    auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, const Tip2 a) -&gt; GMatrica&lt;decltype(a*Tip1())&gt;{
         GMatrica&lt;decltype(a*Tip1())&gt; rezultat(m.brredova, m.brkolona);
          for(int i(0); i&lt;m.brredova; i++){
              for(int j(0); j&lt;m.brkolona; j++){
              
                      rezultat=a*m.matrica[i][j];
                  }
          }
          
          return rezultat;
        
    }
        
    
    
      

int main ()
</font>{
	return 0;
}</pre>
</body>
</html>
