<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6303.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6303.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match60-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_52.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
using namespace std;

template&lt;typename t&gt;
class GMatrica
{
    int r,k;
    t mat[4][4];
public:
    GMatrica(int r=0,int k=0,t n=0);
    GMatrica(GMatrica &amp;m);
    GMatrica(GMatrica &amp;&amp;m);
    GMatrica(const vector&lt;vector&lt;t&gt;&gt;&amp;v);
    GMatrica(const initializer_list&lt;initializer_list&lt;t&gt;&gt;&amp;l);
    int DajBrojRedova()const{return r;}
    int DajBrojKolona()const{return k;}
    GMatrica(t &amp;n)
    {
        r=4;k=4;
        for(int i=0;i&lt;4;i++)
            for(int j=0;j&lt;4;j++)
                mat[i][j]=n;
    }
    template&lt;typename t1,typename t2&gt;
    friend GMatrica&lt;decltype(t1()+t2())&gt;operator+(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2);
    GMatrica &amp;operator+=(GMatrica&lt;t&gt; &amp;m);
    template&lt;typename t1,typename t2&gt;
    friend GMatrica&lt;decltype(t1()+t2())&gt;operator-(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2);
    GMatrica &amp;operator-=(GMatrica&lt;t&gt; &amp;m);
    template&lt;typename t1,typename t2&gt;
    friend GMatrica&lt;decltype(t1()+t2())&gt;operator*(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2);
    GMatrica &amp;operator*=(GMatrica&lt;t&gt; &amp;m);
    template&lt;typename t1,typename t2&gt;
    friend GMatrica&lt;decltype(t1()+t2())&gt;operator*(GMatrica&lt;t1&gt;&amp;m1,const t2 &amp;n);
    template&lt;typename t1,typename t2&gt;
    friend GMatrica&lt;decltype(t1()+t2())&gt;operator*(const t1 &amp;n,GMatrica&lt;t2&gt;&amp;m1);
    GMatrica &amp;operator*=(const t &amp;n);
    t operator()(int i,int j) const
    {
        if(i&lt;=0 || j&lt;=0) throw range_error("Nedozvoljen indeks");
        return mat[i-1][j-1];
    }
    t &amp;operator()(int i,int j)
    {
        return mat[i-1][j-1];
    }
    
    t *operator[](const int &amp;i) const
    {
        return mat[i];
    }
    t *operator[](const int &amp;i)
    {
        return mat[i];
    }
    
    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout,GMatrica&lt;t&gt; m)
    {   
        streamsize n;        
        if(cout.width()==0) n=6;
        else  n=cout.width();
        for(int i=0;i&lt;m.r;i++)
        {
            for(int j=0;j&lt;m.k;j++)
                cout&lt;&lt;setw(n)&lt;&lt;m.mat[i][j];
            cout&lt;&lt;endl;
        }        
        return cout;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;cin,GMatrica&lt;t&gt; &amp;m)
    {
        int a=0;int n=0;
        char c;
        cin&gt;&gt;c;
        if(c=='[')
            while(c!=']')
            {   
                cin&gt;&gt;m.mat[a][n]&gt;&gt;c;
                if(c==',')n++;
                else if(c==';'){a++;n=0;}
                else break;
            }
        m.r=a+2-1;m.k=n+2-1;
        return cin;
    }
    template&lt;typename t1,typename t2&gt;
    friend bool operator==(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2);
    template&lt;typename t1,typename t2&gt;
    friend bool operator!=(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2);
};


template&lt;typename t1&gt;
GMatrica&lt;t1&gt;::GMatrica(int red,int kol,t1 n)
    {
       if(red&lt;0 || red&gt;4 || kol&lt;0 || kol&gt;4) throw logic_error("Ilegalan format matrice");
        r=red;k=kol;
        for(int i=0;i&lt;r;i++)
            for(int j=0;j&lt;k;j++)
                mat[i][j]=n;
    
    }
template&lt;typename t1&gt;
GMatrica&lt;t1&gt;::GMatrica(GMatrica&lt;t1&gt; &amp;m)
    {
        r=m.r;
        k=m.k;
        for(int i=0;i&lt;r;i++)
            for(int j=0;j&lt;k;j++)
                GMatrica::mat[i][j]=m.mat[i][j];
    }
    

template&lt;typename t1&gt;
GMatrica&lt;t1&gt;::GMatrica(GMatrica&lt;t1&gt; &amp;&amp;m)
    {
        r=m.r;
        k=m.k;
        for(int i=0;i&lt;r;i++)
            for(int j=0;j&lt;k;j++)
                GMatrica::mat[i][j]=m.mat[i][j];
    }
template&lt;typename t1&gt;
GMatrica&lt;t1&gt;::GMatrica(const vector&lt;vector&lt;t1&gt;&gt; &amp;v)
{       
    
    if(v.size()&gt;4) throw logic_error("Ilegalan format matrice");
    for(int i=0; i&lt;v.size(); i++) if(v[i].size()!=v[0].size() || v[i].size()&gt;4) throw logic_error("Ilegalan format matrice");
    r=v.size();
    k=v[0].size();
    for(int i=0;i&lt;r;i++)
        for(int j=0;j&lt;k;j++)
            GMatrica::mat[i][j]=v[i][j];
} 
template&lt;typename t1&gt;
GMatrica&lt;t1&gt;::GMatrica(const initializer_list&lt;initializer_list&lt;t1&gt;&gt; &amp;l)
{       
    int br=0;
    for(auto x:l) br++;
    if(br&gt;4)throw logic_error("Ilegalan format matrice");
    for(auto x:l)
    {
        br=0;
        for(auto y:x) br++;
        if(br&gt;4) throw logic_error("Ilegalan format matrice");
    }
    auto it=l.begin();
    r=l.begin()-&gt;size();
    k=it-&gt;size();
    int x=0;
    for(auto i=l.begin();i!=l.end();i++)
    {   
        int y=0;
        for(auto j=i-&gt;begin();j!=i-&gt;end();j++)
             {mat[x][y]=*j; y++; }
        x++;
    }
        
}

template&lt;typename t1,typename t2&gt;
GMatrica&lt;decltype(t1()+t2())&gt;operator+(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2)
{   
    if(m1.k!=m2.k || m1.r!=m2.r) throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(t1()+t2())&gt; m(m1.r,m1.k);
    for(int i=0;i&lt;m.r;i++)
        for(int j=0;j&lt;m.k;j++)
</font><a name="3"></a><font color="#00FFFF"><a href="match60-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_8.gif"/></a>

            m.mat[i][j]=m1.mat[i][j]+m2.mat[i][j];
    return m;
}    

template&lt;typename t1&gt;
GMatrica&lt;t1&gt; &amp;GMatrica&lt;t1&gt;::operator+=(GMatrica&lt;t1&gt; &amp;m)
{
    if(k!=m.k || r!=m.r) throw domain_error("Nedozvoljena operacija");
    for(int i=0;i&lt;m.r;i++)
        for(int j=0;j&lt;m.k;j++)
            mat[i][j]=mat[i][j]+m.mat[i][j];
    return *this;
} 

template&lt;typename t1,typename t2&gt;
GMatrica&lt;decltype(t1()+t2())&gt;operator-(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2)
{
    if(m1.k!=m2.k || m1.r!=m2.r) throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(t1()+t2())&gt; m(m1.r,m1.k);
    for(int i=0;i&lt;m.r;i++)
        for(int j=0;j&lt;m.k;j++)
</font><a name="1"></a><font color="#00FF00"><a href="match60-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

            m.mat[i][j]=m1.mat[i][j]-m2.mat[i][j];
    return m;
}    

template&lt;typename t1&gt;
GMatrica&lt;t1&gt; &amp;GMatrica&lt;t1&gt;::operator-=(GMatrica&lt;t1&gt; &amp;m)
{
    if(k!=m.k || m.r!=r) throw domain_error("Nedozvoljena operacija");
    for(int i=0;i&lt;m.r;i++)
        for(int j=0;j&lt;m.k;j++)
            mat[i][j]=mat[i][j]-m.mat[i][j];
    return *this;
}
 
template&lt;typename t1,typename t2&gt;
GMatrica&lt;decltype(t1()+t2())&gt;operator*(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2)
{

    if(m1.k!=m2.r || m1.r!=m2.k) throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(t1()+t2())&gt; m(m1.r,m1.k);
    for(int i=0;i&lt;m.r;i++)
        for(int j=0;j&lt;m.k;j++)
        {   m.mat[i][j]=0;
            for(int k=0;k&lt;m.k;k++)
              m.mat[i][j]+=m1.mat[i][k]*m2.mat[k][j];
        }
    return m;
}    

template&lt;typename t1,typename t2&gt;
GMatrica&lt;decltype(t1()+t2())&gt;operator*(GMatrica&lt;t1&gt;&amp;m1,const t2 &amp;n)
{
   GMatrica&lt;decltype(t1()+t2())&gt; m(m1.DajBrojRedova(),m1.DajBrojKolona());
    for(int i=0;i&lt;m.DajBrojRedova();i++)
        for(int j=0;j&lt;m.DajBrojKolona();j++)
</font><a name="4"></a><font color="#FF00FF"><a href="match60-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

            m.mat[i][j]=m1.mat[i][j]*n;
    return m;
}
template&lt;typename t1,typename t2&gt;
GMatrica&lt;decltype(t1()+t2())&gt;operator*(const t1 &amp;n,GMatrica&lt;t2&gt;&amp;m1)
{
    GMatrica&lt;decltype(t1()+t2())&gt; m(m1.DajBrojRedova(),m1.DajBrojKolona());
    for(int i=0;i&lt;m.DajBrojRedova();i++)
        for(int j=0;j&lt;m.DajBrojKolona();j++)
</font><a name="5"></a><font color="#FF0000"><a href="match60-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

            m.mat[i][j]=m1.mat[i][j]*n;
    return m;
}

 template&lt;typename t1,typename t2&gt;
 bool operator==(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2)
 {
     if(m1.r!=m2.r || m1.k!=m2.k) return false;
     for(int i=0;i&lt;m1.r;i++)
</font>        for(int j=0;j&lt;m1.k;j++)
<a name="2"></a><font color="#0000FF"><a href="match60-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_12.gif"/></a>

            if(m1.mat[i][j]!=m2.mat[i][j]) return false;
        return true;
 }
template&lt;typename t1,typename t2&gt;
bool operator!=(GMatrica&lt;t1&gt;&amp;m1,GMatrica&lt;t2&gt;&amp;m2)
{
    return !(m1==m2);
}

template&lt;typename t1&gt;
GMatrica&lt;t1&gt; &amp;GMatrica&lt;t1&gt;::operator*=(GMatrica&lt;t1&gt; &amp;m)
{
    for(int i=0;i&lt;m.r;i++)
        for(int j=0;j&lt;m.k;j++)
        {   mat[i][j]=0;
            for(int k=0;k&lt;m.k;k++)
                mat[i][j]+=mat[i][k]*m.mat[k][j];
        }
    return *this;
}
template&lt;typename t1&gt;
GMatrica&lt;t1&gt; &amp;GMatrica&lt;t1&gt;::operator*=(const t1 &amp;n)
{
  for(int i=0;i&lt;r;i++)
    for(int j=0;j&lt;k;j++)
        mat[i][j]=mat[i][j]*n;
    return *this;
}
int main ()
{  
   
   GMatrica&lt;double&gt; m1({{1, 2}, {3, 4}});
   GMatrica&lt;double&gt; m2({{1, 2}, {3, 4}});
   auto m3 = m1 + m2;
   std::cout &lt;&lt; m3 &lt;&lt; std::endl;
   GMatrica&lt;double&gt; m4({{1, 2}, {3, 4}});
   auto m5 = m3-m4;
   std::cout &lt;&lt; m5 &lt;&lt; std::endl;
</font>	
	return 0;
}</pre>
</body>
</html>
