<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8964.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4973.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match63-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_88.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;

using namespace std;

template &lt;typename Tip&gt;
class GMatrica
{
    Tip podaci[4][4];
    int br_redova,br_kolona;

public:
    GMatrica() {};
    GMatrica(int br_redova,int br_kolona,Tip vrijednost=0);
    GMatrica(const GMatrica&lt;Tip&gt;&amp;m);
    GMatrica(Tip vrijednost):
        br_redova(4),br_kolona(4) {
        fill(&amp;(podaci[0][0]),&amp;(podaci[3][3])+1,vrijednost);
    }
    GMatrica(vector&lt;vector&lt;Tip&gt;&gt;m);
    GMatrica(initializer_list&lt;GMatrica&lt;Tip&gt;&gt;lista);

    int DajBrojRedova() const {
        return br_redova;
    }
    int DajBrojKolona() const {
        return br_kolona;
    }
    template&lt;typename Tip2,typename Tip3&gt;
    friend GMatrica&lt;decltype(Tip3()+Tip2())&gt;operator+(const GMatrica&lt;Tip2&gt;&amp;m1,const GMatrica&lt;Tip3&gt;&amp;m2);
    template&lt;typename Tip2,typename Tip3&gt;
    friend GMatrica&lt;decltype(Tip3()-Tip2())&gt;operator-(const GMatrica&lt;Tip2&gt;&amp;m1,const GMatrica&lt;Tip3&gt;&amp;m2);
    template&lt;typename Tip2,typename Tip3&gt;
    friend GMatrica&lt;decltype(Tip3()*Tip2())&gt;operator*(const GMatrica&lt;Tip2&gt;&amp;m1,const GMatrica&lt;Tip3&gt;&amp;m2);
    template&lt;typename Tip2,typename Tip3&gt;
    friend GMatrica&lt;decltype(Tip3()*Tip2())&gt;operator*(const GMatrica&lt;Tip2&gt;&amp;m,Tip3 k);
    template&lt;typename Tip2,typename Tip3&gt;
    friend GMatrica&lt;decltype(Tip3()*Tip2())&gt;operator*(Tip3 k,const GMatrica &amp;m);

    GMatrica &amp;operator+=(const GMatrica&lt;Tip&gt;&amp;m);
    GMatrica &amp;operator-=(const GMatrica&lt;Tip&gt;&amp;m);
    GMatrica &amp;operator*=(const GMatrica&lt;Tip&gt;&amp;m);

    template&lt;typename Tip2,typename Tip3&gt;
    friend bool operator==(const GMatrica&lt;Tip2&gt;&amp;m1,const GMatrica&lt;Tip3&gt;&amp;m2);
    template&lt;typename Tip2,typename Tip3&gt;
    friend bool operator!=(const GMatrica&lt;Tip2&gt;&amp;m,const GMatrica&lt;Tip&gt;&amp;m2);

    Tip operator()(int i,int j) const {
        if(i&lt;1 || i&gt;br_redova || j&lt;1 || j&gt;br_kolona)
            throw range_error("Nedozvoljen indeks");
        return podaci[i-1][j-1];
    }
    Tip&amp; operator()(int i,int j) {
        if(i&lt;1 || i&gt;br_redova || j&lt;1 || j&gt;br_kolona)
            throw range_error("Nedozvoljen indeks");
        return podaci[i-1][j-1];
    }

    vector&lt;Tip&gt;operator [](int i)const {
        return podaci[i];
    }
    vector&lt;Tip&gt;&amp;operator [](int i) {
        return podaci[i];
    }

    template&lt;typename Tip1&gt;
    friend ostream&amp; operator&lt;&lt;(ostream &amp;tok,const GMatrica&lt;Tip&gt;&amp;m)
    {
    auto x=tok.width();
    for(int i=0; i&lt;m.DajBrojRedova(); i++) {
        for(int j=0; j&lt;m.DajBrojKolona(); j++) {
            tok&lt;&lt;setw(6)&lt;&lt;m.podaci[i][j];
            tok&lt;&lt;"\n";
        }
    }
    return tok;
}
    template&lt;typename Tip1&gt;
    friend istream&amp; operator&gt;&gt;(istream &amp;tok,const GMatrica&lt;Tip1&gt;&amp;m);


};


template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int br_redova,int br_kolona,Tip vrijednost):
    br_redova(br_redova),br_kolona(br_kolona)
{
    if(br_redova&lt;0 || br_redova&gt;4 || br_kolona&lt;0 || br_kolona&gt;4) throw logic_error("Ilegalan format matrice");
    fill(&amp;(podaci[0][0]),&amp;(podaci[3][3])+1,vrijednost);
    for(int i=0; i&lt;br_redova; i++) {
        for(int j=0; j&lt;br_kolona; j++) {
            podaci[i][j]=vrijednost;
        }
    }
}

template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(vector&lt;vector&lt;Tip&gt;&gt;m)
{
    for(int i=0; i&lt;m.size(); i++) {
        for(int j=0; j&lt;m[0].size()-1; j++) {
            if(m.size()&lt;0 || m.size()&gt;4 || m[j].size()!=m[j+1].size()) throw logic_error("Ilegalan format matrice");
            break;
        }
    }
br_redova=m.size(); br_kolona=m[0].size();
    for(int i=0; i&lt;DajBrojRedova(); i++) {
        for(int j=i; j&lt;DajBrojKolona(); j++) {
            podaci[i][j]=m[i][j];
        }
    }
}

/*
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(initializer_list&lt;GMatrica&lt;Tip&gt;&gt;lista)
{
    for(auto it=lista.begin(); it!=lista.end(); it++) {
        auto it1=it;
        it1++;
        for(; it1!=lista.end(); it1++) {
            if(it&lt;0 || it&gt;4 || (it-&gt;size()!=it1-&gt;size()))
            }
    }
    for(int it=lista.begin(); it!=lista.end(); it++) {
        podaci=*(it);
    }
}

*/

template&lt;typename Tip2,typename Tip3&gt;
GMatrica&lt;decltype(Tip3()+Tip2())&gt;operator+(const GMatrica&lt;Tip2&gt;&amp;m1,const GMatrica&lt;Tip3&gt;&amp;m2)
{
    if(m1.DajBrojKolona()!=m2.DajBrojKolona() || m1.DajBrojRedova()!=m2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");

    auto x=m1.podaci[0][0]+m2.podaci[0][0];
    vector&lt;vector&lt;decltype(x)&gt;&gt;mat;
    mat.resize(m1.DajBrojKolona());

    for(int i=0; i&lt;m1.DajBrojRedova(); i++) {
        for(int j=0; j&lt;m1.DajBrojKolona(); j++) {
            mat[i].push_back(m1.podaci[i][j]+m2.podaci[i][j]);
        }
    }
    GMatrica&lt;decltype(x)&gt;m(mat);
    return m;
}

template&lt;typename Tip2,typename Tip3&gt;
GMatrica&lt;decltype(Tip3()-Tip2())&gt;operator-(const GMatrica&lt;Tip2&gt;&amp;m1,const GMatrica&lt;Tip3&gt;&amp;m2)
{
    if(m1.DajBrojKolona()!=m2.DajBrojKolona() || m1.DajBrojRedova()!=m2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");

    auto x=m1.podaci[0][0]+m2.podaci[0][0];
    vector&lt;vector&lt;decltype(x)&gt;&gt;mat;
    mat.resize(m1.DajBrojRedova());
    for(int i=0; i&lt;m1.DajBrojRedova(); i++) {
        for(int j=0; j&lt;m1.DajBrojKolona(); j++) {
            mat[i].push_back(m1.podaci[i][j]-m2.podaci[i][j]);
        }
    }
    GMatrica&lt;decltype(x)&gt;m(mat);

    return m;
}

template&lt;typename Tip2,typename Tip3&gt;
GMatrica&lt;decltype(Tip3()*Tip2())&gt;operator*(const GMatrica&lt;Tip2&gt;&amp;m1,const GMatrica&lt;Tip3&gt;&amp;m2)
{
    if(m1.DajBrojKolona()!=m2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");

    auto x=m1.podaci[0][0]*m2.podaci[0][0];
    vector&lt;vector&lt;decltype(x)&gt;&gt;mat;
    mat.resize(m1.DajBrojRedova());

    for(int i=0; i&lt;m1.DajBrojRedova(); i++) {
        mat[i].resize(m2.DajBrojKolona());
        for(int j=0; j&lt;m2.DajBrojKolona(); j++) {
            for(int k=0; k&lt;m1.DajBrojKolona(); k++) {
                mat.podaci[i][j]+=m1.podaci[i][k]*m2.podaci[k][j];
            }
        }
    }
    GMatrica&lt;decltype(x)&gt;m(mat);
    return m;
}

template&lt;typename Tip2,typename Tip3&gt;
GMatrica&lt;decltype(Tip3()*Tip2())&gt;operator*(const GMatrica&lt;Tip2&gt;&amp;m1,Tip3 m2)
{

    auto x=m1.podaci[0][0]*m2;
    vector&lt;vector&lt;decltype(x)&gt;&gt;mat;
    mat.resize(m1.DajBrojRedova());
    for(int i=0; i&lt;m1.DajBrojRedova(); i++) {
        for(int j=0; j&lt;m1.DajBrojKolona(); j++) {
            mat.podaci[i][j]=m1.podaci[i][j]*m2;
        }
    }
    GMatrica&lt;decltype(x)&gt;m(mat);
    return m;
}

template&lt;typename Tip2,typename Tip3&gt;
GMatrica&lt;decltype(Tip3()*Tip2())&gt;operator*(Tip3 m2,const GMatrica&lt;Tip2&gt;&amp;m1)
{
    auto x=m1.podaci[0][0]*m2;
    vector&lt;vector&lt;decltype(x)&gt;&gt;mat;
    mat.resize(m1.DajBrojRedova());
    for(int i=0; i&lt;m1.DajBrojRedova(); i++) {
        for(int j=0; j&lt;m1.DajBrojKolona(); j++) {
            mat.podaci[i][j]=m1.podaci[i][j]*m2;
        }
    }
    GMatrica&lt;decltype(x)&gt;m(mat);
    return m;

}

template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;&amp;GMatrica&lt;Tip&gt;::operator+=(const GMatrica&lt;Tip&gt;&amp;m)
{
    if(DajBrojKolona()!=m.DajBrojKolona() || DajBrojRedova()!=m.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    for(int i=0; i&lt;DajBrojRedova(); i++) {
        for(int j=0; j&lt;DajBrojKolona(); j++) {
            podaci[i][j]+=m.podaci[i][j];
        }
    }
    return *this;
}

template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;&amp;GMatrica&lt;Tip&gt;::operator-=(const GMatrica&lt;Tip&gt;&amp;m)
{
    if(DajBrojKolona()!=m.DajBrojKolona() || DajBrojRedova()!=m.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    for(int i=0; i&lt;DajBrojRedova(); i++) {
        for(int j=0; j&lt;DajBrojKolona(); j++) {
            podaci[i][j]-=m.podaci[i][j];
        }
    }
    return *this;
}

template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;&amp;GMatrica&lt;Tip&gt;::operator*=(const GMatrica&lt;Tip&gt;&amp;m)
{
    if(DajBrojKolona()!=m.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    for(int i=0; i&lt;DajBrojRedova(); i++) {
        for(int j=0; j&lt;m.DajBrojKolona(); j++) {
            podaci[i][j]=0;
            for(int k=0; k&lt;DajBrojKolona(); k++) {
                podaci[i][j]+=podaci[i][k]*m.podaci[k][j];
            }
        }
    }
    return *this;
}

template&lt;typename Tip2,typename Tip3&gt;
bool operator==(const GMatrica&lt;Tip2&gt;&amp;m1,const GMatrica&lt;Tip3&gt;&amp;m2)
{
    if(m1.DajBrojKolona()!=m2.DajBrojKolona() || m1.DajBrojRedova()!=m2.DajBrojRedova()) return false;
</font>
    for(int i=0; i&lt;m1.DajBrojRedova(); i++) {
        for(int j=0; j&lt;m2.DajBrojKolona(); j++) {
<a name="1"></a><font color="#00FF00"><a href="match63-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

            if(m1.podaci[i][j]!=m2.podaci[i][j])
                return false;
        }
    }
    return true;
}

template&lt;typename Tip&gt;
bool operator!=(const GMatrica&lt;Tip&gt;&amp;m1,const GMatrica&lt;Tip&gt;&amp;m2)
{
    return!(m1==m2);
}




template&lt;typename Tip1&gt;
istream &amp;operator &gt;&gt;(istream &amp;tok, GMatrica&lt;Tip1&gt;&amp;m)
{

    for(int i=0; i&lt;m.DajBrojRedova(); i++) {
        tok&gt;&gt;ws;
        for(int j=0; j&lt;m.DajBrojKolona(); j++) {
            tok&gt;&gt;m.podaci[i][j];
        }
    }
}


int main ()
{
   GMatrica&lt;double&gt; m1({{1, 2}, {3, 4}});
   GMatrica&lt;double&gt; m2({{1, 2}, {3, 4}});
   auto m3 = m1 + m2;
   std::cout &lt;&lt; m3 &lt;&lt; std::endl;
   GMatrica&lt;double&gt; m4({{1, 2}, {3, 4}});
   auto m5 = m3-m4;
   std::cout &lt;&lt; m5 &lt;&lt; std::endl;
</font>    return 0;
}</pre>
</body>
</html>
