<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8957.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5475.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
#include &lt;initializer_list&gt;

<a name="0"></a><font color="#FF0000"><a href="match633-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

template&lt;typename Tip&gt;
class GMatrica {
    int br_redova, br_kolona;
    Tip pok[4][4];
public:
    GMatrica();
    GMatrica(int br_redova, int br_kolona, Tip n = Tip());
    template&lt;typename Tip2&gt;
    GMatrica(const GMatrica&lt;Tip2&gt; &amp;m1);
    template&lt;typename Tip2&gt;
    GMatrica(Tip2 mat[4][4]);
    GMatrica(const std::vector&lt;std::vector&lt;Tip&gt;&gt; &amp;v);
</font>    GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; l);
    int DajBrojRedova() const { return br_redova; }
    int DajBrojKolona() const { return br_kolona; }
    //operatori funkcije clanice
    template&lt;typename Tip2&gt;
    GMatrica &amp;operator +=(const GMatrica&lt;Tip2&gt; &amp;m1); 
    template&lt;typename Tip2&gt;
    GMatrica &amp;operator -=(const GMatrica&lt;Tip2&gt; &amp;m1); 
    template&lt;typename Tip2&gt;
    GMatrica &amp;operator *=(Tip2 n); 
    template&lt;typename Tip2&gt;
    GMatrica&lt;Tip&gt; &amp;operator *=(const GMatrica&lt;Tip2&gt; &amp;m1);
    Tip &amp;operator ()(int red, int kol);
    Tip operator ()(int red, int kol) const;
<a name="7"></a><font color="#0000FF"><a href="match633-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    Tip operator [](int n) const;
    Tip *operator [](int n);
    //friend operatori
    template&lt;typename Tip2, typename Tip3&gt;
    friend auto operator +(const GMatrica&lt;Tip2&gt; &amp;m1, const GMatrica&lt;Tip3&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.pok[0][0] + m2.pok[0][0])&gt;;
</font>    template&lt;typename Tip2, typename Tip3&gt;
    friend auto operator -(const GMatrica&lt;Tip2&gt; &amp;m1, const GMatrica&lt;Tip3&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.pok[0][0] - m2.pok[0][0])&gt;;
    template&lt;typename Tip2, typename Tip3&gt;
    friend auto operator *(const GMatrica&lt;Tip2&gt; &amp;m1, const GMatrica&lt;Tip3&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.pok[0][0] * m2.pok[0][0])&gt;;
    template&lt;typename Tip2, typename Tip3&gt;
<a name="10"></a><font color="#FF0000"><a href="match633-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    friend auto operator *(const GMatrica&lt;Tip2&gt; &amp;m1, Tip3 n) -&gt; GMatrica&lt;decltype(m1.pok[0][0] * n)&gt;;
    template&lt;typename Tip2, typename Tip3&gt;
    friend auto operator *(Tip3 n, const GMatrica&lt;Tip2&gt; &amp;m1) -&gt; GMatrica&lt;decltype(n * m1.pok[0][0])&gt;;
</font>    template&lt;typename Tip2&gt;
    friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip2&gt; &amp;m);
    template&lt;typename Tip2&gt;
    friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip2&gt; &amp;m);
<a name="2"></a><font color="#0000FF"><a href="match633-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    template&lt;typename Tip2&gt;
    friend bool operator ==(const GMatrica&lt;Tip2&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
    template&lt;typename Tip2&gt;
    friend bool operator !=(const GMatrica&lt;Tip2&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
};
template&lt;typename Tip&gt;
</font>GMatrica&lt;Tip&gt;::GMatrica() : br_redova(0), br_kolona(0) {}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int br_r, int br_k, Tip n) {
    if(br_r &gt; 4 || br_r &lt; 0 || br_k &gt; 4 || br_k &lt; 0)
        throw std::logic_error("Ilegalan format matrice");
    br_redova = br_r; br_kolona = br_k; 
        for(int i=0; i&lt;br_redova; i++)
            for(int j=0; j&lt;br_kolona; j++)
<a name="11"></a><font color="#00FF00"><a href="match633-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

                pok[i][j] = n;
}
template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;Tip2&gt; &amp;m1) {
</font>    if(m1.DajBrojRedova() &gt; 4 || m1.DajBrojRedova() &lt; 0 || m1.DajBrojKolona() &gt; 4 || m1.DajBrojKolona() &lt; 0)
        throw std::logic_error("Ilegalan format matrice");
    br_redova = m1.DajBrojRedova(); br_kolona = m1.DajBrojKolona(); 
<a name="1"></a><font color="#00FF00"><a href="match633-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        for(int i=0; i&lt;br_redova; i++)
            for(int j=0; j&lt;br_kolona; j++) 
                pok[i][j] = m1(i+1, j+1);
}
template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;::GMatrica(Tip2 mat[4][4]) {
</font>    br_redova = 4; br_kolona = 4;
    for(int i=0; i&lt;4; i++)
        for(int j=0; j&lt;4; j++)
            pok[i][j] = mat[i][j];
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(const std::vector&lt;std::vector&lt;Tip&gt;&gt; &amp;v) {
    if(v.size() == 0) return;
    if(v.size() != 0 &amp;&amp; v.size() &gt; 4)
        throw std::logic_error("Ilegalan format matrice");
    for(int i=0; i&lt;v.size(); i++)
        for(int j=0; j&lt;v.size(); j++)
            if(v[i].size() != v[j].size()) throw std::logic_error("Ilegalan format matrice");
    br_redova = v.size(); br_kolona = v[0].size();
    for(int i=0; i&lt;v.size(); i++)
        for(int j=0; j&lt;v.size(); j++)
            pok[i][j] = v[i][j];
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; l) {
    if(l.size() == 0) return;
    if(l.size() != 0 &amp;&amp; l.size() &gt; 4)
        throw std::logic_error("Ilegalan format matrice");
    for(auto red: l)
        for(auto red2 : l)
            if(red.size() != red2.size()) throw std::logic_error("Ilegalan format matrice");
    br_redova = l.size(); br_kolona = l.begin()-&gt;size();
    int i(0), j(0);
    for(auto red : l) {
        for(auto el: red) {
            pok[i][j] = el;
            j++;
        }
        j = 0; i++;
    }
}
template&lt;typename Tip, typename Tip2&gt;
auto operator +(const GMatrica&lt;Tip&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.pok[0][0] + m2.pok[0][0])&gt; {
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona) 
        throw std::domain_error("Nedozvoljena operacija");
    try {
        GMatrica&lt;decltype(m1.pok[0][0] + m2.pok[0][0])&gt; m(m1.br_redova, m1.br_kolona);
        for(int i=0; i&lt;m1.br_redova; i++)
            for(int j=0; j&lt;m1.br_kolona; j++)
                m.pok[i][j] = m1.pok[i][j] + m2.pok[i][j];
        return m;
    }
    catch(...) {
        throw std::domain_error("Nedozvoljena operacija");
    }
}
template&lt;typename Tip, typename Tip2&gt;
auto operator -(const GMatrica&lt;Tip&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.pok[0][0] - m2.pok[0][0])&gt; {
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona) 
        throw std::domain_error("Nedozvoljena operacija");
    try {
        GMatrica&lt;decltype(m1.pok[0][0] - m2.pok[0][0])&gt; m(m1.br_redova, m1.br_kolona);
        for(int i=0; i&lt;m1.br_redova; i++)
            for(int j=0; j&lt;m1.br_kolona; j++)
                m.pok[i][j] = m1.pok[i][j] - m2.pok[i][j];
        return m;
    }
    catch(...) {
        throw std::domain_error("Nedozvoljena operacija");
    }
}
template&lt;typename Tip, typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1.pok[0][0] * m2.pok[0][0])&gt; {
    if(m1.br_kolona != m2.br_redova)
        throw std::domain_error("Nedozvoljena operacija");
    try {
<a name="12"></a><font color="#0000FF"><a href="match633-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

        GMatrica&lt;decltype(m1.pok[0][0] * m2.pok[0][0])&gt; m(m1.br_redova, m2.br_kolona);
        for(int i=0; i&lt;m1.br_redova; i++)
            for(int j=0; j&lt;m2.br_kolona; j++)
                for(int k=0; k&lt;m1.br_kolona; k++)
</font>                    m.pok[i][j] += m1.pok[i][k] * m2.pok[k][j];
        return m;
    }
    catch(...) {
        throw std::domain_error("Nedozvoljena operacija");
    }
}
template&lt;typename Tip, typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip&gt; &amp;m1, Tip2 n) -&gt; GMatrica&lt;decltype(m1.pok[0][0] * n)&gt; {
    try {
        GMatrica&lt;decltype(m1.pok[0][0] * n)&gt; m(m1.br_redova, m1.br_kolona);
        for(int i=0; i&lt;m1.br_redova; i++)
            for(int j=0; j&lt;m1.br_kolona; j++)
                m.pok[i][j] = m1.pok[i][j] * n;
        return m;
    }
    catch(...) {
        throw std::domain_error("Nedozvoljena operacija");
    }
}
<a name="13"></a><font color="#00FFFF"><a href="match633-0.html#13" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

template&lt;typename Tip, typename Tip2&gt;
auto operator *(Tip2 n, const GMatrica&lt;Tip&gt; &amp;m1) -&gt; GMatrica&lt;decltype(n * m1.pok[0][0])&gt; {
</font>    try {
        GMatrica&lt;decltype(m1.pok[0][0] * n)&gt; m(m1.br_redova, m1.br_kolona);
        m = m1 * n;
        return m;
    }
    catch(...) {
        throw std::domain_error("Nedozvoljena operacija");
    }
} 
template&lt;typename Tip&gt;
Tip &amp;GMatrica&lt;Tip&gt;::operator ()(int red, int kol) {
    if(red &lt; 1 || red &gt; 4 || kol &lt; 1 || kol &gt; 4)
<a name="6"></a><font color="#00FF00"><a href="match633-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        throw std::range_error("Nedozvoljen indeks");
    return pok[red-1][kol-1];
}
template&lt;typename Tip&gt;
Tip GMatrica&lt;Tip&gt;::operator ()(int red, int kol) const {
    if(red &lt; 1 || red &gt; 4 || kol &lt; 1 || kol &gt; 4)
</font>        throw std::range_error("Nedozvoljen indeks");
    return pok[red-1][kol-1];
}
template&lt;typename Tip&gt;
Tip *GMatrica&lt;Tip&gt;::operator [](int n) {
    return &amp;pok[n][0];
}
template&lt;typename Tip&gt;
Tip GMatrica&lt;Tip&gt;::operator [](int n) const {
    return pok[n];
}
template&lt;typename Tip&gt;
std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip&gt; &amp;m1) {
    GMatrica&lt;Tip&gt; m;
    m.br_kolona++; m.br_redova++;
    char zagrada;
    tok &gt;&gt; zagrada;
    if(zagrada != '[') {
        tok.setstate(std::ios::failbit);
        return tok;
    }
    for(int i=0; i&lt;m.br_redova; i++) {
        bool novi_red(false);
        if(m.br_redova &gt; 4) {
            tok.setstate(std::ios::failbit);
        return tok;
        }
        for(int j=0; j&lt;m.br_kolona; j++) {
            if(m.br_kolona &gt; 4) {
                tok.setstate(std::ios::failbit);
                return tok;
            }
            char znak;
            tok &gt;&gt; m.pok[i][j] &gt;&gt; znak;
            if(znak == ';') { novi_red = true; break;}
            else if(znak == ',') {
                if(i == 0) m.br_kolona++;
                else continue;
            }
            else if(znak == ']') break;
            else {
                tok.setstate(std::ios::failbit);
                return tok;
            }
        }
        if(novi_red) m.br_redova++;
    }
    if(m1.br_redova != 0 &amp;&amp; m1.br_kolona != 0 &amp;&amp; (m1.br_redova != m.br_redova || m1.br_kolona != m.br_kolona)) {
        tok.setstate(std::ios::failbit);
        return tok;
    }
    else m1 = m;
    return tok;
}
template&lt;typename Tip&gt;
std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip&gt; &amp;m) {
    int sirina(std::cout.width());
    if(sirina &lt; 6) sirina = 6;
    for(int i=0; i&lt;m.br_redova; i++) {
        for(int j=0; j&lt;m.br_kolona; j++)
            tok &lt;&lt; std::setw(sirina) &lt;&lt; m.pok[i][j];
        tok &lt;&lt; std::endl;
    }
<a name="8"></a><font color="#00FFFF"><a href="match633-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    return tok;
}
template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator +=(const GMatrica&lt;Tip2&gt; &amp;m1) {
</font>    if(m1.DajBrojRedova() != br_redova || m1.DajBrojKolona() != br_kolona) 
        throw std::domain_error("Nedozvoljena operacija");
    try {
<a name="3"></a><font color="#00FFFF"><a href="match633-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        for(int i=0; i&lt;m1.DajBrojRedova(); i++)
            for(int j=0; j&lt;m1.DajBrojKolona(); j++)
                pok[i][j] += m1(i+1,j+1);
        return *this;
    }
    catch(...) {
</font>        throw std::domain_error("Nedozvoljena operacija");
    }
}
<a name="14"></a><font color="#FF00FF"><a href="match633-0.html#14" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator -=(const GMatrica&lt;Tip2&gt; &amp;m1) {
</font>    if(m1.DajBrojRedova() != br_redova || m1.DajBrojKolona()!= br_kolona) 
        throw std::domain_error("Nedozvoljena operacija");
    try {
<a name="4"></a><font color="#FF00FF"><a href="match633-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        for(int i=0; i&lt;m1.br_redova; i++)
            for(int j=0; j&lt;m1.br_kolona; j++)
                pok[i][j] -= m1(i+1,j+1);
        return *this;
    }
    catch(...) {
</font>        throw std::domain_error("Nedozvoljena operacija");
    }
}
template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator *=(Tip2 n) {
    try {
        for(int i=0; i&lt;br_redova; i++)
            for(int j=0; j&lt;br_kolona; j++)
                    pok[i][j] *= n;
        return *this;
    }
    catch(...) {
        throw std::domain_error("Nedozvoljena operacija");
    }
}
<a name="9"></a><font color="#FF00FF"><a href="match633-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator *=(const GMatrica&lt;Tip2&gt; &amp;m1) {
    if(br_kolona != m1.DajBrojRedova())
</font>        throw std::domain_error("Nedozvoljena operacija");
    try {
        GMatrica&lt;Tip&gt; m(br_redova, m1.DajBrojKolona());
        for(int i=0; i&lt;br_redova; i++)
            for(int j=0; j&lt;m1.DajBrojKolona(); j++)
                for(int k=0; k&lt;br_kolona; k++)
                    m.pok[i][j] += pok[i][k] * m1(k+1, j+1);
        *this = m;
        return *this;
    }
    catch(...) {
        throw std::domain_error("Nedozvoljena operacija");
    }
}
<a name="15"></a><font color="#FF0000"><a href="match633-0.html#15" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

template&lt;typename Tip&gt;
bool operator ==(const GMatrica&lt;Tip&gt; &amp;m1, const GMatrica&lt;Tip&gt; &amp;m2) {
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona) return false;
</font>    for(int i=0; i&lt;m1.br_redova; i++)
        for(int j=0; j&lt;m1.br_kolona; j++)
<a name="5"></a><font color="#FF0000"><a href="match633-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

            if(m1.pok[i][j] != m2.pok[i][j]) return false;
    return true;
}
template&lt;typename Tip&gt;
bool operator !=(const GMatrica&lt;Tip&gt; &amp;m1, const GMatrica&lt;Tip&gt; &amp;m2) {
</font>    return !(m1 == m2);
}
int main () {
    //Testiranje konstruktora sa 3 parametra
    int br_r, br_k;
    std::cout &lt;&lt; "Unesite broj redova i kolona matrice: " &lt;&lt; std::endl;
    try {
       std::cin &gt;&gt; br_r &gt;&gt; br_k;
    //Testiranje unosa matrice
        GMatrica&lt;double&gt; m1(br_r, br_k);
        std::cout &lt;&lt; "Unesite elemente matrice: " &lt;&lt; std::endl;
        std::cin &gt;&gt; m1;
        std::cout &lt;&lt; m1;
        if(!std::cin) throw "Neispravan unos"; 
    //Testiranje unosa 0x0 i konstruktora bez parametara
        GMatrica&lt;int&gt; m2;
        std::cout &lt;&lt; "Unesite elemente matrice: " &lt;&lt; std::endl;
        std::cin &gt;&gt; m2;
        if(!std::cin) throw "Neispravan unos";
        std::cout &lt;&lt; m2; 
    //Testiranje konstruktora kopije i dodjele (razliciti tipovi)
        GMatrica&lt;int&gt; mint{{1,2,3},{4,5,6}};
        GMatrica&lt;double&gt; mdoub(mint);
        std::cout &lt;&lt; "Original: \n" &lt;&lt; mint &lt;&lt; "Kopija: \n" &lt;&lt; mdoub &lt;&lt; std::endl;
    //Covski konstruktor
    int niz[4][4] = {{1,2,3,4},{3,4,5,6},{5,6,8,8},{7,8,8,8}};
    GMatrica&lt;double&gt; Cmat(niz);
    std::cout &lt;&lt; Cmat &lt;&lt; std::endl;
    //vector vector u gmatricu i da moze primiti inic listu
    std::vector&lt;std::vector&lt;double&gt;&gt; vint{{1,2},{3,3},{4,4}};
    Cmat = vint;
    std::cout &lt;&lt; Cmat &lt;&lt; std::endl;
    GMatrica&lt;double&gt; mk({{1,2}, {3,5}});
    std::cout &lt;&lt; mk &lt;&lt; std::endl;
    //sekvencijski
    GMatrica&lt;std::string&gt; s{{"A"}, {"B"}, {"C"}}, s1{{"A"}, {"B"}, {"C"}};
    std::cout &lt;&lt; s;
    GMatrica&lt;double&gt; m4{{1,2},{3,5}}, m5{{1,1},{0,1}};
    //operator == i !=
    if(mk == m4 &amp;&amp; s == s1) std::cout &lt;&lt; "jednaki" &lt;&lt; std::endl;
    if(mk != m5) std::cout &lt;&lt; "razliciti" &lt;&lt; std::endl;
    //operator +, -, *
    Cmat = m4 + m5; m5 = m4 - mk;
    m4 = m4 * m5;
    std::cout &lt;&lt; Cmat &lt;&lt; std::endl &lt;&lt; m4 &lt;&lt; std::endl &lt;&lt; m5 &lt;&lt; std::endl &lt;&lt; mk &lt;&lt; std::endl;
    //operator +=, -=, *=
    int x(2); mk *= x; m4 += mk; m5 -= m4;
    GMatrica&lt;double&gt; mat1{{1,1},{1,1}};
    GMatrica&lt;int&gt; mat2{{1,1},{0,0}};
    mat2 *= mat1;
    std::cout &lt;&lt; mk &lt;&lt; std::endl &lt;&lt; m4 &lt;&lt; std::endl &lt;&lt; m5 &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; mat2 &lt;&lt; std::endl;
    std::cout &lt;&lt; mat2[0][1] &lt;&lt; " " &lt;&lt; mat2(1,2);
    }
    catch(std::logic_error e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(std::domain_error e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(std::range_error e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(const char e[]) {
        std::cout &lt;&lt; e &lt;&lt; std::endl;
    }
    catch(...) {}
	return 0;
}</pre>
</body>
</html>
