<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4415.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4415.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match59-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_56.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;initializer_list&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;


template &lt;typename TipEl&gt;
class GMatrica
{
    TipEl matrica[4][4];
    int broj_redova;
    int broj_kolona;

public:
    GMatrica () : broj_redova(0), broj_kolona(0) {}
    GMatrica(int broj_redova, int broj_kolona,TipEl element = {}) {
        if (broj_kolona &lt; 0 or broj_kolona &gt; 4 or broj_redova &gt; 4 or broj_redova &lt; 0) throw std::logic_error ("Ilegalan format matrice");
        GMatrica::broj_kolona = broj_kolona;
        GMatrica::broj_redova = broj_redova;
        for (int i = 0; i &lt; broj_redova; i++) {
            for (int j = 0; j &lt; broj_kolona; j++) {
                matrica[i][j] = element;
            }
        }
    }
    template &lt;typename TipEl2&gt;
    GMatrica (const GMatrica&lt;TipEl2&gt; &amp;m2) {

        broj_kolona = m2.broj_kolona;
        broj_redova = m2.broj_redova;
        for (int i = 0; i &lt; broj_redova; i++) {
            for (int j = 0; j &lt; broj_kolona; j++) {
                matrica[i][j] = m2.matrica[i][j];
            }
        }
    }
    GMatrica (const GMatrica &amp;m2) {

        broj_kolona = m2.broj_kolona;
        broj_redova = m2.broj_redova;
        for (int i = 0; i &lt; broj_redova; i++) {
            for (int j = 0; j &lt; broj_kolona; j++) {
                matrica[i][j] = m2.matrica[i][j];
            }
        }
    }
    GMatrica (GMatrica &amp;&amp;m2) {

        broj_kolona = m2.broj_kolona;
        broj_redova = m2.broj_redova;
        for (int i = 0; i &lt; broj_redova; i++) {
            for (int j = 0; j &lt; broj_kolona; j++) {
                matrica[i][j] = m2.matrica[i][j];
            }
        }
    }
    template &lt;typename TipEl2&gt;
    GMatrica (const TipEl2 m2[4][4]) : broj_redova(4), broj_kolona(4) {
        for (int i = 0; i &lt; broj_redova; i++) {
            for (int j = 0; j &lt; broj_kolona; j++) {
                matrica[i][j] = m2[i][j];
            }
        }
    }
    GMatrica(const std::vector&lt;std::vector&lt;TipEl&gt;&gt; &amp;mat) {
        if (mat.size() &gt; 4 or mat.size() &lt; 0) throw std::logic_error ("Ilegalan format matrice");
        int test(0);
        bool flag(true);
        for (auto &amp;i : mat) {
            if (flag) {
                test = i.size();
                flag = false;
            } else if (test != i.size() or i.size() &lt; 0 or i.size() &gt; 4) throw std::logic_error ("Ilegalan format matrice");
        }
        broj_redova = mat.size();
        broj_kolona = test;
        for (int i = 0; i &lt; broj_redova; i++) {
            for (int j = 0; j &lt; broj_kolona; j++) {
                matrica[i][j] = mat[i][j];
            }
        }
    }
    
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; t) {
        if (t.size() &gt; 4 or t.size() &lt; 0) throw std::logic_error ("Ilegalan format matrice");
        int test;
        bool flag(true);
        for (auto &amp;i : t) {
            if (flag) {
                test = i.size();
                flag = false;
            } else if (test != i.size() or i.size() &lt; 0 or i.size() &gt; 4) throw std::logic_error ("Ilegalan format matrice");
        }
        broj_redova = t.size();
        broj_kolona = test;
        int k(0), j(0);
        for (auto &amp;i : t) {
            j = 0;
            for (auto &amp;i2 : i) {
                matrica[k][j] = i2;
                j++;
            }
            k++;
        }
    }
    int DajBrojRedova() const {
        return broj_redova;
    }
    int DajBrojKolona() const {
        return broj_kolona;
    }
    template &lt;typename TipEl2&gt;
    GMatrica&lt;TipEl&gt; &amp;operator += (const GMatrica&lt;TipEl2&gt; &amp;mat2) {
        if(broj_redova != mat2.broj_redova || broj_kolona != mat2.broj_kolona)
            throw std::domain_error("Nedozvoljena operacija");
        for(int i = 0; i &lt; broj_redova; i++)
            for(int j = 0; j &lt; broj_kolona; j++)
                matrica[i][j] += mat2.matrica[i][j];
        return *this;
    }
    template &lt;typename TipEl2&gt;
    GMatrica&lt;TipEl&gt; &amp;operator *= (TipEl2 broj) {
        for(int i = 0; i &lt; broj_redova; i++)
            for(int j = 0; j &lt; broj_kolona; j++)
                matrica[i][j] *= broj;
        return *this;
    }
    template &lt;typename TipEl2&gt;
    GMatrica&lt;TipEl&gt; &amp;operator -= (const GMatrica&lt;TipEl2&gt; &amp;mat2) {
        if(broj_redova != mat2.broj_redova || broj_kolona != mat2.broj_kolona)
            throw std::domain_error("Nedozvoljena operacija");
        for(int i = 0; i &lt; broj_redova; i++)
            for(int j = 0; j &lt; broj_kolona; j++)
                matrica[i][j] -= mat2.matrica[i][j];
        return *this;
    }
    
    template &lt;typename TipEl2&gt;
    GMatrica&lt;TipEl&gt; &amp;operator *= (const GMatrica&lt;TipEl2&gt; &amp;mat2) {
        if (broj_kolona != mat2.broj_redova)
            throw std::domain_error("Nedozvoljena operacija");
        for(int i = 0; i &lt; broj_redova; i++)
            for(int j = 0; j &lt; mat2.broj_kolona; j++)
                matrica[i][j] *= mat2.matrica[i][j];
        return *this;
    }
    TipEl &amp;operator () (int i, int j) {
        if (i &lt; 1 or i &gt; broj_redova or j &lt; 1 or j &gt; broj_kolona) throw std::range_error ("Nedozvoljenindeks");
        return matrica[i-1][j-1];
    }
    TipEl operator () (int i, int j) const {
        if (i &lt; 1 or i &gt; broj_redova or j &lt; 1 or j &gt; broj_kolona) throw std::range_error ("Nedozvoljenindeks");
        return matrica[i][j];
    }
    TipEl* operator [] (int index) const {
        return matrica[index];
    }
    TipEl* operator [] (int index) {
        return matrica[index];
    }


    template &lt;typename TipEl2&gt;
    friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;TipEl2&gt; &amp;m);

    template &lt;typename TipEl2&gt;
    friend std::ostream &amp;operator &lt;&lt; (std::ostream &amp;tok, const GMatrica&lt;TipEl2&gt; &amp;m);

    template &lt;typename Tip1, typename Tip2 &gt;
    friend bool operator == (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);

    template &lt;typename Tip1, typename Tip2 &gt;
    friend bool operator != (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);

    template &lt;typename Tip1, typename Tip2&gt;
    friend GMatrica&lt;decltype(Tip1() + Tip2())&gt; operator - (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);

    template &lt;typename Tip1, typename Tip2 &gt;
    friend GMatrica&lt;decltype(Tip1() + Tip2())&gt; operator + (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);

    template &lt;typename Tip1, typename Tip2&gt;
    friend GMatrica&lt;decltype(Tip1() * Tip2())&gt; operator * (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);

    template &lt;typename Tip1, typename Tip2&gt;
    friend GMatrica&lt;decltype(Tip1() * Tip2())&gt; operator * (const GMatrica&lt;Tip1&gt; &amp;m1, Tip2 broj);
    template &lt;typename Tip1, typename Tip2&gt;
    friend GMatrica&lt;decltype(Tip1() * Tip2())&gt; operator * (Tip1 broj,const GMatrica&lt;Tip2&gt; &amp;m1);
};

template &lt;typename Tip1, typename Tip2&gt;
    GMatrica&lt;decltype(Tip1() * Tip2())&gt; operator * (const GMatrica&lt;Tip1&gt; &amp;m1, Tip2 broj) {
        GMatrica&lt;decltype(Tip1() * Tip2())&gt; m3(m1.broj_redova, m1.broj_kolona);
        for(int i = 0; i &lt; m1.broj_redova; i++)
            for(int j = 0; j &lt; m1.broj_kolona; j++)
</font><a name="6"></a><font color="#00FF00"><a href="match59-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

                m3.matrica[i][j] = m1.matrica[i][j]*broj;
        return m3;
    }
template &lt;typename Tip1, typename Tip2&gt;
    GMatrica&lt;decltype(Tip1() * Tip2())&gt; operator * (Tip1 broj,const GMatrica&lt;Tip2&gt; &amp;m1) {
        GMatrica&lt;decltype(Tip1() * Tip2())&gt; m3(m1.broj_redova, m1.broj_kolona);
        for(int i = 0; i &lt; m1.broj_redova; i++)
            for(int j = 0; j &lt; m1.broj_kolona; j++)
</font><a name="7"></a><font color="#0000FF"><a href="match59-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

                m3.matrica[i][j] = m1.matrica[i][j]*broj;
        return m3;
    }
template &lt;typename TipEl&gt;
std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;TipEl&gt; &amp;m)
{
    int sirina(std::cout.width());
    if (sirina &lt; 6) sirina = 6;
    for(int i = 0; i &lt; m.DajBrojRedova(); i++) {
</font><a name="1"></a><font color="#00FF00"><a href="match59-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

        for(int j = 0; j &lt; m.DajBrojKolona(); j++) {
            tok &lt;&lt; std::setw(sirina) &lt;&lt; m.matrica[i][j];
        }
        tok &lt;&lt; std::endl;
    }
    return tok;
}

template &lt;typename TipEl&gt;
std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;TipEl&gt; &amp;m)
{
    char znak;
    tok &gt;&gt; znak;
    TipEl broj;
    int i(0), j(0);
    if (znak != '[') tok.setstate(std::ios::failbit);
    while (1) {
        tok &gt;&gt; broj &gt;&gt; znak;
        m.matrica[i][j] = broj;
        j++;
        if (znak == ']')  {i++; break;}
        else if (znak == ';' or i &gt; 3 or j &gt; 3) {
            i++;
            j = 0;
        } else if (znak != ',') tok.setstate(std::ios::failbit);
    }
    
    m.broj_redova = i;
    m.broj_kolona = j;
    if (znak != ']') tok.setstate(std::ios::failbit);
    return tok;
}

template &lt;typename Tip1, typename Tip2 &gt;
bool operator == (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
{
    if (m1.broj_kolona != m2.broj_kolona or m1.broj_redova != m2.broj_redova) return false;

    for (int i = 0; i &lt; m1.broj_redova; i++) {
        for (int j = 0; j &lt; m1.broj_kolona; j++) {
</font><a name="5"></a><font color="#FF0000"><a href="match59-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

            if (m1.matrica[i][j] != m2.matrica[i][j]) return false;
        }
    }
    return true;
}

template &lt;typename Tip1, typename Tip2 &gt;
bool operator != (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
{
    if (m1.broj_kolona != m2.broj_kolona or m1.broj_redova != m2.broj_redova) return true;

    for (int i = 0; i &lt; m1.broj_redova; i++) {
        for (int j = 0; j &lt; m1.broj_kolona; j++) {
</font><a name="3"></a><font color="#00FFFF"><a href="match59-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

            if (m1.matrica[i][j] != m2.matrica[i][j]) return true;
        }
    }
    return false;
}

template &lt;typename Tip1, typename Tip2&gt;
GMatrica&lt;decltype(Tip1() + Tip2())&gt; operator + (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
{
    if(m1.broj_redova != m2.broj_redova || m1.broj_kolona != m2.broj_kolona)
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(Tip1() + Tip2())&gt; m3 (m1.broj_redova, m1.broj_kolona);
    for(int i = 0; i &lt; m1.broj_redova; i++)
        for(int j = 0; j &lt; m1.broj_kolona; j++)
</font><a name="4"></a><font color="#FF00FF"><a href="match59-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

            m3.matrica[i][j] = m1.matrica[i][j] + m2.matrica[i][j];
    return m3;
}

template &lt;typename Tip1, typename Tip2&gt;
GMatrica&lt;decltype(Tip1() + Tip2())&gt; operator - (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
{
    if(m1.broj_redova != m2.broj_redova || m1.broj_kolona != m2.broj_kolona)
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(Tip1() - Tip2())&gt; m3(m1.broj_redova, m1.broj_kolona);
    for(int i = 0; i &lt; m1.broj_redova; i++)
        for(int j = 0; j &lt; m1.broj_kolona; j++)
</font><a name="2"></a><font color="#0000FF"><a href="match59-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

            m3.matrica[i][j] = m1.matrica[i][j] - m2.matrica[i][j];
    return m3;
}

template &lt;typename Tip1, typename Tip2&gt;
GMatrica&lt;decltype(Tip1() + Tip2())&gt; operator * (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
{
    if (m1.broj_kolona != m2.broj_redova) throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(Tip1() * Tip2())&gt; m3(m1.broj_redova, m2.broj_kolona);
    for (int i = 0; i &lt; m1.broj_redova; i++) {
        for (int j = 0; j &lt; m2.broj_kolona; j++) {
            decltype(Tip1() * Tip2()) suma {};
            for (int k = 0; k &lt; m1.broj_kolona; k++) {
                suma+= m1.matrica[i][k]*m2.matrica[k][j];
            }
            m3.matrica[i][j] = suma;
        }
    }
    return m3;
}


int main ()
{
   GMatrica&lt;int&gt; m1;
   std::cin &gt;&gt; m1;
   std::cout &lt;&lt; m1 &lt;&lt; std::endl;
</font>}</pre>
</body>
</html>
