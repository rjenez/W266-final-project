<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8317.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student7001.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;iomanip&gt;

template &lt;typename TipEl&gt;
class GMatrica {
    TipEl niz2D[4][4];
    int stvarni_br_redova, stvarni_br_kolona;
public:
    GMatrica() : stvarni_br_redova(0),stvarni_br_kolona(0) {}
    GMatrica(int br_redova, int br_kolona, TipEl vrijednost=TipEl());
<a name="6"></a><font color="#00FF00"><a href="match140-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    GMatrica&lt;TipEl&gt;(const GMatrica&lt;TipEl&gt; &amp;matrica);
    GMatrica(TipEl matrica[4][4]);
    GMatrica(std::vector&lt;std::vector&lt;TipEl&gt;&gt; matrica);
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; matrica);
</font>    int DajBrojRedova() const { return stvarni_br_redova; }
    int DajBrojKolona() const { return stvarni_br_kolona; }
    template &lt;typename Tip1, typename Tip2&gt;
        friend GMatrica operator +(GMatrica &amp;m1,GMatrica &amp;m2);
    template &lt;typename Tip1, typename Tip2&gt;
        friend GMatrica operator -(GMatrica &amp;m1,GMatrica &amp;m2);
    template &lt;typename Tip1, typename Tip2&gt; 
        friend GMatrica operator *(GMatrica &amp;m1,GMatrica &amp;m2);
    template &lt;typename Tip1, typename Tip2&gt;
        friend GMatrica operator *(GMatrica &amp;m,Tip2 vrijednost);
    template &lt;typename Tip1, typename Tip2&gt;
        friend GMatrica operator *(Tip2 vrijednost,GMatrica &amp;m);
    GMatrica &amp;operator +=(GMatrica &amp;m);
    GMatrica &amp;operator -=(GMatrica &amp;m);
    GMatrica &amp;operator *=(GMatrica &amp;m);
<a name="10"></a><font color="#FF0000"><a href="match140-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    GMatrica &amp;operator *=(TipEl vrijednost);
    template &lt;typename Tip1&gt; 
        friend bool operator ==(GMatrica m1,GMatrica m2);
    template &lt;typename Tip1&gt;
        friend bool operator !=(GMatrica m1,GMatrica m2);
</font><a name="12"></a><font color="#0000FF"><a href="match140-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    TipEl* operator[] (int indeks) {
        return niz2D[indeks];
    }
    TipEl &amp;operator() (int indeks1,int indeks2) {
        if (indeks1&lt;=0 || indeks1&gt;stvarni_br_redova || indeks2&lt;=0 || indeks2&gt;stvarni_br_kolona)
</font>            throw std::range_error("Nedozvoljen indeks");
        return niz2D[indeks1-1][indeks2-1];
    }
    template &lt;typename Tip1&gt;
        friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok,GMatrica&lt;TipEl&gt; &amp;m);
    template &lt;typename Tip1&gt;
<a name="13"></a><font color="#00FFFF"><a href="match140-0.html#13" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok,GMatrica&lt;TipEl&gt; &amp;m);
};

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(int br_redova, int br_kolona, TipEl vrijednost) {
    if (br_redova&lt;0 || br_redova&gt;4 || br_kolona&lt;0 || br_kolona&gt;4)
</font>        throw std::logic_error("Ilegalan format matrice");
    stvarni_br_redova=br_redova; stvarni_br_kolona=br_kolona;
    for (int i=0; i&lt;br_redova; i++)
<a name="2"></a><font color="#0000FF"><a href="match140-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

        for (int j=0; j&lt;br_kolona; j++)
            niz2D[i][j]=vrijednost;
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(const GMatrica&lt;TipEl&gt; &amp;matrica) {
    stvarni_br_redova=matrica.DajBrojRedova();
    stvarni_br_kolona=matrica.DajBrojKolona();
    for (int i=0; i&lt;matrica.DajBrojRedova(); i++)
        for (int j=0; j&lt;matrica.DajBrojKolona(); j++)
            niz2D[i][j]=matrica.niz2D[i][j];
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(TipEl matrica[4][4]) {
    stvarni_br_redova=4;
    stvarni_br_kolona=4;
    for (int i=0; i&lt;stvarni_br_redova; i++)
</font>        for (int j=0; j&lt;stvarni_br_kolona; j++)
            niz2D[i][j]=matrica[i][j];
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(std::vector&lt;std::vector&lt;TipEl&gt;&gt; matrica) {
    if (matrica.size()&lt;0 || matrica.size()&gt;4)
        throw std::logic_error("Ilegalan format matrice");
    int tmp=matrica[0].size();
    for (int i=0; i&lt;matrica.size(); i++)
        if (matrica[i].size()&lt;0 || matrica[i].size()&gt;4 || matrica[i].size()!=tmp)
            throw std::logic_error("Ilegalan format matrice");
    stvarni_br_redova=matrica.size();
    stvarni_br_kolona=matrica[0].size();
    for (int i=0; i&lt;matrica.size(); i++)
        for (int j=0; j&lt;matrica[0].size(); j++)
            niz2D[i][j]=matrica[i][j];
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; matrica) {
    if (matrica.size()&lt;0 || matrica.size()&gt;4)
        throw std::logic_error("Ilegalan format matrice");
    auto it=matrica.begin();
    int tmp=it-&gt;size();
    for (auto it=matrica.begin(); it!=matrica.end(); it++)
        if (it-&gt;size()&lt;0 || it-&gt;size()&gt;4 || it-&gt;size()!=tmp)
            throw std::logic_error("Ilegalan format matrice");
    stvarni_br_redova=matrica.size();
    stvarni_br_kolona=tmp;
    int indeks1=0;
    for (auto it1=matrica.begin(); it1!=matrica.end(); it1++) {
        int indeks2=0;
        for (auto it2=it1-&gt;begin(); it2!=it1-&gt;end(); it2++) {
            niz2D[indeks1][indeks2]=*it2;
            indeks2++;
        }
        indeks1++;
    }
}

template &lt;typename TipEl1, typename TipEl2&gt;
<a name="0"></a><font color="#FF0000"><a href="match140-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

auto operator +(GMatrica&lt;TipEl1&gt; &amp;m1,GMatrica&lt;TipEl2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1[0][0]+m2[0][0])&gt; {
    if (m1.DajBrojRedova()!=m2.DajBrojRedova() || m1.DajBrojKolona()!=m2.DajBrojKolona())
        throw std::domain_error("Matrice nemaju jednake dimenzije");
    GMatrica&lt;decltype(m1[0][0]+m2[0][0])&gt; m3(m1.DajBrojRedova(),m1.DajBrojKolona());
    for (int i=0; i&lt;m1.DajBrojRedova(); i++)
        for (int j=0; j&lt;m1.DajBrojKolona(); j++)
            m3[i][j]=m1[i][j]+m2[i][j];
    return m3;
}

template &lt;typename TipEl1, typename TipEl2&gt;
auto operator -(GMatrica&lt;TipEl1&gt; &amp;m1,GMatrica&lt;TipEl2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1[0][0]-m2[0][0])&gt; {
</font><a name="1"></a><font color="#00FF00"><a href="match140-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

    if (m1.DajBrojRedova()!=m2.DajBrojRedova() || m1.DajBrojKolona()!=m2.DajBrojKolona())
        throw std::domain_error("Matrice nemaju jednake dimenzije");
    GMatrica&lt;decltype(m1[0][0]-m2[0][0])&gt; m3(m1.DajBrojRedova(),m1.DajBrojKolona());
    for (int i=0; i&lt;m1.DajBrojRedova(); i++)
        for (int j=0; j&lt;m1.DajBrojKolona(); j++)
            m3[i][j]=m1[i][j]-m2[i][j];
    return m3;
}

template &lt;typename TipEl1, typename TipEl2&gt;
auto operator *(GMatrica&lt;TipEl1&gt; &amp;m1,GMatrica&lt;TipEl2&gt; &amp;m2) -&gt; GMatrica&lt;decltype(m1[0][0]*m2[0][0])&gt; {
</font><a name="4"></a><font color="#FF00FF"><a href="match140-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

    if (m1.DajBrojKolona()!=m2.DajBrojRedova())
        throw std::domain_error("Matrice nisu saglasne za mnozenje");
    GMatrica&lt;decltype(m1[0][0]*m2[0][0])&gt; m3(m1.DajBrojRedova(),m2.DajBrojKolona());
    for (int i=0; i&lt;m1.DajBrojRedova(); i++) {
        for (int j=0; j&lt;m2.DajBrojKolona(); j++) {
            decltype(m1[0][0]*m2[0][0]) suma=0;
</font>            for (int k=0; k&lt;m2.DajBrojRedova(); k++)
                suma+=m1[i][k]*m2[k][j];
            m3[i][j]=suma;
        }
    }
    return m3;
}

template &lt;typename TipEl1, typename TipEl2&gt;
auto operator *(GMatrica&lt;TipEl1&gt; &amp;m1, TipEl2 vrijednost) -&gt; GMatrica&lt;decltype(m1[0][0]*vrijednost)&gt; {
    GMatrica&lt;decltype(m1[0][0]*vrijednost)&gt; m2(m1.DajBrojRedova(),m1.DajBrojKolona());
    for (int i=0; i&lt;m1.DajBrojRedova(); i++)
        for (int j=0; j&lt;m1.DajBrojKolona(); j++)
            m2[i][j]=m1[i][j]*vrijednost;
    return m2;
}

template &lt;typename TipEl1, typename TipEl2&gt;
auto operator *(TipEl2 vrijednost, GMatrica&lt;TipEl1&gt; &amp;m1) -&gt; GMatrica&lt;decltype(m1[0][0]*vrijednost)&gt; {
    GMatrica&lt;decltype(m1[0][0]*vrijednost)&gt; m2(m1.DajBrojRedova(),m1.DajBrojKolona());
    for (int i=0; i&lt;m1.DajBrojRedova(); i++)
        for (int j=0; j&lt;m1.DajBrojKolona(); j++)
            m2[i][j]=m1[i][j]*2;
    return m2;
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator +=(GMatrica&lt;TipEl&gt; &amp;m2) {
    if (stvarni_br_redova!=m2.DajBrojRedova() || stvarni_br_kolona!=m2.DajBrojKolona())
        throw std::domain_error("Matrice nemaju jednake dimenzije");
    for (int i=0; i&lt;stvarni_br_redova; i++)
        for (int j=0; j&lt;stvarni_br_kolona; j++)
<a name="11"></a><font color="#00FF00"><a href="match140-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

            niz2D[i][j]+=m2[i][j];
    return *this;
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator -=(GMatrica&lt;TipEl&gt; &amp;m2) {
</font>    if (stvarni_br_redova!=m2.DajBrojRedova() || stvarni_br_kolona!=m2.DajBrojKolona())
        throw std::domain_error("Matrice nemaju jednake dimenzije");
    for (int i=0; i&lt;stvarni_br_redova; i++)
        for (int j=0; j&lt;stvarni_br_kolona; j++)
            niz2D[i][j]-=m2[i][j];
    return *this;
}

template &lt;typename TipEl&gt;
<a name="7"></a><font color="#0000FF"><a href="match140-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator *=(GMatrica&lt;TipEl&gt; &amp;m2) {
    if (stvarni_br_kolona!=m2.DajBrojRedova())
        throw std::domain_error("Matrice nisu saglasne za mnozenje");
    GMatrica&lt;TipEl&gt; m3(stvarni_br_redova,m2.DajBrojKolona());
    for (int i=0; i&lt;stvarni_br_redova; i++) {
</font>        for (int j=0; j&lt;m2.DajBrojKolona(); j++) {
            TipEl suma=0;
            for (int k=0; k&lt;m2.DajBrojRedova(); k++)
                suma+=niz2D[i][k]*m2[k][j];
            m3[i][j]=suma;
        }
    }
    stvarni_br_redova=m3.DajBrojRedova();
    stvarni_br_kolona=m3.DajBrojKolona();
    for (int i=0; i&lt;m3.DajBrojRedova(); i++)
        for (int j=0; j&lt;m3.DajBrojKolona(); j++)
            niz2D[i][j]=m3[i][j];
<a name="5"></a><font color="#FF0000"><a href="match140-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    return *this;
}

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator *=(TipEl vrijednost) {
    for (int i=0; i&lt;stvarni_br_redova; i++)
        for (int j=0; j&lt;stvarni_br_kolona; j++)
</font><a name="3"></a><font color="#00FFFF"><a href="match140-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

            niz2D[i][j]*=vrijednost;
    return *this;
}

template &lt;typename TipEl&gt; 
bool operator ==(GMatrica&lt;TipEl&gt; m1, GMatrica&lt;TipEl&gt; m2) {
    if (m1.DajBrojRedova()!=m2.DajBrojRedova() || m1.DajBrojKolona()!=m2.DajBrojKolona()) return false;
    for (int i=0; i&lt;m1.DajBrojRedova(); i++)
        for (int j=0; j&lt;m1.DajBrojKolona(); j++)
            if (m1[i][j]!=m2[i][j]) return false;
    return true;
}

template &lt;typename TipEl&gt;
bool operator !=(GMatrica&lt;TipEl&gt; m1, GMatrica&lt;TipEl&gt; m2) { return !(m1==m2); }

template &lt;typename TipEl&gt;
</font><a name="8"></a><font color="#00FFFF"><a href="match140-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, GMatrica&lt;TipEl&gt; &amp;m) {
    int sirina_ispisa=tok.width();
    if (sirina_ispisa&lt;6) sirina_ispisa=6;
    for (int i=0; i&lt;m.DajBrojRedova(); i++) {
        for (int j=0; j&lt;m.DajBrojKolona(); j++)
</font><a name="9"></a><font color="#FF00FF"><a href="match140-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

            tok &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; m[i][j];
        tok &lt;&lt; std::endl;
    }
    return tok;
}

template &lt;typename TipEl&gt;
std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;TipEl&gt; &amp;m) {
</font>    char znak;
    GMatrica&lt;TipEl&gt; pomocna(4,4);
    int indeks1=1, indeks2=1, prethodna_duzina_reda=0;
    if (tok.peek()!='[') tok.setstate(std::ios::failbit);
    else tok &gt;&gt; znak;
    do {
        if (tok.peek()==']' &amp;&amp; indeks2==prethodna_duzina_reda) break;
        else if (tok.peek()&gt;='0' &amp;&amp; tok.peek()&lt;='9') tok &gt;&gt; pomocna(indeks1,indeks2);
        else if (tok.peek()==',') {
            tok &gt;&gt; znak;
            indeks2++;
            if (indeks2&gt;4) {
                tok.setstate(std::ios::failbit);
                break;
            }
        }
        else if (tok.peek()==';') {
            tok &gt;&gt; znak;
            indeks1++;
            if (indeks1&gt;4 || (prethodna_duzina_reda!=0 &amp;&amp; indeks2!=prethodna_duzina_reda)) {
                tok.setstate(std::ios::failbit);
                break;
            }
            prethodna_duzina_reda=indeks2;
            indeks2=1;
        }
        else {
            tok.setstate(std::ios::failbit);
            break;
        }
    } while(1);
    if (!tok) return tok;
    GMatrica&lt;int&gt; pomocna1(indeks1,indeks2);
    for (int i=0; i&lt;indeks1; i++)
        for (int j=0; j&lt;indeks2; j++)
            pomocna1[i][j]=pomocna[i][j];
    m=std::move(pomocna1);
    return tok;
}

int main () {
    GMatrica&lt;int&gt; m1{{1,2,3},{1,2,3},{1,2,3}};
    GMatrica&lt;double&gt; m2({{1.5,2.5,3.5},{1.5,2.5,3.5},{1.5,2.5,3.5}});
    auto m3=m1+m2;
    std::cout &lt;&lt; m3 &lt;&lt; std::endl;
    auto m4=m1-m2;
    std::cout &lt;&lt; m4 &lt;&lt; std::endl;
    auto m5=m1*m2;
    std::cout &lt;&lt; m5 &lt;&lt; std::endl;
    auto m6=m1*2.5;
    std::cout &lt;&lt; m6 &lt;&lt; std::endl;
	return 0;
}</pre>
</body>
</html>
