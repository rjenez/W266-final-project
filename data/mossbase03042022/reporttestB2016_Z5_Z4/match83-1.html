<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4602.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3900.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match83-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_51.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
using namespace std;

template &lt;typename t&gt;
class GMatrica{
    int br_redova, br_kolona;
    t matrica[4][4];
    public:
    GMatrica() : br_redova(0), br_kolona(0) {}
    GMatrica(int br_redova, int br_kolona, t vrijednost);
    
    GMatrica(initializer_list&lt;initializer_list&lt;t&gt;&gt;lista);
    GMatrica(GMatrica&lt;t&gt;mat[4][4]);
    GMatrica(vector&lt;vector&lt;t&gt;&gt;matt);
    template&lt;typename t1&gt;
    GMatrica(const GMatrica&lt;t1&gt;&amp;mat);
    int DajBrojRedova() const{
        return br_redova;
    }
    int DajBrojKolona() const{
        return br_kolona;
    }
    template&lt;typename t2, typename t1&gt;
    friend auto operator+(const GMatrica&lt;t2&gt; &amp;m1, const GMatrica&lt;t1&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1[0][0]+m2[0][0])&gt;;
    template&lt;typename t2, typename t1&gt;
    friend auto operator-(const GMatrica&lt;t2&gt; &amp;m1, const GMatrica&lt;t1&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1[0][0]-m2[0][0])&gt;;
    template&lt;typename t2, typename t1&gt;
    friend auto operator*(const GMatrica&lt;t2&gt; &amp;m1, const GMatrica&lt;t1&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1[0][0]*m2[0][0]+m1[0][1]*m2[1][0])&gt;;
    template&lt;typename t2, typename t1&gt;
    friend auto operator*(const GMatrica&lt;t2&gt; &amp;m1, t1 k)-&gt;GMatrica&lt;decltype(m1[0][0]*k)&gt;;
    template&lt;typename t2, typename t1&gt;
    friend auto operator*(t1 k, const GMatrica&lt;t2&gt; &amp;m1)-&gt;GMatrica&lt;decltype(k*m1[0][0])&gt;;
    template&lt;typename t2&gt;
    friend ostream&amp; operator&lt;&lt;(ostream &amp;tok, GMatrica&lt;t2&gt; &amp;m1);
    GMatrica &amp;operator+=(const GMatrica &amp;m1);
    GMatrica &amp;operator-=(const GMatrica &amp;m1);
    GMatrica &amp;operator*=(const GMatrica &amp;m1);
    template&lt;typename t2, typename t1&gt;
    friend bool operator==(const GMatrica&lt;t2&gt;&amp;m1, const GMatrica&lt;t1&gt;&amp;m2);
    template&lt;typename t2, typename t1&gt;
    friend bool operator!=(const GMatrica&lt;t2&gt;&amp;m1, const GMatrica&lt;t1&gt;&amp;m2);
};
template&lt;typename t&gt;
    GMatrica&lt;t&gt;::GMatrica(int br_redova, int br_kolona, t vrijednost){
        if(br_redova&lt;0 || br_redova&gt;4 || br_kolona&lt;0 || br_kolona&gt;4) throw logic_error("Ilegalan format matrice");
        GMatrica::br_redova=br_redova;
        GMatrica::br_kolona=br_kolona;
        vrijednost={};
    }
template&lt;typename t&gt;
    GMatrica&lt;t&gt;::GMatrica(GMatrica&lt;t&gt;mat[4][4]){
        for(int i=0; i&lt;4; i++){
            for(int j=0; j&lt;4; j++){
                matrica[i][j]=mat[i][j];
            }
        }
    }
template&lt;typename t&gt;
    GMatrica&lt;t&gt;::GMatrica(vector&lt;vector&lt;t&gt;&gt;matt){
        if(matt.size()!=matt[0].size()) throw logic_error("Ilegalan format matrice");
        if(matt.size()&lt;0 || matt.size()&gt;4 || matt[0].size()&lt;0 || matt[0].size()&gt;4) throw logic_error("Ilegalan format matrice");
        for(int i=0; i&lt;matt.size(); i++){
            for(int j=0; j&lt;matt.size(); j++){
                matrica[i][j]=matt[i][j];
            }
        }
    }
template&lt;typename t&gt;
    GMatrica&lt;t&gt;::GMatrica(initializer_list&lt;initializer_list&lt;t&gt;&gt;lista){
    vector&lt;vector&lt;t&gt;&gt;pomocni;
    for(auto it=lista.begin(); it!=lista.end(); it++){
        vector&lt;t&gt;pomi;
        for(auto n:*it){
            pomi.push_back(n);
        }
        pomocni.push_back(pomi);
        pomi.clear();
    }
    for(int i=0; i&lt;pomocni.size(); i++){
        for(int j=0; j&lt;pomocni[i].size(); j++){
            matrica[i][j]=pomocni[i][j];
        }
    }
}

/*template&lt;typename t1&gt;
GMatrica&lt;t&gt;::GMatrica(const GMatrica&lt;t1&gt;&amp;mat){
return static_cast&lt;t&gt;(mat);
    }*/

template &lt;typename t,typename t1&gt;
auto operator+(const GMatrica&lt;t&gt; &amp;m1, const GMatrica&lt;t1&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1[0][0]+m2[0][0])&gt;{
    if(m1.DajBrojKolona()!=m2.DajBrojKolona() &amp;&amp; m1.DajBrojRedova()!=m2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1[0][0]+m2[0][0])&gt; m3;
    for(int i=0; i&lt;m1.DajBrojRedova(); i++){
        for(int j=0; j&lt;m1.DajBrojKolona(); i++) {
</font><a name="2"></a><font color="#0000FF"><a href="match83-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

            m3.matrica[i][j]=m1.matrica[i][j]+m2.matrica[i][j];
        }
    }
    return m3;
}
//template &lt;typename t&gt;
template &lt;typename t,typename t1&gt;
auto operator-(const GMatrica&lt;t&gt; &amp;m1, const GMatrica&lt;t1&gt; &amp;m2)-&gt; GMatrica&lt;decltype(m1[0][0]-m2[0][0])&gt;{
    if(m1.DajBrojKolona()!=m2.DajBrojKolona() &amp;&amp; m1.DajBrojRedova()!=m2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1[0][0]-m2[0][0])&gt; m3;
    for(int i=0; i&lt;m1.DajBrojRedova(); i++){
        for(int j=0; j&lt;m1.DajBrojKolona(); i++) {
</font>            m3.matrica[i][j]=m1.matrica[i][j]-m2.matrica[i][j];
        }
    }
    return m3;
}
template&lt;typename t2, typename t1&gt;
<a name="1"></a><font color="#00FF00"><a href="match83-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_37.gif"/></a>

auto operator*(const GMatrica&lt;t2&gt; &amp;m1, const GMatrica&lt;t1&gt; &amp;m2)-&gt; GMatrica &lt;decltype(m1[0][0]*m2[0][0]+m1[0][1]*m2[1][0])&gt;{
    if(m1.DajBrojKolona()!=m2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1[0][0]*m2[0][0]+m1[0][1]*m2[1][0])&gt;m3;
    //GMatrica&lt;decltype(m1[0][0]+m2[0][0])&gt;suma;
    for(int i=0; i&lt;m1.DajBrojRedova(); i++){
        for(int j=0; j&lt;m2.DajBrojKolona(); j++){
            m3.matrica[i][j]=0;
            for(int k=0; k&lt;m2.DajBrojRedova(); k++) m3.matrica[i][j]+=m1[i][k]*m2[k][j];
        }
    }
    return m3;
}
template&lt;typename t2, typename t1&gt;
auto operator*(const GMatrica&lt;t2&gt; &amp;m1, t1 k)-&gt;GMatrica&lt;decltype(m1[0][0]*k)&gt;{
    GMatrica&lt;decltype(m1[0][0]*k)&gt;m;
    for(int i=0; i&lt;m1.DajBrojRedova(); i++){
        for(int j=0; j&lt;m1.DajBrojKolona(); j++){
            m.matrica[i][k]*=k;
        }
    }
    return m;
}
template&lt;typename t2, typename t1&gt;
auto operator*(t1 k, const GMatrica&lt;t2&gt;&amp;m1)-&gt;GMatrica&lt;decltype(k*m1[0][0])&gt;{
    return m1*k;
}
template&lt;typename t&gt;
GMatrica&lt;t&gt; &amp;GMatrica&lt;t&gt;::operator+=(const GMatrica&lt;t&gt; &amp;m1){
    for(int i=0; i&lt;DajBrojRedova(); i++){
        for(int j=0; j&lt;DajBrojKolona(); j++){
            matrica[i][j]+=m1.matrica[i][j];
        }
    }
    return *this;
}


template&lt;typename t&gt;
GMatrica&lt;t&gt; &amp;GMatrica&lt;t&gt;::operator-=(const GMatrica&lt;t&gt; &amp;m1){
    for(int i=0; i&lt;DajBrojRedova(); i++){
        for(int j=0; j&lt;DajBrojKolona(); j++){
            matrica[i][j]-=m1.matrica[i][j];
        }
    }
    return *this;
}
template&lt;typename t&gt;
GMatrica&lt;t&gt; &amp;GMatrica&lt;t&gt;::operator*=(const GMatrica &amp;m1){
    if(m1.DajBrojKolona()!=DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    for(int i=0; i&lt;DajBrojRedova(); i++){
        for(int j=0; j&lt;DajBrojKolona(); j++){
            matrica[i][j]=0;
            for(int k=0; k&lt;m1.DajBrojRedova(); k++) matrica[i][j]+=m1.matrica[i][k]*m1.matrica[k][j];
        }
    }
    return *this;
}

/*template&lt;typename t2, typename t1&gt;
bool operator==(const GMatrica&lt;t2&gt;&amp;m1, const GMatrica&lt;t1&gt;&amp;m2){
    if(m1.DajBrojKolona()!=m2.DajBrojKolona() || m1.DajBrojRedova()!=m2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    if(m1.DajBrojKolona()&lt;1 || m1.DajBrojRedova()!=m2.DajBrojRedova()) throw domain_error("Nedozvoljena operacija");
    template&lt;typename t2, typename t1&gt;
    friend bool operator!=(const GMatrica&lt;t2&gt;&amp;m1, const GMatrica&lt;t1&gt;&amp;m2);
*/
template&lt;typename t2&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;tok, GMatrica&lt;t2&gt;&amp;m1){
   //if(m1.DajBrojKolona()&lt;6 &amp;&amp; m1.DajBrojRedova()&lt;6){
        for(int i=0; i&lt;m1.DajBrojRedova(); i++){
            for(int j=0; j&lt;m1.DajBrojKolona(); j++){
                tok&lt;&lt;m1.matrica[i][j];
                tok&lt;&lt;endl;
            }
        }
    return tok;
}
int main ()
{
   GMatrica&lt;double&gt; m1({{1, 2}, {3, 4}});
   //GMatrica&lt;double&gt; m2({{1, 2}, {3, 4}});
   //auto m3 = m1 + m2;
   std::cout &lt;&lt; m1 &lt;&lt; std::endl;
</font>   //GMatrica&lt;double&gt; m4({{1, 2}, {3, 4}});
   //auto m5 = m3-m4;
   //std::cout &lt;&lt; m5 &lt;&lt; std::endl;

  return 0;      
    }</pre>
</body>
</html>
