<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1579.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student9897.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;initializer_list&gt;

template &lt;typename TipEl&gt; 
class GMatrica {
   
   TipEl mat[4][4]; 
   int broj_redova, broj_kolona; 
   
   public: 
   GMatrica(); 
   GMatrica(int broj_redova, int broj_kolona, TipEl vrijednost={});  
   GMatrica(const GMatrica &amp;matr);
   GMatrica(TipEl matr[4][4]);
   GMatrica(std::vector&lt;std::vector&lt;TipEl&gt;&gt; matr); 
   GMatrica(std::initializer_list&lt;std::initializer_list&lt;TipEl&gt;&gt; lista); 
   int DajBrojRedova() const { return broj_redova; } 
   int DajBrojKolona() const { return broj_kolona; }
   GMatrica&lt;TipEl&gt; &amp;operator()(int i, int j) const {
      if (i&lt;1 || i&gt;broj_redova || j&lt;1 || j&gt;broj_kolona) 
      throw std::range_error ("Nedozvoljen indeks"); 
      return mat[i][j];
   }
   
<a name="10"></a><font color="#FF0000"><a href="match929-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

   template &lt;typename TipEl1, typename TipEl2&gt; 
   friend GMatrica&lt;TipEl1&gt; operator +(const GMatrica&lt;TipEl2&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2); 
   template &lt;typename TipEl1, typename TipEl2&gt;
</font><a name="11"></a><font color="#00FF00"><a href="match929-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

   friend GMatrica&lt;TipEl1&gt; operator -(const GMatrica&lt;TipEl2&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2);  
   template &lt;typename TipEl1, typename TipEl2&gt; 
</font>   friend GMatrica&lt;TipEl1&gt; operator *(const GMatrica&lt;TipEl2&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2); 
   template &lt;typename TipEl1, typename TipEl2&gt; 
   friend GMatrica&lt;TipEl1&gt; operator *(const GMatrica&lt;TipEl1&gt; &amp;m1, TipEl2 a); 
   template &lt;typename TipEl1, typename TipEl2&gt; 
   friend GMatrica&lt;TipEl1&gt; operator *(TipEl2 a, const GMatrica&lt;TipEl1&gt; &amp;m1); 
   
   template &lt;typename TipEl1, typename TipEl2&gt; 
   friend GMatrica&lt;TipEl1&gt; &amp;operator += (GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2); 
   template &lt;typename TipEl1, typename TipEl2&gt; 
   friend GMatrica&lt;TipEl1&gt; &amp;operator -= (GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2); 
   template &lt;typename TipEl1, typename TipEl2&gt; 
<a name="3"></a><font color="#00FFFF"><a href="match929-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

   friend GMatrica&lt;TipEl1&gt; &amp;operator *= (GMatrica&lt;TipEl1&gt; &amp;m1, TipEl2 a); 
   
   template &lt;typename TipEl1&gt;
   friend bool operator ==(const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2);  
   template &lt;typename TipEl1&gt; 
   friend bool operator !=(const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2); 
</font>   
   template &lt;typename TipEl1&gt; 
   friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;TipEl1&gt; &amp;m1); 
   template &lt;typename TipEl1&gt; 
   friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;TipEl1&gt; &amp;m1); 
}; 

template &lt;typename TipEl1&gt; 
std::istream &amp;operator &gt;&gt; (std::istream &amp;tok, GMatrica&lt;TipEl1&gt; &amp;m1) {
   char znak; 
   tok &gt;&gt; znak; 
   if (znak != '[') tok.setstate(std::ios::failbit); 
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++) {
         tok &gt;&gt; m1.mat[i][j]; 
      }
      tok &gt;&gt; znak; 
      if (znak != ';') tok.setstate(std::ios::failbit); 
   }
   
   tok &gt;&gt; znak; 
   if (znak != ']') tok.setstate(std::ios::failbit); 
   
   return tok; 
}

template &lt;typename TipEl1&gt; 
<a name="9"></a><font color="#FF00FF"><a href="match929-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;TipEl1&gt; &amp;m1) {
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++) {
</font>      tok &lt;&lt; std::setw(6);
      tok &lt;&lt; m1.mat[i][j];
      }
      tok &lt;&lt; std::endl;
   }
   return tok; 
}

template &lt;typename TipEl1&gt;
bool operator ==(const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2) {
   bool iste=false; 
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++) {
      if (m1.mat[i][j]==m2.mat[i][j]) {
         iste=true; 
      }
     }
   }
   if (iste==true) return true; 
   else return false; 
}

template &lt;typename TipEl1&gt; 
bool operator !=(const GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2) {
   bool razlicite=false; 
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++) {
      if (m1.mat[i][j]!=m2.mat[i][j]) {
         razlicite=true; 
      }
     }
   }
   if (razlicite==true) return true; 
   else return false; 
}

template&lt;typename Tip1&gt; 
GMatrica&lt;Tip1&gt;::GMatrica() { broj_kolona=0; broj_redova=0; }

template &lt;typename Tip1&gt; 
<a name="2"></a><font color="#0000FF"><a href="match929-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

GMatrica&lt;Tip1&gt;::GMatrica(int broj_redova, int broj_kolona, Tip1 vrijednost) : broj_redova(broj_redova), broj_kolona(broj_kolona) {
   if (broj_redova&lt;0 || broj_redova&gt;4 || broj_kolona&lt;0 || broj_kolona&gt;4) 
   throw std::logic_error ("Ilegalan format matrice"); 
   
   for (int i=0; i&lt;broj_redova; i++) {
      for (int j=0; j&lt;broj_kolona; j++) 
      mat[i][j]=vrijednost; 
</font>   }
}

template &lt;typename Tip1&gt; 
GMatrica&lt;Tip1&gt;::GMatrica(const GMatrica &amp;matr) : broj_redova(matr.broj_redova), broj_kolona(matr.broj_kolona) {
   
   for (int i=0; i&lt;broj_redova; i++) {
      for (int j=0; j&lt;broj_kolona; j++) 
      mat[i][j]=matr[i][j];
   }
}

template &lt;typename Tip1&gt; 
<a name="8"></a><font color="#00FFFF"><a href="match929-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

GMatrica&lt;Tip1&gt;::GMatrica(Tip1 matr[4][4]) {
   for (int i=0; i&lt;4; i++) {
      for (int j=0; j&lt;4; j++) 
      mat[i][j]=matr[i][j];
</font>   }
}

template &lt;typename Tip1&gt; 
GMatrica&lt;Tip1&gt;::GMatrica(std::vector&lt;std::vector&lt;Tip1&gt;&gt; matr) {
   if (matr.size()&gt;4) throw std::logic_error ("Ilegalan format matrice"); 
   for (int i=0; i&lt;matr.size(); i++) {
      if (matr[i].size()&gt;4 || matr[i].size()&lt;0) throw std::logic_error("Ilegalan format matrice"); 
   }
   
   for (int i=0; i&lt;matr.size(); i++) {
      for (int j=0; j&lt;matr[i].size(); j++) 
      mat[i][j]=matr[i][j];
   }
}

template &lt;typename Tip1&gt; 
GMatrica&lt;Tip1&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip1&gt;&gt; lista) : broj_redova(lista.size()), broj_kolona(lista.size()) {
   if (lista.size()&lt;0 || lista.size()&gt;4) throw std::logic_error ("Ilegalan format matrice");
   
   auto it=lista.begin(); 
   auto it1=((*it).begin());
   
   for (auto i=0; i&lt;broj_redova; i++) {
      for (auto j=0; j&lt;broj_kolona; j++) {
      mat[i][j]=*it1; 
      it1++;
      }
      it++;
   }
}

<a name="0"></a><font color="#FF0000"><a href="match929-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

template &lt;typename TipEl1, typename TipEl2&gt; 
GMatrica&lt;TipEl1&gt; operator +(const GMatrica&lt;TipEl2&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2) {
   if (m1.broj_redova != m2.broj_redova || m1.broj_kolona != m2.broj_kolona) 
   throw std::domain_error ("Nedozvoljena operacija"); 
   
   GMatrica&lt;TipEl1&gt; m3(m1.broj_redova, m1.broj_kolona);
</font>   
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++)
         m3.mat[i][j]=m1.mat[i][j]+m2.mat[i][j]; 
   }
   return m3; 
}

<a name="1"></a><font color="#00FF00"><a href="match929-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

template &lt;typename TipEl1, typename TipEl2&gt; 
GMatrica&lt;TipEl1&gt; operator -(const GMatrica&lt;TipEl2&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2) {
   if (m1.broj_redova != m2.broj_redova || m1.broj_kolona != m2.broj_kolona) 
   throw std::domain_error ("Nedozvoljena operator"); 
   
   GMatrica&lt;TipEl1&gt; m3(m1.broj_redova, m1.broj_kolona); 
</font>   
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++) 
      m3.mat[i][j]=m1.mat[i][j]-m2.mat[i][j]; 
   }
   return m3; 
}

template &lt;typename TipEl1, typename TipEl2&gt; 
<a name="4"></a><font color="#FF00FF"><a href="match929-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

GMatrica&lt;TipEl1&gt; operator *(const GMatrica&lt;TipEl2&gt; &amp;m1, const GMatrica&lt;TipEl1&gt; &amp;m2) {
   if (m1.DajBrojRedova() != m2.DajBrojKolona()) throw std::domain_error ("Nedozvoljena operacija"); 
   
   GMatrica&lt;TipEl1&gt; m3; 
</font>   
<a name="7"></a><font color="#0000FF"><a href="match929-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

   for (int i=0; i&lt;m1.broj_redova; i++) 
   for (int j=0; j&lt;m2.broj_kolona; j++) {
   
      m3.mat[i][j]=0;
      for (int k=0; k&lt;m1.broj_kolona; k++) 
</font><a name="12"></a><font color="#0000FF"><a href="match929-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

      m3.mat[i][j]+=m1.mat[i][k]*m2.mat[k][j];
   }
   return m3; 
}

template &lt;typename TipEl1, typename TipEl2&gt; 
</font>GMatrica&lt;TipEl1&gt; operator *(const GMatrica&lt;TipEl1&gt; &amp;m1, TipEl2 a) {
   GMatrica&lt;TipEl1&gt; m3; 
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++)
      m3.mat[i][j]=m1.mat[i][j]*a; 
   }
}

template &lt;typename TipEl1, typename TipEl2&gt; 
GMatrica&lt;TipEl1&gt; operator *(TipEl2 a, const GMatrica&lt;TipEl1&gt; &amp;m1) {
   GMatrica&lt;TipEl1&gt; m3; 
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++) 
      m3.mat[i][j]=a*m1.mat[i][j]; 
   }
}

template &lt;typename TipEl1, typename TipEl2&gt; 
<a name="5"></a><font color="#FF0000"><a href="match929-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

GMatrica&lt;TipEl1&gt; &amp;operator +=(GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2) {
   
   if (m1.broj_redova != m2.broj_redova || m1.broj_kolona != m2.broj_kolona) 
   throw std::domain_error ("Nedozvoljena operacija"); 
   
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++) {
</font>         m1.mat[i][j]=m1.mat[i][j]+m2.mat[i][j]; 
      }
   }
   return m1; 
}

template &lt;typename TipEl1, typename TipEl2&gt; 
<a name="6"></a><font color="#00FF00"><a href="match929-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

GMatrica&lt;TipEl1&gt; &amp;operator -= (GMatrica&lt;TipEl1&gt; &amp;m1, const GMatrica&lt;TipEl2&gt; &amp;m2) {
   if (m1.broj_redova != m2.broj_redova || m1.broj_kolona != m2.broj_kolona) 
   throw std::domain_error ("Nedozvoljena operacija"); 
   
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m2.broj_kolona; j++) {
</font>         m1.mat[i][j]=m1.mat[i][j]-m2.mat[i][j];
      }
   }
   return m1; 
}

template &lt;typename TipEl1, typename TipEl2&gt; 
GMatrica&lt;TipEl1&gt; &amp;operator *= (GMatrica&lt;TipEl1&gt; &amp;m1, TipEl2 a) {
   
   for (int i=0; i&lt;m1.broj_redova; i++) {
      for (int j=0; j&lt;m1.broj_kolona; j++) {
         m1.mat[i][j]=m1.mat[i][j]*a; 
      }
   }
      return m1; 
}

int main () {
   
   GMatrica&lt;int&gt; m1 ({{1,2}, {3,4}});
   GMatrica&lt;int&gt; m2 ({{1,2}, {3,4}}); 
   
   m1+=m2; 
   std::cout &lt;&lt; m1 &lt;&lt; std::endl; 
   
   m1-=m2; 
   std::cout &lt;&lt; m1 &lt;&lt; std::endl; 
   
   m1*=2; 
   std::cout &lt;&lt; m1 &lt;&lt; std::endl; 
   
   if (m1==m2) std::cout &lt;&lt; std::endl &lt;&lt; "OK"; 
   else std::cout &lt;&lt; std::endl &lt;&lt; "NOT OK"; 
   
	return 0;
}</pre>
</body>
</html>
