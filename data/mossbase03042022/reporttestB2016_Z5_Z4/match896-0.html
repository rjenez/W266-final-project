<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6321.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6321.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;stdexcept&gt;
#include&lt;initializer_list&gt;
#include&lt;iomanip&gt;
#include&lt;utility&gt;
template&lt;typename tip&gt;
class GMatrica{
    
    int broj_redova;
<a name="8"></a><font color="#00FFFF"><a href="match896-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    int broj_kolona;
    tip mat[4][4];
    
    
    public:
    
    GMatrica():broj_redova(0),broj_kolona(0){};
    GMatrica(int broj_redova,int broj_kolona,tip t=tip());
</font>    
    template&lt;typename tip2&gt;
    GMatrica(GMatrica&lt;tip2&gt; mat2);
    
    GMatrica(tip m[4][4]);
    GMatrica(std::vector&lt;std::vector&lt;tip&gt;&gt; v);
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt; lista);
    int DajBrojRedova() const{return broj_redova;};
    int DajBrojKolona() const {return broj_kolona;}
    
<a name="0"></a><font color="#FF0000"><a href="match896-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

   template&lt;typename tip1,typename tip2&gt;
    friend auto operator +(const GMatrica&lt;tip1&gt; &amp;mat1,const GMatrica&lt;tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.mat[0][0]+mat2.mat[0][0])&gt;;
    
    template&lt;typename tip1,typename tip2&gt;
    friend auto operator -(const GMatrica&lt;tip1&gt; &amp;mat1,const GMatrica&lt;tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.mat[0][0]-mat2.mat[0][0])&gt;;
    
    template&lt;typename tip1,typename tip2&gt;
  friend auto operator *(const GMatrica&lt;tip1&gt; &amp;mat1,const GMatrica&lt;tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.mat[0][0]*mat2.mat[0][0])&gt;;
</font>  
  
  template&lt;typename tip1&gt;
  GMatrica &amp;operator +=(const GMatrica&lt;tip1&gt; &amp;m);
  template&lt;typename tip1&gt;
  GMatrica &amp;operator -=(const GMatrica&lt;tip1&gt; &amp;m);
  template&lt;typename tip1&gt;
  GMatrica &amp;operator *=(const GMatrica&lt;tip1&gt; &amp;m);
  template&lt;typename tip1&gt;
  GMatrica &amp;operator *=(tip1 t);
  
 
   template&lt;typename tip1,typename tip2&gt;
   friend auto operator *(tip1 t,const GMatrica&lt;tip2&gt; &amp;m)-&gt;GMatrica&lt;decltype(t*m.mat[0][0])&gt;;
<a name="2"></a><font color="#0000FF"><a href="match896-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    
    template&lt;typename tip1,typename tip2&gt;
 friend auto operator *(const GMatrica&lt;tip1&gt; &amp;m,tip2 t)-&gt;GMatrica&lt;decltype(t*m.mat[0][0])&gt;;
</font> 
  template&lt;typename tip1,typename tip2&gt;
  friend bool operator ==(const GMatrica&lt;tip1&gt; &amp;mat1,const GMatrica&lt;tip2&gt; &amp;mat2);
  
  template&lt;typename tip1,typename tip2&gt;
  friend bool operator !=(const GMatrica&lt;tip1&gt; &amp;mat1,const GMatrica&lt;tip2&gt; &amp;mat2);
 

 auto operator [](int indeks)-&gt;decltype(mat[indeks]);

 
  
  tip operator ()(int x,int y);

 
    
    template&lt;typename tip1&gt;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok,const GMatrica&lt;tip1&gt; &amp;m);
    template&lt;typename tip1&gt;
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;tok,GMatrica&lt;tip1&gt; &amp;m);
    
    
    
};

template&lt;typename tip&gt;
<a name="9"></a><font color="#FF00FF"><a href="match896-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

tip GMatrica&lt;tip&gt;:: operator ()(int x, int y){
    if(x&lt;1 || x&gt;4 || y&lt;1 || y&gt;4) throw std::range_error("Nedozvoljen indeks");
</font>    return mat[x-1][y-1];
}

template&lt;typename tip&gt;


 auto GMatrica&lt;tip&gt;::operator [](int indeks)-&gt;decltype(mat[indeks]) {
     return mat[indeks];
 }
 

template&lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica(int broj_redova,int broj_kolona,tip t ){
    
    if(broj_redova&lt;0 || broj_redova&gt;4 || broj_kolona&lt;0 || broj_kolona&gt;4) throw std::logic_error("Ilegalan format matrice");
    
    GMatrica::broj_redova=broj_redova; GMatrica::broj_kolona=broj_kolona;
    
    for(int i=0;i&lt;broj_redova;i++){
        for(int j=0;j&lt;broj_redova;j++){
            mat[i][j]=t;
        }
    }
}
template&lt;typename tip&gt;
template&lt;typename tip2&gt;
<a name="5"></a><font color="#FF0000"><a href="match896-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

GMatrica&lt;tip&gt;::GMatrica(GMatrica&lt;tip2&gt; mat2){
    
    broj_redova=mat2.broj_redova;
    broj_kolona=mat2.broj_kolona;
    for(int i=0;i&lt;broj_redova;i++){
        for(int j=0;j&lt;broj_kolona;j++){
</font><a name="10"></a><font color="#FF0000"><a href="match896-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

            mat[i][j]=mat2[i][j];
        }
    }
    
}
template&lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica(tip m[4][4]):broj_redova(4),broj_kolona(4){
</font>    for(int i=0;i&lt;broj_redova;i++){
        for(int j=0;j&lt;broj_kolona;j++){
            mat[i][j]=m[i][j];
        }
    }
}

template&lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica(std::vector&lt;std::vector&lt;tip&gt;&gt; v){
    int red(v.size());
    
    if(red&gt;4) throw std::logic_error("Ilegalan format matrice");
    int kolona;
    if(red==0) kolona=0;
    else kolona=v[0].size();
    for(int i=0;i&lt;red;i++){
        if(v[i].size()!=kolona) throw std::logic_error("Ilegalan format matrice");
    }
    broj_redova=red; broj_kolona=kolona;
    for(int i=0;i&lt;broj_redova;i++){
        for(int j=0;j&lt;broj_kolona;j++){
            mat[i][j]=v[i][j];
        }
    }
  
}
template&lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt; lista){
    auto red(lista.size());
    if(red&gt;4) throw std::logic_error("Ilegalan format matrice");
    auto kolona(lista.begin()-&gt;size());
   for(auto it=lista.begin();it!=lista.end();it++){
        
            if(it-&gt;size()!=kolona)  throw std::logic_error("Ilegalan format matrice");
    
    }
    
    broj_redova=red; broj_kolona=kolona;
   
    int i(0);
    for(auto it=lista.begin();it!=lista.end();it++){
        int j(0);
        for(auto it2=it-&gt;begin();it2!=it-&gt;end();it2++){
            mat[i][j]=*it2;
            
            j++;
        }
        i++;
    }
    
   
    
}

template&lt;typename tip1,typename tip2&gt;

auto operator +(const  GMatrica&lt;tip1&gt; &amp;mat1, const GMatrica&lt;tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.mat[0][0]+mat2.mat[0][0])&gt;
{
    
   if(mat1.broj_redova!=mat2.broj_redova || mat1.broj_kolona!=mat2.broj_kolona) throw std::domain_error("Nedozvoljena operacija");
    
    GMatrica&lt;decltype(mat1.mat[0][0]+mat2.mat[0][0])&gt; gmat(mat1.broj_redova,mat1.broj_kolona,0);
    
   
    for(int i=0;i&lt;mat1.broj_redova;i++){
        for(int j=0;j&lt;mat1.broj_kolona;j++){
            
       
         gmat.mat[i][j]=mat1.mat[i][j]+mat2.mat[i][j];
        }
    }
    
    return gmat;
}

template&lt;typename tip&gt;
template&lt;typename tip1&gt;
GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator +=(const GMatrica&lt;tip1&gt; &amp;m){
     
   if(broj_redova!=m.broj_redova || broj_kolona!=m.broj_kolona) throw std::domain_error("Nedozvoljena operacija");
 
    for(int i=0;i&lt;m.broj_redova;i++){
        for(int j=0;j&lt;m.broj_kolona;j++){
     
         mat[i][j]=mat[i][j]+m.mat[i][j];
        }
    }
    
    return *this;
}
template&lt;typename tip&gt;
template&lt;typename tip1&gt;
GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator -=(const GMatrica&lt;tip1&gt; &amp;m){
     
   if(broj_redova!=m.broj_redova || broj_kolona!=m.broj_kolona) throw std::domain_error("Nedozvoljena operacija");
  
    for(int i=0;i&lt;m.broj_redova;i++){
        for(int j=0;j&lt;m.broj_kolona;j++){
     
         mat[i][j]=mat[i][j]-m.mat[i][j];
        }
    }
    
    return *this;
}
template&lt;typename tip&gt;
 template&lt;typename tip1&gt;
   GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator *=(const GMatrica&lt;tip1&gt; &amp;m){
        if(broj_kolona!=m.broj_redova) throw std::domain_error("Nedozvoljena operacija");
          
          for(int i=0;i&lt;broj_redova;i++){
              for(int j=0;j&lt;m.broj_kolona;j++){
                  tip1 pomocna(0);
                  for(int k=0;k&lt;broj_kolona;k++){
                      pomocna+=mat[i][k]*m.mat[k][j];
                  }
                  mat[i][j]=pomocna;
                
              }
          }
          return *this;
        
        
    }
    template&lt;typename tip&gt;
<a name="4"></a><font color="#FF00FF"><a href="match896-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    template&lt;typename tip1&gt;
 GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator *=(tip1 t){
    
       
        for(int i=0;i&lt;broj_redova;i++){
            for(int j=0;j&lt;broj_kolona;j++){
               mat[i][j]=t*mat[i][j];
</font>            }
        }
        return *this;
    }
template&lt;typename tip1,typename tip2&gt;
<a name="6"></a><font color="#00FF00"><a href="match896-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

auto operator -(const  GMatrica&lt;tip1&gt; &amp;mat1, const GMatrica&lt;tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.mat[0][0]-mat2.mat[0][0])&gt;
{
    
   if(mat1.broj_redova!=mat2.broj_redova || mat1.broj_kolona!=mat2.broj_kolona) throw std::domain_error("Nedozvoljena operacija");
</font>    
<a name="11"></a><font color="#00FF00"><a href="match896-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    GMatrica&lt;decltype(mat1.mat[0][0]-mat2.mat[0][0])&gt; gmat(mat1.broj_redova,mat1.broj_kolona,0);
</font>    for(int i=0;i&lt;mat1.broj_redova;i++){
        for(int j=0;j&lt;mat1.broj_kolona;j++){
<a name="3"></a><font color="#00FFFF"><a href="match896-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

            gmat.mat[i][j]=mat1.mat[i][j]-mat2.mat[i][j];
        }
    }
    
    return gmat;
}

 template&lt;typename tip1,typename tip2&gt;
 auto operator *(tip1 t,const GMatrica&lt;tip2&gt; &amp;m)-&gt;GMatrica&lt;decltype(t*m.mat[0][0])&gt;{
</font>    
     
        GMatrica&lt;decltype(t*m.mat[0][0])&gt; gmat(m.broj_redova,m.broj_kolona,1);
<a name="1"></a><font color="#00FF00"><a href="match896-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        for(int i=0;i&lt;m.broj_redova;i++){
            for(int j=0;j&lt;m.broj_kolona;j++){
                gmat.mat[i][j]=t*m.mat[i][j];
            }
        }
        return gmat;
    }
    
template&lt;typename tip1, typename tip2&gt;
    auto operator *(const GMatrica&lt;tip1&gt; &amp;m,tip2 t)-&gt;GMatrica&lt;decltype(t*m.mat[0][0])&gt;{
</font>        return t*m;
    }
  
     template&lt;typename tip1,typename tip2&gt;
   auto operator *(const GMatrica&lt;tip1&gt; &amp;mat1,const GMatrica&lt;tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(mat1.mat[0][0]*mat2.mat[0][0])&gt;{
        if(mat1.broj_kolona!=mat2.broj_redova) throw std::domain_error("Nedozvoljena operacija");
          GMatrica&lt;decltype(mat1.mat[0][0]*mat2.mat[0][0])&gt; gmat(mat1.broj_redova,mat2.broj_kolona,1);
          for(int i=0;i&lt;mat1.broj_redova;i++){
              for(int j=0;j&lt;mat2.broj_kolona;j++){
                  tip1 pomocna(0);
                  for(int k=0;k&lt;mat1.broj_kolona;k++){
                      pomocna+=mat1.mat[i][k]*mat2.mat[k][j];
                  }
                  gmat.mat[i][j]=pomocna;
                  
                  
                  
              }
          }
          return gmat;
        
        
    }

template &lt;typename tip1&gt;
<a name="7"></a><font color="#0000FF"><a href="match896-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok,const GMatrica&lt;tip1&gt; &amp;m){
    
    for(int i=0;i&lt;m.broj_redova;i++){
        for(int j=0;j&lt;m.broj_kolona;j++){
</font>            tok&lt;&lt;std::setw(6)&lt;&lt;m.mat[i][j];
        }
        tok&lt;&lt;std::endl;
    }
    return tok;
}
template&lt;typename tip1&gt;
    std::istream &amp;operator&gt;&gt;(std::istream &amp;tok,GMatrica&lt;tip1&gt; &amp;m){
        
        
        char znak;
        tok&gt;&gt;std::ws;
        if(tok.peek()!='[') tok.setstate(std::ios::failbit);
        tok&gt;&gt;znak;
        int i(0);
        bool prvi(true);
        int provjera(0);
        int j(0);
       
        p:
     
        tok&gt;&gt;m.mat[i][j];
        j++;
       
        
        if(tok.peek()==',') {
            tok&gt;&gt;znak;
            goto p;
        }
        if(tok.peek()==';'&amp;&amp; prvi) {
            tok&gt;&gt;znak;
            prvi=false;
            provjera=j;
            if(j&gt;3) tok.setstate(std::ios::failbit);
            
           
            
            i++; j=0; goto p;
        }
        if(tok.peek()==';' &amp;&amp; !prvi){
            tok&gt;&gt;znak;
            if(provjera!=j || j&gt;3) tok.setstate(std::ios::failbit);
         
            i++; j=0;goto p;
        }
    if(tok.peek()==']'){
        if(provjera!=j || j&gt;3) tok.setstate(std::ios::failbit);
        tok&gt;&gt;znak;
        if(tok.peek()!='\n' || tok.peek()!='\r' || tok.peek()!='\f' || tok.peek()!='\v' || tok.peek()!='\t' || tok.peek()!=' ') tok.setstate(std::ios::failbit);
        
       i++;
        }
        
       m.broj_redova=i;
        m.broj_kolona=provjera;
    
    return tok;
  }
    

template&lt;typename tip1,typename tip2&gt;
bool operator ==(const GMatrica&lt;tip1&gt; &amp;mat1,const GMatrica&lt;tip2&gt; &amp;mat2){
    
    if(mat1.broj_redova!=mat2.broj_redova || mat1.broj_kolona!=mat2.broj_kolona) return false;
    for(int i=0;i&lt;mat1.broj_redova;i++){
        for(int j=0;j&lt;mat1.broj_kolona;j++){
            if(mat1.mat[i][j]!=mat2.mat[i][j]) return false;
        }
    }
    
    return true;
}
template &lt;typename tip1,typename tip2&gt;
bool operator !=(const GMatrica&lt;tip1&gt; &amp;mat1,const GMatrica&lt;tip2&gt; &amp;mat2){
    return !(mat1==mat2);
}


int main ()
{
    GMatrica&lt;int&gt; m1({{1, 2}, {3, 4}});
   GMatrica&lt;int&gt; m2({{1, 2}, {3, 4}});
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
   m1 += m2;
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
   m1 -= m2;
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
	return 0;
}</pre>
</body>
</html>
