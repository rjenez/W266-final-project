<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student7125.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student7125.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match37-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template &lt;typename T&gt;
class GMatrica{
    T matrica[4][4];
    int redovi,kolone;
    public:
    GMatrica();
    GMatrica(int red, int kolona, T inicijaliziraj = 0);
    template &lt;typename T2&gt;
    GMatrica(GMatrica&lt;T2&gt; mat);
    template &lt;typename T2&gt;
    GMatrica(T2 **mat);
    template &lt;typename T2&gt;
    GMatrica(std::vector&lt;std::vector&lt;T2&gt;&gt; mat);
    template &lt;typename T2&gt;
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;T2&gt;&gt; lista);
    int DajBrojRedova() const { return redovi;}
    int DajBrojKolona() const { return kolone;}
    
    template &lt;typename T2, typename T3&gt;
    friend auto operator +(GMatrica&lt;T2&gt; mat1, GMatrica&lt;T3&gt; mat2) -&gt; decltype(GMatrica&lt;decltype(mat1[0][0]+mat2[0][0])&gt;(mat1.DajBrojRedova(),mat2.DajBrojKolona(),mat1[0][0]+mat2[0][0]));
    template &lt;typename T3&gt;
    GMatrica &amp;operator +=(GMatrica&lt;T3&gt; &amp;mat2);
    template &lt;typename T2, typename T3&gt;
    friend auto operator *(GMatrica&lt;T2&gt; mat1, GMatrica&lt;T3&gt; mat2) -&gt; decltype(GMatrica&lt;decltype(mat1[0][0]*mat2[0][0])&gt;(mat1.DajBrojRedova(),mat2.DajBrojKolona(),mat1[0][0]*mat2[0][0]));
    template &lt;typename T2, typename T3&gt;
    friend GMatrica&lt;T3&gt; operator *(T2 br, GMatrica&lt;T3&gt; mat2);
    template &lt;typename T2, typename T3&gt;
    friend GMatrica&lt;T2&gt; operator *(GMatrica&lt;T2&gt; mat1,T3 br);
    template &lt; typename T3&gt;
    GMatrica &amp;operator *=(GMatrica&lt;T3&gt; &amp;mat2);
    template &lt; typename T3&gt;
    GMatrica &amp;operator *=(T3 broj);
    template &lt;typename T2, typename T3&gt;
    friend auto operator -(GMatrica&lt;T2&gt; mat1, GMatrica&lt;T3&gt; mat2) -&gt; decltype(GMatrica&lt;decltype(mat1[0][0]-mat2[0][0])&gt;(mat1.DajBrojRedova(),mat2.DajBrojKolona(),mat1[0][0]-mat2[0][0]));
    template &lt;typename T3&gt;
    GMatrica &amp;operator -=(GMatrica&lt;T3&gt; &amp;mat2);
    T &amp;operator ()(int i, int j);
    T *operator [](int i);
    constexpr T operator () (int i, int j);
    constexpr T *operator [] (int i);
    template &lt;typename T3&gt;
    friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, GMatrica&lt;T3&gt; &amp; mat1);
    template &lt;typename T3&gt;
    friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;T3&gt; &amp; mat1);
};
template &lt;typename T, typename T2&gt;
bool operator ==(GMatrica&lt;T&gt; &amp;mat1, GMatrica&lt;T2&gt; &amp;mat2);
template &lt;typename T, typename T2&gt;
bool operator !=(GMatrica&lt;T&gt; &amp;mat1, GMatrica&lt;T2&gt; &amp;mat2);

int main ()
{
   GMatrica&lt;int&gt; m1;
   std::cin &gt;&gt; m1;
   std::cout &lt;&lt; m1 &lt;&lt; std::endl;
	return 0;
}
template &lt;typename T&gt;
GMatrica&lt;T&gt;::GMatrica(): redovi(0),kolone(0){}
template &lt;typename T&gt;
GMatrica&lt;T&gt;::GMatrica(int red, int kolona, T inicijaliziraj): redovi(red), kolone(kolona){
        if(red &lt; 0 || red &gt; 4 || kolona &lt; 0 || kolona &gt; 4)
            throw std::logic_error("Ilegalan format matrice");
        for(int i(0); i &lt; red; i++)
            for(int j(0); j &lt; kolona; j++)
                matrica[i][j] = inicijaliziraj;
    }
template &lt;typename T&gt;
template &lt;typename T2&gt;
GMatrica&lt;T&gt;::GMatrica(GMatrica&lt;T2&gt; mat): redovi(mat.redovi),kolone(mat.kolone){
        for(int i(0); i &lt; redovi; i++)
            for(int j(0); j &lt; kolone; j++)
                matrica[i][j] = mat[i][j];
    }
template &lt;typename T&gt;
template &lt;typename T2&gt;
GMatrica&lt;T&gt;::GMatrica(T2 **mat): redovi(4),kolone(4){
        for(int i(0); i &lt; redovi; i++)
            for(int j(0); j &lt; kolone; j++)
                matrica[i][j] = mat[i][j];
    }
template &lt;typename T&gt;
template &lt;typename T2&gt;
GMatrica&lt;T&gt;::GMatrica(std::vector&lt;std::vector&lt;T2&gt;&gt; mat): redovi(mat.size()),kolone(mat[0].size()){
        if(redovi &lt; 0 || redovi &gt; 4 || kolone &lt; 0 || kolone &gt; 4)
            throw std::logic_error("Ilegalan format matrice");
        for(int i(0); i &lt; redovi; i++)
            if(mat[i].size() != mat[0].size())
                throw std::logic_error("Ilegalan format matrice");
            
        for(int i(0); i &lt; redovi; i++)
            for(int j(0); j &lt; kolone; j++)
                matrica[i][j] = mat[i][j];
}
template&lt;typename T&gt;
template&lt;typename T2&gt;
GMatrica&lt;T&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;T2&gt;&gt; mat){
    auto it(mat.begin());
    redovi = mat.size();
    kolone = (*it).size();
    if(mat.size() &lt; 0 || mat.size() &gt; 4 || (*it).size() &lt; 0 || (*it).size() &gt; 4)
            throw std::logic_error("Ilegalan format matrice");
        for(int i(0); i &lt; redovi; i++)
            if((*(it+i)).size() != (*it).size())
                throw std::logic_error("Ilegalan format matrice");
                
        redovi = mat.size();
        kolone = (*it).size();
        
    int i(0),j(0);
    for(auto x: mat){
        for(auto y: x){
            matrica[i][j] = y;
            j++;
        }
        j = 0;
        i++;
    }
}
            

template &lt;typename T2, typename T3&gt;
auto operator +(GMatrica&lt;T2&gt; mat1, GMatrica&lt;T3&gt; mat2) -&gt; decltype(GMatrica&lt;decltype(mat1[0][0]+mat2[0][0])&gt;(mat1.DajBrojRedova(),mat2.DajBrojKolona(),mat1[0][0]+mat2[0][0])){
    if(mat1.redovi != mat2.redovi || mat1.kolone != mat2.kolone)
        throw std::domain_error("Nedozvoljena operacija");
    
   decltype(GMatrica&lt;decltype(mat1[0][0]+mat2[0][0])&gt;(mat1.DajBrojRedova(),mat2.DajBrojKolona(),mat1[0][0]+mat2[0][0])) mat3(mat1);
    mat3 += mat2;
    return mat3;
}
template &lt;typename T&gt;
template &lt;typename T3&gt;
GMatrica&lt;T&gt; &amp;GMatrica&lt;T&gt;::operator +=(GMatrica&lt;T3&gt; &amp;mat2){
    if(redovi != mat2.redovi || kolone != mat2.kolone)
        throw std::domain_error("Nedozvoljena operacija");

        for(int i(0); i &lt; redovi; i++)
            for(int j(0); j &lt; kolone; j++)
                matrica[i][j] += mat2.matrica[i][j];
    return *this;
}

template &lt;typename T2, typename T3&gt;
auto operator -(GMatrica&lt;T2&gt; mat1, GMatrica&lt;T3&gt; mat2) -&gt; decltype(GMatrica&lt;decltype(mat1[0][0]-mat2[0][0])&gt;(mat1.DajBrojRedova(),mat2.DajBrojKolona(),mat1[0][0]-mat2[0][0])){
    if(mat1.redovi != mat2.redovi || mat1.kolone != mat2.kolone)
        throw std::domain_error("Nedozvoljena operacija");
        
    decltype(GMatrica&lt;decltype(mat1[0][0]-mat2[0][0])&gt;(mat1.DajBrojRedova(),mat2.DajBrojKolona(),mat1[0][0]-mat2[0][0])) mat3(mat1);
    mat3 -= mat2;
    
    return mat3;
}
template &lt;typename T&gt;
template &lt; typename T3&gt;
GMatrica&lt;T&gt; &amp;GMatrica&lt;T&gt;::operator -=(GMatrica&lt;T3&gt; &amp;mat2){
    if(redovi != mat2.redovi || kolone != mat2.kolone)
        throw std::domain_error("Nedozvoljena operacija");
        
         for(int i(0); i &lt; redovi; i++)
            for(int j(0); j &lt; kolone; j++)
                matrica[i][j] -= mat2.matrica[i][j];
    return *this;
  
}
template &lt;typename T2, typename T3&gt;
auto operator *(GMatrica&lt;T2&gt; mat1, GMatrica&lt;T3&gt; mat2) -&gt; decltype(GMatrica&lt;decltype(mat1[0][0]*mat2[0][0])&gt;(mat1.DajBrojRedova(),mat2.DajBrojKolona(),mat1[0][0]*mat2[0][0])){
     if(mat1.kolone != mat2.redovi) throw std::domain_error("Nedozvoljena operacija");
     decltype(GMatrica&lt;decltype(mat1[0][0]*mat2[0][0])&gt;(mat1.DajBrojRedova(),mat2.DajBrojKolona(),mat1[0][0]*mat2[0][0])) mat3(mat1);
     mat3 *= mat2;
     return mat3;
}
template &lt;typename T&gt;
template &lt;typename T3&gt;
GMatrica&lt;T&gt; &amp;GMatrica&lt;T&gt;::operator *=(GMatrica&lt;T3&gt; &amp;mat2){
    if(kolone != mat2.redovi) throw std::domain_error("Nedozvoljena operacija");
    
    GMatrica&lt;T&gt; treca(*this);  
        for(int i(0); i &lt; treca.br_redova; i++)
            for(int j(0); j &lt; mat2.br_kolona; j++)
            matrica[i][j] = 0; 
        
        for(int i(0); i &lt; treca.br_redova; i++)
            for(int j(0); j &lt; mat2.br_kolona; j++)
                for(int k(0); k &lt;treca.br_kolona; k++)
                    matrica[i][j] += treca.matrica[i][k]*mat2.matrica[k][j];
    return *this;
}
template &lt;typename T, typename T2&gt;
bool operator ==(GMatrica&lt;T&gt; &amp;mat1, GMatrica&lt;T2&gt; &amp;mat2){
    if(mat1.DajBrojRedova() != mat2.DajBrojRedova() || mat1.DajBrojKolona() != mat2.DajBrojKolona())
        return false;
    for(int i(0); i &lt; mat1.DajBrojRedova(); i++)
        for(int j(0); j &lt; mat1.DajBrojKolona(); j++)
            if(mat1[i][j] != mat2[i][j])
                return false;
    return true;
}
template &lt;typename T, typename T2&gt;
bool operator !=(GMatrica&lt;T&gt; &amp;mat1, GMatrica&lt;T2&gt; &amp;mat2){
    return !(mat1 == mat2);
}
template &lt;typename T&gt;
T &amp;GMatrica&lt;T&gt;::operator ()(int i, int j){
    if(i &lt; 1 || i &gt; redovi || j &lt; 1 || j &gt; kolone) throw std::range_error("Nedozvoljen indeks");
    return matrica[i-1][j-1];
}
template &lt;typename T&gt;
T *GMatrica&lt;T&gt;::operator [](int i){
    return matrica[i];
}
template &lt;typename T&gt;
constexpr T GMatrica&lt;T&gt;::operator ()(int i, int j){
    if(i &lt; 1 || i &gt; redovi || j &lt; 1 || j &gt; kolone) throw std::range_error("Nedozvoljen indeks");
    return matrica[i-1][j-1];
}
template &lt;typename T&gt;
constexpr T *GMatrica&lt;T&gt;::operator [](int i){
    return matrica[i];
}
template &lt;typename T3&gt;
std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, GMatrica&lt;T3&gt; &amp; mat1){
        int sirina(tok.width());
        if(sirina &lt; 6) sirina = 6;
        for(int i(1); i &lt; mat1.redovi+1; i++){
            for(int j(1); j &lt; mat1.kolone+1; j++)
                tok &lt;&lt; std::setw(sirina) &lt;&lt; mat1(i,j);
            tok&lt;&lt;std::endl;
        }
    return tok;
    }
template &lt;typename T3&gt;
std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;T3&gt; &amp;mat1){
        char znak;
        tok&gt;&gt;znak;
        if(znak == '['){
            ++mat1.redovi;
            ++mat1.kolone;
            for(int i(0); i &lt; mat1.redovi; i++){
                for(int j(0); j &lt; mat1.kolone; j++){
                    if(!(tok&gt;&gt;mat1[i][j]&gt;&gt;znak))
                        tok.setstate(std::ios::failbit);
                    if(znak == ',')
                        ++mat1.kolone;
                    if(znak != ',' &amp;&amp; znak != ';')
                        tok.setstate(std::ios::failbit);
                }
                if(znak != ';')
                    tok.setstate(std::ios::failbit);
                if(znak == ';'){
                    ++mat1.redovi;
                    mat1.kolone = 1;
                }
            }
            if(znak != ']')
                tok.setstate(std::ios::failbit);
        }
        else tok.setstate(std::ios::failbit);
        return tok;
    }
template &lt;typename T2, typename T3&gt;
GMatrica&lt;T3&gt; operator *(T2 br, GMatrica&lt;T3&gt; mat2){
    for(int i(0); i &lt; mat2.redovi; i++)
        for(int j(0); j &lt; mat2.kolone; j++)
            mat2[i][j] *= br;
    return mat2;
}
template &lt;typename T2, typename T3&gt;
GMatrica&lt;T2&gt; operator *(GMatrica&lt;T2&gt; mat1,T3 br){
    mat1 *= br;
    return mat1;
}
template &lt;typename T&gt;
template &lt; typename T3&gt;
GMatrica&lt;T&gt; &amp;GMatrica&lt;T&gt;::operator *=(T3 broj){
    for(int i(0); i &lt; redovi; i++)
        for(int j(0); j &lt; kolone; j++)
            matrica[i][j] *= broj;
</font>    return *this;
}</pre>
</body>
</html>
