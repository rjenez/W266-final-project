<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4167.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4167.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;initializer_list&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

template &lt;typename Tip&gt;
class GMatrica {
    Tip matrica[4][4];
    int br_redova, br_kolona;
public:
    GMatrica() : br_redova(0), br_kolona(0) {}
    GMatrica(int br_redova, int br_kolona, Tip el={});
    
    template &lt;typename Tip2&gt;
    GMatrica(const GMatrica&lt;Tip2&gt; &amp;mat);
    
    template &lt;typename Tip2&gt;
    GMatrica(Tip2 niz[]);
    
    GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; v);
    GMatrica(std::initializer_list&lt;std::vector&lt;Tip&gt;&gt; lista);
    
<a name="9"></a><font color="#FF00FF"><a href="match585-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    int DajBrojRedova() const {return br_redova;}
    int DajBrojKolona() const {return br_kolona;}
    
    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator +(const GMatrica&lt;Tip1&gt; m1, const GMatrica&lt;Tip2&gt; m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt; ;
</font><a name="8"></a><font color="#00FFFF"><a href="match585-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    
    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator -(const GMatrica&lt;Tip1&gt; m1, const GMatrica&lt;Tip2&gt; m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]-m2.matrica[0][0])&gt; ;
</font><a name="4"></a><font color="#FF00FF"><a href="match585-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    
    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator *(const GMatrica&lt;Tip1&gt; m1, const GMatrica&lt;Tip2&gt; m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]*m2.matrica[0][0])&gt;;
</font><a name="0"></a><font color="#FF0000"><a href="match585-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    
    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, Tip2 x) -&gt; GMatrica&lt;decltype(m.matrica[0][0]*x)&gt;;
    
    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator *(Tip2 x, const GMatrica&lt;Tip1&gt; &amp;m) -&gt; GMatrica&lt;decltype(m.matrica[0][0]*x)&gt;;
</font>    
    GMatrica&lt;Tip&gt; &amp;operator +=(const GMatrica&lt;Tip&gt; &amp;m);
    GMatrica&lt;Tip&gt; &amp;operator -=(const GMatrica&lt;Tip&gt; &amp;m);
    GMatrica&lt;Tip&gt; &amp;operator *=(const GMatrica&lt;Tip&gt; &amp;m);
    
    GMatrica&lt;Tip&gt; &amp;operator +=(const Tip &amp;x);
    GMatrica&lt;Tip&gt; &amp;operator -=(const Tip &amp;x);
<a name="2"></a><font color="#0000FF"><a href="match585-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    GMatrica&lt;Tip&gt; &amp;operator *=(const Tip &amp;x);
    
    template &lt;typename Tip1, typename Tip2&gt;
    friend bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
    
    template &lt;typename Tip1, typename Tip2&gt;
    friend bool operator !=(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
</font>    
    auto operator [](int i) const -&gt; decltype(matrica[i]);
	auto operator [](int i) -&gt; decltype(matrica[i]);
	
	auto operator ()(int i, int j) const -&gt; decltype(matrica[i][j]);
	auto operator ()(int i, int j) -&gt; decltype(matrica[i][j]);
	
	template &lt;typename Tip2&gt;
	friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip2&gt; &amp;m);
	
	template &lt;typename Tip2&gt;
	friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip2&gt; &amp;m);
	
};

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int br_redova, int br_kolona, Tip el) : br_redova(br_redova), br_kolona(br_kolona) {
    if(br_redova&lt;0 or br_redova&gt;4 or br_kolona&lt;0 or br_kolona&gt;4)
        throw std::logic_error("Ilegalan format matrice");
    GMatrica&lt;Tip&gt;::br_redova=br_redova;
    GMatrica&lt;Tip&gt;::br_kolona=br_kolona;
<a name="11"></a><font color="#00FF00"><a href="match585-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    for(int i(0); i&lt;br_redova; i++)
        for(int j(0); j&lt;br_kolona; j++)
            matrica[i][j]=el;
}

template &lt;typename Tip&gt;
</font>template &lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;Tip2&gt; &amp;mat) : br_redova(mat.DajBrojRedova()), br_kolona(mat.DajBrojKolona()) {
    for(int i(0); i&lt;br_redova; i++)
        for(int j(0); j&lt;br_kolona; j++)
            matrica[i][j]=mat(i+1,j+1);
}

template &lt;typename Tip&gt;
template &lt;typename Tip2&gt;
<a name="12"></a><font color="#0000FF"><a href="match585-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

GMatrica&lt;Tip&gt;::GMatrica(Tip2 niz[]) : br_redova(4), br_kolona(4) {
    for(int i(0); i&lt;4; i++)
        for(int j(0); j&lt;4; j++)
            matrica[i][j]=niz[i][j];
</font>}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::vector&lt;std::vector&lt;Tip&gt;&gt; v) {
    if(v.size()&gt;4 or v.size&lt;0)
        throw std::logic_error("Ilegalan format matrice");
    int broj(v[0].size());
    for(auto x : v)
        if(x.size()!=broj)
            throw std::logic_error("Ilegalan format matrice");
    br_redova=v.size();
    br_kolona=broj;
    for(int i(0); i&lt;br_redova; i++)
        for(int j(0); j&lt;br_kolona; j++)
            matrica[i][j]=v[i][j];
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::vector&lt;Tip&gt;&gt; lista) {
    if(lista.size()&gt;4 or lista.size()&lt;0)
        throw std::logic_error("Ilegalan format matrice");
    int broj((*lista.begin()).size());
    for(auto x : lista)
        if(x.size()!=broj)
            throw std::logic_error("Ilegalan format matrice");
    br_redova=lista.size();
    br_kolona=broj;
    auto it(lista.begin());
    int i(0);
    while(it!=lista.end()) {
        int j(0);
        for(auto it2(it-&gt;begin()); it2!=it-&gt;end(); it2++) {
            matrica[i][j]=*it2;
            j++;
        }
        it++; i++;
    }
    /*for(int i(0); i&lt;br_redova; i++)
        for(int j(0); j&lt;br_kolona; j++)
            matrica[i][j]=lista[i][j];*/
}

template &lt;typename Tip1, typename Tip2&gt;
auto operator +(const GMatrica&lt;Tip1&gt; m1, const GMatrica&lt;Tip2&gt; m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt; {
    if(m1.DajBrojRedova()!=m2.DajBrojRedova() or m1.DajBrojKolona()!=m2.DajBrojKolona())
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt; mat(m1.DajBrojRedova(), m1.DajBrojKolona());
    for(int i(0); i&lt;mat.br_redova; i++)
        for(int j(0); j&lt;mat.br_kolona; j++)
<a name="7"></a><font color="#0000FF"><a href="match585-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

            mat.matrica[i][j]=m1.matrica[i][j]+m2.matrica[i][j];
    return mat;
}

template &lt;typename Tip1, typename Tip2&gt;
auto operator -(const GMatrica&lt;Tip1&gt; m1, const GMatrica&lt;Tip2&gt; m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]-m2.matrica[0][0])&gt; {
</font><a name="1"></a><font color="#00FF00"><a href="match585-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    if(m1.DajBrojRedova()!=m2.DajBrojRedova() or m1.DajBrojKolona()!=m2.DajBrojKolona())
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1.matrica[0][0]-m2.matrica[0][0])&gt; mat(m1.DajBrojRedova(), m1.DajBrojKolona());
</font>    for(int i(0); i&lt;mat.br_redova; i++)
        for(int j(0); j&lt;mat.br_kolona; j++)
            mat.matrica[i][j]=m1.matrica[i][j]-m2.matrica[i][j];
    return mat;
}
    
template &lt;typename Tip1, typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip1&gt; m1, const GMatrica&lt;Tip2&gt; m2) -&gt; GMatrica&lt;decltype(m1.matrica[0][0]*m2.matrica[0][0])&gt;{
    if(m1.DajBrojKolona()!=m2.DajBrojRedova())
        throw std::domain_error("Nedozvoljena operacija");
<a name="10"></a><font color="#FF0000"><a href="match585-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    GMatrica&lt;decltype(m1.matrica[0][0]*m2.matrica[0][0])&gt; mat(m1.DajBrojRedova(), m2.DajBrojKolona());
</font>    for(int i(0); i&lt;mat.br_redova; i++)
		for(int j(0); j&lt;mat.br_kolona; j++)
			for(int k(0); k&lt;m1.br_kolona; k++)
				mat.matrica[i][j] += m1.matrica[i][k]*m2.matrica[k][j];
    return mat;
}

<a name="5"></a><font color="#FF0000"><a href="match585-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

template &lt;typename Tip1, typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, Tip2 x) -&gt; GMatrica&lt;decltype(m.matrica[0][0]*x)&gt; {
	GMatrica&lt;Tip1&gt; m3(m.br_redova, m.br_kolona);
</font>	for(int i(0); i&lt;m3.br_redova; i++)
		for(int j(0); j&lt;m3.br_kolona; j++)
			m3.matrica[i][j]=x*m.matrica[i][j];
	return m3;
}

<a name="13"></a><font color="#00FFFF"><a href="match585-1.html#13" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

template &lt;typename Tip1, typename Tip2&gt;
auto operator *(Tip2 x, const GMatrica&lt;Tip1&gt; &amp;m) -&gt; GMatrica&lt;decltype(m.matrica[0][0]*x)&gt; {
</font>	GMatrica&lt;Tip1&gt; m3(m.br_redova, m.br_kolona);
	for(int i(0); i&lt;m3.br_redova; i++)
		for(int j(0); j&lt;m3.br_kolona; j++)
			m3.matrica[i][j]=x*m.matrica[i][j];
	return m3;
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator +=(const GMatrica&lt;Tip&gt; &amp;m) {
    if(br_redova!=m.br_redova or br_kolona!=m.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
    for(int i(0); i&lt;br_redova; i++)
        for(int j(0); j&lt;br_kolona; j++)
            matrica[i][j]+=m.matrica[i][j];
    return *this;
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator -=(const GMatrica&lt;Tip&gt; &amp;m) {
    if(br_redova!=m.br_redova or br_kolona!=m.br_kolona)
        throw std::domain_error("Nedozvoljena operacija");
    for(int i(0); i&lt;br_redova; i++)
        for(int j(0); j&lt;br_kolona; j++)
            matrica[i][j]-=m.matrica[i][j];
    return *this;
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator *=(const GMatrica&lt;Tip&gt; &amp;m) {
    if(br_kolona!=m.br_redova)
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;Tip&gt; mat(m);
    for(int i(0); i&lt;mat.br_redova; i++)
		for(int j(0); j&lt;mat.br_kolona; j++)
			for(int k(0); k&lt;m.br_kolona; k++)
				matrica[i][j] += mat.matrica[i][k]*m.matrica[k][j];
    return *this;
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator +=(const Tip &amp;x) {
    for(int i(0); i&lt;br_redova; i++)
		for(int j(0); j&lt;br_kolona; j++)
			matrica[i][j] += x;
    return *this;
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator -=(const Tip &amp;x) {
    for(int i(0); i&lt;br_redova; i++)
		for(int j(0); j&lt;br_kolona; j++)
			matrica[i][j] -= x;
    return *this;
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator *=(const Tip &amp;x) {
    for(int i(0); i&lt;br_redova; i++)
		for(int j(0); j&lt;br_kolona; j++)
			matrica[i][j] *= x;
<a name="6"></a><font color="#00FF00"><a href="match585-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    return *this;
}

template &lt;typename Tip1, typename Tip2&gt;
bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) {
    if(m1.br_redova!=m2.br_redova) return false;
</font>    if(m1.br_kolona!=m2.br_kolona) return false;
    for(int i(0); i&lt;m1.br_redova; i++)
        for(int j(0); j&lt;m1.br_kolona; j++)
<a name="3"></a><font color="#00FFFF"><a href="match585-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

            if(m1.matrica[i][j]!=m2.matrica[i][j]) return false;
    return true;
}

template &lt;typename Tip1, typename Tip2&gt;
bool operator !=(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) {
</font>    return !(m1==m2);
}

template &lt;typename Tip&gt;
auto GMatrica&lt;Tip&gt;::operator [](int i) const -&gt; decltype(matrica[i]) { 
    return matrica[i];
}
    
template &lt;typename Tip&gt;
auto GMatrica&lt;Tip&gt;::operator [](int i) -&gt; decltype(matrica[i]) {
    return matrica[i];
}

template &lt;typename Tip&gt;
auto GMatrica&lt;Tip&gt;::operator ()(int i, int j) const -&gt; decltype(matrica[i][j]) {
		if(i&lt;1 or i&gt;br_redova+1 or j&lt;1 or j&gt;br_kolona+1)
			throw std::range_error("Nedozvoljen indeks");
		return matrica[i-1][j-1];
}

template &lt;typename Tip&gt;
auto GMatrica&lt;Tip&gt;::operator ()(int i, int j) -&gt; decltype(matrica[i][j]) {
		if(i&lt;1 or i&gt;br_redova+1 or j&lt;1 or j&gt;br_kolona+1)
			throw std::range_error("Nedozvoljen indeks");
		return matrica[i-1][j-1];
}

template &lt;typename Tip&gt;
std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip&gt; &amp;m) {
    int sirina(tok.width());
    if(sirina==0) sirina=6;
<a name="14"></a><font color="#FF00FF"><a href="match585-1.html#14" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    for(int i(0); i&lt;m.br_redova; i++) {
		for(int j(0); j&lt;m.br_kolona; j++)
			tok &lt;&lt; std::setw(sirina) &lt;&lt; m.matrica[i][j];
</font>		tok &lt;&lt; std::endl;
	}
	return tok;
}

template &lt;typename Tip&gt;	
std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip&gt; &amp;m) {
    tok &gt;&gt; std::ws;
    int i(0), j(0); char znak;
    tok &gt;&gt; znak;
    if(znak!='[') {
        tok.setstate(std::ios::failbit);
    } else {
        while(1) {
        if(i==4) tok.setstate(std::ios::failbit);
        while(1) {
        if(j==4) tok.setstate(std::ios::failbit);
        tok.clear();
        tok &gt;&gt; m.matrica[i][j]; j++; tok &gt;&gt; znak;
        //std::cout &lt;&lt; "O" &lt;&lt; znak &lt;&lt; "O";
        if(znak==';') break;
        if(znak==']') {
            m.br_redova=i+1;
            m.br_kolona=j;
            return tok;
        }
        if(znak!=',') tok.setstate(std::ios::failbit);
        }
        i++; j=0;
        }
    }
	return tok;
}

int main ()
{
    GMatrica&lt;int&gt; g;
    std::cin &gt;&gt; g;
    std::cout &lt;&lt; std::endl &lt;&lt; "Matrica g:" &lt;&lt; std::endl &lt;&lt; std::setw(6) &lt;&lt; g;
    GMatrica&lt;double&gt; g3(g);
    std::cout &lt;&lt; std::endl &lt;&lt; "Matrica g3:" &lt;&lt; std::endl &lt;&lt; std::setw(6) &lt;&lt; g3 &lt;&lt; std::endl;
    int niz[4][4]{{1,2,3},{0,0,2}};
    GMatrica&lt;double&gt; g2(niz);
    std::cout &lt;&lt; std::endl &lt;&lt; "Matrica g2:" &lt;&lt; std::endl &lt;&lt; std::setw(6) &lt;&lt; g2;
	return 0;
}</pre>
</body>
</html>
