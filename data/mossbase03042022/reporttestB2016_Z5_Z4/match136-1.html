<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6321.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student9823.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
template &lt;typename tip&gt;
class GMatrica {
    tip matrica[4][4];
    int br_redova, br_kolona;
public:
    // -------------------- konstrukcija ------------------
    GMatrica();
    GMatrica(int br_redova, int br_kolona, int pocVrj);
    template &lt;typename tip2&gt; 
    GMatrica(GMatrica&lt;tip2&gt; &amp;a);
    template &lt;typename tip2&gt;
    GMatrica(tip2 **Vedranovniz);
    GMatrica(std::vector&lt;std::vector&lt;tip&gt;&gt; &amp;vektor);
<a name="0"></a><font color="#FF0000"><a href="match136-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

    GMatrica(std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt; lista);
    // --------------------- operacija --------------------
    int DajBrojRedova() const { return br_redova; }
    int DajBrojKolona() const { return br_kolona; }
    template &lt;typename tip1, typename tip2&gt;
    friend auto operator +(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b) -&gt; GMatrica&lt;decltype(a.matrica[0][0] + b.matrica[0][0])&gt;;
    template &lt;typename tip1, typename tip2&gt;
    friend auto operator -(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b) -&gt; GMatrica&lt;decltype(a.matrica[0][0] - b.matrica[0][0])&gt;;
    template &lt;typename tip1, typename tip2&gt;
    friend auto operator *(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b) -&gt; GMatrica&lt;decltype(a.matrica[0][0] * b.matrica[0][0])&gt;;
    template &lt;typename tip1, typename tip2&gt;
</font><a name="2"></a><font color="#0000FF"><a href="match136-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

    friend auto operator *(tip1 broj, const GMatrica&lt;tip2&gt; &amp;b) -&gt; GMatrica&lt;decltype(broj * b.matrica[0][0])&gt;;
    template &lt;typename tip1, typename tip2&gt;
    friend auto operator *(const GMatrica&lt;tip1&gt; &amp;b, tip2 broj) -&gt; GMatrica&lt;decltype(b.matrica[0][0] * broj)&gt;;
</font>    // -------------------- unutrasnja -------------------
    GMatrica&lt;tip&gt; &amp;operator += (const GMatrica&lt;tip&gt; &amp;b);
    GMatrica&lt;tip&gt; &amp;operator -= (const GMatrica&lt;tip&gt; &amp;b);
    GMatrica&lt;tip&gt; &amp;operator *= (const GMatrica&lt;tip&gt; &amp;b);
    GMatrica&lt;tip&gt; &amp;operator *= (tip broj);
<a name="3"></a><font color="#00FFFF"><a href="match136-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    template &lt;typename tip1, typename tip2&gt;
    friend bool operator ==(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b);
    template &lt;typename tip1, typename tip2&gt;
    friend bool operator !=(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b);
    // --------- ostala jos 4 braco mila -----------------
    const tip operator ()(int indeks1, int indeks2) const;
</font>    tip operator ()(int indeks1, int indeks2);
    const tip* operator [](int indeks) const;
    tip* operator [](int indeks);
    template&lt;typename tip2&gt;
	friend std::ostream &amp;operator &lt;&lt; (std::ostream&amp; ispis, GMatrica&lt;tip2&gt; m);		
	template &lt;typename Tip3&gt;
	friend std::istream &amp;operator &gt;&gt; (std::istream&amp; ispis, GMatrica&lt;Tip3&gt; &amp;m);
    
};

// -------------------- konstrukcija -----------------

template &lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica() { br_kolona = 0; br_redova = 0; }

template &lt;typename tip&gt;
<a name="16"></a><font color="#00FF00"><a href="match136-0.html#16" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

GMatrica&lt;tip&gt;::GMatrica(int br_redova, int br_kolona, int pocVrj) {
    if(br_redova &lt; 0 || br_kolona &lt; 0 || br_redova &gt;= 4 || br_kolona &gt;= 4) throw std::logic_error("Ilegalan format matrice");
</font>    this-&gt;br_redova = br_redova; this-&gt;br_kolona = br_kolona;
    for(int i=0; i &lt; br_redova; i++) for(int j=0; j &lt; br_kolona; j++) matrica[i][j] = pocVrj;
}

template &lt;typename tip&gt;
template &lt;typename tip2&gt; 
GMatrica&lt;tip&gt;::GMatrica(GMatrica&lt;tip2&gt; &amp;a) : br_redova(a.br_redova), br_kolona(a.br_kolona) {
    for(int i = 0; i &lt; a.br_redova; i++) for(int j = 0; j &lt; a.br_kolona; j++) matrica[i][j] = a.matrica[i][j];
}

template &lt;typename tip&gt;
template &lt;typename tip2&gt;
GMatrica&lt;tip&gt;::GMatrica(tip2 **Vedranovniz) : br_redova(4), br_kolona(4) {
    for(int i = 0; i &lt; 4; i++) for(int j = 0; j &lt; 4; j++) matrica[i][j] = Vedranovniz[i][j];
}

template &lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica(std::vector&lt;std::vector&lt;tip&gt;&gt; &amp;vektor){
    int brojRV(vektor.size());
    int brojKV(vektor[0].size());
    if(brojRV &lt; 0 || brojKV &lt;0 || brojRV &gt;= 4 || brojKV &gt;= 4) throw std::logic_error("Ilegalan format matrice");
<a name="14"></a><font color="#FF00FF"><a href="match136-0.html#14" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    for(int i=0; i &lt; brojRV; i++) if(vektor[i] != brojKV) throw std::logic_error("Ilegalan format matrice");
    br_redova = brojRV; br_kolona = brojKV;
    for(int i=0; i &lt; br_redova; i++) for(int j=0; j &lt; br_kolona; j++) matrica[i][j] = vektor[i][j];
</font>}

<a name="11"></a><font color="#00FF00"><a href="match136-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

template &lt;typename tip&gt;
GMatrica&lt;tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt; lista){
    int brojRV(lista.size());
</font>    int brojKV((lista.begin())-&gt;size());
    if(brojRV &lt; 0 || brojKV &lt;0 || brojRV &gt;= 4 || brojKV &gt;= 4) throw std::logic_error("Ilegalan format matrice");
<a name="9"></a><font color="#FF00FF"><a href="match136-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    for(auto it = lista.begin(); it != lista.end(); it++) if(it-&gt;size() != brojKV) throw std::logic_error("Ilegalan format matrice");
    br_redova = brojRV; br_kolona = brojKV;
    int i(0), j(0);
</font>    for(auto it1 = lista.begin(); it1 != lista.end(); it1++){
<a name="10"></a><font color="#FF0000"><a href="match136-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

        for(auto it2 = it1-&gt;begin(); it2 != it1-&gt;end(); it2++){
            matrica[i][j] = *it2;
            j++;
        }
        i++; j=0;
</font>    }
}

// -------------------- operacija -----------------

template &lt;typename tip1, typename tip2&gt;
auto operator +(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b) -&gt; GMatrica&lt;decltype(a.matrica[0][0] + b.matrica[0][0])&gt; {
    if(a.DajBrojRedova() != b.DajBrojRedova() || a.DajBrojKolona() != b.DajBrojKolona()) throw std::domain_error("Nedozvoljena operacija");
<a name="12"></a><font color="#0000FF"><a href="match136-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    GMatrica&lt;decltype(a[0][0] + b[0][0])&gt; Nova(a.DajBrojRedova(), a.DajBrojKolona(), 0);
    for(int i=0; i &lt; Nova.DajBrojRedova(); i++) for(int j=0; j &lt; Nova.DajBrojKolona(); j++) Nova.matrica[i][j] = a.matrica[i][j] + b.matrica[i][j];
</font>    return Nova;
}

template &lt;typename tip1, typename tip2&gt;
<a name="8"></a><font color="#00FFFF"><a href="match136-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

auto operator -(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b) -&gt; GMatrica&lt;decltype(a.matrica[0][0] - b.matrica[0][0])&gt; {
    if(a.DajBrojRedova() != b.DajBrojRedova() || a.DajBrojKolona() != b.DajBrojKolona()) throw std::domain_error("Nedozvoljena operacija");
</font><a name="13"></a><font color="#00FFFF"><a href="match136-0.html#13" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    GMatrica&lt;decltype(a[0][0] - b[0][0])&gt; Nova(a.DajBrojRedova(), a.DajBrojKolona(), 0);
    for(int i=0; i &lt; Nova.DajBrojRedova(); i++) for(int j=0; j &lt; Nova.DajBrojKolona(); j++) Nova.matrica[i][j] = a.matrica[i][j] - b.matrica[i][j];
</font>    return Nova;
}

template &lt;typename tip1, typename tip2&gt;
<a name="6"></a><font color="#00FF00"><a href="match136-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

auto operator *(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b) -&gt; GMatrica&lt;decltype(a.matrica[0][0] * b.matrica[0][0])&gt; {
    if(b.DajBrojKolona() != b.DajBrojRedova()) throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;typename std::remove_reference&lt;decltype(a[0][0] * b[0][0])&gt;&gt; Nova(a.DajBrojRedova(), b.DajBrojKolona(), 0);
</font>    
<a name="17"></a><font color="#0000FF"><a href="match136-0.html#17" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    for(int i=0; i &lt; a.DajBrojRedova(); i++) {
        for(int j=0; j &lt; b.DajBrojKolona(); j++) {
            typename std::remove_reference&lt;decltype(a[0][0] * b[0][0])&gt; suma = 0;
</font><a name="5"></a><font color="#FF0000"><a href="match136-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

            for(int k=0; k &lt; b.DajBrojRedova(); k++) {
                suma += a.matrica[i][k] * b.matrica[k][j];
            }
            Nova.matrica[i][j] = suma;
        }
    }
    return Nova;
}

</font><a name="1"></a><font color="#00FF00"><a href="match136-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

template &lt;typename tip1, typename tip2&gt;
auto operator *(tip1 broj, const GMatrica&lt;tip2&gt; &amp;b) -&gt; GMatrica&lt;decltype(broj * b.matrica[0][0])&gt; {
    GMatrica&lt;decltype(broj * b.matrica[0][0])&gt; Nova(b.DajBrojRedova(), b.DajBrojKolona(), 0);
    for(int i=0; i &lt; Nova.DajBrojRedova(); i++) for(int j=0; j &lt; Nova.DajBrojKolona(); j++) Nova.matrica[i][j] = broj * b.matrica[i][j];
    return Nova;
}

template &lt;typename tip1, typename tip2&gt;
auto operator *(const GMatrica&lt;tip1&gt; &amp;b, tip2 broj) -&gt; GMatrica&lt;decltype(b.matrica[0][0] * broj)&gt; {
</font>    return broj * b;
}

// -------------------- unutrasnja -----------------

template &lt;typename tip&gt;
GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator += (const GMatrica&lt;tip&gt; &amp;b) {
    GMatrica&lt;tip&gt; a(*this);
    if(a.DajBrojRedova() != b.DajBrojRedova() || a.DajBrojKolona() != b.DajBrojKolona()) throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;tip&gt; Nova(a.DajBrojRedova(), a.DajBrojKolona(), 0);
    for(int i=0; i &lt; Nova.DajBrojRedova(); i++) for(int j=0; j &lt; Nova.DajBrojKolona(); j++) Nova.matrica[i][j] = a.matrica[i][j] + b.matrica[i][j];
    for(int i=0; i &lt; Nova.DajBrojRedova(); i++) for(int j=0; j &lt; Nova.DajBrojKolona(); j++) matrica[i][j] = Nova.matrica[i][j];
    return *this;
}

template &lt;typename tip&gt;
GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator -= (const GMatrica&lt;tip&gt; &amp;b) {
    GMatrica&lt;tip&gt; a(*this);
    if(a.DajBrojRedova() != b.DajBrojRedova() || a.DajBrojKolona() != b.DajBrojKolona()) throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;tip&gt; Nova(a.DajBrojRedova(), a.DajBrojKolona(), 0);
    for(int i=0; i &lt; Nova.DajBrojRedova(); i++) for(int j=0; j &lt; Nova.DajBrojKolona(); j++) Nova.matrica[i][j] = a.matrica[i][j] - b.matrica[i][j];
    for(int i=0; i &lt; Nova.DajBrojRedova(); i++) for(int j=0; j &lt; Nova.DajBrojKolona(); j++) matrica[i][j] = Nova.matrica[i][j];
    return *this;
}

template &lt;typename tip&gt;
GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator *= (const GMatrica&lt;tip&gt; &amp;b) {
    GMatrica&lt;tip&gt; a(*this);
    if(b.DajBrojKolona() != b.DajBrojRedova()) throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;tip&gt; Nova(a.DajBrojRedova(), b.DajBrojKolona(), 0);
    
    for(int i=0; i &lt; a.DajBrojRedova(); i++) {
        for(int j=0; j &lt; b.DajBrojKolona(); j++) {
            decltype(a.matrica[0][0] * b.matrica[0][0]) suma = 0;
            for(int k=0; k &lt; b.DajBrojRedova(); k++) {
                suma += a.matrica[i][k] * b.matrica[k][j];
            }
            Nova.matrica[i][j] = suma;
        }
    }
    for(int i=0; i &lt; Nova.DajBrojRedova(); i++) for(int j=0; j &lt; Nova.DajBrojKolona(); j++) matrica[i][j] = Nova.matrica[i][j];
    return *this;
}

<a name="7"></a><font color="#0000FF"><a href="match136-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

template &lt;typename tip&gt;
GMatrica&lt;tip&gt; &amp;GMatrica&lt;tip&gt;::operator *= (tip broj){
    for(int i=0; i &lt; br_redova; i++) for(int j=0; j &lt; br_kolona; j++) matrica[i][j] *= broj;
</font>    return *this;
}
    
template &lt;typename tip1, typename tip2&gt;
<a name="15"></a><font color="#FF0000"><a href="match136-0.html#15" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

bool operator ==(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b) {
    for(int i=0; i &lt; a.DajBrojRedova(); i++) for(int j=0; j &lt; a.DajBrojKolona(); j++) if(a.matrica[i][j] != b.matrica[i][j]) return false;
</font><a name="4"></a><font color="#FF00FF"><a href="match136-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    return true;
}

template &lt;typename tip1, typename tip2&gt;
bool operator !=(const GMatrica&lt;tip1&gt; &amp;a, const GMatrica&lt;tip2&gt; &amp;b){
    return !(a == b);
</font>}

// --------- ostala jos 4 braco mila -----------------

template &lt;typename tip&gt;
const tip GMatrica&lt;tip&gt;::operator ()(int indeks1, int indeks2) const {
    if(indeks1 &lt; 1 || indeks1 &gt; br_redova || indeks2 &lt; 1 || indeks2 &gt; br_kolona) throw std::range_error("Nedozvoljen indeks"); 
    return matrica[indeks1-1][indeks2-1];
}

template &lt;typename tip&gt;
tip GMatrica&lt;tip&gt;::operator ()(int indeks1, int indeks2) {
    if(indeks1 &lt; 1 || indeks1 &gt; br_redova || indeks2 &lt; 1 || indeks2 &gt; br_kolona) throw std::range_error("Nedozvoljen indeks"); 
    return matrica[indeks1-1][indeks2-1];
}

template &lt;typename tip&gt;
const tip* GMatrica&lt;tip&gt;::operator [](int indeks) const {
    return matrica[indeks];
}

template &lt;typename tip&gt;
tip* GMatrica&lt;tip&gt;::operator [](int indeks) {
    return matrica[indeks];
}

template &lt;typename TipEl&gt;
std::ostream &amp;operator &lt;&lt;(std::ostream &amp;ispis, GMatrica&lt;TipEl&gt; m) {
	int duzina = ispis.width();
	if(duzina &lt; 6) duzina = 6;
	for(int i=0; i &lt; m.DajBrojRedova(); i++) {
		for(int j=0; j &lt; m.DajBrojKolona(); j++) {
			ispis.width(duzina);
			ispis &lt;&lt; m.matrica[i][j];
		}
		std::cout &lt;&lt; std::endl;
	}
	return ispis;
}


template &lt;typename TipEl&gt;
std::istream &amp;operator &gt;&gt;(std::istream &amp;ispis, GMatrica&lt;TipEl&gt; &amp;m){
    std::vector&lt;TipEl&gt; novi;
    char a;
    ispis &gt;&gt; a;
    if(a != '[')  ispis.setstate(std::ios::failbit);
    int i(0),j(0), brojac(1);
    for(;;){
        ispis &gt;&gt; m.matrica[i][j] &gt;&gt; a;
        if(a == ';' || a == ']') {
            if( j &gt; 4) ispis.setstate(std::ios::failbit);
            for(int i=0; i &lt; novi.size(); i++) if(j != novi[i]) ispis.setstate(std::ios::failbit);
            novi.push_back(brojac);
            i++;
            if( i &gt; 4 ) ispis.setstate(std::ios::failbit);
            j = 0; brojac=0;
            if(a == ']') break; 
            else continue;
        }
        j++; brojac++;
        if(a == ']') break; 
    }
    m.br_redova = i; m.br_kolona = novi[0];
	return ispis;
}

int main ()
{
   GMatrica&lt;int&gt; m1;
   std::cin &gt;&gt; m1;
   std::cout &lt;&lt; m1 &lt;&lt; std::endl;
   return 0;
}</pre>
</body>
</html>
