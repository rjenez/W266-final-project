<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3899.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4473.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;


template &lt;typename TIP&gt;
class GMatrica {
    TIP matrica[4][4];
    int br_redova = 0;
    int br_kolona = 0;
    
    public:
    
    GMatrica() = default;
    
    
    GMatrica(int br_redova, int br_kolona, TIP elementi = {});
      
    
  
    GMatrica(const GMatrica&lt;TIP&gt; &amp;nova);
    
    
<a name="0"></a><font color="#FF0000"><a href="match935-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    GMatrica(TIP niz[4][4]);
   
    GMatrica(std::vector&lt;std::vector&lt;TIP&gt;&gt; dmat);
    
   
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;TIP&gt;&gt; lista);
       
    
    int DajBrojRedova() const { return br_redova; }
    int DajBrojKolona() const { return br_kolona; } 
   
   template &lt;typename tip, typename tip1&gt;
   friend auto operator +(const GMatrica&lt;tip&gt; &amp;mat, const GMatrica&lt;tip1&gt; &amp;m) -&gt; GMatrica&lt;decltype( mat.matrica[0][0] + m.matrica[0][0] )&gt;;
</font><a name="9"></a><font color="#FF00FF"><a href="match935-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    
    template &lt;typename tip1, typename tip2&gt;
    friend auto operator *(const GMatrica&lt;tip1&gt; &amp;mat, const GMatrica&lt;tip2&gt; &amp;m) -&gt; GMatrica&lt;decltype( mat.matrica[0][0] + m.matrica[0][0] )&gt;;
</font><a name="8"></a><font color="#00FFFF"><a href="match935-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    
    template &lt;typename tip1, typename tip2&gt;
    friend auto operator *(const GMatrica&lt;tip1&gt; &amp;m, tip2 mnozac) -&gt; GMatrica&lt;decltype( m.matrica[0][0] + mnozac)&gt;;
</font>   
    template &lt;typename tip1, typename tip2&gt;
    friend auto operator *(tip1 mnozac, GMatrica&lt;tip2&gt; &amp;m) -&gt; GMatrica&lt;decltype( m.matrica[0][0] + mnozac)&gt;;
    
    
    GMatrica&lt;TIP&gt; &amp;operator +=( const GMatrica&lt;TIP&gt; &amp;mat); 
    
   
    GMatrica&lt;TIP&gt; &amp;operator *=(const GMatrica&lt;TIP&gt; &amp;mat);
    
    
    GMatrica&lt;TIP&gt; &amp;operator *=(TIP mnozac);
    
  
    GMatrica&lt;TIP&gt; &amp;operator -=( const GMatrica&lt;TIP&gt; &amp;m); 
    
    template &lt;typename tip1, typename tip2&gt;
    friend auto operator -(const GMatrica&lt;tip1&gt; &amp;mat, const GMatrica&lt;tip2&gt; &amp;m) -&gt; GMatrica&lt;decltype( m.matrica[0][0] + mat.matrica[0][0] )&gt;;
    
    TIP &amp;operator ()(int x_ind, int y_ind); 
    TIP operator ()(int x_ind, int y_ind) const; 
    
    TIP *operator [](int br);  
    TIP operator [](int br) const;  
    
    template &lt;typename tip&gt;
    friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;tip&gt; &amp;m);
    
<a name="5"></a><font color="#FF0000"><a href="match935-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    template &lt;typename tip1, typename tip2&gt;
    friend bool operator ==(const GMatrica&lt;tip1&gt; &amp;m, const GMatrica&lt;tip2&gt; &amp;mat);
    
    template &lt;typename tip1, typename tip2&gt;
</font>    friend inline bool operator !=(const GMatrica&lt;tip1&gt; &amp;m, const GMatrica&lt;tip2&gt; &amp;mat);
    
    template &lt;typename tip&gt;
    friend std::istream &amp;operator &gt;&gt;(std::istream &amp;cin, GMatrica&lt;tip&gt; &amp;m);
};

 template&lt;typename tip&gt;
 GMatrica&lt;tip&gt;::GMatrica(int br_redova, int br_kolona, tip elementi) : br_redova(br_redova), br_kolona(br_kolona) {
     if(br_redova &lt; 0 || br_redova &gt; 4 || br_kolona &lt; 0 || br_kolona &gt; 4) throw std::logic_error("Ilegalan format");
     for(int i = 0; i &lt; br_redova; i++)
     for(int j = 0; j &lt; br_kolona; j++)
     matrica[i][j] = elementi;
 }
 
 template &lt;typename tip&gt;
 GMatrica&lt;tip&gt;::GMatrica(const GMatrica&lt;tip&gt; &amp;nova) : br_redova(nova.br_redova) , br_kolona(nova.br_kolona) {
      if( br_redova &lt; 0 || br_redova &gt; 4 || br_kolona &lt; 0 || br_kolona &gt; 4) throw std::logic_error("Ilegalan format matrice");
     for(int i = 0; i &lt; br_redova; i++)
     for(int j = 0; j &lt; br_kolona; j++)
<a name="3"></a><font color="#00FFFF"><a href="match935-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

     matrica[i][j] = nova.matrica[i][j];
 }
 
 template &lt;typename tip&gt;
 GMatrica&lt;tip&gt;::GMatrica(tip niz[4][4]) : br_redova(4), br_kolona(4) {
     for(int i = 0; i &lt; 4; i++)
</font>     for(int j = 0; j &lt; 4; j++)
     matrica[i][j] = niz[i][j];
 }
 
 template &lt;typename tip&gt;
 GMatrica&lt;tip&gt;::GMatrica(std::vector&lt;std::vector&lt;tip&gt;&gt; dmat) : br_redova(dmat.size()), br_kolona(dmat[0].size()) {
      if( br_redova &lt; 0 || br_redova &gt; 4 || br_kolona &lt; 0 || br_kolona &gt; 4) throw std::logic_error("Ilegalan format matrice");
     for(int i = 0; i &lt; br_redova; i++)
     for(int j = 0; j &lt; br_kolona; j++)
     matrica[i][j] = dmat[i][j];
 }
 
 template &lt;typename tipy&gt;
 GMatrica&lt;tipy&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;tipy&gt;&gt; lista) : br_redova(lista.size()), br_kolona((*lista.begin()).size()) {
      if( br_redova &lt; 0 || br_redova &gt; 4 || br_kolona &lt; 0 || br_kolona &gt; 4) throw std::logic_error("Ilegalan format matrice");
     int k = 0, r = 0;
     for(const std::initializer_list&lt;tipy&gt; &amp;v : lista) {
         k = 0;
         for(const tipy &amp;el : v)
         matrica[r][k++] = el;
         ++r;
     }
 }


  template &lt;typename tip&gt;
  std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;tip&gt; &amp;m) {
      std::vector&lt;tip&gt; brojevi;
      tip broj = {};
      int red = 0, kolona = 0;
      char unos[100];
      bool neg = false;
      tok.get(unos,100);
             int i = 0;
          while( i &lt; 100) {
             
              if( unos[0] != '[') tok.setstate(std::ios::failbit);
              i++;
              if( unos[i] == '-' || (unos[i] &gt;= '0' &amp;&amp; unos[i] &lt;= '9') ) {
                  broj = 0;
                  if(unos[i] == '-') { neg = true; i++; }
                  if(!(unos[i] &gt;= '0' &amp;&amp; unos[i] &lt;= '9') ) tok.setstate(std::ios::failbit);
                  while  (unos[i] &gt;= '0' &amp;&amp; unos[i] &lt;= '9') {
                      broj *= 10;
                      broj += unos[i] -'0';
                      i++;
                  } 
                  if(neg) { broj *= -1; neg = false; }
                  brojevi.push_back(broj);
              }
              if( unos[i] == ']' || unos[i] == '\0') break;
             if(unos[i] != ',' &amp;&amp; unos[i] != ';') tok.setstate(std::ios::failbit);
              if(unos[i] == ',') kolona++;
              if(unos[i] == ';') red++;
              
          }
          
          if(tok) {
               red++;
          kolona += red;
          
          if( double(kolona)/red - kolona/red != 0) tok.setstate(std::ios::failbit);
          kolona /= red;
         
         
          if( m.br_kolona == 0 &amp;&amp; m.br_redova == 0) {
          m.br_kolona = kolona;
          m.br_redova = red;
          }
          else if( m.br_kolona != kolona || m.br_redova != red) tok.setstate(std::ios::failbit);
          if(tok) {
          int br = 0;
          
          for(int i = 0; i &lt; red; i++)
          for(int j = 0; j &lt; kolona; j++) {
             m.matrica[i][j] = brojevi[br];
             br++;
          }
          }
  }
          
          return tok;
  }
  
     
  
  template &lt;typename tip&gt;
<a name="1"></a><font color="#00FF00"><a href="match935-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

  tip &amp;GMatrica&lt;tip&gt;::operator ()(int x_ind, int y_ind) {
      if( x_ind &lt; 1 || x_ind &gt; 5 || y_ind &lt; 1 || y_ind &gt; 5) throw std::range_error("Nedozvoljen indeks");
      return matrica[x_ind-1][y_ind-1];
  }
  
  template &lt;typename tip&gt;
  tip GMatrica&lt;tip&gt;::operator ()(int x_ind, int y_ind) const {
</font>      if( x_ind &lt; 1 || x_ind &gt; 5 || y_ind &lt; 1 || y_ind &gt; 5) throw std::range_error("Nedozvoljen indeks");
      GMatrica&lt;tip&gt; nova(*this);
      return nova[x_ind-1][y_ind-1];
  }
  
  template &lt;typename tip&gt;
  tip *GMatrica&lt;tip&gt;::operator [](int br) {
      return matrica[br];
  }
  
  template &lt;typename tip&gt;
  tip GMatrica&lt;tip&gt;::operator [](int br) const {
      GMatrica&lt;tip&gt; nova(*this);
      return nova[br];
  }

<a name="11"></a><font color="#00FF00"><a href="match935-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

  template &lt;typename tip1, typename tip2&gt;
  bool operator ==(const GMatrica&lt;tip1&gt; &amp;m, const GMatrica&lt;tip2&gt; &amp;mat) {
      if( m.DajBrojKolona() != mat.DajBrojKolona() || mat.DajBrojRedova() != m.DajBrojRedova()) return false;
</font>      
      for(int i = 0; i &lt; m.DajBrojRedova(); i++)
      for(int j = 0; j &lt; m.DajBrojKolona(); j++)
<a name="12"></a><font color="#0000FF"><a href="match935-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

      if(m.matrica[i][j] != mat.matrica[i][j]) return false;
      
      return true;
  }
  
  template &lt;typename tip1, typename tip2&gt;
</font>  inline bool operator != (const GMatrica&lt;tip1&gt; &amp;m, const GMatrica&lt;tip2&gt; &amp;mat) {
      return !(m == mat);
  }

   template &lt;typename tip1&gt;
   GMatrica&lt;tip1&gt; &amp;GMatrica&lt;tip1&gt;::operator +=(const GMatrica&lt;tip1&gt; &amp;mat)  {
       if( mat.DajBrojRedova() != (*this).br_redova || (*this).br_kolona != mat.DajBrojKolona()) throw std::domain_error("Nedozvoljena operacija");
       for(int i = 0; i &lt; mat.DajBrojRedova(); i++)
       for(int j = 0; j &lt; mat.DajBrojKolona(); j++)
       (*this).matrica[i][j] += mat.matrica[i][j];
       
       return *this;
   }
   
<a name="7"></a><font color="#0000FF"><a href="match935-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

   template &lt;typename tip1&gt;
    GMatrica&lt;tip1&gt; &amp;GMatrica&lt;tip1&gt;::operator *=(const GMatrica&lt;tip1&gt; &amp;m) {
        if(br_redova != m.br_kolona) throw std::domain_error("Nedozvoljena operacija");
</font>        GMatrica&lt;tip1&gt; mat(*this);
        GMatrica&lt;tip1&gt; to(mat.br_redova,m.br_kolona);
         for(int i = 0; i &lt; mat.br_redova; i++)
        for(int j = 0; j &lt; m.br_kolona; j++) {
            double suma = 0;
<a name="2"></a><font color="#0000FF"><a href="match935-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

            for(int k = 0; k &lt; m.br_redova; k++ ) suma += (mat.matrica[i][k]*m.matrica[k][j]);
            to.matrica[i][j] = suma;
</font>        }
        *this = to;
        
        return *this;
    }
    
   
<a name="10"></a><font color="#FF0000"><a href="match935-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    template &lt;typename tip1&gt;
    GMatrica&lt;tip1&gt;  &amp;GMatrica&lt;tip1&gt;::operator *=(tip1 mnozac) {
        for(int i = 0; i &lt; (*this).DajBrojRedova(); i++)
</font>        for(int j = 0; j &lt; (*this).DajBrojKolona(); j++)
        (*this).matrica[i][j] *= mnozac;
        
        return *this;
    }
    
    template &lt;typename tip1&gt;
    GMatrica&lt;tip1&gt; &amp;GMatrica&lt;tip1&gt;::operator -=(const GMatrica&lt;tip1&gt; &amp;m)  {
        if( (*this).DajBrojRedova() != m.DajBrojRedova() || m.DajBrojKolona() != (*this).DajBrojKolona()) throw std::domain_error("Nedozvoljena operacija");
        for(int i = 0; i &lt; (*this).DajBrojRedova(); i++)
        for(int j = 0; j &lt; (*this).DajBrojKolona(); j++)
        (*this).matrica[i][j] -= m.matrica[i][j];
        
        return *this;
    }

  template &lt;typename tip&gt;
  std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;tip&gt; &amp;m) {
      int w = tok.width();
      if( w &lt; 6) w = 6;
      
      for(int i = 0; i &lt; m.DajBrojRedova(); i++) {
      for(int j = 0; j &lt; m.DajBrojKolona(); j++)
       tok &lt;&lt; std::setw(w) &lt;&lt; m.matrica[i][j];
       tok &lt;&lt; "\n";
      }
      
      return tok;
  }

  template &lt;typename tip, typename tip1&gt;
   auto operator +(const GMatrica&lt;tip&gt; &amp;mat, const GMatrica&lt;tip1&gt; &amp;m) -&gt; GMatrica&lt;decltype( mat.matrica[0][0] + m.matrica[0][0] )&gt;{  //trebal bit prijateljska il s jednim parametrom?
         if(m.br_redova != mat.br_redova || m.br_kolona != mat.br_kolona) throw std::domain_error("Nedozvoljena operacija");
        GMatrica&lt;decltype(mat.matrica[0][0] + m.matrica[0][0])&gt; nova(m.br_redova,m.br_kolona);
        for(int i = 0; i &lt; m.br_redova; i++)
        for(int j = 0; j &lt; m.br_kolona; j++)
        nova.matrica[i][j] = m.matrica[i][j] + mat.matrica[i][j];
        
        return nova;
    }
    
    template &lt;typename tip1, typename tip2&gt;
<a name="6"></a><font color="#00FF00"><a href="match935-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    auto operator *(const GMatrica&lt;tip1&gt; &amp;mat, const GMatrica&lt;tip2&gt; &amp;m) -&gt; GMatrica&lt;decltype( mat.matrica[0][0] + m.matrica[0][0] )&gt; {
        if(mat.br_redova != m.br_kolona) throw std::domain_error("Nedozvoljena operacija");
        GMatrica&lt;decltype(mat.matrica[0][0] + m.matrica[0][0])&gt; nova(mat.br_redova,m.br_kolona);
</font>        for(int i = 0; i &lt; mat.br_redova; i++)
        for(int j = 0; j &lt; m.br_kolona; j++) {
            double suma = 0;
            for(int k = 0; k &lt; m.br_redova; k++ ) suma += mat.matrica[i][k]*m.matrica[k][j];
            nova.matrica[i][j] = suma;
        }
        
        return nova;
    }
    
    template &lt;typename tip1, typename tip2&gt;
    auto operator *(const GMatrica&lt;tip1&gt; &amp;m, tip2 mnozac) -&gt; GMatrica&lt;decltype( m.matrica[0][0] + mnozac)&gt; {
        GMatrica&lt;decltype(m.matrica[0][0] + mnozac)&gt; nova(m.br_redova, m.br_kolona);
        for(int i = 0; i &lt; m.br_redova; i++)
        for(int j = 0; j &lt; m.br_kolona; j++)
        nova.matrica[i][j] = m.matrica[i][j]*mnozac;
        
        return nova;
        
    }
    
    template &lt;typename tip1, typename tip2&gt;
    auto operator *(tip1 mnozac, GMatrica&lt;tip2&gt; &amp;m) -&gt; GMatrica&lt;decltype( m.matrica[0][0] + mnozac)&gt; {
        GMatrica&lt;decltype(m.matrica[0][0] + mnozac)&gt; nova(m.br_redova, m.br_kolona);
        for(int i = 0; i &lt; m.br_redova; i++)
        for(int j = 0; j &lt; m.br_kolona; j++)
        nova.matrica[i][j] = m.matrica[i][j]*mnozac;
        
        return nova;
    }
    
    template &lt;typename tip1, typename tip2&gt;
    auto operator -(const GMatrica&lt;tip1&gt; &amp;mat, const GMatrica&lt;tip2&gt; &amp;m) -&gt; GMatrica&lt;decltype( m.matrica[0][0] + mat.matrica[0][0] )&gt; {
        if( mat.br_redova != m.br_redova || mat.br_kolona != m.br_kolona) throw std::domain_error("Nedozvoljena operacija");
        GMatrica&lt;decltype(m.matrica[0][0] + mat.matrica[0][0])&gt; nova(mat.br_redova, mat.br_kolona);
        for(int i = 0; i &lt; mat.br_redova; i++)
        for(int j = 0; j &lt; mat.br_kolona; j++)
         nova.matrica[i][j] = mat.matrica[i][j] - m.matrica[i][j];
         
         return nova;
    }



int main ()
{
    try{
   int niz[4][4] = {{1,2,3,4},{2,3,4,5},{3,4,5,6},{3,4,4,4}};
   GMatrica&lt;int&gt; m1({{1, 2, 7}, {3, 4, 5}});
   GMatrica&lt;int&gt; m12(niz);
   GMatrica&lt;double&gt; m;
   GMatrica&lt;int&gt; miii{{2,3},{1,2},{1,3}};
       GMatrica&lt;int&gt; m2{{1, 2, 1}, {3, 4, 5}};
      auto m3 = m1 + m2;
       std::cout &lt;&lt; m3 &lt;&lt; std::endl;
       GMatrica&lt;int&gt; m4({{1, 2, 8}, {3, 4, 8}});
       auto m5 = m2-m4;
       std::cout &lt;&lt; m5 &lt;&lt; std::endl;
       auto mu = miii*m4;
       std::cout &lt;&lt; mu &lt;&lt; std::endl;
       mu = mu *4;
       std::cout &lt;&lt; mu &lt;&lt; std::endl;
       mu = 4*mu;
<a name="4"></a><font color="#FF00FF"><a href="match935-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

       std::cout &lt;&lt; mu &lt;&lt; std::endl;
      
       m1 += m2;
       std::cout &lt;&lt; m1 &lt;&lt; std::endl;
       m2 -= m4;
       std::cout &lt;&lt; m2 &lt;&lt; std::endl;
</font>       miii *= m4;
       std::cout &lt;&lt; miii &lt;&lt; std::endl;
        miii *= 4;
       std::cout &lt;&lt; miii &lt;&lt; std::endl;
       int br = miii(1,1);
       std::cout &lt;&lt; br &lt;&lt; std::endl;
       br = miii[1][1];
       std::cout &lt;&lt; br &lt;&lt; std::endl;
        miii[1][1] = 2;
        miii(1,1) = 0;
        std::cout &lt;&lt; miii &lt;&lt; std::endl;
        if(miii == m4) std::cout &lt;&lt; "jes" &lt;&lt; std::endl;
        else std::cout &lt;&lt; "nije" &lt;&lt; std::endl;
        if(miii != m4) std::cout &lt;&lt; "jes" &lt;&lt; std::endl;
        else std::cout &lt;&lt; "nije" &lt;&lt; std::endl;
    }catch(std::domain_error d) {
        std::cout &lt;&lt; d.what() &lt;&lt; std::endl;
    }
    catch(std::range_error r) {
        std::cout &lt;&lt; r.what() &lt;&lt; std::endl;
    }
   return 0;
}
</pre>
</body>
</html>
