<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3386.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3386.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;initializer_list&gt;

using std::cin;
using std::cout;
using std::vector;
using std::string;




<a name="4"></a><font color="#FF00FF"><a href="match391-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

template&lt;typename Tip&gt;
class GMatrica
{
    Tip niz[4][4];
    int redovi,kolone;
    public:
    GMatrica():redovi(0),kolone(0){}
    GMatrica(int red,int kol,Tip a=Tip());
</font>    template&lt;typename Tip1&gt;
    GMatrica(const GMatrica&lt;Tip1&gt; &amp;m);
    template&lt;typename Tip1&gt;
    GMatrica(Tip1 niz1[4][4]);
    GMatrica(vector&lt;vector&lt;Tip&gt;&gt; v);
    template&lt;typename Tip1&gt;
<a name="0"></a><font color="#FF0000"><a href="match391-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip1&gt;&gt; a);
    int DajBrojRedova()const{return redovi;}
    int DajBrojKolona()const{return kolone;}
    template&lt;typename Tip1,typename Tip2&gt;
    friend auto operator+(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;typename std::remove_reference&lt;decltype(m1.niz[0][0]+m2.niz[0][0])&gt;::type&gt;;
    template&lt;typename Tip1,typename Tip2&gt;
    friend auto operator-(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;typename std::remove_reference&lt;decltype(m1.niz[0][0]-m2.niz[0][0])&gt;::type&gt;;
</font>    template&lt;typename Tip1,typename Tip2&gt;
    friend auto operator*(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;typename std::remove_reference&lt;decltype(m1.niz[0][0]*m2.niz[0][0])&gt;::type&gt;;
    template&lt;typename Tip1&gt;
    friend GMatrica&lt;Tip1&gt; operator*(const GMatrica&lt;Tip1&gt; &amp;m1,double elem);
    template&lt;typename Tip1&gt;
    friend GMatrica&lt;Tip1&gt; operator*(double elem,const GMatrica&lt;Tip1&gt; &amp;m1);
    template&lt;typename Tip1&gt;
    GMatrica&lt;Tip&gt; &amp;operator+=(const GMatrica&lt;Tip1&gt; &amp;m1);
    template&lt;typename Tip1&gt;
    GMatrica&lt;Tip&gt; &amp;operator-=(const GMatrica&lt;Tip1&gt; &amp;m1);
    template&lt;typename Tip1&gt;
    GMatrica&lt;Tip&gt; &amp;operator*=(const GMatrica&lt;Tip1&gt; &amp;m1);
    GMatrica&lt;Tip&gt; &amp;operator*=(double elem);
    template&lt;typename Tip1&gt;
    friend bool operator==(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip1&gt; &amp;m2);
    template&lt;typename Tip1&gt;
    friend bool operator!=(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip1&gt; &amp;m2);
    Tip *operator [](int x){return niz[x];}
    const Tip *operator [](int x)const{return niz[x];}
    Tip &amp;operator()(int x,int y);
    Tip operator()(int x,int y)const;
    template&lt;typename Tip1&gt;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok,const GMatrica&lt;Tip1&gt; &amp;m);
    template&lt;typename Tip1&gt;
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;tok,GMatrica&lt;Tip1&gt; &amp;m);
};
<a name="9"></a><font color="#FF00FF"><a href="match391-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

template&lt;typename Tip1&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;tok,GMatrica&lt;Tip1&gt; &amp;m)
{
    char znak;
    tok &gt;&gt; znak;
</font>    if(znak!='[')
    {
        tok.setstate(std::ios::failbit);
        return tok;
    }
    if(m.redovi == 0 and m.kolone == 0)
    {
        int i=0,j=0;
        int pamti;
        bool promijeni=true;
        for(;;)
        {
            j=0;
            for(;;)
            {
                if(j&gt;=4)
                {
                    tok.setstate(std::ios::failbit);
                    return tok;
                }
                Tip1 pomoc;
                tok &gt;&gt; pomoc;
                if(!tok or (tok.peek()!=',' and tok.peek()!=';' and tok.peek()!=']'))
                {
                    tok.setstate(std::ios::failbit);
                    return tok;
                }
                m[i][j]=pomoc;
                if(tok.peek() == ';')
                {
                    tok.get();
                    break;
                }
                if(tok.peek() == ']')
                    break;
                if(tok.peek() == ',')
                {
                    j++;
                    tok.get();
                    if(promijeni)
                        pamti=j;
                    continue;
                }
            }
            if(pamti!=j)
            {
                tok.setstate(std::ios::failbit);
                return tok;
            }
            else
                promijeni=false;
            if(tok.peek() == ']')
                break;
            i++;
        }
    m.redovi=i+1;
    m.kolone=j+1;
    }
    else
    {
        for(int i=0;i&lt;m.redovi;i++)
        {
            for(int j=0;j&lt;m.kolone;j++)
            {
                if(tok.peek()&lt;'0' or tok.peek()&gt;'9')
                {
                    tok.setstate(std::ios::failbit);
                    return tok;
                }
                tok &gt;&gt; m[i][j];
                if(tok.peek()==';' and j!=m.kolone-1)
                {
                    tok.setstate(std::ios::failbit);
                    return tok;
                }
                if(tok.peek() == ']')
                    break;
                if(tok.peek()!=',' and tok.peek()!=';')
                {
                    tok.setstate(std::ios::failbit);
                    return tok;
                }
                tok.get();
            }
            if(tok.peek()!=';' and tok.peek()!=']')
            {
                tok.setstate(std::ios::failbit);
                return tok;
            }
            char znak1;
            if(tok.peek() == ';')
                tok &gt;&gt; znak1;
            if(tok.peek()==']' and i!=m.redovi-1)
            {
                tok.setstate(std::ios::failbit);
                return tok;
            }
        }
    }
    return tok;
}
template&lt;typename Tip1&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok,const GMatrica&lt;Tip1&gt; &amp;m)
{
    int a=tok.width();
    if(a&lt;6)
        a=6;
<a name="6"></a><font color="#00FF00"><a href="match391-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    for(int i=0;i&lt;m.redovi;i++)
    {
        for(int j=0;j&lt;m.kolone;j++)
            tok &lt;&lt; std::setw(a) &lt;&lt; m[i][j];
        tok &lt;&lt; "\n";
</font>    }
    return tok;
}
template&lt;typename Tip&gt;
Tip &amp;GMatrica&lt;Tip&gt;::operator ()(int x,int y)
{
    if(x&lt;1 or y&lt;1 or x&gt;this-&gt;redovi or y&gt;this-&gt;kolone)
        throw std::range_error("Nedozvoljen indeks");
    return (*this)[x-1][y-1];
}
template&lt;typename Tip&gt;
Tip GMatrica&lt;Tip&gt;::operator ()(int x,int y)const
{
    if(x&lt;1 or y&lt;1 or x&gt;this-&gt;redovi or y&gt;this-&gt;kolone)
        throw std::range_error("Nedozvoljen indeks");
    return (*this)[x-1][y-1];
}
template&lt;typename Tip1&gt;
bool operator!=(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip1&gt; &amp;m2)
{
    return !(m1==m2);
}
template&lt;typename Tip1&gt;
bool operator==(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip1&gt; &amp;m2)
{
    if(m1.redovi!=m2.redovi or m1.kolone!=m2.kolone)
        return false;
<a name="3"></a><font color="#00FFFF"><a href="match391-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    for(int i=0;i&lt;m1.redovi;i++)
        for(int j=0;j&lt;m1.kolone;j++)
            if(m1[i][j]!=m2[i][j])
                return false;
    return true;
</font>}
template&lt;typename Tip&gt;
<a name="10"></a><font color="#FF0000"><a href="match391-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator*=(double elem)
{
    for(int i=0;i&lt;redovi;i++)
        for(int j=0;j&lt;kolone;j++)
            niz[i][j]*=elem;
</font>    return *this;
}
template&lt;typename Tip&gt;
template&lt;typename Tip1&gt;
<a name="11"></a><font color="#00FF00"><a href="match391-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator*=(const GMatrica&lt;Tip1&gt; &amp;m1)
{
    if(kolone!=m1.redovi)    
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;Tip&gt; mat;
</font>    mat.redovi=this-&gt;redovi;
    mat.kolone=m1.kolone;
    for(int i=0;i&lt;mat.redovi;i++)
        for(int j=0;j&lt;mat.kolone;j++)
            mat[i][j]=0;
    for(int i=0;i&lt;this-&gt;redovi;i++)
        for(int j=0;j&lt;m1.kolone;j++)
<a name="5"></a><font color="#FF0000"><a href="match391-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

            for(int k=0;k&lt;this-&gt;kolone;k++)
                mat[i][j]+=((*this)[i][k])*(m1[k][j]);
    *this=mat;
    return *this;
}
template&lt;typename Tip&gt;
</font>template&lt;typename Tip1&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator-=(const GMatrica&lt;Tip1&gt; &amp;m1)
{
    if(this-&gt;redovi!=m1.redovi or this-&gt;kolone!=m1.kolone)
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;Tip&gt; mat(m1.redovi,m1.kolone);
    mat=*this;
    for(int i=0;i&lt;mat.redovi;i++)
        for(int j=0;j&lt;mat.kolone;j++)
            mat[i][j]-=m1[i][j];
    *this=mat;
<a name="7"></a><font color="#0000FF"><a href="match391-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    return *this;
}
template&lt;typename Tip&gt;
template&lt;typename Tip1&gt;
GMatrica&lt;Tip&gt; &amp;GMatrica&lt;Tip&gt;::operator+=(const GMatrica&lt;Tip1&gt; &amp;m1)
</font>{
    if(this-&gt;redovi!=m1.redovi or this-&gt;kolone!=m1.kolone)
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;Tip&gt; mat(m1.redovi,m1.kolone);
    mat=*this;
    for(int i=0;i&lt;mat.redovi;i++)
        for(int j=0;j&lt;mat.kolone;j++)
            mat[i][j]+=m1[i][j];
    *this=mat;
    return *this;
}
template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt; operator*(double elem,const GMatrica&lt;Tip1&gt; &amp;m1)
{
    GMatrica&lt;Tip1&gt; nova(m1.redovi,m1.kolone);
<a name="12"></a><font color="#0000FF"><a href="match391-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    for(int i=0;i&lt;m1.redovi;i++)
        for(int j=0;j&lt;m1.kolone;j++)
            nova[i][j]=m1[i][j]*elem;
</font>    return nova;
}
template&lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt; operator*(const GMatrica&lt;Tip1&gt; &amp;m1,double elem)
{
    GMatrica&lt;Tip1&gt; nova(m1.DajBrojRedova(),m1.DajBrojKolona());
    for(int i=0;i&lt;m1.DajBrojRedova();i++)
        for(int j=0;j&lt;m1.DajBrojKolona();j++)
            nova[i][j]=m1[i][j]*elem;
    return nova;
}
template&lt;typename Tip1,typename Tip2&gt;
auto operator*(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;typename std::remove_reference&lt;decltype(m1.niz[0][0]*m2.niz[0][0])&gt;::type&gt;
{
    if(m1.kolone!=m2.redovi)    
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;typename std::remove_reference&lt;decltype(m1.niz[0][0]*m2.niz[0][0])&gt;::type&gt; mat;
    mat.redovi=m1.redovi;
    mat.kolone=m2.kolone;
    for(int i=0;i&lt;mat.redovi;i++)
        for(int j=0;j&lt;mat.kolone;j++)
            mat[i][j]=0;
    for(int i=0;i&lt;m1.redovi;i++)
        for(int j=0;j&lt;m2.kolone;j++)
            for(int k=0;k&lt;m1.kolone;k++)
                mat[i][j]+=m1[i][k]*m2[k][j];
    return mat;
}
template&lt;typename Tip1,typename Tip2&gt;
<a name="2"></a><font color="#0000FF"><a href="match391-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

auto operator-(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;typename std::remove_reference&lt;decltype(m1.niz[0][0]-m2.niz[0][0])&gt;::type&gt;
{
    if(m1.redovi!=m2.redovi or m1.kolone!=m2.kolone)
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;typename std::remove_reference&lt;decltype(m1.niz[0][0]-m2.niz[0][0])&gt;::type&gt; mat;
</font>    mat.redovi=m1.redovi;
    mat.kolone=m1.kolone;
    for(int i=0;i&lt;mat.redovi;i++)
        for(int j=0;j&lt;mat.kolone;j++)
            mat.niz[i][j]=m1.niz[i][j]-m2.niz[i][j];
    return mat;
}
<a name="1"></a><font color="#00FF00"><a href="match391-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

template&lt;typename Tip1,typename Tip2&gt;
auto operator+(const GMatrica&lt;Tip1&gt; &amp;m1,const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;typename std::remove_reference&lt;decltype(m1.niz[0][0]+m2.niz[0][0])&gt;::type&gt;
{
    if(m1.redovi!=m2.redovi or m1.kolone!=m2.kolone)
        throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;typename std::remove_reference&lt;decltype(m1.niz[0][0]+m2.niz[0][0])&gt;::type&gt; mat;
    mat.redovi=m1.redovi;
</font>    mat.kolone=m1.kolone;
    for(int i=0;i&lt;mat.redovi;i++)
        for(int j=0;j&lt;mat.kolone;j++)
            mat.niz[i][j]=m1.niz[i][j]+m2.niz[i][j];
<a name="8"></a><font color="#00FFFF"><a href="match391-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    return mat;
}
template&lt;typename Tip&gt;
template&lt;typename Tip1&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip1&gt;&gt; a)
</font>{
    vector&lt;vector&lt;Tip1&gt;&gt; v;
    for(auto it=a.begin();it!=a.end();it++)
        v.push_back(*it);
    redovi=v.size();
    kolone=v[0].size();
    auto b=GMatrica&lt;Tip1&gt;(v);
    *this=b;
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(vector&lt;vector&lt;Tip&gt;&gt; v)
{
    if(v.size()&gt;4)
        throw std::logic_error("Ilegalan format matrice");
    for(int i=0;i&lt;v.size()-1;i++)
        if(v[i].size()!=v[i+1].size() or v[i].size()&gt;4)
            throw std::logic_error("Ilegalan format matrice");
    redovi=v.size();
    kolone=v[0].size();
    for(int i=0;i&lt;redovi;i++)
        for(int j=0;j&lt;kolone;j++)
            niz[i][j]=v[i][j];
}
template&lt;typename Tip&gt;
template&lt;typename Tip1&gt;
GMatrica&lt;Tip&gt;::GMatrica(Tip1 niz1[4][4])
{
    for(int i=0;i&lt;4;i++)
        for(int j=0;j&lt;4;j++)
            niz[i][j]=niz1[i][j];
    redovi=4;
    kolone=4;
}
template&lt;typename Tip&gt;
template&lt;typename Tip1&gt;
GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;Tip1&gt; &amp;m)
{
    for(int i=0;i&lt;m.DajBrojRedova();i++)
        for(int j=0;j&lt;m.DajBrojKolona();j++)
            niz[i][j]=m[i][j];
    kolone=m.DajBrojKolona();
    redovi=m.DajBrojRedova();
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int red,int kol,Tip a)
{
    if(kol&gt;4 or kol&lt;0 or red&gt;4 or red&lt;0)
        throw std::logic_error("Ilegalan format matrice");
    kolone=kol;
    redovi=red;
    for(int i=0;i&lt;redovi;i++)
        for(int j=0;j&lt;kolone;j++)
            niz[i][j]=a;
}
int main ()
{
   
   //operator+ i operator- i &lt;&lt;
   
   GMatrica&lt;double&gt; m1({{1, 2}, {3, 4}});
   GMatrica&lt;double&gt; m2({{1, 2}, {3, 4}});
   m1[0][0]=5;
   cout&lt;&lt;m1;
	return 0;
}</pre>
</body>
</html>
