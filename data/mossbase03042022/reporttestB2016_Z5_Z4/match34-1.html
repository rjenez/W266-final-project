<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5222.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8532.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match34-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;cmath&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;utility&gt;
#include &lt;complex&gt;
#include &lt;string&gt;

using namespace std;

template &lt;typename T1, typename T2&gt;
bool poredi(T1 a, T2 b){
    return fabs(a - b) &lt; 0.001;
}

template &lt;typename T&gt;
class GMatrica {
    T mat[4][4];
    int redovi, kolone;
    
public:
    GMatrica&lt;T&gt; () : mat{{0}}, redovi(0), kolone(0) {}
    GMatrica&lt;T&gt; (int, int, T n = T());
    template &lt;typename T2&gt;
    GMatrica&lt;T&gt; (const GMatrica&lt;T2&gt;&amp;);
    template &lt;typename T2&gt;
    GMatrica&lt;T&gt; (T2**);
    GMatrica&lt;T&gt; (vector&lt;vector&lt;T&gt;&gt;);
    GMatrica&lt;T&gt; (initializer_list&lt;initializer_list&lt;T&gt;&gt;);
    //
    int DajBrojRedova() const { return redovi; }
    int DajBrojKolona() const { return kolone; }
    template &lt;typename T1, typename T2&gt;
    friend auto operator+ (const GMatrica&lt;T1&gt;&amp; m1, const GMatrica&lt;T2&gt;&amp; m2) 
        -&gt; decltype(GMatrica&lt;decltype(m1(1, 1) + m2(1, 1))&gt;());
    template &lt;typename T1, typename T2&gt;
    friend auto operator- (const GMatrica&lt;T1&gt;&amp; m1, const GMatrica&lt;T2&gt;&amp; m2) 
        -&gt; decltype(GMatrica&lt;decltype(m1(1, 1) - m2(1, 1))&gt;());
    template &lt;typename T1, typename T2&gt;
    friend auto operator* (const GMatrica&lt;T1&gt;&amp; m1, const GMatrica&lt;T2&gt;&amp; m2) 
        -&gt; decltype(GMatrica&lt;decltype(m1(1, 1) * m2(1, 1))&gt;());
    template &lt;typename T1, typename T2&gt;
    friend auto operator* (const GMatrica&lt;T1&gt;&amp; m, const T2 n) 
        -&gt; decltype(GMatrica&lt;decltype(m(1, 1) * n)&gt;());
    //template &lt;typename T1, typename T2&gt;
    //friend auto operator* (const T1 n, const GMatrica&lt;T2&gt;&amp; m) -&gt; decltype(GMatrica&lt;decltype(m(1, 1) * n)&gt;()) { return m * n; }
    template &lt;typename T2&gt;
    GMatrica&lt;T&gt; operator+= (const GMatrica&lt;T2&gt;&amp;);
    template &lt;typename T2&gt;
    GMatrica&lt;T&gt; operator-= (const GMatrica&lt;T2&gt;&amp;);
    template &lt;typename T2&gt;
    GMatrica&lt;T&gt; operator*= (const GMatrica&lt;T2&gt;&amp;);
    template &lt;typename T2&gt;
    GMatrica&lt;T&gt; operator*= (const T2&amp;);
    //template &lt;typename T2&gt;
    //friend GMatrica&lt;T&gt; operator*= (const T2&amp; n, GMatrica&lt;T&gt;&amp; m) { return m *= n; }
    template &lt;typename T1, typename T2&gt;
    friend bool operator==(const GMatrica&lt;T1&gt;&amp;, const GMatrica&lt;T2&gt;&amp;);
    //template &lt;typename T1, typename T2&gt;
    //friend bool operator!=(const GMatrica&lt;T1&gt;&amp; m1, const GMatrica&lt;T2&gt;&amp; m2) { return !(m1 == m2); }
    
    T&amp; operator() (int, int);
    const T operator() (int, int) const;
    T* operator[] (int);
    const T* operator[] (int) const;
    
    template &lt;typename T2&gt;
    friend ostream&amp; operator&lt;&lt; (ostream&amp;, const GMatrica&lt;T2&gt;&amp;);
    template &lt;typename T2&gt;
    friend istream&amp; operator&gt;&gt; (istream&amp;, GMatrica&lt;T2&gt;&amp;);
};

template &lt;typename T1, typename T2&gt;
bool operator!=(const GMatrica&lt;T1&gt;&amp; m1, const GMatrica&lt;T2&gt;&amp; m2) { return !(m1 == m2); }

template &lt;typename T1, typename T2&gt;
auto operator* (const T1 n, const GMatrica&lt;T2&gt;&amp; m) -&gt; decltype(GMatrica&lt;decltype(m(1, 1) * n)&gt;()) { return m * n; }

template &lt;typename T&gt;
GMatrica&lt;T&gt;::GMatrica(int redovi, int kolone, T n){
    if(redovi &lt; 0 || redovi &gt; 4 || kolone &lt; 0 || kolone &gt; 4)
        throw logic_error("Ilegalan format matrice");
    this-&gt;redovi = redovi;
    this-&gt;kolone = kolone;
    for(int i(0); i &lt; redovi; i++)
        for(int j(0); j &lt; kolone; j++) mat[i][j] = n;
}

template &lt;typename T&gt;
template &lt;typename T2&gt;
GMatrica&lt;T&gt;::GMatrica (const GMatrica&lt;T2&gt;&amp; g){
    this-&gt;redovi = g.DajBrojRedova();
    this-&gt;kolone = g.DajBrojKolona();
    for(int i(0); i &lt; this-&gt;redovi; i++)
        for(int j(0); j &lt; this-&gt;kolone; j++)
            mat[i][j] = g[i][j];
}

template &lt;typename T&gt;
template &lt;typename T2&gt;
GMatrica&lt;T&gt;::GMatrica (T2** mat){
    redovi = 4;
    kolone = 4;
    for(int i(0); i &lt; this-&gt;redovi; i++)
        for(int j(0); j &lt; this-&gt;kolone; j++)
            this-&gt;mat[i][j] = mat[i][j];
}

template &lt;typename T&gt;
GMatrica&lt;T&gt;::GMatrica (vector&lt;vector&lt;T&gt;&gt; v){
    int vel = (int)v.size();
    int brojKolona = 0;
    if(vel &gt; 4) throw logic_error("Ilegalan format matrice");
    if(vel != 0){
        brojKolona = (int)v.at(0).size();
        for(vector&lt;T&gt; x : v)
            if(x.size() &gt; 4 || (int)x.size() != brojKolona) throw logic_error("Ilegalan format matrice");
    }
    this-&gt;redovi = vel;
    this-&gt;kolone = brojKolona;
    for(int i(0); i &lt; vel; i++)
        for(int j(0); j &lt; brojKolona; j++)
            mat[i][j] = v.at(i).at(j);
}

template &lt;typename T&gt;
GMatrica&lt;T&gt;::GMatrica (initializer_list&lt;initializer_list&lt;T&gt;&gt; lista){
    int vel = (int)lista.size();
    int brojKolona = 0;
    if(vel &gt; 4) throw logic_error("Ilegalan format matrice");
    if(vel != 0){
        brojKolona = (int)lista.begin()-&gt;size();
        for(initializer_list&lt;T&gt; x : lista)
            if(x.size() &gt; 4 || (int)x.size() != brojKolona) throw logic_error("Ilegalan format matrice");
    }
    this-&gt;redovi = vel;
    this-&gt;kolone = brojKolona;
    auto it = lista.begin();
    for(int i(0); i &lt; vel; i++, it++){
        auto element = it-&gt;begin();
        for(int j(0); j &lt; brojKolona; j++, element++)
            mat[i][j] = *element;
    }
}

template &lt;typename T1, typename T2&gt;
auto operator+ (const GMatrica&lt;T1&gt;&amp; m1, const GMatrica&lt;T2&gt;&amp; m2) -&gt; decltype(GMatrica&lt;decltype(m1(1, 1) + m2(1, 1))&gt;()){
    typedef decltype(GMatrica&lt;decltype(m1(1, 1) + m2(1, 1))&gt;()) tip;
    if(m1.DajBrojRedova() != m2.DajBrojRedova() || m1.DajBrojKolona() != m2.DajBrojKolona())
        throw domain_error("Nedozvoljena operacija");
    tip rez(m1.DajBrojRedova(), m1.DajBrojKolona());
    for(int i(0); i &lt; m1.DajBrojRedova(); i++)
        for(int j(0); j &lt; m1.DajBrojKolona(); j++)
            rez[i][j] = m1[i][j] + m2[i][j];
    return rez;
}

template &lt;typename T1, typename T2&gt;
auto operator- (const GMatrica&lt;T1&gt;&amp; m1, const GMatrica&lt;T2&gt;&amp; m2) -&gt; decltype(GMatrica&lt;decltype(m1(1, 1) - m2(1, 1))&gt;()){
    typedef decltype(GMatrica&lt;decltype(m1(1, 1) - m2(1, 1))&gt;()) tip;
    if(m1.DajBrojRedova() != m2.DajBrojRedova() || m1.DajBrojKolona() != m2.DajBrojKolona())
        throw domain_error("Nedozvoljena operacija");
    tip rez(m1.DajBrojRedova(), m1.DajBrojKolona());
    for(int i(0); i &lt; m1.DajBrojRedova(); i++)
        for(int j(0); j &lt; m1.DajBrojKolona(); j++)
            rez[i][j] = m1[i][j] - m2[i][j];
    return rez;
}

template &lt;typename T1, typename T2&gt;
auto operator* (const GMatrica&lt;T1&gt;&amp; m1, const GMatrica&lt;T2&gt;&amp; m2) -&gt; decltype(GMatrica&lt;decltype(m1(1, 1) * m2(1, 1))&gt;()){
    typedef decltype(GMatrica&lt;decltype(m1(1, 1) * m2(1, 1))&gt;()) tip;
    if(m1.DajBrojKolona() != m2.DajBrojRedova())
        throw domain_error("Nedozvoljena operacija");
    tip rez(m1.DajBrojRedova(), m2.DajBrojKolona());
    for(int i(0); i &lt; rez.DajBrojRedova(); i++)
        for(int j(0); j &lt; rez.DajBrojKolona(); j++)
            for(int k(0); k &lt; rez.DajBrojKolona(); k++)
                rez[i][j] += m1[i][k] * m2[k][j];
    return rez;
}

template &lt;typename T1, typename T2&gt;
auto operator* (const GMatrica&lt;T1&gt;&amp; m, const T2 n) -&gt; decltype(GMatrica&lt;decltype(m(1, 1) * n)&gt;()){
    typedef decltype(GMatrica&lt;decltype(m(1, 1) * n)&gt;()) tip;
    tip rez(m);
    for(int i(0); i &lt; rez.DajBrojRedova(); i++)
        for(int j(0); j &lt; rez.DajBrojKolona(); j++)
            rez[i][j] *= n;
    return rez;
}

template &lt;typename T&gt;
template &lt;typename T2&gt;
GMatrica&lt;T&gt; GMatrica&lt;T&gt;::operator+= (const GMatrica&lt;T2&gt;&amp; m){
    if(DajBrojRedova() != m.DajBrojRedova() || DajBrojKolona() != m.DajBrojKolona())
        throw domain_error("Nedozvoljena operacija");
    for(int i(0); i &lt; DajBrojRedova(); i++)
        for(int j(0); j &lt; DajBrojKolona(); j++)
            mat[i][j] += m[i][j];
    return *this;
}

template &lt;typename T&gt;
template &lt;typename T2&gt;
GMatrica&lt;T&gt; GMatrica&lt;T&gt;::operator-= (const GMatrica&lt;T2&gt;&amp; m){
    if(DajBrojRedova() != m.DajBrojRedova() || DajBrojKolona() != m.DajBrojKolona())
        throw domain_error("Nedozvoljena operacija");
    for(int i(0); i &lt; DajBrojRedova(); i++)
        for(int j(0); j &lt; DajBrojKolona(); j++)
            mat[i][j] -= m[i][j];
    return *this;
}

template &lt;typename T&gt;
template &lt;typename T2&gt;
GMatrica&lt;T&gt; GMatrica&lt;T&gt;::operator*= (const GMatrica&lt;T2&gt;&amp; m){
    if(DajBrojKolona() != m.DajBrojRedova())
        throw domain_error("Nedozvoljena operacija");
    GMatrica&lt;T&gt; rez(DajBrojRedova(), m.DajBrojKolona());
    for(int i(0); i &lt; rez.DajBrojRedova(); i++)
        for(int j(0); j &lt; rez.DajBrojKolona(); j++)
            for(int k(0); k &lt; rez.DajBrojKolona(); k++)
                rez[i][j] += mat[i][k] * m[k][j];
    return *this = rez;
}

template &lt;typename T&gt;
template &lt;typename T2&gt;
GMatrica&lt;T&gt; GMatrica&lt;T&gt;::operator*= (const T2&amp; n){
    for(int i(0); i &lt; DajBrojRedova(); i++)
        for(int j(0); j &lt; DajBrojKolona(); j++)
            mat[i][j] *= n;
    return *this;
}

template &lt;typename T1, typename T2&gt;
bool operator==(const GMatrica&lt;T1&gt;&amp; m1, const GMatrica&lt;T2&gt;&amp; m2){
    if(m1.DajBrojRedova() != m2.DajBrojRedova() || m1.DajBrojKolona() != m2.DajBrojKolona())
        return false;
    for(int i(0); i &lt; m1.DajBrojRedova(); i++)
        for(int j(0); j &lt; m1.DajBrojKolona(); j++)
            if(!poredi(m1[i][j], m2[i][j])) return false;
    return true;
}

template &lt;typename T&gt;
T&amp; GMatrica&lt;T&gt;::operator() (int red, int kolona){
    if(red &lt; 1 || red &gt;= redovi || kolona &lt; 1 || kolona &gt;= kolone)
        throw range_error("Nedozvoljen indeks");
    return mat[red-1][kolona-1];
}

template &lt;typename T&gt;
const T GMatrica&lt;T&gt;::operator() (int red, int kolona) const{
    if(red &lt; 1 || red &gt;= redovi || kolona &lt; 1 || kolona &gt;= kolone)
        throw range_error("Nedozvoljen indeks");
    return mat[red-1][kolona-1];
}

template &lt;typename T&gt;
T* GMatrica&lt;T&gt;::operator[] (int indeks){
    return mat[indeks];
}

template &lt;typename T&gt;
const T* GMatrica&lt;T&gt;::operator[] (int indeks) const {
    return mat[indeks];
}

template &lt;typename T&gt;
ostream&amp; operator&lt;&lt; (ostream&amp; tok, const GMatrica&lt;T&gt;&amp; g){
    int sirina = tok.width();
    if(sirina &lt; 6) sirina = 6;
    for(int i(0); i &lt; g.redovi; i++){
        for(int j(0); j &lt; g.kolone; j++){
            int brojCifri = poredi(g[i][j], 0) ? 1 : 0;
            int temp = g[i][j];
            while(temp != 0){
                brojCifri++;
                temp /= 10;
            }
            for(int k(0); k &lt; sirina - brojCifri; k++)
                tok &lt;&lt; " ";
            tok &lt;&lt; g.mat[i][j];
        }
        tok &lt;&lt; endl;
    }
    return tok;
}

template &lt;typename T&gt;
istream&amp; operator&gt;&gt; (istream&amp; tok, GMatrica&lt;T&gt;&amp; m){
    //tok.setstate(ios_base::failbit)
    vector&lt;vector&lt;T&gt;&gt; temp(1);
    int brojKolona(0);
    int red(0), kolona(0);
    bool prvired = true;
    while(1){
        if(tok.peek() == char_traits&lt;char&gt;::to_int_type('[')) {
            char c;
            tok &gt;&gt; c;
            continue;
        }
        else if(tok.peek() == char_traits&lt;char&gt;::to_int_type(']')) break;
        else if(tok.peek() == char_traits&lt;char&gt;::to_int_type(';')){
            if(prvired){
                brojKolona = kolona;
                prvired = false;
            }
            else if(kolona != brojKolona){
                tok.setstate(ios_base::failbit);
                return tok;
            }
            else kolona = 0;
            char c;
            tok &gt;&gt; c;
            red++;
            if(red == 4){
                tok.setstate(ios_base::failbit);
                return tok;
            }
            temp.push_back(vector&lt;T&gt;());
        }
        else if(tok.peek() == char_traits&lt;char&gt;::to_int_type(',')){
            char c;
            tok &gt;&gt; c;
            kolona++;
            if(kolona == 4){
                tok.setstate(ios_base::failbit);
                return tok;
            }
        }
        else{
            T broj;
            tok &gt;&gt; broj;
            if(!tok){
                tok.setstate(ios_base::failbit);
                return tok;
            }
            temp[red].push_back(broj);
            //cout &lt;&lt; broj;
        }
    }
    //cout &lt;&lt; kolona &lt;&lt; " " &lt;&lt; brojKolona;
    if(kolona - 1 != brojKolona){ // DORADITI DORADITI DORADTII DORADITI
        tok.setstate(ios_base::failbit);
        return tok;
    }
    m = temp;
    return tok;
}

int main ()
{
    try{
   GMatrica&lt;int&gt; m1;
   std::cin &gt;&gt; m1;
   std::cout &lt;&lt; m1 &lt;&lt; std::endl;  
    }catch(exception &amp;e){
        cout &lt;&lt; e.what();
    }
	return 0;
</font>}</pre>
</body>
</html>
