<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8957.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student8957.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
using namespace std;

template &lt;typename Tip&gt;
class GMatrica {
    int redovi, kolone;
    Tip matrica[4][4];  
    public:
    GMatrica();
    GMatrica(int redovi, int kolone, Tip element = Tip());
    template &lt;typename Tip2&gt;
    GMatrica(const GMatrica&lt;Tip2&gt; &amp;mat);
    template &lt;typename Tip2&gt;
    GMatrica(Tip2 mat[4][4]);
    GMatrica(const vector&lt;vector&lt;Tip&gt;&gt; &amp;vektor);
    GMatrica(const initializer_list&lt;initializer_list&lt;Tip&gt;&gt; &amp;mat);
    int DajBrojRedova() const {
        return redovi;
    }
    int DajBrojKolona() const {
<a name="0"></a><font color="#FF0000"><a href="match788-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

        return kolone;
    }
    
    template &lt;typename Tip2&gt;
    GMatrica&lt;Tip&gt; &amp;operator +=(const GMatrica&lt;Tip2&gt; &amp;mat);
    
    template &lt;typename Tip2&gt;
    GMatrica&lt;Tip&gt; &amp;operator -=(const GMatrica&lt;Tip2&gt; &amp;mat);
    
    template &lt;typename Tip2&gt;
    GMatrica&lt;Tip&gt; &amp;operator *=(const GMatrica&lt;Tip2&gt; &amp;mat);
    
    template&lt;typename Tip2&gt;
    GMatrica&lt;Tip&gt; &amp;operator *=(Tip2 broj);
    
    Tip &amp;operator ()(int i, int j);
    Tip operator ()(int i, int j) const;
    
    Tip *operator [](int i);
    
    template&lt;typename Tip1, typename Tip2&gt;
</font>    friend auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() + Tip2())&gt;::type&gt;;
    
    template&lt;typename Tip1, typename Tip2&gt;
    friend auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() - Tip2())&gt;::type&gt;;
    
    template&lt;typename Tip1, typename Tip2&gt;
<a name="1"></a><font color="#00FF00"><a href="match788-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() * Tip2())&gt;::type&gt;;

    template&lt;typename Tip1&gt;
    friend bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip1&gt; &amp;m2);
    
    template&lt;typename Tip1&gt;
    friend bool operator !=(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip1&gt; &amp;m2);
    
    template&lt;typename Tip1, typename Tip2&gt;
</font><a name="9"></a><font color="#FF00FF"><a href="match788-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, Tip2 broj) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() * Tip2())&gt;::type&gt;;
    
    template&lt;typename Tip1, typename Tip2&gt;
    friend auto operator *(Tip1 broj, const GMatrica&lt;Tip2&gt; &amp;m1) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() * Tip2())&gt;::type&gt;;
</font>    
    template&lt;typename Tip1&gt;
    friend ostream &amp;operator &lt;&lt;(ostream &amp;tok, const GMatrica&lt;Tip1&gt; &amp;m);
    
    template&lt;typename Tip1&gt;
    friend istream &amp;operator &gt;&gt;(istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;m);
    
};

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica() : redovi(0), kolone(0) {
    
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int redovi, int kolone, Tip element) : redovi(redovi), kolone(kolone) {
    if(redovi &lt; 0 || redovi &gt; 4 || kolone &lt; 0 || kolone &gt; 4) {
        throw logic_error("Ilegalan format matrice");
    }
    for(int i=0; i &lt; redovi; i++) {
        for(int j=0; j&lt;kolone; j++) {
<a name="11"></a><font color="#00FF00"><a href="match788-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

            matrica[i][j] = element;
        }
    }
}

template &lt;typename Tip&gt;
template &lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;Tip2&gt; &amp;mat) : redovi(mat.DajBrojRedova()), kolone(mat.DajBrojKolona()) {
</font>    for(int i=0; i &lt; redovi; i++) {
        for(int j=0; j&lt;kolone; j++) {
            matrica[i][j] = mat(i+1,j+1);
        }
    }
}

template &lt;typename Tip&gt;
template &lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;::GMatrica(Tip2 mat[4][4]) : redovi(4), kolone(4) {
    for(int i=0; i&lt;redovi; i++) {
        for(int j=0; j&lt;kolone; j++) {
            matrica[i][j] = mat[i][j];
        }
    }
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(const vector&lt;vector&lt;Tip&gt;&gt; &amp;vektor) : redovi(vektor.size()) {
    if(redovi &gt; 0) {
        kolone = vektor[0].size();
    }
    if(redovi &lt; 0 || redovi &gt; 4 || kolone &lt; 0 || kolone &gt; 4) {
        throw logic_error("Ilegalan format matrice");
    }
    for(int i=1; i &lt; vektor.size(); i++) {
        if(vektor[0].size() != vektor[i].size()) {
            throw logic_error("Ilegalan format matrice");
        }
    }
    for(int i=0; i &lt; vektor.size(); i++) {
        for(int j=0; j&lt;vektor[i].size(); j++) {
            matrica[i][j] = vektor[i][j];
        }
    }
}

template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(const initializer_list&lt;initializer_list&lt;Tip&gt;&gt; &amp;lista) {
    vector&lt;vector&lt;Tip&gt;&gt; mat;
    for(initializer_list&lt;Tip&gt; red : lista) {
        vector&lt;Tip&gt; temp;
        for(Tip e : red) {
            temp.push_back(e);
        }
        mat.push_back(temp);
    }
    redovi = mat.size();
    if(redovi &gt; 0) {
        kolone = mat[0].size();
    }
    if(redovi &lt; 0 || redovi &gt; 4 || kolone &lt; 0 || kolone &gt; 4) {
        throw logic_error("Ilegalan format matrice");
    }
    for(int i=1; i &lt; mat.size(); i++) {
        if(mat[0].size() != mat[i].size()) {
            throw logic_error("Ilegalan format matrice");
        }
    }
    for(int i=0; i &lt; mat.size(); i++) {
        for(int j=0; j &lt; mat[i].size(); j++) {
            matrica[i][j] = mat[i][j];
        }
    }
}

template&lt;typename Tip&gt;
Tip* GMatrica&lt;Tip&gt;::operator [](int i) {
    return matrica[i];
}

template&lt;typename Tip1, typename Tip2&gt;
auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() + Tip2())&gt;::type&gt; {
    if(m1.DajBrojRedova() != m2.DajBrojRedova() || m1.DajBrojKolona() != m2.DajBrojKolona()) {
        throw domain_error("Nedozvoljena operacija");
    }
    GMatrica&lt;typename remove_reference&lt;decltype(Tip1() + Tip2())&gt;::type&gt; temp(m1);
    for(int i=0; i &lt; m2.DajBrojRedova(); i++) {
<a name="3"></a><font color="#00FFFF"><a href="match788-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        for(int j=0; j &lt; m2.DajBrojKolona(); j++) {
            temp.matrica[i][j] += m2.matrica[i][j];
        }
    }
    return temp;
}

template&lt;typename Tip1, typename Tip2&gt;
auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() - Tip2())&gt;::type&gt; {
</font>    if(m1.DajBrojRedova() != m2.DajBrojRedova() || m1.DajBrojKolona() != m2.DajBrojKolona()) {
        throw domain_error("Nedozvoljena operacija");
    }
    GMatrica&lt;typename remove_reference&lt;decltype(Tip1() - Tip2())&gt;::type&gt; temp(m1);
    for(int i=0; i &lt; m2.DajBrojRedova(); i++) {
<a name="4"></a><font color="#FF00FF"><a href="match788-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        for(int j=0; j &lt; m2.DajBrojKolona(); j++) {
            temp.matrica[i][j] -= m2.matrica[i][j];
        }
    }
    return temp;
}

template&lt;typename Tip1, typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() * Tip2())&gt;::type&gt; {
</font>    if(m1.DajBrojKolona() != m2.DajBrojRedova()) {
        throw domain_error("Nedozvoljena operacija");
    }
    GMatrica&lt;typename remove_reference&lt;decltype(Tip1() * Tip2())&gt;::type&gt; temp(m1.DajBrojRedova(), m2.DajBrojKolona());
    for(int i=0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j=0; j &lt; m2.DajBrojKolona(); j++) {
            for(int k=0; k &lt; m1.DajBrojKolona(); k++) {
                temp.matrica[i][j] += m1.matrica[i][k] * m2.matrica[k][j];
            }
        }
    }
    return temp;
}

template&lt;typename Tip1, typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, Tip2 broj) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() * Tip2())&gt;::type&gt; {
    GMatrica&lt;typename remove_reference&lt;decltype(Tip1() * Tip2())&gt;::type&gt; temp(m1);
    for(int i=0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j=0; j &lt; m1.DajBrojKolona(); j++) {
<a name="5"></a><font color="#FF0000"><a href="match788-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

            temp.matrica[i][j] *= broj;
        }
    }
    return temp;
}

template&lt;typename Tip1, typename Tip2&gt;
auto operator *(Tip1 broj, const GMatrica&lt;Tip2&gt; &amp;m1) -&gt; GMatrica&lt;typename remove_reference&lt;decltype(Tip1() * Tip2())&gt;::type&gt; {
</font>    GMatrica&lt;typename remove_reference&lt;decltype(Tip1() * Tip2())&gt;::type&gt; temp(m1);
    for(int i=0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j=0; j &lt; m1.DajBrojKolona(); j++) {
<a name="2"></a><font color="#0000FF"><a href="match788-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

            temp.matrica[i][j] *= broj;
        }
    }
    return temp;
}

template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;&amp; GMatrica&lt;Tip&gt;::operator +=(const GMatrica&lt;Tip2&gt; &amp;mat) {
</font>    if(DajBrojRedova() != mat.DajBrojRedova() || DajBrojKolona() != mat.DajBrojKolona()) {
        throw domain_error("Nedozvoljena operacija");
    }
    for(int i=0; i &lt; mat.DajBrojRedova(); i++) {
        for(int j=0; j &lt; mat.DajBrojKolona(); j++) {
            matrica[i][j] += mat(i+1,j+1);
        }
    }
<a name="8"></a><font color="#00FFFF"><a href="match788-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    return *this;
}

template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;&amp; GMatrica&lt;Tip&gt;::operator -=(const GMatrica&lt;Tip2&gt; &amp;mat) {
</font>    if(DajBrojRedova() != mat.DajBrojRedova() || DajBrojKolona() != mat.DajBrojKolona()) {
        throw domain_error("Nedozvoljena operacija");
    }
    for(int i=0; i &lt; mat.DajBrojRedova(); i++) {
        for(int j=0; j &lt; mat.DajBrojKolona(); j++) {
            matrica[i][j] -= mat(i+1,j+1);
        }
    }
    return *this;
}

<a name="10"></a><font color="#FF0000"><a href="match788-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;&amp; GMatrica&lt;Tip&gt;::operator *=(const GMatrica&lt;Tip2&gt; &amp;mat) {
</font>    if(DajBrojKolona() != mat.DajBrojRedova() || DajBrojKolona() != mat.DajBrojKolona()) {
        throw domain_error("Nedozvoljena operacija");
    }
    for(int i=0; i &lt; DajBrojRedova(); i++) {
        for(int j=0; j &lt; DajBrojKolona(); j++) {
            for(int k=0; k &lt; DajBrojKolona(); k++) {
                matrica[i][j] += matrica[i][k] * mat(i+1,k+1);
            }
        }
    }
    return *this;
}

<a name="12"></a><font color="#0000FF"><a href="match788-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

template&lt;typename Tip&gt;
template&lt;typename Tip2&gt;
GMatrica&lt;Tip&gt;&amp; GMatrica&lt;Tip&gt;::operator *=(Tip2 broj) {
    for(int i=0; i &lt; DajBrojRedova(); i++) {
</font>        for(int j=0; j &lt; DajBrojKolona(); j++) {
            matrica[i][j] *= broj;
        }
    }
    return *this;
}

template&lt;typename Tip1&gt;
bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip1&gt; &amp;m2) {
    if(m1.DajBrojRedova() != m2.DajBrojRedova() || m1.DajBrojKolona() != m2.DajBrojKolona()) {
        return false;
    }
    for(int i=0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j=0; j &lt; m1.DajBrojKolona(); j++) {
            if(m1.matrica[i][j] != m2.matrica[i][j]) {
                return false;
            }
        }
    }
<a name="7"></a><font color="#0000FF"><a href="match788-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    return true;
}

template &lt;typename Tip1&gt;
bool operator !=(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip1&gt; &amp;m2) {
    if(m1.DajBrojRedova() != m2.DajBrojRedova() || m1.DajBrojKolona() != m2.DajBrojKolona()) {
</font>        return true;
    }
    for(int i=0; i &lt; m1.DajBrojRedova(); i++) {
        for(int j=0; j &lt; m1.DajBrojKolona(); j++) {
            if(m1.matrica[i][j] != m2.matrica[i][j]) {
                return true;
            }
        }
    }
    return false;
}

template&lt;typename Tip&gt;
Tip&amp; GMatrica&lt;Tip&gt;::operator ()(int i, int j) {
    if(i &lt; 1 || i &gt; redovi || j &lt; 1 || j &gt; kolone) {
<a name="6"></a><font color="#00FF00"><a href="match788-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        throw range_error("Nedozvoljen indeks");
    }
    return matrica[i-1][j-1];
}

template&lt;typename Tip&gt;
Tip GMatrica&lt;Tip&gt;::operator ()(int i, int j) const {
    if(i &lt; 1 || i &gt; redovi || j &lt; 1 || j &gt; kolone) {
</font>        throw range_error("Nedozvoljen indeks");
    }
    return matrica[i-1][j-1];
}

template&lt;typename Tip1&gt;
ostream &amp;operator &lt;&lt;(ostream &amp;tok, const GMatrica&lt;Tip1&gt; &amp;m) {
    int sirina(tok.width());
    if(sirina &lt; 6) {
        sirina = 6;
    }
    for(int i=0; i &lt; m.DajBrojRedova(); i++) {
        for(int j=0; j &lt; m.DajBrojKolona(); j++) {
            tok &lt;&lt; setw(sirina) &lt;&lt; m.matrica[i][j];
        }
        tok &lt;&lt; endl;
    }
    return tok;
}

template&lt;typename Tip1&gt;
istream &amp;operator &gt;&gt;(istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;m) {
    char znak;
    tok &gt;&gt; znak;
    vector&lt;vector&lt;Tip1&gt;&gt; vektor(1,vector&lt;Tip1&gt;());
    if(znak == '[') {
        Tip1 element;
        int i(0);
        do {
            tok &gt;&gt; element &gt;&gt; znak;
            vektor[i].push_back(element);
            if(znak == ';') {
                i++;
                vektor.push_back(vector&lt;Tip1&gt;());
            } else if(znak == ',') {
                continue;
            } else if(znak == ']') {
                break;
            } else {
                tok.setstate(ios::failbit);
                return tok;
            }
        }while(znak != ']');
    } else {
        tok.setstate(ios::failbit);
        return tok;
    }
    m = GMatrica&lt;Tip1&gt;(vektor);
    return tok;
}

int main() {
    //orbob
    GMatrica&lt;int&gt; m1({{1, 2}, {3, 4}});
    GMatrica&lt;double&gt; m2{{2,3},{3,3}};
    cout &lt;&lt; m1 + m2 &lt;&lt; endl;
    cout &lt;&lt; m1 - m2 &lt;&lt; endl;
    cout &lt;&lt; m1 * m2 &lt;&lt; endl;
    GMatrica&lt;int&gt; m3(m1 *= 3);
    cout &lt;&lt; m1(1,1) &lt;&lt; endl;
    cout &lt;&lt; m1[1][1] &lt;&lt; endl;
    cout &lt;&lt; m3 &lt;&lt; endl;
    GMatrica&lt;double&gt; m4(m3);
    m4 *= m3;
    m3 += m2;
    m1 -= m3;
    m1 = m3;
    if(m1 != m3) {
        cout &lt;&lt; "Nisu jednaki" &lt;&lt; endl;
    } else if(m1 == m3) {
        cout &lt;&lt; "Jednaki su" &lt;&lt; endl;
    }
    m4 *= 3;
    cout &lt;&lt; m4 &lt;&lt; endl;
    return 0;
}</pre>
</body>
</html>
