<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4628.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5829.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
using namespace std;
template&lt;typename TipEl&gt;
class GMatrica{

    int redovi, kolone;
    
    TipEl elementi[4][4];
public:

    GMatrica(){}
    GMatrica(int red, int kol, TipEl vrijednost=0): redovi(red), kolone(kol)
    {
        if(redovi&gt;4 || kolone&gt;4) throw logic_error("Ilegalan format matrice");
    for(int i=0;i&lt;redovi;i++)
        for(int j=0;j&lt;kolone;j++)
        elementi[i][j]=vrijednost; 
    }   
    template&lt;typename TipEl1&gt;
    GMatrica(const GMatrica&lt;TipEl1&gt; &amp;mat):redovi(mat.redovi), kolone(mat.kolone)
    {
        for(int i=0;i&lt;mat.redovi;i++)
            for(int j=0;j&lt;mat.kolone;j++)
                elementi[i][j]=mat.elementi[i][j];
    }
    GMatrica(const vector&lt;vector&lt;TipEl&gt;&gt; &amp;v)
    {
        redovi=v.size();
        kolone=v[0].size();
        bool br_se_ne_slaze=false;
        for(int i=1;i&lt;v.size();i++)
        if(v[i].size()!=v[0].size())br_se_ne_slaze=true;
        if(v.size()&gt;4 || v[0].size()&gt;4 || br_se_ne_slaze)throw logic_error("Ilegalan format matrice");

        for(int i=0;i&lt;v.size();i++)
            for(int j=0;j&lt;v[0].size();j++)
                elementi[i][j]=v[i][j];
    }
    template&lt;typename TipEl1&gt;
    GMatrica(TipEl1 **a)
    {
        cout&lt;&lt;"hamo";
<a name="12"></a><font color="#0000FF"><a href="match341-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        redovi=4;
        kolone=4;
        for(int i=0;i&lt;4;i++)
            for(int j=0;j&lt;4;j++)
                elementi[i][j]=a[i][j];
</font>        
        
    }
    int DajBrojRedova()const {return redovi;}
    int DajBrojKolona()const {return kolone;}
<a name="0"></a><font color="#FF0000"><a href="match341-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

 template&lt;typename TipEl1&gt;
 friend GMatrica&lt;TipEl1&gt; operator +(const  GMatrica&lt;TipEl1&gt; &amp;mat1 ,const  GMatrica&lt;TipEl1&gt; &amp;mat2);
 template&lt;typename TipEl1&gt;
 friend GMatrica&lt;TipEl1&gt; operator -(const  GMatrica&lt;TipEl1&gt; &amp;mat1 ,const GMatrica&lt;TipEl1&gt; &amp;mat2);
 template&lt;typename TipEl1&gt;
 friend GMatrica&lt;TipEl1&gt; operator *(const GMatrica&lt;TipEl1&gt; &amp;mat1,const GMatrica&lt;TipEl1&gt; &amp;mat2);
 template&lt;typename TipEl1, typename TipEl2&gt;
</font> friend GMatrica&lt;TipEl1&gt; operator *(const GMatrica&lt;TipEl1&gt; &amp;mat, TipEl2 a);
 template&lt;typename TipEl1, typename TipEl2&gt;
 friend GMatrica&lt;TipEl1&gt; operator *(TipEl2 a,const GMatrica&lt;TipEl1&gt; &amp;mat);
 template&lt;typename TipEl1,typename TipEl2&gt;
 friend GMatrica&lt;TipEl1&gt; operator *(TipEl2 a,const GMatrica&lt;TipEl1&gt; &amp;mat);
 template&lt;typename TipEl1,typename TipEl2&gt;
<a name="8"></a><font color="#00FFFF"><a href="match341-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

 friend GMatrica&lt;TipEl1&gt; operator *(TipEl2 a,const GMatrica&lt;TipEl1&gt; &amp;mat);
 
 GMatrica&lt;TipEl&gt; &amp;operator +=(const GMatrica&lt;TipEl&gt; &amp;mat);

 GMatrica&lt;TipEl&gt; &amp;operator -=(const GMatrica&lt;TipEl&gt; &amp;mat);

 GMatrica&lt;TipEl&gt; &amp;operator *=(TipEl a);
</font>
GMatrica&lt;TipEl&gt; operator *=(const GMatrica&lt;TipEl&gt; &amp;mat);

 
 template&lt;typename TipEl1&gt;
 friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const GMatrica&lt;TipEl1&gt; &amp;mat1);
 template&lt;typename TipEl1&gt;
<a name="4"></a><font color="#FF00FF"><a href="match341-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

 friend istream &amp;operator&gt;&gt;(istream &amp;cin, GMatrica&lt;TipEl1&gt; &amp;mat1);
 template&lt;typename TipEl1&gt;
 friend bool operator ==(const GMatrica&lt;TipEl1&gt; &amp;mat1,const GMatrica&lt;TipEl1&gt; &amp;mat2);
 template&lt;typename TipEl1&gt;
 friend bool operator !=(const GMatrica&lt;TipEl1&gt; &amp;mat1,const GMatrica&lt;TipEl1&gt; &amp;mat2);
</font>double operator ()(int red,int k)
{
    if(red&gt;4 || k&gt;4)throw range_error("Nedozvoljeni indexi");
    redovi=red; kolone=k;
    return elementi[red-1][k-1];
}
template&lt;typename TipEl1&gt;
double* operator [](int a) 
{  return elementi[a];
}
//}
/*template&lt;typename TipEl1&gt;
auto operator[](int a)-&gt;vector&lt;decltype (a)&gt; 
{return elementi[a];}
*/
};

<a name="11"></a><font color="#00FF00"><a href="match341-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

 template&lt;typename TipEl1&gt;
GMatrica&lt;TipEl1&gt; operator +(const GMatrica&lt;TipEl1&gt; &amp;mat1 , const GMatrica&lt;TipEl1&gt; &amp;mat2)
 {
     if(mat1.redovi!=mat2.redovi || mat1.kolone!=mat2.kolone) throw domain_error("Nedozvoljena operacija");
</font><a name="13"></a><font color="#00FFFF"><a href="match341-0.html#13" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

     GMatrica&lt;TipEl1&gt;mat3(mat1.redovi, mat1.kolone);
     for(int i=0;i&lt;mat1.redovi;i++)
</font>        for(int j=0;j&lt;mat1.kolone;j++)
<a name="2"></a><font color="#0000FF"><a href="match341-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

            mat3.elementi[i][j]=mat1.elementi[i][j]+mat2.elementi[i][j];
            return mat3;
 }
 
  template&lt;typename TipEl1&gt;
GMatrica&lt;TipEl1&gt; operator -(const GMatrica&lt;TipEl1&gt; &amp;mat1 , const GMatrica&lt;TipEl1&gt; &amp;mat2)
 {
     
     if(mat1.redovi!=mat2.redovi || mat1.kolone!=mat2.kolone)throw domain_error("Nedozvoljena operacija");
</font><a name="14"></a><font color="#FF00FF"><a href="match341-0.html#14" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

     GMatrica&lt;TipEl1&gt;mat3(mat1.redovi, mat1.kolone);
     for(int i=0;i&lt;mat1.redovi;i++)
</font>        for(int j=0;j&lt;mat1.kolone;j++)
<a name="3"></a><font color="#00FFFF"><a href="match341-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

            mat3.elementi[i][j]=mat1.elementi[i][j]-mat2.elementi[i][j];
            return mat3;
 }
 template&lt;typename TipEl1&gt;
 GMatrica&lt;TipEl1&gt; operator *(const GMatrica&lt;TipEl1&gt; &amp;mat1,const GMatrica&lt;TipEl1&gt; &amp;mat2)
 {
    if(mat1.kolone!=mat2.redovi)throw domain_error("Nedozvoljena operacija");
</font><a name="15"></a><font color="#FF0000"><a href="match341-0.html#15" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

     GMatrica&lt;TipEl1&gt;mat(mat1.redovi, mat2.kolone);
     for(int i=0;i&lt;mat1.redovi;i++)
</font>         for(int j=0;j&lt;mat2.kolone;j++)
            for(int k=0;k&lt;mat2.redovi;k++)
            mat.elementi[i][j]=mat.elementi[i][j]+(mat1.elementi[i][k]*mat2.elementi[k][j]);
            return mat;
 }
 template&lt;typename TipEl1, typename TipEl2&gt;
<a name="5"></a><font color="#FF0000"><a href="match341-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

 GMatrica&lt;TipEl1&gt; operator *(const GMatrica&lt;TipEl1&gt; &amp;mat, TipEl2 a)
 {
      
     GMatrica&lt;TipEl1&gt;mat3(mat.redovi, mat.kolone);
     for(int i=0;i&lt;mat.redovi;i++)
         for(int j=0;j&lt;mat.kolone;j++)
</font>            mat3.elementi[i][j]=mat.elementi[i][j]*a;
            return mat3;
 }
<a name="6"></a><font color="#00FF00"><a href="match341-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

 template&lt;typename TipEl1, typename TipEl2&gt;
 GMatrica&lt;TipEl1&gt; operator *(TipEl2 a,const GMatrica&lt;TipEl1&gt; &amp;mat)
 {
     GMatrica&lt;TipEl1&gt;mat3(mat.redovi, mat.kolone);
     for(int i=0;i&lt;mat.redovi;i++)
</font>         for(int j=0;j&lt;mat.kolone;j++)
<a name="7"></a><font color="#0000FF"><a href="match341-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

            mat3.elementi[i][j]=mat.elementi[i][j]*a;
            return mat3;
 }
 template&lt;typename TipEl&gt;
 GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator +=(const GMatrica&lt;TipEl&gt; &amp;mat)
</font> {
     for(int i=0;i&lt;mat.redovi;i++)
        for(int j=0;j&lt;mat.kolone;j++)
<a name="10"></a><font color="#FF0000"><a href="match341-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

            elementi[i][j]+=mat.elementi[i][j];
    return *this;
 }
 
 template&lt;typename TipEl&gt;
 GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator-=(const GMatrica&lt;TipEl&gt; &amp;mat)
</font> {
     for(int i=0;i&lt;mat.redovi;i++)
        for(int j=0;j&lt;mat.kolone;j++)
<a name="1"></a><font color="#00FF00"><a href="match341-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

            elementi[i][j]-=mat.elementi[i][j];
    return *this;
 }
template&lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt; &amp;GMatrica&lt;TipEl&gt;::operator *=(TipEl a)
{
     for(int i=0;i&lt;redovi;i++)
        for(int j=0;j&lt;kolone;j++)
            elementi[i][j]*=a;
    return *this;
 }
 template&lt;typename TipEl&gt;
</font>GMatrica&lt;TipEl&gt; GMatrica&lt;TipEl&gt;::operator *=(const GMatrica&lt;TipEl&gt; &amp;mat)
 {
     
    if(kolone!=mat.redovi)throw domain_error("Nedozvoljena operacija");
     GMatrica&lt;TipEl&gt;mat1(redovi, mat.kolone);
     for(int i=0;i&lt;redovi;i++)
         for(int j=0;j&lt;mat.kolone;j++)
            for(int k=0;k&lt;mat.redovi;k++)
            mat1.elementi[i][j]+=elementi[i][k]*mat.elementi[k][j];
            
            for(int i=0;i&lt;redovi;i++)
                for(int j=0;j&lt;mat.kolone;j++)
                    elementi[i][j]=mat1.elementi[i][j];
            
            
            return *this;
 }


 
 template&lt;typename TipEl1&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;cout, const GMatrica&lt;TipEl1&gt; &amp;mat1)
 {
     for(int i = 0; i &lt; mat1.redovi; i++) {
        for(int j = 0; j &lt; mat1.kolone; j++)
            cout&lt;&lt;setw(6)&lt;&lt;mat1.elementi[i][j];
            cout&lt;&lt;endl;
            }
            return cout;
 }
 template&lt;typename TipEl1&gt;
 istream &amp;operator&gt;&gt;(istream &amp;cin, GMatrica&lt;TipEl1&gt; &amp;mat1)
 {
     char znak;
     bool kraj=false;
     cin&gt;&gt;znak;
     if(znak=='[')
     {
         for(int i=0;i&lt;4;i++){
            for(int j=0;j&lt;4;j++){
                cin&gt;&gt;mat1.elementi[i][j]&gt;&gt;znak;
                if(znak==',')continue;
                if(znak==';'){mat1.kolone=j+1;break;}
                if(znak==']'){break;}
            }
          if(znak==']'){ mat1.redovi=i+1;kraj=true;break;}
         }
     }
    
            if(kraj) return cin;
            else throw;
     
 }
 template&lt;typename TipEl1&gt;
 bool operator ==(const GMatrica&lt;TipEl1&gt; &amp;mat1,const GMatrica&lt;TipEl1&gt; &amp;mat2)
 {
     if(mat1.redovi != mat2.redovi || mat1.kolone!=mat2.kolone) { return false;}
     for(int i=0;i&lt;mat1.redovi;i++)
        for(int j=0;j&lt;mat1.kolone;j++)
<a name="9"></a><font color="#FF00FF"><a href="match341-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

            if(mat1.elementi[i][j]!=mat2.elementi[i][j])return false;
            return true;
 }
 template&lt;typename TipEl1&gt;
 bool operator !=(const GMatrica&lt;TipEl1&gt; &amp;mat1,const GMatrica&lt;TipEl1&gt; &amp;mat2)
</font> {
     if(mat1.redovi != mat2.redovi || mat1.kolone!=mat2.kolone) { return true;}
     for(int i=0;i&lt;mat1.redovi;i++)
        for(int j=0;j&lt;mat1.kolone;j++)
            if(mat1.elementi[i][j]!=mat2.elementi[i][j])return true;
            return false;
 }
 
int main ()
{
    
   GMatrica&lt;int&gt; m1({{1, 2}, {3, 4}});
std::cout &lt;&lt; m1[1][1] &lt;&lt; std::endl;
	return 0;
}</pre>
</body>
</html>
