<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student6357.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student4780.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt; 
#include &lt;type_traits&gt;

<a name="0"></a><font color="#FF0000"><a href="match75-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_46.gif"/></a>

template &lt;typename TipEl&gt;
class GMatrica{
    int br_redova;
    int br_kolona;
    int matrica[4][4];
    public:
    GMatrica();
    GMatrica(int br_redova, int br_kolona, TipEl element);
    
    template&lt;typename TipEl2&gt;
    GMatrica(GMatrica&lt;TipEl2&gt; nova);
    
    template&lt;typename TipEl2&gt;
    GMatrica(TipEl2 nova[4][4]);
    
    GMatrica(std::vector&lt;std::vector&lt;TipEl&gt;&gt; vek);
    
    int DajBrojRedova()const;
    
    int DajBrojKolona()const;
    
    template&lt;typename TipEl2, typename TipEl3&gt;
    friend auto  operator +( GMatrica&lt;TipEl2&gt;m1 , GMatrica&lt;TipEl3&gt; m2)-&gt; GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt;;
    template&lt;typename TipEl2, typename TipEl3&gt;
    friend auto operator -( GMatrica&lt;TipEl2&gt;m1,  GMatrica&lt;TipEl3&gt;m2)-&gt; GMatrica&lt; decltype(m1.matrica[0][0]-m2.matrica[0][0])&gt;;
   template&lt;typename TipEl2, typename TipEl3&gt;
    friend auto operator *( GMatrica&lt;TipEl3&gt;m1,  GMatrica&lt;TipEl2&gt;m2)-&gt; decltype(m1.matrica[0][0]*m2.matrica[0][0]);
    template &lt;typename TipEl2&gt;
  friend GMatrica&lt;TipEl2&gt; operator *(int n, GMatrica&lt;TipEl2&gt; m);
  template &lt;typename TipEl2&gt;
  friend GMatrica&lt;TipEl2&gt; operator *( GMatrica&lt;TipEl2&gt; m, int n);
  
  template&lt;typename TipEl2, typename TipEl3&gt;
  friend bool operator==(GMatrica&lt;TipEl2&gt; m1, GMatrica&lt;TipEl3&gt; m2);
  
  template&lt;typename TipEl2, typename TipEl3&gt;
  friend bool operator!=(GMatrica&lt;TipEl2&gt; m1, GMatrica&lt;TipEl3&gt; m2);
  
  template&lt;typename TipEl2&gt;
  GMatrica&lt;TipEl&gt; &amp;operator+=(GMatrica&lt;TipEl2&gt; m2);
  
  template&lt;typename TipEl2&gt;
  GMatrica&lt;TipEl&gt; &amp;operator-=(GMatrica&lt;TipEl2&gt; m2);
  

  GMatrica&lt;TipEl&gt; &amp;operator*=(int n);
  
  
  TipEl &amp;operator()(int indeks1,int indeks2);
  
  TipEl *operator[](int n);
  
  template&lt;typename TipEl2&gt;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok,  GMatrica&lt;TipEl2&gt; m);
    
};

template &lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(){
    br_redova=0;
    br_kolona=0;
    matrica[br_redova][br_kolona]=0;
}

template&lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(int br_redova, int br_kolona, TipEl element):br_redova(br_redova), br_kolona(br_kolona){
   if(br_redova&lt;0 || br_redova&gt;4 || br_kolona&lt;0 || br_kolona&gt;4) throw std::logic_error("Ilegalan format matrice");
   
    for(int i=0; i&lt;br_redova; i++)
    for(int j=0; j&lt;br_kolona; j++)
    matrica[i][j]=element;
}

template&lt;typename TipEl&gt; template&lt; typename TipEl2&gt;
GMatrica&lt;TipEl&gt;::GMatrica(GMatrica&lt;TipEl2&gt;nova){
    for(int i=0; i&lt;nova.size(); i++)
    for(int j=0; j&lt;nova[i].size(); j++)
    matrica[i][j]=nova[i][j];
}

template&lt;typename TipEl&gt; template&lt; typename TipEl2&gt;
GMatrica&lt;TipEl&gt;::GMatrica(TipEl2 nova[4][4]){
    for(int i=0; i&lt;4; i++)
    for(int j=0; j&lt;4; j++)
    matrica[i][j]=nova[i][j];
}

template&lt;typename TipEl&gt;
GMatrica&lt;TipEl&gt;::GMatrica(std::vector&lt;std::vector&lt;TipEl&gt;&gt; vek){
       br_redova=vek.size();
    if(vek.size()&lt;0 || vek.size()&gt;4)throw std::logic_error("Ilegalan format matrice");
    else {
        for(int i=0; i&lt;vek.size(); i++){{
            br_kolona=vek[i].size();
    
        if(vek[i].size()&lt;0 || vek[i].size()&gt;4)throw std::logic_error("Ilegalan format matrice");
    }}}
    
    for(int i=0; i&lt;vek.size(); i++)
    for(int j=0; j&lt;vek[i].size(); j++)
    matrica[i][j]=vek[i][j];
}

template&lt;typename TipEl&gt;
 int GMatrica&lt;TipEl&gt;:: DajBrojRedova()const{
    return br_redova;
}

template&lt;typename TipEl&gt;
int GMatrica&lt;TipEl&gt;::DajBrojKolona()const{
    return br_kolona;
}

template&lt;typename TipEl2,typename TipEl3&gt;
auto operator+( GMatrica&lt;TipEl2&gt; m1 ,  GMatrica&lt;TipEl3&gt; m2)-&gt;GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt;{
       GMatrica&lt;decltype(m1.matrica[0][0]+m2.matrica[0][0])&gt; ret;
       ret.br_kolona=m1.br_kolona; ret.br_redova=m1.br_redova;
    if(m1.br_kolona!=m2.br_kolona || m1.br_redova!=m2.br_redova) throw std::domain_error("Nedozvoljena operacija");
    for(int i=0; i&lt;m1.br_redova; i++)
    for(int j=0; j&lt;m1.br_kolona; j++)
</font><a name="2"></a><font color="#0000FF"><a href="match75-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

    ret.matrica[i][j]=m1.matrica[i][j]+m2.matrica[i][j];
    return ret;
}

template&lt;typename TipEl2, typename TipEl3&gt;
auto operator-(GMatrica&lt;TipEl2&gt; m1,  GMatrica&lt;TipEl3&gt; m2)-&gt; GMatrica&lt;decltype(m1.matrica[0][0]-m2.matrica[0][0])&gt;{
     GMatrica&lt;decltype (m1.matrica[0][0]-m2.matrica[0][0])&gt;ret;
     ret.br_kolona=m1.br_kolona; ret.br_redova=m1.br_redova;
    if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona) throw std::domain_error("Nedozvoljena operacija");
    for(int i=0; i&lt;m1.br_redova; i++)
    for(int j=0; j&lt;m1.br_kolona; j++)
</font><a name="3"></a><font color="#00FFFF"><a href="match75-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

    ret.matrica[i][j]=m1.matrica[i][j]-m2.matrica[i][j];
    return ret;
}




template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl2&gt; operator *(int n, GMatrica&lt;TipEl2&gt; m){
    GMatrica&lt;TipEl2&gt; ret;
    ret.br_kolona=m.br_kolona; ret.br_redova=m.br_redova;
    for(int i=0; i&lt;m.br_redova; i++)
</font>    for(int j=0; j&lt;m.br_kolona; j++)
<a name="5"></a><font color="#FF0000"><a href="match75-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

    ret.matrica[i][j]=m.matrica[i][j]*n;
    return ret;
}

template &lt;typename TipEl2&gt;
  GMatrica&lt;TipEl2&gt; operator *( GMatrica&lt;TipEl2&gt; m, int n){
       GMatrica&lt;TipEl2&gt; ret;
    ret.br_kolona=m.br_kolona; ret.br_redova=m.br_redova;
    for(int i=0; i&lt;m.br_redova; i++)
</font>    for(int j=0; j&lt;m.br_kolona; j++)
<a name="6"></a><font color="#00FF00"><a href="match75-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    ret.matrica[i][j]=m.matrica[i][j]*n;
    return ret;
  }
  
 template&lt;typename TipEl2, typename TipEl3&gt;
 bool operator ==(GMatrica&lt;TipEl2&gt; m1, GMatrica&lt;TipEl3&gt; m2){
     if(m1.br_kolona != m2.br_kolona || m1.br_redova!=m2.br_redova) return false;
         for(int i=0; i&lt;m1.br_redova; i++){
</font>         for(int j=0; j&lt;m1.br_kolona; j++)
<a name="4"></a><font color="#FF00FF"><a href="match75-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

         if(m1.matrica[i][j]!=m2.matrica[i][j])return false;
         }
         return true;
 }
 
 template&lt;typename TipEl2 , typename TipEl3&gt;
 bool operator!=(GMatrica&lt;TipEl2&gt; m1, GMatrica&lt;TipEl3&gt;m2){
     if(m1.br_kolona!=m2.br_kolona || m1.br_redova!= m2.br_redova) return true;
     for(int i=0; i&lt;m1.br_redova; i++)
</font>     for(int j=0; j&lt;m1.br_kolona; j++)
<a name="1"></a><font color="#00FF00"><a href="match75-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_25.gif"/></a>

     if(m1.matrica[i][j]!=m2.matrica[i][j])return true;
     return false;
     
 }


template&lt;typename TipEl&gt; template&lt; typename TipEl2&gt;
GMatrica&lt;TipEl&gt;&amp;GMatrica&lt;TipEl&gt;::operator +=(GMatrica&lt;TipEl2&gt; m2){
    if(br_kolona!=m2.br_kolona || br_redova!=m2.br_redova) throw std::domain_error("Nedozvoljena operacija");
    for(int i=0; i&lt;m2.br_redova; i++)
    for(int j=0; j&lt;m2.br_kolona; j++)
    matrica[i][j]+=m2.matrica[i][j];
    return *this;
}

template&lt;typename TipEl&gt; template&lt;typename TipEl2&gt;
GMatrica&lt;TipEl&gt;&amp;GMatrica&lt;TipEl&gt;::operator -=(GMatrica&lt;TipEl2&gt;m2){
    if(br_kolona!=m2.br_kolona || br_redova!=m2.br_redova)throw std::domain_error("Nedozvoljena operacija");
    for(int i=0; i&lt;m2.br_redova; i++)
    for(int j=0; j&lt;m2.br_kolona; j++)
    matrica[i][j]-=m2.matrica[i][j];
    return *this;
}

template&lt;typename TipEl&gt; 
GMatrica&lt;TipEl&gt;&amp;GMatrica&lt;TipEl&gt;::operator *=(int n){
    for(int i=0; i&lt;br_redova; i++)
    for(int j=0; j&lt;br_kolona; j++)
    matrica[i][j]*=n;
    return *this;
}


template&lt;typename TipEl&gt;
TipEl &amp;GMatrica&lt;TipEl&gt;::operator()(int indeks1, int indeks2){
    if (indeks1&lt;1 || indeks2&lt;1 || indeks1&gt;4 || indeks2&gt;4) throw std::range_error("Nedozvoljen indeks");
    return matrica[indeks1-1][indeks2-1];
}

template&lt;typename TipEl&gt;
TipEl *GMatrica&lt;TipEl&gt;::operator[](int n){
    return (matrica[n]);
}




template&lt;typename TipEl2&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;tok,  GMatrica&lt;TipEl2&gt; m){
    for(int i=0; i&lt;m.br_redova; i++){
    for(int j=0; j&lt;m.br_kolona; j++)
    tok&lt;&lt;std::setw(6)&lt;&lt;m.matrica[i][j];
    tok&lt;&lt;std::endl;
    }
    return tok;
}



int main ()
{
   
    GMatrica&lt;int&gt; m1({{1, 2}, {3, 4}});
   GMatrica&lt;int&gt; m2({{1, 2}, {3, 4}});
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
   m1 += m2;
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
   m1 -= m2;
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
   m1 *= 2;
   std::cout &lt;&lt;  m1 &lt;&lt; std::endl;
	return 0;
</font>}</pre>
</body>
</html>
