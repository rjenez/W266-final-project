<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student2908.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3776.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;iomanip&gt;




<a name="0"></a><font color="#FF0000"><a href="match56-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_46.gif"/></a>

template &lt;typename tip&gt; class GMatrica{
  
    
  
    int realrou,realkol;
    tip elementi[4][4];
    public:
    GMatrica();
    GMatrica(int br_redova,int br_kolona,tip vrednost=0);
     /*    GMatrica(const GMatrica &lt;int&gt; &amp;matrica);*/
     GMatrica(const std::vector&lt;std::vector&lt;tip&gt;&gt; &amp;v);
     GMatrica (const std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt;  &amp;lista);
     void Ispisi () const; 
     tip DajBrojRedova () const { return realrou;}
     tip DajBrojKolona () const { return realkol;}
    /* template &lt;typename tip&gt;  friend auto  operator + (const GMatrica&lt;tip&gt; &amp;m1,const GMatrica&lt;tip&gt; &amp;m2)-&gt;decltype(m1.elementi[0][0]+m2.elementi[0][0]) ;*/
     /*template &lt;typename tip&gt; friend GMatrica&lt;tip&gt; operator -(const GMatrica&lt;tip&gt; &amp;m1,const GMatrica&lt;tip&gt; &amp;m2);*/
     
template&lt;typename T1, typename T2&gt; friend auto operator+(const GMatrica&lt;T1&gt;  &amp;a, const GMatrica &lt;T2&gt; &amp;b) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt; ;
template&lt;typename T1, typename T2&gt; friend auto operator-(const GMatrica&lt;T1&gt;  &amp;a, const GMatrica &lt;T2&gt; &amp;b) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt; ;
template&lt;typename T1, typename T2&gt; friend auto operator*(const GMatrica&lt;T1&gt;  &amp;a, const GMatrica &lt;T2&gt; &amp;b) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt; ;
template&lt;typename T1, typename T2&gt; friend auto operator*(const GMatrica&lt;T1&gt;  &amp;a,  T2 b) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt; ;
template&lt;typename T1, typename T2&gt; friend auto operator*(T2 b,const GMatrica&lt;T1&gt;  &amp;a  ) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt; ;
template &lt;typename T1&gt;  friend std::ostream &amp;operator &lt;&lt;  (std::ostream &amp;tok, const GMatrica&lt;T1&gt; &amp;a); 
template &lt;typename T1&gt;  friend std::istream &amp;operator &gt;&gt;  (std::istream &amp;tok,  GMatrica&lt;T1&gt; &amp;a); 
 GMatrica &amp;operator +=(const GMatrica&lt;tip&gt;  &amp;a);
 GMatrica &amp;operator -=(const GMatrica&lt;tip&gt;  &amp;a);
 GMatrica &amp;operator *=(tip b);
 GMatrica &amp;operator *=(const GMatrica&lt;tip&gt;  &amp;a);
 tip &amp;operator () (int indeks1,int indeks2){
    if(indeks1&lt;1 || indeks2&lt;1 ) throw std::range_error("Nedozvoljen indeks");
    return elementi[indeks1-1][indeks2-1];
}


tip operator () (int indeks1,int indeks2) const {
    if(indeks1&lt;1 || indeks2&lt;1 ) throw std::range_error("Neispravan indeks");
    return elementi[indeks1-1][indeks2-1];
}


tip* operator [] (int indeks1)   {/*ovaj ne diraj emire */
    if(indeks1&lt;1 ) throw std::range_error("Neispravan indeks");
    return elementi[indeks1];
}

/*tip &amp;operator [](int kolona,int red){ /*ovaj popravi 
     if(indeks1&lt;1 || indeks2&lt;1 ) throw std::range_error("Nedozvoljen indeks");
     return elementi[red][kolona];
    
}*/


 template &lt;typename z&gt; friend bool operator ==(const GMatrica&lt;z&gt;  &amp;a, const GMatrica &lt;z&gt; &amp;b);
 template &lt;typename z&gt; friend bool operator !=(const GMatrica&lt;z&gt;  &amp;a, const GMatrica &lt;z&gt; &amp;b);
 
 




     


     


    
};



template&lt;typename tip&gt;GMatrica&lt;tip&gt;::GMatrica(const std::initializer_list&lt;std::initializer_list&lt;tip&gt;&gt; &amp;lista){
         std::vector&lt;std::vector&lt;tip&gt;&gt; vrednosti;
        vrednosti.reserve(lista.size());
        for (auto const&amp; red : lista)
        {
            vrednosti.emplace_back(std::begin(red), std::end(red));
        }
        int brojredova=lista.size();
         int granica(0);
        for(int i=0;i&lt;brojredova-1;i++){
            if(vrednosti[i].size()==vrednosti[i+1].size()){granica++;}
        }
        if((brojredova&lt;0 || brojredova&gt;4 ) &amp;&amp; granica&gt;4) throw std::logic_error("Ilegalan format matrice");
           realrou=vrednosti.size();
           realkol=vrednosti[0].size();
        for(int i=0;i&lt;vrednosti.size();i++){
            for(int j=0;j&lt;vrednosti[i].size();j++){
                elementi[i][j]=vrednosti[i][j];
            }
        }
}
     
      
   template&lt;typename tip&gt; void GMatrica&lt;tip&gt;::Ispisi() const {
        for(int i=0;i&lt;realrou;i++){
            for(int j=0;j&lt;realkol;j++){
                std::cout&lt;&lt;elementi[i][j]&lt;&lt;"   ";
            }
            std::cout&lt;&lt;std::endl;
        }
    }

 /*template&lt;typename tip&gt; GMatrica&lt;tip&gt;::GMatrica ( const GMatrica &lt;int&gt; &amp;matrica) {
     realkol=matrica.realkol; realrou=matrica.realrou;
        for(int i=0;i&lt;matrica.realrou;i++){
            for(int j=0;j&lt;matrica.realkol;j++){
                elementi[i][j]=(int)matrica.elementi[i][j];
            }
        }
    }*/
    
template&lt;typename tip&gt;GMatrica&lt;tip&gt;::GMatrica(const std::vector&lt;std::vector&lt;tip&gt;&gt; &amp;v){
        int brojredova=v.size();
        int granica(0);
        for(int i=0;i&lt;brojredova-1;i++){
            if(v[i].size()==v[i+1].size()){granica++;}
        }
        if((brojredova&lt;0 || brojredova&gt;4 ) &amp;&amp; granica&gt;4) throw std::logic_error("Ilegalan format matrice");
        else{
        realkol=v[0].size();
        realrou=v.size();
        for(int i=0;i&lt;realrou;i++){
            for(int j=0;j&lt;realkol;j++){
                elementi[i][j]=v[i][j];
            }
        }
        }
}


 template&lt;typename tip&gt;GMatrica&lt;tip&gt;::GMatrica(int br_redova,int br_kolona,tip  vrednost){
  if(br_redova&lt;0 || br_redova&gt;4 || br_kolona&lt;0 || br_kolona&gt;4) throw std::logic_error("Ilegalan format matrice");
  else{
    realkol=br_kolona;
    realrou=br_redova;
  }
    for(int i=0;i&lt;realrou;i++){
        for(int j=0;j&lt;realkol;j++){
            elementi[i][j]=vrednost;
        }
    }
    
   
}

template&lt;typename tip&gt; GMatrica&lt;tip&gt;::GMatrica(){
    realkol=0; realrou=0;
    elementi[0][0]={};
}
 

template&lt;typename T1, typename T2&gt; auto operator+(const GMatrica&lt;T1&gt;  &amp;a, const GMatrica &lt;T2&gt; &amp;b) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt;{
    if(a.realrou != b.realrou || a.realkol != b.realkol) throw std::domain_error("Nedozvoljena operacija"); 
    using value_type = decltype(T1{} + T2{});
    GMatrica &lt;decltype(T1{} * T2{})&gt; result(a.realrou,a.realkol);
    for (int i = 0; i&lt; a.realrou; i++){
        for (int j = 0; j&lt; a.realkol; j++){
</font><a name="2"></a><font color="#0000FF"><a href="match56-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

          result.elementi[i][j] = a.elementi[i][j] + b.elementi[i][j]; 
        }
    }
    return result;
}

    
template&lt;typename T1, typename T2&gt; auto operator-(const GMatrica&lt;T1&gt;  &amp;a, const GMatrica &lt;T2&gt; &amp;b) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt;{
    if(a.realrou != b.realrou || a.realkol != b.realkol) throw std::domain_error("Nedozvoljena operacija"); 
    using value_type = decltype(T1{} + T2{});
    GMatrica &lt;decltype(T1{} * T2{})&gt; result(a.realrou,a.realkol);
    for (int i = 0; i&lt; a.realrou; i++){
        for (int j = 0; j&lt; a.realkol; j++){
</font>          result.elementi[i][j] = a.elementi[i][j] - b.elementi[i][j]; 
        }
    }
    return result;
}

<a name="1"></a><font color="#00FF00"><a href="match56-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_44.gif"/></a>

template&lt;typename T1, typename T2&gt; auto operator*(const GMatrica&lt;T1&gt;  &amp;a, const GMatrica &lt;T2&gt; &amp;b) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt;{
     if (a.realrou != b.realkol) throw std::domain_error("Nedozvoljena operacija"); 
    using value_type = decltype(T1{} + T2{});
    GMatrica&lt;decltype(T1{} * T2{})&gt; nova(a.realrou, b.realkol);
    for (int i = 0; i&lt; a.realrou; i++)
        for (int j = 0; j&lt; b.realkol; j++)
        {
            value_type sum = 0;
            for (int k = 0; k&lt; b.realkol; k++)    sum += a.elementi[i][k] * b.elementi[k][j];
            nova.elementi[i][j] = sum;
        }
    return nova;
}

template&lt;typename T1, typename T2&gt; auto operator*(const GMatrica&lt;T1&gt;  &amp;a, T2  b) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt;{
    using value_type = decltype(T1{} + T2{});
    GMatrica&lt;decltype(T1{} * T2{})&gt; nova(a.realrou, a.realkol);
    for (int i = 0; i&lt; a.realrou; i++){
        for (int j = 0; j&lt; a.realkol; j++){
            nova.elementi[i][j]=b*a.elementi[i][j];
        }
    }
    return nova;
}

template&lt;typename T1, typename T2&gt; auto operator*(T2  b,const GMatrica&lt;T1&gt;  &amp;a ) -&gt; GMatrica &lt;decltype(T1{} + T2{})&gt;{
    using value_type = decltype(T1{} + T2{});
    GMatrica&lt;decltype(T1{} * T2{})&gt; nova(a.realrou, a.realkol);
    for (int i = 0; i&lt; a.realrou; i++){
        for (int j = 0; j&lt; a.realkol; j++){
            nova.elementi[i][j]=b*a.elementi[i][j];
        }
    }
    return nova;
}

template &lt;typename TipEl&gt;    std::ostream  &amp;operator  &lt;&lt; (std::ostream &amp;tok,const GMatrica&lt;TipEl&gt; &amp;m){
     int sirina=tok.width();
     if(sirina&lt;6) sirina=6;
      for(int i = 0; i &lt; m.realrou; i++) {   
          for(int j = 0; j &lt; m.realkol; j++)  
            tok  &lt;&lt;std::setw(sirina)&lt;&lt; m.elementi[i][j];  
          tok&lt;&lt;std::endl;
      }
          return tok;
 }

  template&lt;typename t&gt;GMatrica&lt;t&gt;  &amp;GMatrica&lt;t&gt;::operator +=(const GMatrica&lt;t&gt; &amp;m){
      for(int i=0;i&lt;m.realrou;i++){
          for(int j=0;j&lt;m.realkol;j++){
              elementi[i][j]+=m.elementi[i][j];
          }
      }
      return *this;
  }
  
  template&lt;typename t&gt;GMatrica&lt;t&gt;  &amp;GMatrica&lt;t&gt;::operator -=(const GMatrica&lt;t&gt; &amp;m){
      for(int i=0;i&lt;m.realrou;i++){
          for(int j=0;j&lt;m.realkol;j++){
              elementi[i][j]-=m.elementi[i][j];
          }
      }
      return *this;
  }
  
  template&lt;typename t&gt;GMatrica&lt;t&gt; &amp;GMatrica&lt;t&gt;::operator*=(t b){
    for (int i = 0; i&lt; realrou; i++){
        for (int j = 0; j&lt; realkol; j++){
            elementi[i][j]*=b;
        }
    }
    return *this;
}

template&lt;typename t&gt;GMatrica&lt;t&gt;  &amp;GMatrica&lt;t&gt;::operator *=(const GMatrica&lt;t&gt; &amp;m){
    GMatrica nova=(*this)*m;
    (*this)=nova;
      return *this;
  }
  
 
/*template&lt;typename T&gt; T&amp; GMatrica&lt;T&gt;::operator()(int row, int col) {
  return [row-1][col-1];
}*/
template&lt;typename pit&gt; bool operator ==(const GMatrica&lt;pit&gt; &amp;a,const GMatrica&lt;pit&gt; &amp;b){
    int br(0);
    for(int i=0;i&lt;a.realrou;i++){
        for(int j=0;j&lt;a.realkol;j++){
            if(a.elementi[i][j]==b.elementi[i][j]) br++;
        }
    }
    if(br==(a.realrou*a.realkol)) return true;
    return false;
}

template&lt;typename pita&gt; bool operator !=(const GMatrica&lt;pita&gt; &amp;a,const GMatrica&lt;pita&gt; &amp;b){
    int br(0);
    for(int i=0;i&lt;a.realrou;i++){
        for(int j=0;j&lt;a.realkol;j++){
            if(a.elementi[i][j]==b.elementi[i][j]) br++;
        }
    }
    if(br!=(a.realrou*a.realkol)) return true;
    return false;
}

template &lt;typename TipEl&gt;    std::istream  &amp;operator  &gt;&gt; (std::istream &amp;tok, GMatrica&lt;TipEl&gt; &amp;m){
    char znak;
int i=0;
    tok&gt;&gt;std::ws;
int broj(0),g(0);
   tok&gt;&gt;znak;
    if(znak!='[') tok.setstate(std::ios::failbit);
   for(int j=0;j&lt;1000;j++){
       a:
    tok&gt;&gt;m.elementi[i][j]&gt;&gt;znak;
    if(znak==','){g++;}
    if(znak==';'){ i++; broj++;  j=0; goto a; }
     if(znak==']') break;
   }
    
   int t=g/(broj+1)+1;
   m.realkol=t; m.realrou=broj+1;
   return tok;
 }



int main (){
    try{
 GMatrica&lt;int&gt;a;
 std::cin&gt;&gt;a;
 std::cout&lt;&lt;a;
    }
    catch(std::logic_error e){
        std::cout&lt;&lt;e.what();
</font>    }
	return 0;
}</pre>
</body>
</html>
