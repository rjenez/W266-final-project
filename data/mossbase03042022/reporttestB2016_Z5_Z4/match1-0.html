<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3047.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3047.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match1-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt; 
#include &lt;iomanip&gt;

template&lt;typename _Ty&gt;
class GMatrica
{
    _Ty mat[4][4];
    int bk, br;
public:
    GMatrica();
    
    int DajBrojRedova()const
    {
        return br;
    }
    
    int DajBrojKolona()const
    {
        return bk;
    }
    
    GMatrica(int x, int y, _Ty el = _Ty {});
    
    template&lt;typename _Ty1&gt;
    GMatrica(const GMatrica&lt;_Ty1&gt;&amp;);
    
    template&lt;typename _Ty1&gt;
    GMatrica(const std::vector&lt;std::vector&lt;_Ty1&gt;&gt;&amp;);
    
    template&lt;typename _Ty1&gt;
    GMatrica(const _Ty1 n[4][4]);
    
    template&lt;typename _Ty1&gt;
    GMatrica(std::initializer_list&lt;std::initializer_list&lt;_Ty1&gt;&gt; lista);
    
    template&lt;typename _Ty1, typename _Ty2&gt;
    friend auto operator*=(GMatrica&lt;_Ty1&gt;&amp; g, const GMatrica&lt;_Ty2&gt;&amp; m) -&gt; GMatrica&lt;decltype(g[0][0] * m[0][0])&gt;;
    
    _Ty* operator[](int i)
    {
        return mat[i];
    }
    
    const _Ty* operator[](int i) const
    {
        return mat[i];
    }
    
    _Ty&amp; operator()(int r, int k)
    {
        if(r &lt; 1 || r &gt; br || k &lt; 1  || k&gt; bk)
            throw std::range_error("Nedozvoljen indeks");
        return mat[r -1][k - 1];
    }
    
    _Ty operator()(int r, int k) const
    {
        if(r &lt; 1 || r &gt; br || k &lt; 1  || k&gt; bk)
            throw std::range_error("Nedozvoljen indeks");
        return mat[r -1][k - 1];
    }
    
}; /// Kraj klase GMatrica


template&lt;typename _Ty1, typename _Ty2&gt;
auto operator+=(GMatrica&lt;_Ty1&gt;&amp; g, const GMatrica&lt;_Ty2&gt;&amp; m) -&gt; GMatrica&lt;decltype(g[0][0] + m[0][0])&gt;
{
    if(g.DajBrojKolona() != m.DajBrojKolona() || g.DajBrojRedova() != m.DajBrojRedova())
        throw std::domain_error("Nedozvoljena operacija");
    for(int i= 0; i &lt; g.DajBrojRedova(); ++i)
        for(int j = 0; j &lt; g.DajBrojKolona(); ++j)
            g[i][j] += m[i][j];
    return g;
}

template&lt;typename _Ty1, typename _Ty2&gt;
auto operator-=(GMatrica&lt;_Ty1&gt;&amp; g, const GMatrica&lt;_Ty2&gt;&amp; m) -&gt; GMatrica&lt;decltype(g[0][0] - m[0][0])&gt;
{
    if(g.DajBrojKolona() != m.DajBrojKolona() || g.DajBrojRedova() != m.DajBrojRedova())
        throw std::domain_error("Nedozvoljena operacija");
    for(int i= 0; i &lt; g.DajBrojRedova(); ++i)
        for(int j = 0; j &lt; g.DajBrojKolona(); ++j)
            g[i][j] -= m[i][j];
    return g;
}

template&lt;typename _Ty1, typename _Ty2&gt;
auto operator*=(GMatrica&lt;_Ty1&gt;&amp; g, const GMatrica&lt;_Ty2&gt;&amp; m) -&gt; GMatrica&lt;decltype(g[0][0] * m[0][0])&gt;
{
    if(g.DajBrojKolona() !=  m.DajBrojRedova())
        throw std::domain_error("Nedozvoljena operacija");
    auto p = g;
    g.bk = m.bk;
    for(int i= 0; i &lt; p.DajBrojRedova(); ++i)
    {
        for(int j = 0; j &lt; m.DajBrojKolona(); ++j)
        {
            _Ty1 s {};
            for(int k = 0; k &lt; p.DajBrojKolona(); ++k)
                s+= p[i][k] * m[k][j];
            g[i][j] = s;
        }
    }
    return g;
}

template&lt;typename _Ty1, typename _Ty2&gt;
auto operator*=(GMatrica&lt;_Ty1&gt;&amp; g, const _Ty2&amp; m) -&gt; GMatrica&lt;decltype(g[0][0] * m)&gt;
{
    for(int i= 0; i &lt; g.DajBrojRedova(); ++i)
        for(int j = 0; j &lt; g.DajBrojKolona(); ++j)
            g[i][j] *= m;
    return g;
}



template&lt;typename _Ty&gt;
GMatrica&lt;_Ty&gt;::GMatrica() : bk(0), br(0) {}

template&lt;typename _Ty&gt;
template&lt;typename _Ty1&gt;
GMatrica&lt;_Ty&gt;::GMatrica(const std::vector&lt;std::vector&lt;_Ty1&gt;&gt;&amp; vv)
{
    
    if(vv.size() == 0)
    {
        br = bk = 0;
        return;
    }
    if(vv.size() &gt; 4)
        throw std::logic_error("Ilegalan format matrice");
    for( int i = 1; i &lt; vv.size(); ++i)
        if(vv[i].size() != vv[0].size() &amp;&amp; vv[i].size() &gt; 4)
            throw std::logic_error("Ilegalan format matrice");
    br = vv.size();
    bk = vv[0].size();
    for(int i = 0; i &lt; br ; ++i)
        for(int j = 0; j &lt; bk; ++j)
            mat[i][j] = vv[i][j];
}

template&lt;typename _Ty&gt;
template&lt;typename _Ty1&gt;
GMatrica&lt;_Ty&gt;::GMatrica(const _Ty1 n[4][4]) : bk(4), br(4)
{
    for(int i = 0; i &lt; br ; ++i)
        for(int j = 0; j &lt; bk; ++j)
            mat[i][j] = n[i][j];
}

template&lt;typename _Ty&gt;
template&lt;typename _Ty1&gt;
GMatrica&lt;_Ty&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;_Ty1&gt;&gt; lista)
{
  br = lista.size();
  bk = lista.begin()-&gt;size();
  if(bk &gt; 4 || br &gt; 4)
    throw std::logic_error("Ilegalan format matrice");
  int r = 0, k = 0;
  for(auto i(lista.begin()); i != lista.end(); i++) {
    k = 0;
    for(auto j(i-&gt;begin()); j != (i-&gt;end()); j++) {
      if(bk != i-&gt;size())
        throw std::logic_error("Ilegalan format matrice");
      mat[r][k] = (*j);
      k++;
    }
    r++;
  }
}

template&lt;typename _Ty&gt;
GMatrica&lt;_Ty&gt;::GMatrica(int x, int y, _Ty el) : bk(x), br(y)
{
    if(x &lt; 1 || y &lt; 1 || x &gt; 4 || y &gt; 4)
        throw std::logic_error("Ilegalan format matrice");
    for(int i = 0; i &lt; br ; ++i)
        for(int j = 0; j &lt; bk; ++j)
            mat[i][j] = el;
}

template&lt;typename _Ty&gt;
template&lt;typename _Ty1&gt;
GMatrica&lt;_Ty&gt;::GMatrica(const GMatrica&lt;_Ty1&gt;&amp; m) : bk(m.DajBrojKolona()), br(m.DajBrojRedova())
{
    for(int i = 0; i &lt; br; ++i)
        for(int j = 0; j &lt; bk; ++j)
            mat[i][j] = m[i][j];
}

template&lt;typename _Ty1, typename _Ty2&gt;
auto operator+(const GMatrica&lt;_Ty1&gt;&amp; g, const GMatrica&lt;_Ty2&gt;&amp; m) -&gt; GMatrica&lt;decltype(g[0][0] + m[0][0])&gt;
{
   auto p = g;
   p+=m;
   return p;
}

template&lt;typename _Ty1, typename _Ty2&gt;
auto operator-(const GMatrica&lt;_Ty1&gt;&amp; g, const GMatrica&lt;_Ty2&gt;&amp; m) -&gt; GMatrica&lt;decltype(g[0][0] - m[0][0])&gt;
{
   auto p = g;
   p-=m;
   return p;
}

template&lt;typename _Ty1, typename _Ty2&gt;
auto operator*(const GMatrica&lt;_Ty1&gt;&amp; g, const GMatrica&lt;_Ty2&gt;&amp; m) -&gt; GMatrica&lt;decltype(g[0][0] * m[0][0])&gt;
{
   auto p = g;
   p*=m;
   return p;
}

template&lt;typename _Ty1, typename _Ty2&gt;
auto operator*(const GMatrica&lt;_Ty1&gt;&amp; g, const _Ty2&amp; m) -&gt; GMatrica&lt;decltype(g[0][0] * m)&gt;
{
    auto p =g;
    p*=m;
    return p;
}

template&lt;typename _Ty1, typename _Ty2&gt;
auto operator*(const _Ty2&amp; m, const GMatrica&lt;_Ty1&gt;&amp; g) -&gt; GMatrica&lt;decltype(m * g[0][0])&gt;
{
    auto p =g;
    p*=m;
    return p;
}

template&lt;typename _Ty1, typename _Ty2&gt;
bool operator==(const GMatrica&lt;_Ty1&gt;&amp; g, const GMatrica&lt;_Ty2&gt;&amp; m)
{
    if(g.DajBrojKolona() != m.DajBrojKolona() || g.DajBrojRedova() != m.DajBrojRedova())
        return false;
     for(int i = 0; i &lt; g.DajBrojRedova(); ++i)
        for(int j = 0; j &lt; g.DajBrojKolona(); ++j)
            if(g[i][j] != m[i][j])
                return false;
    return true;
}

template&lt;typename _Ty1, typename _Ty2&gt;
bool operator!=(const GMatrica&lt;_Ty1&gt;&amp; g, const GMatrica&lt;_Ty2&gt;&amp; m)
{
    return !(g == m);
}

template&lt;typename _Ty&gt;
std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, const GMatrica&lt;_Ty&gt;&amp; m)
{
  auto sirina = (os.width() &lt; 6 ? 6 : os.width());
  
  for(int i(0); i &lt; m.DajBrojRedova(); i++) {
    for(int j(0); j &lt; m.DajBrojKolona(); j++)
      os &lt;&lt; std::setw(sirina) &lt;&lt; m[i][j];
    os &lt;&lt; "\n";
  }
  return os;
}

template&lt;typename _Ty&gt;
std::istream&amp; operator &gt;&gt;(std::istream&amp; is, GMatrica&lt;_Ty&gt;&amp; m1)
{
  char c;
  is &gt;&gt; c;
  if(c != '[') {
    is.setstate(std::ios::failbit);
    return is;
  }
  _Ty broj; int red = 0;
  std::vector&lt;std::vector&lt;_Ty&gt;&gt; v;
  v.push_back(std::vector&lt;_Ty&gt;());
  while(c != ']' || c == EOF) {
    is &gt;&gt; broj &gt;&gt; c;
    v[red].push_back(broj);
    if(c == ';') {
      red++;
      v.push_back(std::vector&lt;_Ty&gt;());
    }
    if(!is.good())
      return is;
  }
  if(c != ']') {
    is.setstate(std::ios::failbit);
    return is;
  }
  GMatrica&lt;_Ty&gt; temp(v);
  m1 = temp;
  return is;

}

int main()
{
	try {
		//test transponiranja
		std::cout &lt;&lt; "Unesite matricu dimenzija 3x3:\n";
		GMatrica&lt;double&gt; m1 (3, 3);
		std::cin &gt;&gt; m1;
		GMatrica&lt;double&gt; test = {{m1 (1, 1), m1 (2, 1), m1 (3, 1) },
			{m1 (1, 2), m1 (2, 2), m1 (3, 2) },
			{m1 (1, 3), m1 (2, 3), m1 (3, 3) }
		};
		//test konstruktora sa inicijalizacionom listom
		GMatrica&lt;int&gt; m2 {{11, 22, 33}, {55, 66, 77}, {88, 99, 26}};
		std::cout.width (5);
		std::cout &lt;&lt; "Inicijalizaciona lista\n" &lt;&lt; std::setw (7) &lt;&lt;  m2 &lt;&lt; std::endl;
		test =  {{m1 (1, 1) + m2 (1, 1), m1 (1, 2) + m2 (1, 2), m1 (1, 3) + m2 (1, 3) },
			{m1 (2, 1) + m2 (2, 1), m1 (2, 2) + m2 (2, 2), m1 (2, 3) + m2 (2, 3) },
			{m1 (3, 1) + m2 (3, 1), m1 (3, 2) + m2 (3, 2), m1 (3, 3) + m2 (3, 3) }
		};
		//test operator +
		auto* pom = new GMatrica&lt;double&gt; (m1 + m2);
		if (*pom == test) {
			std::cout &lt;&lt; "Sabiranje uredu!\n";
			std::cout.width (5);
			std::cout &lt;&lt; *pom &lt;&lt; std::endl;
			delete pom;
		}
		test =  {{m1 (1, 1) - m2 (1, 1), m1 (1, 2) - m2 (1, 2), m1 (1, 3) - m2 (1, 3) },
			{m1 (2, 1) - m2 (2, 1), m1 (2, 2) - m2 (2, 2), m1 (2, 3) - m2 (2, 3) },
			{m1 (3, 1) - m2 (3, 1), m1 (3, 2) - m2 (3, 2), m1 (3, 3) - m2 (3, 3) }
		};
		//test operatora -
		pom = new GMatrica&lt;double&gt; (m1 - m2);
		if (*pom == test) {
			std::cout &lt;&lt; "Oduzimanje uredu!\n";
			std::cout.width (5);
			std::cout &lt;&lt; *pom &lt;&lt; std::endl;
			delete pom;
		}
		//test operatora * i GMatrica*=GMatrica
		GMatrica&lt;int&gt; aaaa {{1, 2}, {3, 4}};
		GMatrica&lt;int&gt; bbbb {{1, 1}, {2, 2}};
		auto* oo = new GMatrica&lt;int&gt; (aaaa * bbbb);
		test = {{5, 5}, {11, 11}};
		aaaa *= bbbb;
		if (test == *oo &amp;&amp; test == aaaa) {
			std::cout &lt;&lt; "Test operatora * i GMatrica*=GMatrica radii\n";
			std::cout &lt;&lt; std::setw (10) &lt;&lt; std::setprecision (3) &lt;&lt; *oo &lt;&lt; std::endl;
			std::cout &lt;&lt; std::setw (10) &lt;&lt; std::setprecision (3) &lt;&lt; aaaa &lt;&lt; std::endl;
			delete oo;
		}
		//test ctor koji inicijalizuje matricu matricom drugog tipa
		GMatrica&lt;double&gt; m3 (m2);
		if (m3 == m2)
			std::cout &lt;&lt; "Ctor koji prima matricu drugacijeg tipa i inicijalizuje matricu tom proslijedjenom matricom! RADIII!\n\n";
		//test operatora +=
		test =  {{m1 (1, 1) + m3 (1, 1), m1 (1, 2) + m3 (1, 2), m1 (1, 3) + m3 (1, 3) },
			{m1 (2, 1) + m3 (2, 1), m1 (2, 2) + m3 (2, 2), m1 (2, 3) + m3 (2, 3) },
			{m1 (3, 1) + m3 (3, 1), m1 (3, 2) + m3 (3, 2), m1 (3, 3) + m3 (3, 3) }
		};
		m3 += m1;
		if (m3 == test) {
			std::cout &lt;&lt; "Operator += radii!\n";
			std::cout.width (5);
			std::cout &lt;&lt; m3;
		}
		test =  {{m2 (1, 1) - m1 (1, 1), m2 (1, 2) - m1 (1, 2), m2 (1, 3) - m1 (1, 3) },
			{m2 (2, 1) - m1 (2, 1), m2 (2, 2) - m1 (2, 2), m2 (2, 3) - m1 (2, 3) },
			{m2 (3, 1) - m1 (3, 1), m2 (3, 2) - m1 (3, 2), m2 (3, 3) - m1 (3, 3) }
		};
		//test operatora -=
		m2 -= m1;
		if (m2 == test) {
			std::cout &lt;&lt; "Operator -= radii!\n";
			std::cout.width (5);
			std::cout &lt;&lt; m2;
		}
		//test konmstruktora koji prima vektor vektora i inicijalizuje matricu njime
		std::vector&lt;std::vector&lt;int&gt;&gt; vv (3);
		for (int i {0}; i &lt; 3; i++)
			vv[i].resize (3);
		for (int i {0}; i &lt; int (vv.size() ); i++)
			for (int j {0}; j &lt; int (vv[i].size() ); j++)
				vv[i][j] = i * 2.;
		GMatrica&lt;int&gt;F (vv);
		bool isti (true);
		for (int i {0}; i &lt; int (vv.size() ); i++)
			for (int j {0}; j &lt; int (vv[i].size() ); j++)
				if (F[i][j] != vv[i][j]) {
					isti = false;
					break;
				}
		if (isti) {
			//test const operatora []
			std::cout &lt;&lt; "Konstruktor vektor vektora u matricu radii\n";
			const auto gg (F);
			for (int i {0}; i &lt; gg.DajBrojRedova(); i++) {
				for (int j {0}; j &lt; gg.DajBrojKolona(); j++)
					std::cout &lt;&lt; std::setprecision (5) &lt;&lt; std::setw (8) &lt;&lt; gg[i][j] &lt;&lt; ' ';
				std::cout &lt;&lt; std::endl;
			}
		}
		//test operator Matrica*=broj
		test =  {{ - m1 (1, 1), - m1 (1, 2), - m1 (1, 3) },
			{ - m1 (2, 1), - m1 (2, 2), - m1 (2, 3) },
			{ - m1 (3, 1), - m1 (3, 2), - m1 (3, 3) }
		};
		m1 *= -1.;
		if (m1 == test) {
			std::cout &lt;&lt; "Operator matrica*=broj radii!\n";
			std::cout.width (5);
			std::cout &lt;&lt; m1 &lt;&lt; std::endl;
		}
		//test operatora Matrica * broj
		test =  {{5 * m1 (1, 1) , 5 * m1 (1, 2), 5 * m1 (1, 3) },
			{ 5 * m1 (2, 1), 5 * m1 (2, 2), 5 * m1 (2, 3) },
			{ 5 * m1 (3, 1), 5 * m1 (3, 2), 5 * m1 (3, 3) }
		};
		pom = new GMatrica&lt;double&gt; (m1 * 5);
		if (*pom == test) {
			std::cout &lt;&lt; "Operator matrica * broj radii \n";
			std::cout.width (5);
			std::cout &lt;&lt; *pom &lt;&lt; std::endl;
			delete pom;
		}
		//test operatora broj * Matrica
		pom = new GMatrica&lt;double&gt; (5 * m1);
		if (*pom == test) {
			std::cout &lt;&lt; "Operator broj * matrica radii \n";
			std::cout.width (5);
			std::cout &lt;&lt; *pom &lt;&lt; std::endl;
			delete pom;
		}
		//test opratora ==   !=   !
		GMatrica&lt;int&gt; g(2, 2);
		GMatrica&lt;int&gt; h;
		if (g == h)
			std::cout &lt;&lt; "ISTE" &lt;&lt; std::endl;
		else
			std::cout &lt;&lt; "NISU ISTE" &lt;&lt; std::endl;
		if (g != h)
			std::cout &lt;&lt; "RAZLICITE" &lt;&lt; std::endl;
		else
			std::cout &lt;&lt; "ISTE" &lt;&lt; std::endl;
		
		//test operatora () const i ne const
		g (1, 1) = 5;
		g (1, 2) = 6;
		g (2, 1) = 56;
		g (2, 2) = 15;
		test =  {{5 , 6,}, {56, 15} };
		if (test == g) {
			std::cout &lt;&lt; "operator () const i ne const radii\n\n";
			const auto hh (g);
			for (int i {1}; i &lt;= hh.DajBrojRedova(); i++) {
				for (int j {1}; j &lt;= hh.DajBrojKolona(); j++)
					std::cout &lt;&lt; hh (i, j) &lt;&lt; "   ";
				std::cout &lt;&lt; std::endl;
			}
		}
		//test operatora [] ne const
		h[0][0] = 11; h[0][1] = 1; h[0][2] = 2; h[0][3] = 3;
		h[1][0] = 9; h[1][1] = 6; h[1][2] = 7; h[1][3] = 6;
		test =  {{11 , 1, 2, 3}, {9, 6, 7, 6} };
		if (test == h)
			std::cout &lt;&lt; "operator [] ne const radii\n\n";
		std::cout.width (5);
		std::cout &lt;&lt; h &lt;&lt; std::endl;
		//test jos jednog ctora
		GMatrica&lt;double&gt; u (g);
		GMatrica&lt;int&gt; o ({{1, 1}, {2, 2}});
		test =  {{1, 1}, {2, 2}};
		if (test == o)
			std::cout &lt;&lt; "konstruktor koji prima inicijalizacionu list u pretvara u vektor i poziva ctor sa vektorom vektora! Radii\n";
	} catch (std::range_error r) {
		std::cout &lt;&lt; r.what();
	} catch (std::domain_error e) {
		std::cout &lt;&lt; e.what();
	}catch (std::logic_error e) {
		std::cout &lt;&lt; e.what();
	}catch (...) {
		std::cout &lt;&lt; "Doslo je do bacanja izuzetka";
</font>	}
}
</pre>
</body>
</html>
