<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student3171.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student5263.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
using std::cout;
using std::cin;
using std::endl;
using std::logic_error;
using std::domain_error;
using std::initializer_list;
template&lt;typename Tip&gt;
class GMatrica{
    Tip matrica[4][4];
    int br_redova;
    int br_kolona;
    public:
    GMatrica&lt;Tip&gt;() : br_redova(0), br_kolona(0){};
    GMatrica&lt;Tip&gt;(int redovi, int kolone, Tip poc_vrijednost=Tip());
    template &lt;typename DrugiTip&gt;
    GMatrica&lt;Tip&gt; ( GMatrica&lt;DrugiTip&gt; &amp;m);
    GMatrica&lt;Tip&gt; (Tip niz [4][4]);
    GMatrica&lt;Tip&gt; (std::vector&lt;std::vector&lt;Tip&gt;&gt; v);
    GMatrica&lt;Tip&gt; (std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; lista);
    int DajBrojRedova () const {return br_redova;};
    int DajBrojKolona () const {return br_kolona;};
    template &lt;typename Tip1, typename NoviTip&gt;
    friend auto operator +( const GMatrica&lt;Tip1&gt; &amp;mat1, const GMatrica&lt;NoviTip&gt; &amp;mat2)-&gt; GMatrica&lt;decltype(Tip1()+NoviTip())&gt;;
    template &lt;typename Tip1, typename NoviTip&gt;
    friend auto operator -( const GMatrica&lt;Tip1&gt; &amp;mat1, const GMatrica&lt;NoviTip&gt; &amp;mat2)-&gt; GMatrica&lt;decltype(Tip1()+NoviTip())&gt;;
    template &lt;typename Tip1, typename NoviTip&gt;
    friend auto operator *( const GMatrica&lt;Tip1&gt; &amp;mat1, const GMatrica&lt;NoviTip&gt; &amp;mat2)-&gt; GMatrica&lt;decltype(Tip1()+NoviTip())&gt;;
<a name="3"></a><font color="#00FFFF"><a href="match770-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    template &lt;typename NoviTip, typename TipBroja&gt;
    friend GMatrica&lt;NoviTip&gt; operator *(const GMatrica&lt;NoviTip&gt; &amp;mat1, TipBroja broj);
    template &lt;typename TipBroja,typename NoviTip&gt;
    friend GMatrica&lt;NoviTip&gt; operator *(TipBroja broj, const GMatrica&lt;NoviTip&gt; &amp;mat1);
    GMatrica&lt;Tip&gt; operator +=(const GMatrica &amp;mat2);
</font>    GMatrica&lt;Tip&gt; operator -=(const GMatrica &amp;mat2);
    GMatrica&lt;Tip&gt; operator *=(const GMatrica &amp;mat2);
    template &lt;typename NoviTip&gt;
    GMatrica&lt;Tip&gt; operator +=(NoviTip broj);
    template &lt;typename NoviTip&gt;
    GMatrica&lt;Tip&gt; operator -=(NoviTip broj);
    template &lt;typename NoviTip&gt;
    GMatrica&lt;Tip&gt; operator *=(NoviTip broj);
<a name="5"></a><font color="#FF0000"><a href="match770-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    template &lt;typename NoviTip&gt;
    friend bool operator ==(const GMatrica&lt;NoviTip&gt; &amp;mat1, const GMatrica&lt;NoviTip&gt; &amp;mat2);
    template &lt;typename NoviTip&gt;
    friend bool operator !=(const GMatrica&lt;NoviTip&gt; &amp;mat1, const GMatrica&lt;NoviTip&gt; &amp;mat2);
</font>    Tip&amp; operator () (int red, int kolona) ;
    Tip* operator [] (int index) ;
    template&lt;typename NoviTip&gt;
    friend std::ostream&amp; operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;NoviTip&gt; &amp;mat);
    template&lt;typename NoviTip&gt;
    friend std::istream&amp; operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;NoviTip&gt; &amp;mat);
};
template &lt;typename Tip1, typename Tip2&gt;
auto operator +(const GMatrica&lt;Tip1&gt; &amp;mat1, const GMatrica&lt;Tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(Tip1()+Tip2())&gt;
{
    if((mat1.br_redova != mat2.br_redova) || (mat1.br_kolona != mat2.br_kolona)) throw domain_error ("Nedozvoljena operacija");
    GMatrica&lt;decltype(Tip1()+Tip2())&gt; mat3 (mat1.br_redova,mat1.br_kolona);
    for(int i=0;i&lt;mat1.br_redova;i++)
            for(int j=0;j&lt;mat1.br_kolona;j++)
                mat3.matrica[i][j]=mat1.matrica[i][j]+mat2.matrica[i][j];
    return mat3;
}
template &lt;typename Tip1, typename Tip2&gt;
auto operator -(const GMatrica&lt;Tip1&gt; &amp;mat1, const GMatrica&lt;Tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(Tip1()+Tip2())&gt;
{
<a name="6"></a><font color="#00FF00"><a href="match770-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    if((mat1.br_redova != mat2.br_redova) || (mat1.br_kolona != mat2.br_kolona)) throw domain_error ("Nedozvoljena operacija");
    GMatrica&lt;Tip1&gt; mat3 (mat1.br_redova,mat1.br_kolona);
    for(int i=0;i&lt;mat1.br_redova;i++)
</font>            for(int j=0;j&lt;mat1.br_kolona;j++)
                mat3.matrica[i][j]=mat1.matrica[i][j]-mat2.matrica[i][j];
    return mat3;
}
template &lt;typename Tip1, typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip1&gt; &amp;mat1, const GMatrica&lt;Tip2&gt; &amp;mat2)-&gt;GMatrica&lt;decltype(Tip1()+Tip2())&gt;
{
<a name="4"></a><font color="#FF00FF"><a href="match770-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    if((mat1.br_kolona != mat2.br_redova)) throw domain_error ("Nedozvoljena operacija");
    GMatrica&lt;Tip1&gt; mat3 (mat1.br_redova,mat2.br_kolona);
    for(int i=0;i&lt;mat1.br_redova;i++)
            for(int j=0;j&lt;mat2.br_kolona;j++)
                for(int k=0;k&lt;mat1.br_kolona;k++)
</font><a name="1"></a><font color="#00FF00"><a href="match770-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

                mat3.matrica[i][j]+=(mat1.matrica[i][k]*mat2.matrica[k][j]);
    return mat3;
}
template &lt;typename Tip1, typename Tip2&gt;
GMatrica&lt;Tip1&gt; operator *(const GMatrica&lt;Tip1&gt; &amp;mat1, Tip2 broj){
    GMatrica&lt;Tip1&gt; mat3 (mat1.br_redova,mat1.br_kolona);
    for(int i=0;i&lt;mat1.br_redova;i++)
            for(int j=0;j&lt;mat1.br_kolona;j++)
</font><a name="2"></a><font color="#0000FF"><a href="match770-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

                mat3.matrica[i][j]=mat1.matrica[i][j]*broj;
    return mat3;
}
template &lt;typename Tip2, typename Tip1&gt;
GMatrica&lt;Tip1&gt; operator *(Tip2 broj, const GMatrica&lt;Tip1&gt; &amp;mat1){
    GMatrica&lt;Tip1&gt; mat3 (mat1.br_redova,mat1.br_kolona);
    for(int i=0;i&lt;mat1.br_redova;i++)
</font>            for(int j=0;j&lt;mat1.br_kolona;j++)
<a name="9"></a><font color="#FF00FF"><a href="match770-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

                mat3.matrica[i][j]=mat1.matrica[i][j]*broj;
    return mat3;
}
template &lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt; GMatrica&lt;Tip1&gt;:: operator +=(const GMatrica&lt;Tip1&gt; &amp;mat2){
</font>if((br_redova != mat2.br_redova) || (br_kolona != mat2.br_kolona)) throw domain_error ("Nedozvoljena operacija");
    for(int i=0;i&lt;br_redova;i++)
        for(int j=0;j&lt;br_kolona;j++)
            matrica[i][j]+=mat2.matrica[i][j];
    return *this;
}
template &lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt; GMatrica&lt;Tip1&gt;:: operator -=(const GMatrica&lt;Tip1&gt; &amp;mat2){
    if((br_redova != mat2.br_redova) || (br_kolona != mat2.br_kolona)) throw domain_error ("Nedozvoljena operacija");
    for(int i=0;i&lt;br_redova;i++)
        for(int j=0;j&lt;br_kolona;j++)
            matrica[i][j]-=mat2.matrica[i][j];
<a name="0"></a><font color="#FF0000"><a href="match770-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    return *this;
}
template &lt;typename Tip1&gt;
GMatrica&lt;Tip1&gt; GMatrica&lt;Tip1&gt;:: operator *=(const GMatrica&lt;Tip1&gt; &amp;mat2){
    if((br_kolona != mat2.br_redova)) throw domain_error ("Nedozvoljena operacija");
    GMatrica&lt;Tip1&gt; mat3(br_redova,mat2.br_kolona);
    for(int i=0;i&lt;br_redova;i++)
            for(int j=0;j&lt;mat2.br_kolona;j++){
                for(int k=0;k&lt;br_kolona;k++)
</font><a name="8"></a><font color="#00FFFF"><a href="match770-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

                mat3.matrica[i][j]+=(matrica[i][k]*mat2.matrica[k][j]);
</font>            }
    *this=mat3;
    return *this;
}
<a name="10"></a><font color="#FF0000"><a href="match770-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

template &lt;typename Tip1&gt;
bool operator == (const GMatrica&lt;Tip1&gt; &amp;mat1, const GMatrica&lt;Tip1&gt; &amp;mat2){
    if((mat1.br_redova != mat2.br_redova) || (mat1.br_kolona != mat2.br_kolona)) return false;
</font>    for(int i=0;i&lt;mat1.br_redova;i++){
        bool ima_razlicit(false);
        for(int j=0;j&lt;mat1.br_kolona;j++){
            if(mat1.matrica[i][j]!=mat2.matrica[i][j]) {ima_razlicit=true; break;}
        }
<a name="11"></a><font color="#00FF00"><a href="match770-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        if(ima_razlicit) return false;
    }
    return true;
}
template &lt;typename Tip1&gt;
bool operator != (const GMatrica&lt;Tip1&gt; &amp;mat1, const GMatrica&lt;Tip1&gt; &amp;mat2){
</font>    return !(mat1==mat2);
}
template&lt;typename Tip1&gt;
std::ostream&amp; operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip1&gt; &amp;mat){
    int sirina(tok.width());
    if(tok.width()&lt;6) sirina=6;
    for(int i=0;i&lt;mat.br_redova;i++){
        for(int j=0;j&lt;mat.br_kolona;j++)
            tok&lt;&lt;std::setw(sirina)&lt;&lt;mat.matrica[i][j];
            tok&lt;&lt;endl;
    }
    return tok;
}
template&lt;typename Tip1&gt;
std::istream&amp; operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;mat){
    char znak;
    int brojredova(0),brojclanova(0);
    std::vector&lt;Tip1&gt; v ;
    cout&lt;&lt;"Unesi: ";
    tok&gt;&gt;znak;
    if(tok.peek()!='[') tok.setstate(std::ios::failbit);
    do{
        tok&gt;&gt;znak;
        if(tok.peek()&gt;='0' &amp;&amp; tok.peek()&lt;='9') v.push_back(znak);
        else if (tok.peek()==',') {tok&gt;&gt;znak;continue;}
        else if(tok.peek()==';') {tok&gt;&gt;znak;brojredova++;}
        else if(tok.peek()==']') {tok&gt;&gt;znak;break;}
    }while (1);
    for(Tip1 x : v) cout&lt;&lt;x&lt;&lt;" ";
/*    for(int i=0;i&lt;mat.br_redova;i++){
        for(int j=0;j&lt;mat.br_kolona;j++){
            tok &gt;&gt; mat.matrica[i][j];
    }
    }*/
    return tok;
}
template &lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int redovi, int kolone, Tip poc_vrijednost){
        if(redovi &lt;0 || redovi&gt;4 || kolone&lt;0 || kolone&gt;4) throw logic_error ("Ilegalan format matrice");
        br_kolona=kolone;br_redova=redovi;
        for(int i=0;i&lt;redovi;i++)
            for(int j=0;j&lt;kolone;j++)
                matrica[i][j]=poc_vrijednost;
}
template &lt;typename Tip&gt;
template &lt;typename Tip1&gt;
GMatrica&lt;Tip&gt;::GMatrica( GMatrica&lt;Tip1&gt; &amp;m){
    br_kolona=m.DajBrojRedova();br_redova=m.DajBrojKolona();
    for(int i=0;i&lt;br_redova;i++)
        for(int j=0;j&lt;br_kolona;j++)
        matrica[i][j]=m[i][j];
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica (std::vector&lt;std::vector&lt;Tip&gt;&gt; v){
        if(v.size()&gt;4) throw logic_error ("Ilegalan format matrice");
        for(int i=0;i&lt;br_redova;i++)
            if(v[i].size()!=v[0].size()) throw logic_error ("Ilegalan format matrice");
        br_redova=v.size();
        br_kolona=v[0].size();
        for(int i=0;i&lt;br_redova;i++)
            for(int j=0;j&lt;br_kolona;j++)
            matrica[i][j]=v[i][j];
    }
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica (Tip niz [4][4]) {
        br_kolona=4;br_redova=4;
        for(int i=0;i&lt;br_redova;i++)
            for(int j=0;j&lt;br_kolona;j++)
            matrica[i][j]=niz[i][j];
    }
template &lt;typename Tip&gt;
Tip&amp; GMatrica&lt;Tip&gt; :: operator () (int red, int kolona) {
    if(red&lt;0 || kolona&lt;0 || red&gt;br_redova || kolona&gt;br_kolona) throw std::range_error ("Nedozvoljen indeks");
    return matrica[red-1][kolona-1];
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::initializer_list&lt;Tip&gt;&gt; lista){
        if(lista.size()&gt;4) throw logic_error ("Ilegalan format matrice");
        for(auto it(lista.begin());it!=lista.end();it++){
            if(it-&gt;size()!=lista.begin()-&gt;size()) throw logic_error ("Ilegalan format matrice");
        }
        br_redova=lista.size();
        br_kolona=lista.begin()-&gt;size();
        int i(0);
        for(auto it(lista.begin());it!=lista.end();it++){
            int j(0);
            for(auto it1(it-&gt;begin());it1!=it-&gt;end();it1++){
                matrica[i][j]=*it1;
                j++;
            }
            i++;
        }
    }
template &lt;typename Tip&gt;
Tip* GMatrica&lt;Tip&gt; :: operator [] (int index)  {
    return matrica[index];
}
template &lt;typename Tip&gt;
template &lt;typename NoviTip&gt;
GMatrica&lt;Tip&gt; GMatrica&lt;Tip&gt;::operator +=(NoviTip broj){
    for(int i=0;i&lt;br_redova;i++){
        for(int j=0;j&lt;br_kolona;j++)
        matrica[i][j]+=broj;
    }
    return *this;
}
template &lt;typename Tip&gt;
template &lt; typename NoviTip&gt;
GMatrica&lt;Tip&gt; GMatrica&lt;Tip&gt;::operator -=(NoviTip broj){
    for(int i=0;i&lt;br_redova;i++){
        for(int j=0;j&lt;br_kolona;j++)
        matrica[i][j]-=broj;
    }
    return *this;
}
template &lt;typename Tip&gt;
template &lt;typename NoviTip&gt;
<a name="7"></a><font color="#0000FF"><a href="match770-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

GMatrica&lt;Tip&gt; GMatrica&lt;Tip&gt;::operator *=(NoviTip broj){
        for(int i=0;i&lt;br_redova;i++){
            for(int j=0;j&lt;br_kolona;j++)
            matrica[i][j]*=broj;
</font>        }
    return *this;
}
int main ()
{
    GMatrica&lt;int&gt; m1;
    cin&gt;&gt;m1;
	return 0;
}</pre>
</body>
</html>
