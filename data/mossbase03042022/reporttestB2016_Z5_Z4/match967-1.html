<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student2675.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z4/student1477.cpp<p></p><pre>
/B16/17 (ZadaÄ‡a 5, Zadatak 4)
//Autotestovi by Ivona Ivkovic (mail: iivkovic2@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

template &lt;typename Tip&gt;
class GMatrica
{
    Tip elementi[4][4];
    int broj_redova, broj_kolona;
public:
    GMatrica() ;
    GMatrica(int broj_redova, int broj_kolona, Tip x=Tip());
    template &lt;typename Tip1&gt;
    GMatrica(const GMatrica&lt;Tip1&gt;&amp;m);
    template &lt;typename Tip1&gt;
    GMatrica(Tip1 niz[4][4]);
    GMatrica(const std::vector&lt;std::vector&lt;Tip&gt;&gt; &amp;v);
<a name="9"></a><font color="#FF00FF"><a href="match967-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    GMatrica( std::initializer_list&lt;std::vector&lt;Tip&gt;&gt; m);

    int DajBrojRedova()const {
        return broj_redova;
    }
    int DajBrojKolona()const {
        return broj_kolona;
    }
    template&lt;typename Tip1&gt;
</font>    friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok,const GMatrica&lt;Tip1&gt; &amp;m);
<a name="0"></a><font color="#FF0000"><a href="match967-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] + m2.elementi[0][0]) &gt;;
    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] - m2.elementi[0][0]) &gt;;
</font><a name="10"></a><font color="#FF0000"><a href="match967-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] * m2.elementi[0][0]) &gt;;
</font><a name="7"></a><font color="#0000FF"><a href="match967-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, Tip2 x)-&gt;GMatrica &lt; decltype(m.elementi[0][0] * x) &gt;;
</font><a name="4"></a><font color="#FF00FF"><a href="match967-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator *(Tip2 x, const GMatrica&lt;Tip1&gt; &amp;m)-&gt;GMatrica &lt; decltype(m.elementi[0][0] * x) &gt;;
</font>    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator +=(GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] + m2.elementi[0][0]) &gt;;
    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator -=(GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] - m2.elementi[0][0]) &gt; ;
    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator *=(GMatrica&lt;Tip1&gt; &amp;m1, Tip2 x)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] * x) &gt;;
    template &lt;typename Tip1, typename Tip2&gt;
    friend auto operator *=(GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] * m2.elementi[0][0]) &gt; ;
<a name="1"></a><font color="#00FF00"><a href="match967-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    template &lt;typename Tip1, typename Tip2&gt;
    friend bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
    template &lt;typename Tip1, typename Tip2&gt;
    friend bool operator!= (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2);
</font>    Tip operator ()(int broj_redova, int broj_kolona) const;
    Tip &amp;operator ()(int broj_redova, int broj_kolona);
    Tip* &amp;operator [](int broj_redova)const;
    Tip* operator [](int broj_redova);
    template&lt;typename Tip1&gt;
    friend std::istream &amp;operator &gt;&gt;(std::istream &amp;tok, GMatrica&lt;Tip1&gt; &amp;m);
};
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica()
{
    broj_redova=0;
<a name="11"></a><font color="#00FF00"><a href="match967-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    broj_kolona=0;
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(int broj_redova, int broj_kolona, Tip x)
{
    if(broj_redova&lt;0 || broj_redova&gt;4 ||broj_kolona&gt;4 || broj_kolona&lt;0) throw std::logic_error("Ilegalan format matrice");
</font>    GMatrica::broj_kolona=broj_kolona;
    GMatrica::broj_redova=broj_redova;
    for(int i=0; i&lt;broj_redova; i++) {
        for(int j=0; j&lt;broj_kolona; j++) {
            elementi[i][j]=x;
        }
    }

}
template&lt;typename Tip&gt;template&lt;typename Tip1&gt; GMatrica&lt;Tip&gt;::GMatrica(const GMatrica&lt;Tip1&gt;&amp;m)
{
    if(m.broj_redova&lt;0 || m.broj_kolona&lt;0 || m.broj_redova&gt;4 || m.broj_kolona&gt;4) throw std::logic_error("Ilegalan format matrica");
    GMatrica::broj_kolona=m.broj_kolona;
    GMatrica::broj_redova=m.broj_redova;
    for(int i=0; i&lt;broj_redova; i++) {
        for(int j=0; j&lt;broj_kolona; j++) {
            elementi[i][j]=m.elementi[i][j];
        }
    }
}
template&lt;typename Tip&gt;template&lt;typename Tip1&gt; GMatrica&lt;Tip&gt;::GMatrica(Tip1 niz[4][4])
{
    GMatrica::broj_kolona=4;
<a name="12"></a><font color="#0000FF"><a href="match967-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    GMatrica::broj_redova=4;
    for(int i=0; i&lt;4; i++) {
        for(int j=0; j&lt;4; j++) {
            elementi[i][j]=niz[i][j];
</font>        }
    }
}

template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(const std::vector&lt;std::vector&lt;Tip&gt;&gt; &amp;v)
{
    if(v.size()&lt;0 || v[0].size()&lt;0 || v.size()&gt;4|| v[0].size()&gt;4) throw std::logic_error("Ilegalan format matrice");
    for(int i=0; i&lt;v.size(); i++) {
        for(int j=0; j&lt;v.size(); j++) {
            if(v[i].size()!=v[j].size()) throw std::logic_error("Ilegalan format matrice");
        }
    }
    for(int i=0; i&lt;v.size(); i++) {
        for(int j=0; j&lt;v[0].size(); j++) {
            elementi[i][j]=v[i][j];
        }
    }
    GMatrica::broj_redova=v.size();
    GMatrica::broj_kolona=v[0].size();
}
template&lt;typename Tip&gt;
GMatrica&lt;Tip&gt;::GMatrica(std::initializer_list&lt;std::vector&lt;Tip&gt;&gt; lista)
{
    GMatrica::broj_kolona=lista.begin()-&gt;size();
    GMatrica::broj_redova=lista.size();
    auto it=lista.begin();
    for(int i=0; i&lt;lista.size(); i++) {
        int k(0);
        for(int j=0; j&lt;lista.begin()-&gt;size(); j++) {
            elementi[i][j]=(*it)[k];
            k++;
        }
        it++;
    }

}
template&lt;typename Tip&gt;
std::ostream &amp;operator &lt;&lt;(std::ostream &amp;tok, const GMatrica&lt;Tip&gt;&amp;m)
{
    std::streamsize n;
    if(tok.width()&lt;6) n=6;
    else n=tok.width();
    for(int i=0; i&lt;m.broj_redova; i++) {
        for(int j=0; j&lt;m.broj_kolona; j++) {
            tok&lt;&lt;std::setw(n)&lt;&lt;m.elementi[i][j];
        }
        tok&lt;&lt;std::endl;
    }
    return tok;

}
template &lt;typename Tip1, typename Tip2&gt;
auto operator +(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] + m2.elementi[0][0]) &gt; {
    if (m1.DajBrojRedova() != m2.DajBrojRedova() || m1.DajBrojKolona() != m2.DajBrojKolona()) throw std::domain_error("Nedozvoljena operacija");
<a name="8"></a><font color="#00FFFF"><a href="match967-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    GMatrica&lt;decltype(m1.elementi[0][0] + m2.elementi[0][0])&gt; mat(m1.DajBrojRedova(), m1.DajBrojKolona());
    for (int i=0; i &lt; m1.DajBrojRedova(); i++) {
</font>        for (int j=0; j &lt; m1.DajBrojKolona(); j++) {
            mat.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
        }
    }
    return mat;
}
template &lt;typename Tip1, typename Tip2&gt;
auto operator -(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] - m2.elementi[0][0]) &gt; {
    if (m1.DajBrojRedova() != m2.DajBrojRedova() || m1.DajBrojKolona() != m2.DajBrojKolona()) throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1.elementi[0][0] - m2.elementi[0][0])&gt; mat(m1.DajBrojRedova(), m1.DajBrojKolona());
    for (int i=0; i &lt; m1.DajBrojRedova(); i++) {
        for (int j=0; j &lt; m1.DajBrojKolona(); j++) {
            mat.elementi[i][j] = m1.elementi[i][j] - m2.elementi[i][j];
        }
    }
    return mat;
}

template&lt;typename Tip1, typename Tip2&gt;
<a name="3"></a><font color="#00FFFF"><a href="match967-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

auto operator *(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica&lt;decltype(m1.elementi[0][0]*m2.elementi[0][0])&gt; {
    if (m1.DajBrojKolona() != m2.DajBrojRedova()) throw std::domain_error("Nedozvoljena operacija");
    GMatrica&lt;decltype(m1.elementi[0][0]*m2.elementi[0][0])&gt; mat(m1.DajBrojRedova(), m2.DajBrojKolona());
</font><a name="13"></a><font color="#00FFFF"><a href="match967-0.html#13" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    for (int i=0; i &lt; m1.DajBrojKolona(); i++) {
        for (int j=0; j &lt; m2.DajBrojKolona(); j++) {
            for(int k=0; k&lt;m2.DajBrojRedova(); k++) {
</font>                mat.elementi[i][j] += m1.elementi[i][k] * m2.elementi[k][j];
            }
        }
    }
    return mat;
}
template &lt;typename Tip1, typename Tip2&gt;
auto operator +=(GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] + m2.elementi[0][0]) &gt; {
    if(m1.DajBrojKolona()!=m2.DajBrojKolona() || m1.DajBrojRedova()!=m2.DajBrojRedova()) throw std::logic_error("Ilegalan format matrice");
    for(int i=0; i&lt;m1.DajBrojRedova(); i++) {
        for(int j=0; j&lt;m1.DajBrojKolona(); j++) {
            m1.elementi[i][j]+=m2.elementi[i][j];
        }
    }
    return m1;
}
template &lt;typename Tip1, typename Tip2&gt;
auto operator -=(GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] - m2.elementi[0][0]) &gt; {
    if(m1.DajBrojKolona()!=m2.DajBrojKolona() || m1.DajBrojRedova()!=m2.DajBrojRedova()) throw std::logic_error("Ilegalan format matrice");
    for(int i=0; i&lt;m1.DajBrojRedova(); i++) {
        for(int j=0; j&lt;m1.DajBrojKolona(); j++) {
            m1.elementi[i][j]-=m2.elementi[i][j];
        }
    }
    return m1;
}
template &lt;typename Tip1, typename Tip2&gt;
auto operator *=(GMatrica&lt;Tip1&gt; &amp;m1, Tip2 x)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] * x) &gt; {
    for (int i=0; i &lt; m1.DajBrojRedova(); i++)
        for (int j=0; j &lt; m1.DajBrojKolona(); j++)
            m1.elementi[i][j] *=x;
    return m1;
}

template &lt;typename Tip1, typename Tip2&gt;
auto operator *=(GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)-&gt;GMatrica &lt; decltype(m1.elementi[0][0] * m2.elementi[0][0]) &gt; {
    if (m1.DajBrojKolona() != m2.DajBrojRedova()) throw std::domain_error("Nedozvoljena operacija");
    GMatrica &lt; decltype(m1.elementi[0][0] * m2.elementi[0][0])&gt; mat(m1.DajBrojRedova(), m2.DajBrojKolona());
    for (int i=0; i &lt; m1.DajBrojKolona(); i++)
        for (int j=0; j &lt; m2.DajBrojKolona(); j++)
            for (int k=0; k &lt; m2.DajBrojRedova(); k++)
                mat.elementi[i][j] += m1.elementi[i][k] * m2.elementi[k][j];
    m1 = mat;
    return m1;
}
<a name="5"></a><font color="#FF0000"><a href="match967-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

template &lt;typename Tip1, typename Tip2&gt;
auto operator *(Tip2 x, const GMatrica&lt;Tip1&gt; &amp;m)-&gt;GMatrica &lt; decltype(m.elementi[0][0] * x) &gt; {
</font>    return m*x;
}

<a name="6"></a><font color="#00FF00"><a href="match967-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

template &lt;typename Tip1, typename Tip2&gt;
auto operator *(const GMatrica&lt;Tip1&gt; &amp;m, Tip2 x)-&gt;GMatrica &lt; decltype(m.elementi[0][0] * x) &gt; {
</font>    GMatrica&lt;decltype(m.elementi[0][0] * x)&gt; mat(m.DajBrojRedova(), m.DajBrojKolona());
    for (int i=0; i &lt; m.DajBrojRedova(); i++)
        for (int j=0; j &lt; m.DajBrojKolona(); j++)
<a name="2"></a><font color="#0000FF"><a href="match967-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

            mat.elementi[i][j] = m.elementi[i][j] * x;
    return mat;
}
template &lt;typename Tip1, typename Tip2&gt;
bool operator ==(const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
</font>{
    int isti(0);
    for(int i=0; i&lt;m1.DajBrojRedova(); i++) {
        for(int j=0; j&lt;m1.DajBrojKolona(); j++) {
            if(m1.elementi[i][j]==m2.elementi[i][j]) isti=1;
            else {
                isti=0;
                break;
            }
        }
    }
    if(isti) return 1;
    return 0;
}

template &lt;typename Tip1, typename Tip2&gt;
bool operator!= (const GMatrica&lt;Tip1&gt; &amp;m1, const GMatrica&lt;Tip2&gt; &amp;m2)
{
    return !(m1==m2);
}
template&lt;typename Tip&gt;
Tip  &amp;GMatrica&lt;Tip&gt;::operator ()(int broj_redova, int broj_kolona)
{
    if(broj_redova&gt;GMatrica&lt;Tip&gt;::broj_redova || broj_redova&lt;1 || broj_kolona&gt;GMatrica&lt;Tip&gt;::broj_kolona || broj_kolona&lt;1) throw std::range_error("Nedozvoljen indeks");
    return elementi[broj_redova-1][broj_kolona-1];
}
template&lt;typename Tip&gt;
Tip  GMatrica&lt;Tip&gt;::operator ()(int broj_redova, int broj_kolona) const
{
    if(broj_redova&gt;DajBrojRedova() || broj_redova&lt;1 || broj_kolona&gt;DajBrojKolona() || broj_kolona&lt;1) throw std::range_error("Nedozvoljen indeks");
    return elementi[broj_redova-1][broj_kolona-1];
}
template &lt;typename Tip&gt;
Tip* &amp;GMatrica&lt;Tip&gt;::operator [](int broj_redova) const
{
    return elementi[broj_redova];
}

template &lt;typename Tip&gt;
Tip* GMatrica&lt;Tip&gt;::operator [](int broj_redova)
{
    return elementi[broj_redova];
}
template&lt;typename Tip1&gt;
std::istream &amp;operator &gt;&gt;(std::istream &amp;tok,  GMatrica&lt;Tip1&gt; &amp;m)
{
    char znak;
    tok &gt;&gt; std::ws;
    tok&gt;&gt;znak;
    if(znak!='[') tok.setstate(std::ios::failbit);
    Tip1 x;
    int i(0), j(0);
    if(m.broj_redova==0 &amp;&amp; m.broj_kolona==0) {
        for(;;) {
            tok&gt;&gt;x&gt;&gt;znak;
            m[i][j]=x;
            if(znak!=',') {
                m.broj_redova++;
                i++;
                j=0;
            }
            if(znak==',') {
                j++;
                m.broj_kolona++;
            }
            if(znak==']') break;
            if(znak!=',' &amp;&amp; znak!=';' &amp;&amp; znak!=']') tok.setstate(std::ios::failbit);

        }
    } else {
        int br(0), br2(0);
        for(;;) {
            Tip1 x;
            tok&gt;&gt;x&gt;&gt;znak;
            m.elementi[i][j]=x;
            if(znak!=',') {
                br++;
                i++;
                j=0;
            }
            if(znak==',') {
                j++;
                br2++;
            }
            if(znak==']') break;
            if(br!=m.broj_redova-1 &amp;&amp; br2!=m.broj_kolona-1) tok.setstate(std::ios::failbit);
            if(znak!=',' &amp;&amp; znak!=';' &amp;&amp; znak!=']') tok.setstate(std::ios::failbit);

        }
    }
    return tok;
}

int main ()
{
    return 0;
}</pre>
</body>
</html>
