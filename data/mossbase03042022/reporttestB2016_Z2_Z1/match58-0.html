<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student1547.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student1547.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1

	NAPOMENA: i javni ATo-vi su dio postavke

	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba

*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;string&gt;

<a name="1"></a><font color="#00FF00"><a href="match58-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_20.gif"/></a>

using std::cin;

enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
	Tabla igra(n, std::vector&lt;Polje&gt;(n, Polje::Prazno));
	for(int i=0; i&lt;mine.size(); i++) {
		if(mine[i].size()!=2) throw std::domain_error ("Ilegalan format zadavanja mina");
		if(mine[i][0]&gt;n-1 or mine[i][1]&gt;n-1) throw std::domain_error ("Ilegalne pozicije mina");
		igra[mine[i][0]][mine[i][1]]=Polje::Mina;
	}
	return igra;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 or y&lt;0 or x&gt;=polja.size() or y&gt;=polja.size()) throw std::domain_error ("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	std::vector&lt;std::vector&lt;int&gt;&gt; brojmina(3, std::vector&lt;int&gt;(3, 0));
	int px(x), py(y);
	// px - pozicija x
	// p2x - pozicija x koordinate kad se ispituje ima li mina
	if(x==0 and y==0) {
		px=x;
		py=y;
	} else if(x!=0 and y!=0) {
		px=x-1;
		py=y-1;
	} else if(x==0) {
		px=x;
		py=y-1;
	} else if(y==0) {
		px=x-1;
		py=y;
	}
	for(int i=0; i&lt;3; i++) {
		if(px+i&gt;=polja.size()) continue;
		if(px+i&gt;x+1) continue;
		for(int j=0; j&lt;3; j++) {
			if(py+j&gt;=polja.size()) continue;
			if(py+j&gt;=y+2) continue;
			int p2x(px+i), p2y(py+j);
			if(px+i==0 and py+j==0) {
				p2x=px+i;
				p2y=py+j;
			} else if(px+i!=0 and py+j!=0) {
				p2x=px+i-1;
				p2y=py+j-1;
			} else if(px+i==0) {
				p2x=px+i;
				p2y=py+j-1;
			} else if(py+j==0) {
				p2x=px+i-1;
				p2y=py+j;
			}
			for(int p=p2x; p&lt;p2x+3; p++) {
				if(p&gt;polja.size()-1) break;
				if(p&gt;px+i+1) continue;
				for(int q=p2y; q&lt;p2y+3; q++) {
					if(q&gt;polja.size()-1) break;
					if(q&gt;py+j+1) continue;
					if(px+i==p and py+j==q) continue;
					if(polja[p][q]==Polje::Mina) {
						brojmina[i][j]++;
					}
				}
			}
		}
	}
	return brojmina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 or y&lt;0 or x&gt;=polja.size() or y&gt;=polja.size()) throw std::domain_error ("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if(polja[x][y]==Polje::Prazno) polja[x][y]=Polje::BlokiranoPrazno;
</font>	if(polja[x][y]==Polje::Posjeceno) polja[x][y]=Polje::BlokiranoPosjeceno;
<a name="2"></a><font color="#0000FF"><a href="match58-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	if(polja[x][y]==Polje::Mina) polja[x][y]=Polje::BlokiranoMina;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 or y&lt;0 or x&gt;=polja.size() or y&gt;=polja.size()) throw std::domain_error ("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	if(polja[x][y]==Polje::BlokiranoPrazno) polja[x][y]=Polje::Prazno;
</font><a name="0"></a><font color="#FF0000"><a href="match58-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_73.gif"/></a>

	if(polja[x][y]==Polje::BlokiranoPosjeceno) polja[x][y]=Polje::Posjeceno;
	if(polja[x][y]==Polje::BlokiranoMina) polja[x][y]=Polje::Mina;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{	int novi_x(x), novi_y(y);
	if(smjer==Smjerovi::Gore) novi_x--;
	else if(smjer==Smjerovi::GoreDesno) {
		novi_x--;
		novi_y++;
	} else if(smjer==Smjerovi::GoreLijevo) {
		novi_x--;
		novi_y--;
	} else if(smjer==Smjerovi::DoljeLijevo) {
		novi_x++;
		novi_y--;
	} else if(smjer==Smjerovi::DoljeDesno) {
		novi_x++;
		novi_y++;
	} else if(smjer==Smjerovi::Dolje) novi_x++;
	else if(smjer==Smjerovi::Lijevo)novi_y--;
	else if(smjer==Smjerovi::Desno) novi_y++;
	if(novi_x&lt;0 or novi_x&gt;=polja.size() or novi_y&lt;0 or novi_y&gt;=polja.size()) throw std::out_of_range ("Izlazak van igrace table");
	if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno or polja[novi_x][novi_y]==Polje::BlokiranoPrazno or polja[novi_x][novi_y]==Polje::BlokiranoMina)
		throw std::logic_error ("Blokirano polje");
	polja[x][y]=Polje::Posjeceno;
	x=novi_x;
	y=novi_y;
	if (polja[novi_x][novi_y]==Polje::Mina) return Status::KrajPoraz;
	bool nijekraj(false);
	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja[i].size(); j++) {
			if(polja[i][j]==Polje::Prazno) nijekraj=true;
		}
	}
	if(nijekraj) return Status::NijeKraj;
	return Status::KrajPobjeda;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if(novi_x&lt;0 or novi_x&gt;=polja.size() or novi_y&lt;0 or novi_y&gt;=polja.size()) throw std::out_of_range ("Izlazak van igrace table");
	if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno or polja[novi_x][novi_y]==Polje::BlokiranoPrazno or polja[novi_x][novi_y]==Polje::BlokiranoMina)
		throw std::logic_error ("Blokirano polje");
	polja[x][y]=Polje::Posjeceno;
	x=novi_x;
	y=novi_y;
	if (polja[x][y]==Polje::Mina) return Status::KrajPoraz;
	bool nijekraj(false);
	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja[i].size(); j++) {
			if(polja[i][j]==Polje::Prazno) nijekraj=true;
		}
	}
	if(nijekraj) return Status::NijeKraj;
	return Status::KrajPobjeda;
}

enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
using std::cout;

void PrijaviGresku(KodoviGresaka greska)
{
	if(greska==KodoviGresaka::PogresnaKomanda) std::cout &lt;&lt; "Nerazumljiva komanda!"&lt;&lt;std::endl;
	if(greska==KodoviGresaka::NedostajeParametar) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;std::endl;
	if(greska==KodoviGresaka::NeispravanParametar) cout &lt;&lt; "Parametar komande nije ispravan!"&lt;&lt;std::endl;
	if(greska==KodoviGresaka::SuvisanParametar) cout &lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;std::endl;
}

enum class Komande
{
    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
    ZavrsiIgru, KreirajIgru
};


bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y,KodoviGresaka &amp;greska)
{
	std::string s;
	std::getline(std::cin, s);
	std::vector&lt;std::string&gt; komande {"PO", "K", "Z", "P1", "P&gt;", "B", "D"};
	std::vector&lt;Komande&gt; komande_nestring {Komande::PrikaziOkolinu, Komande::KreirajIgru, Komande::ZavrsiIgru, Komande::PomjeriJednoMjesto, Komande::PomjeriDalje, Komande::Blokiraj, Komande::Deblokiraj};
	std::vector&lt;std::string&gt; parametri_p1 {"GD", "GL", "G", "DoD", "DoL", "Do","D", "L"};
	std::vector&lt;Smjerovi&gt; parametri_p1_nestr {Smjerovi::GoreDesno, Smjerovi::GoreLijevo, Smjerovi::Gore, Smjerovi::DoljeDesno, Smjerovi::DoljeLijevo, Smjerovi::Dolje, Smjerovi::Desno, Smjerovi::Lijevo};
	for(int i=0; i&lt;s.length(); i++) {
		while(i&lt;s.length() and s.at(i)==' ') i++;
		for(int k=0; k&lt;komande.size(); k++) {
			if(i+komande[k].length()-1&lt; s.length() and s.substr(i,komande[k].length())==komande[k]) {
				if(k&lt;3) {
					if(s[i+komande[k].length()]=='\n'){ 
						komanda=komande_nestring[k];
						return true;
					}
					else if(i+komande[k].length()&lt;s.length() and s[i+komande[k].length()]!=' ') {
						greska=KodoviGresaka::SuvisanParametar;
						return false;
					}
					while(i+komande[k].length()&lt;s.length() and s[i+komande[k].length()]==' ') i++;
					if(i+komande[k].length()!=s.length()) {
						greska=KodoviGresaka::SuvisanParametar;
						return false;
					}
					komanda=komande_nestring[k];
					return true;
				} else if(k==3) {
					i+=komande[k].length();
					while(i&lt;s.length() and s[i]==' ') i++;
					if(i==s.length()) {
						greska=KodoviGresaka::NedostajeParametar;
						return false;
					}
					for(int j=0; j&lt;parametri_p1.size(); j++) {
						if(i+parametri_p1[j].length()&lt;int(s.length()+1) and s.substr(i, parametri_p1[j].length())==parametri_p1[j]) {
							if(i+parametri_p1[j].length()&lt;s.length() and s[i+parametri_p1[j].length()]!=' ') {
								greska=KodoviGresaka::NeispravanParametar;
								return false;
							}
							while(i+parametri_p1[j].length()&lt;s.length() and s[i+parametri_p1[j].length()]==' ') i++;
							if(i+parametri_p1[j].length()!=s.length()) {
								greska=KodoviGresaka::NeispravanParametar;
								return false;
							}
							for (auto z=i+parametri_p1[j].length(); z&lt;s.length(); z++){
								if(s[z]!=' '){
									greska=KodoviGresaka::NeispravanParametar;
									return false;
								}
							}
							smjer=parametri_p1_nestr[j];
							komanda=komande_nestring[k];
							return true;
						}
					}
					if(i!=s.length()) greska=KodoviGresaka::NeispravanParametar;
					else greska=KodoviGresaka::NedostajeParametar;
					return false;
				} else if(k&gt;3) {
					i+=komande[k].length();
					while(i&lt;s.length() and s[i]==' ') i++;
					if(i==s.length()) {
						greska=KodoviGresaka::NedostajeParametar;
						return false;
					}
					if(s[i]&lt;'0' or s[i]&gt;'9') {
						greska=KodoviGresaka::NeispravanParametar;
						return false;
					}
					int x1(i);
					if(i+1&lt;s.length()) i++;
					while(i&lt;s.length() and s[i]==' ') i++;
					if(i==s.length()) {
						greska=KodoviGresaka::NedostajeParametar;
						return false;
					}
					if(s[i]&lt;'0' or s[i]&gt;'9') {
						greska=KodoviGresaka::NeispravanParametar;
						return false;
					}
					for(auto z=i+1; z&lt;s.length(); z++){
						if(s[z]!=' '){
							greska=KodoviGresaka::NeispravanParametar;
							return false;
						}
					}
					x=s[x1]-'0';
					y=s[i]-'0';
					komanda=komande_nestring[k];
					return true;
				}
			}
		}
	}
	greska=KodoviGresaka::PogresnaKomanda;
	return false;
}


void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0)
{
	std::vector&lt;Komande&gt; komande {Komande::PomjeriJednoMjesto, Komande::PomjeriDalje, Komande::Blokiraj, Komande::Deblokiraj, Komande::PrikaziOkolinu, Komande::ZavrsiIgru, Komande::KreirajIgru};
	int i;
	bool izuz(false);
	for(i=0; i&lt;komande.size(); i++) {
		if(komanda==komande[i]) break;
	}
	Status status;
	if(i==0) {
		try {
			status=Idi(polja,x,y,p_smjer);
		} catch(std::out_of_range izuzetak) {
			cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
			izuz=true;
		} catch (std::logic_error izuzetak) {
			cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
			izuz=true;
		}
	} else if(i==1) {
		try {
			status=Idi(polja,x,y,p_x,p_y);
		} catch(std::out_of_range izuzetak) {
			cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
			izuz=true;
		} catch (std::logic_error izuzetak) {
			cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
			izuz=true;
		}

	} else if(i==2) {
		try {
			BlokirajPolje(polja,p_x,p_y);
		} catch(...) {
			cout &lt;&lt; "Polje ("&lt;&lt; p_x &lt;&lt; ","&lt;&lt;p_y &lt;&lt;") ne postoji!" &lt;&lt; std::endl;
		}
	} else if(i==3) {
		try {
			DeblokirajPolje(polja, p_x,p_y);
		} catch(...) {
			cout &lt;&lt; "Polje ("&lt;&lt; p_x &lt;&lt; ","&lt;&lt;p_y &lt;&lt;") ne postoji!" &lt;&lt; std::endl;
		}
	} else if(i==4) {
		try {
			std::vector&lt;std::vector&lt;int&gt;&gt; a(PrikaziOkolinu(polja,x,y));
			for(int j=0; j&lt;3; j++) {
				for(int k=0; k&lt;3; k++) {
					cout&lt;&lt; a[j][k] &lt;&lt; " ";
				}
				cout &lt;&lt; std::endl;
			}
		} catch(...) {
			cout &lt;&lt; "Polje ("&lt;&lt; p_x &lt;&lt; ","&lt;&lt;p_y &lt;&lt;") ne postoji!"&lt;&lt; std::endl;
		}
	} else if(i==5) {
		
		for(int j=0; j&lt;polja.size(); j++) {
			for(int k=0; k&lt;polja[j].size(); k++) {
				polja[j][k]=Polje::Prazno;
			}
		}
		throw std::runtime_error ("Igra zavrsena");
	} else if(i==6) {
		cout &lt;&lt; "Unesite broj polja: ";
		int n;
		cin &gt;&gt; n;
		std::cin.ignore(10000, '\n');
		std::string s;
		std::vector&lt;std::vector&lt;int&gt;&gt; mine;
		std::vector&lt;int&gt; red;
		cout &lt;&lt; "Unesite pozicije mina: ";
		std::getline(std::cin, s);
		for(;;) {
			if(s==".") break;
			bool greska(false);
			std::vector&lt;int&gt; red;
			if(int(s.length())!=5) {
				cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
				s.resize(0);
				std::getline(std::cin, s);
				if(s==".") break;
				continue;
			}
			if(s[0]!='(') greska=true;
			if(s[1]&lt;'0' or s[1]&gt;'9' or s[1]-'0'&gt;=n) greska=true;
			if(s[2]!=',') greska=true;
			if(s[3]&lt;'0' or s[3]&gt;'9' or s[3]-'0'&gt;=n) greska=true;
			if(s[4]!=')') greska=true;
			if(s[1]==0 and s[3]==0) greska=true;
			if(greska) {
				cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
				s.resize(0);
				std::getline(std::cin, s);
				if(s=="."){ 
					break;
				}
				continue;
			} else {
				red.push_back(s[1]-'0');
				red.push_back(s[3]-'0');
				mine.push_back(red);
				s.resize(0);
				std::getline(std::cin, s);
				if(s==".") break;
			}
		}
		try {
			polja=KreirajIgru(n, mine);
		} catch(std::domain_error izuzetak) {
			cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
		}
	}
	if((i==0 or i==1) and !izuz) {
		if(status==Status::NijeKraj) cout &lt;&lt; "Tekuca pozicija igraca je ("&lt;&lt; x &lt;&lt; ","&lt;&lt;y &lt;&lt;")"&lt;&lt; std::endl;
		else if(status==Status::KrajPoraz) {
			cout &lt;&lt; "Nagazili ste na minu"&lt;&lt; std::endl;
			for(int j=0; j&lt;polja.size(); j++) {
				for(int k=0; k&lt;polja[i].size(); k++) {
					polja[j][k]=Polje::Prazno;
				}
			}
			throw std::runtime_error ("Igra zavrsena");
		} else if(status==Status::KrajPobjeda) {
			cout &lt;&lt; "Bravo, obisli ste sva sigurna polja";
			for(int j=0; j&lt;polja.size(); j++) {
				for(int k=0; k&lt;polja[i].size(); k++) {
					polja[j][k]=Polje::Prazno;
				}
			}
			throw std::runtime_error ("Igra zavrsena");
		}
	}

}



int main ()
{
	Tabla polja;
	int x(0), y(0), p_x(0), p_y(0);
	Komande komanda;
	KodoviGresaka greska;
	Smjerovi smjer;
	for(;;){
		cout &lt;&lt; "Unesite komandu: ";
		if(UnosKomande(komanda, smjer, p_x, p_y, greska)){
			try{
				IzvrsiKomandu(komanda, polja, x, y, smjer, p_x, p_y);
			}
			catch(...){
				cout &lt;&lt; "Dovidjenja!";
				break; 
			}
		}
		else PrijaviGresku(greska);
	}
	

	return 0;
</font>}</pre>
</body>
</html>
