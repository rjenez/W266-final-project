<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6992.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6992.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;


<a name="0"></a><font color="#FF0000"><a href="match89-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;


int neposjeceno(0);

enum class Polje {
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

typedef vector&lt;vector&lt;Polje&gt;&gt; Tabla;

enum class Smjerovi {
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
    NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
    PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar
};

enum class Komande {
    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

Tabla KreirajIgru(int n, const vector&lt;vector&lt;int&gt;&gt; &amp;mine){
	Tabla tabla(n, vector&lt;Polje&gt; (n, Polje::Prazno));
	if(mine.empty()) return tabla;
		for(auto red : mine){
			if((int)red.size() != 2) throw domain_error("Ilegalan format zadavanja mina");
			if(red.at(0) &gt;= n || red.at(0) &lt; 0 || red.at(1) &gt;= n || red.at(1) &lt; 0)
				throw domain_error("Ilegalne pozicije mina");
		}

	int brojacMina(0);
	for(auto red : mine){
		if(tabla.at(red.at(0)).at(red.at(1)) != Polje::Mina){
			tabla.at(red.at(0)).at(red.at(1)) = Polje::Mina;
			brojacMina++;
		}
	}
	neposjeceno = n * n - brojacMina;
	return tabla;
}

int BrojMinaUOkolini(const Tabla&amp; polja, const int x, const int y){
	int rezultat = 0;
	int redPocetak, redKraj;
	int kolonaPocetak, kolonaKraj;
	redPocetak = (x - 1) &lt; 0 ? x : x - 1;
	redKraj = (x + 1) &gt; (int)polja.size() ? x : x + 1;
	
	kolonaPocetak = (y - 1) &lt; 0 ? y : y - 1;
	kolonaKraj = (y + 1) &gt; (int)polja.size() ? y : y + 1;
	
	for(int i(redPocetak); i &lt;= redKraj; i++){
		for(int j(kolonaPocetak); j &lt;= kolonaKraj; j++){
			if(polja[i][j] == Polje::Mina) rezultat++;
			if(x == i &amp;&amp; y == j &amp;&amp; polja[i][j] == Polje::Mina) rezultat--;
		}
	}
	return rezultat;
}

vector&lt;vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla&amp; polja, int x, int y){
	if(x &lt; 0 || y &lt; 0 || x &gt; (int)polja.size() || y &gt; (int)polja.size()){
		stringstream ss;
		ss &lt;&lt; "Polje (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ") ne postoji";
		throw domain_error(ss.str());
	}
	vector&lt;vector&lt;int&gt;&gt; rez;
	for(int i(x - 1); i &lt;= x + 1; i++){
		vector&lt;int&gt; v;
		for(int j(y - 1); j &lt;= y + 1; j++){
			if(i &lt; 0 || j &lt; 0 || i &gt; (int)polja.size() || j &gt; (int)polja.size())
				v.push_back(0);
			else v.push_back(BrojMinaUOkolini(polja, i, j));
		}
		rez.push_back(v);
	}
	return rez;
}

void BlokirajPolje(Tabla&amp; polja, int x, int y){
	if(x &lt; 0 || y &lt; 0 || x &gt; (int)polja.size() || y &gt; (int)polja.size()){
		stringstream ss;
		ss &lt;&lt; "Polje (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ") ne postoji";
		throw domain_error(ss.str());
	}
	switch(polja[x][y]){
		case Polje::Mina:
			polja[x][y] = Polje::BlokiranoMina;
			break;
		case Polje::Prazno:
			polja[x][y] = Polje::BlokiranoPrazno;
			break;
		case Polje::Posjeceno:
			polja[x][y] = Polje::BlokiranoPosjeceno;
			break;
		default: break;
	}
}

void DeblokirajPolje(Tabla&amp; polja, int x, int y){
	if(x &lt; 0 || y &lt; 0 || x &gt; (int)polja.size() || y &gt; (int)polja.size()){
		stringstream ss;
		ss &lt;&lt; "Polje (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ") ne postoji";
		throw domain_error(ss.str());
	}
	switch(polja[x][y]){
		case Polje::BlokiranoMina:
			polja[x][y] = Polje::Mina;
			break;
		case Polje::BlokiranoPrazno:
			polja[x][y] = Polje::Prazno;
			break;
		case Polje::BlokiranoPosjeceno:
			polja[x][y] = Polje::Posjeceno;
			break;
		default: break;
	}
}

Status Idi(Tabla&amp; polja, int&amp; x, int&amp; y, Smjerovi smjer){
	int moguciX(x);
	int moguciY(y);
	switch(smjer){
		case Smjerovi::Desno:
			moguciY++; break;
		case Smjerovi::Lijevo:
			moguciY--; break;
		case Smjerovi::Gore:
			moguciX--; break;
		case Smjerovi::Dolje:
			moguciX++; break;
		case Smjerovi::DoljeDesno:
			moguciX++; moguciY++; break;
		case Smjerovi::DoljeLijevo:
			moguciX++; moguciY--; break;
		case Smjerovi::GoreDesno:
			moguciX--; moguciY++; break;
		case Smjerovi::GoreLijevo:
			moguciX--; moguciY--; break;
	}
	
	if(moguciX &lt; 0 || moguciX == (int)polja.size() || moguciY &lt; 0 || moguciY == (int)polja.size())
		throw out_of_range("Izlazak van igrace table");
	else if(polja[moguciX][moguciY] == Polje::BlokiranoPosjeceno ||
			polja[moguciX][moguciY] == Polje::BlokiranoPrazno ||
			polja[moguciX][moguciY] == Polje::BlokiranoMina)
			cout &lt;&lt; "Blokirano polje" &lt;&lt; endl;
	else {
		x = moguciX;
		y = moguciY;
		if(polja[x][y] == Polje::Mina){
			polja = KreirajIgru((int)polja.size(), {});
			return Status::KrajPoraz;
		}
		if(--neposjeceno == 0) return Status::KrajPobjeda;
	}
	return Status::NijeKraj;
}

Status Idi(Tabla&amp; polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	int moguciX(novi_x), moguciY(novi_y);
	if(moguciX &lt; 0 || moguciX == (int)polja.size() || moguciY &lt; 0 || moguciY == (int)polja.size())
		throw out_of_range("Izlazak van igrace table");
	else if(polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno ||
			polja[novi_x][novi_y] == Polje::BlokiranoPrazno ||
			polja[novi_x][novi_y] == Polje::BlokiranoMina)
			cout &lt;&lt; "Blokirano polje" &lt;&lt; endl;
	else {
		x = moguciX;
		y = moguciY;
		if(polja[x][y] == Polje::Mina){
			polja = KreirajIgru((int)polja.size(), {});
			return Status::KrajPoraz;
		}
		if(--neposjeceno == 0) return Status::KrajPobjeda;
	}
	return Status::NijeKraj;
}

void PrijaviGresku(KodoviGresaka kodGreske){
	string poruka;
	switch(kodGreske){
		case KodoviGresaka::NedostajeParmetar:
			poruka = "Komanda trazi parametar koji nije naveden!";
			break;
		case KodoviGresaka::NeispravanParametar:
			poruka = "Parametar komande nije ispravan!";
			break;
		case KodoviGresaka::PogresnaKomanda:
			poruka = "Nerazumljiva komanda!";
			break;
		case KodoviGresaka::SuvisanParametar:
			poruka = "Zadan je suvisan parametar nakon komande!";
			break;
	}
	cout &lt;&lt; poruka &lt;&lt; endl;
}

void IzvrsiKomandu(Komande komanda, Tabla&amp; polja, int&amp; x, int&amp; y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0){
	auto ZavrsiIgru = [&amp;polja](){
		polja = KreirajIgru(polja.size(), {});
		throw runtime_error("Igra zavrsena");
	};
	if(komanda == Komande::ZavrsiIgru) ZavrsiIgru();
		else if(komanda == Komande::Blokiraj){
			BlokirajPolje(polja, x, y);
		
		
		}
		else if(komanda == Komande::Deblokiraj)
			DeblokirajPolje(polja, x, y);
		else if(komanda == Komande::KreirajIgru){
			vector&lt;vector&lt;int&gt;&gt; mat;
			int n;
			cout &lt;&lt; "Unesite broj polja: ";
			cin &gt;&gt; n;
			cout &lt;&lt; "Unesite pozicije mina: ";
			cin.ignore(100, '\n'); cin.clear(); 
			while(1){
				string s;
				int tx, ty;

				getline(cin, s);
				{
					if(s == ".") break;
					stringstream ss(s);
					char c;
					ss &gt;&gt; c &gt;&gt; tx &gt;&gt; c &gt;&gt; ty &gt;&gt; c;
					if(tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= n)
						cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; endl;
					else mat.push_back({tx, ty});
				}
			}
			polja = KreirajIgru(n, mat);
		}
		else if(komanda == Komande::PomjeriDalje){
			Status status = Idi(polja, x, y, p_x, p_y);
			if(polja[x][y] == Polje::BlokiranoPosjeceno ||
				polja[x][y] == Polje::BlokiranoPrazno ||
				polja[x][y] == Polje::BlokiranoMina)
					cout &lt;&lt; "Blokirano polje" &lt;&lt; endl;
			else cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; endl;
			if(status == Status::KrajPoraz){
				cout &lt;&lt; "Nagazili ste minu" &lt;&lt; endl;
				ZavrsiIgru();
			}
			else if(status == Status::KrajPobjeda){
				cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; endl;
				ZavrsiIgru();
			}
		}
		else if(komanda == Komande::PomjeriJednoMjesto){
			Status status = Idi(polja, x, y, p_smjer);
			cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; endl;
			if(status == Status::KrajPoraz){
				cout &lt;&lt; "Nagazili ste minu" &lt;&lt; endl;
				ZavrsiIgru();
			}
			else if(status == Status::KrajPobjeda){
				cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; endl;
				ZavrsiIgru();
			}
		}
		else if(komanda == Komande::PrikaziOkolinu){
			vector&lt;vector&lt;int&gt;&gt; okolina = PrikaziOkolinu(polja, x, y);
			for(auto v : okolina){
				for(int x : v)
					cout &lt;&lt; x &lt;&lt; " ";
				cout &lt;&lt; endl;
			}
		}
}

bool UnosKomande(Komande&amp; komanda, Smjerovi&amp; smjer, int&amp; x, int&amp; y, KodoviGresaka&amp; greska){
	string unos, s;
	getline(cin, unos);

	unique_copy(unos.begin(), unos.end(), back_inserter(s), [](char a, char b) { return a == ' ' &amp;&amp; b == ' ';});

    int i = s[0] == ' ' ? 1 : 0;
    if(s[i] == 'Z'){
    	komanda = Komande::ZavrsiIgru;
    }
    else if(s[i] == 'K'){
    	komanda = Komande::KreirajIgru;
    }
    else if(s[i] == 'B' || s[i] == 'D'){
    	char k = s[i];
    	if(s[++i] == ' ')
    		i++;
   		if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') x = s[i] - '0';
   		else {
   			greska = KodoviGresaka::NeispravanParametar;
   			return false;
   		}
   		if(s[++i] != ' '){
   			greska = KodoviGresaka::NeispravanParametar;
  			return false;
   		}
   		i++;
   		if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') y = s[i] - '0';
   		else {
   			greska = KodoviGresaka::NeispravanParametar;
   			return false;
   		}
   		k == 'B' ? komanda = Komande::Blokiraj : komanda = Komande::Deblokiraj;
    }
    else if(s[i] == 'P'){
    	
    	if(s[++i] == ' '){
    		greska = KodoviGresaka::PogresnaKomanda;
    		return false;
    	}
    	if(s[i] == '1'){
    		
    		i++;
    		if(s[i] == ' ') i++;
    		string podstring = s.substr(i);
    		if(*(podstring.end() - 1) == ' ') podstring.erase(podstring.end() - 1);
    		if(podstring == "GL"){
    			komanda = Komande::PomjeriJednoMjesto;
    			smjer = Smjerovi::GoreLijevo;
    		}
    		else if(podstring == "G"){
    			komanda = Komande::PomjeriJednoMjesto;
    			smjer = Smjerovi::Gore;
    		}
    		else if(podstring == "GD"){
    			komanda = Komande::PomjeriJednoMjesto;
    			smjer = Smjerovi::GoreDesno;
    		}
    		else if(podstring == "D"){
    			komanda = Komande::PomjeriJednoMjesto;
    			smjer = Smjerovi::Desno;
    		}
    		else if(podstring == "L"){
    			komanda = Komande::PomjeriJednoMjesto;
    			smjer = Smjerovi::Lijevo;
    		}
    		else if(podstring == "DoL"){
    			komanda = Komande::PomjeriJednoMjesto;
    			smjer = Smjerovi::DoljeLijevo;
    		}
    		else if(podstring == "DoD"){
    			komanda = Komande::PomjeriJednoMjesto;
    			smjer = Smjerovi::DoljeDesno;
    		}
    		else if(podstring == "Do"){
    			komanda = Komande::PomjeriJednoMjesto;
    			smjer = Smjerovi::Dolje;
    		}
    		else{
    			greska = KodoviGresaka::NeispravanParametar;
    			return false;
    		}
    	}
    	else if(s[i] == '&gt;'){
    		
    		if(s[++i] == ' ') i++;
    		//pretpostavka da ce koord biti jednocifreni brojevi
	   		if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') x = s[i] - '0';
   			else {
   				greska = KodoviGresaka::NeispravanParametar;
   				return false;
   			}
   			if(s[++i] != ' '){
   				greska = KodoviGresaka::NeispravanParametar;
   				return false;
   			}
   			i++;
   			if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') y = s[i] - '0';
   			else {
	   			greska = KodoviGresaka::NeispravanParametar;
   				return false;
   			}
   			komanda = Komande::PomjeriDalje;
    	}
    	else if(s[i] == 'O'){
    		komanda = Komande::PrikaziOkolinu;
    	}
    }
    else {
    	greska = KodoviGresaka::PogresnaKomanda;
    	return false;
    }
    
    return true;
}

int main ()
{
	Tabla polja; 
    int x(0), y(0);
    while(1){
        try{
            Komande komanda;
            Smjerovi smjer;
            KodoviGresaka greska;
            int tx, ty;
            cout &lt;&lt; "Unesite komandu: ";
            bool unos = UnosKomande(komanda, smjer, tx, ty, greska);
            unos ? IzvrsiKomandu(komanda, polja, x, y, smjer, tx, ty) : PrijaviGresku(greska);
        }catch(std::runtime_error e){
            
            std::cout &lt;&lt; "Dovidjenja!" &lt;&lt; std::endl;
            break;
        }catch(std::exception &amp;e){
            std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
</font>        }
    }
    return 0;
}</pre>
</body>
</html>
