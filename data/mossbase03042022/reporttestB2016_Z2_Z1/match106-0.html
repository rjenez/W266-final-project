<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student8428.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student8428.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
enum class Polje {
<a name="1"></a><font color="#00FF00"><a href="match106-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_33.gif"/></a>

 Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
enum class Smjerovi {
 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar
};
enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
    Tabla t;
    t.resize(n);
    for(int i(0); i &lt; n; i++)
        t[i].resize(n);
        
    for(int i(0); i &lt; n; i++)
        for(int j(0); j &lt; n; j++)
            t[i][j] = Polje::Prazno;
            
    for(int i(0); i &lt; mine.size(); i++)
    {
        if(mine[i].size() != 2)
            throw std::domain_error("Ilegalan format zadavanja mina");
        if(mine[i][0] &gt;= n || mine[i][1] &gt;= n || mine[i][0] &lt; 0 || mine[i][1] &lt; 0)
            throw std::domain_error("Ilegalne pozicije mina");
        t[mine[i][0]][mine[i][1]] = Polje::Mina;
    }
    
    return t;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
    if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size())
        throw std::domain_error("Polje(x,y) ne postoji");
    int n = polja.size();
    std::vector&lt;std::vector&lt;int&gt;&gt; matrica(n, std::vector&lt;int&gt;(n, 0));
    for(int i(0); i &lt; 3; i++)
    {
        for(int j(0); j &lt; 3; j++)
        {
            int brojMina = 0;
            for(int k(0); k &lt; 8; k++)
            {
                if(x-1 &gt;= 0 &amp;&amp; y-1 &gt;= 0)
                    if(polja[x-1][y-1] == Polje::Mina)
                        brojMina++;
                if(x-1 &gt;= 0)
                    if(polja[x-1][y] == Polje::Mina)
                        brojMina++;
                if(x-1 &gt;= 0 &amp;&amp; y + 1 &lt; polja.size())
                    if(polja[x-1][y+1] == Polje::Mina)
                        brojMina++;
                if(y+1 &lt; polja.size())
                    if(polja[x][y+1] == Polje::Mina)
                        brojMina++;
                if(x+1 &lt; polja.size() &amp;&amp; y+1 &lt; polja.size())
                    if(polja[x+1][y+1] == Polje::Mina)
                        brojMina++;
                if(x+1 &lt; polja.size())
                    if(polja[x+1][y] == Polje::Mina)
                        brojMina++;
                if(x+1 &lt; polja.size() &amp;&amp; y - 1 &lt;= 0)
                    if(polja[x+1][y-1] == Polje::Mina)
                        brojMina++;
                if(y - 1 &lt;= 0)
                    if(polja[x][y-1] == Polje::Mina)
                        brojMina++;
            }
            
            matrica[i][j] = brojMina;
        }
    }
}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
    if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size())
        throw std::domain_error("Polje(x,y) ne postoji");
    if(polja[x][y] == Polje::Prazno)
        polja[x][y] = Polje::BlokiranoPrazno;
    else if(polja[x][y] == Polje::Posjeceno)
</font>        polja[x][y] = Polje::BlokiranoPosjeceno;
    else if(polja[x][y] == Polje::Mina)
<a name="2"></a><font color="#0000FF"><a href="match106-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

        polja[x][y] = Polje::BlokiranoMina;
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
    if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size())
        throw std::domain_error("Polje(x,y) ne postoji");
    if(polja[x][y] == Polje::BlokiranoPrazno)
        polja[x][y] = Polje::Prazno;
    else if(polja[x][y] == Polje::BlokiranoPosjeceno)
</font>        polja[x][y] = Polje::Posjeceno;
<a name="0"></a><font color="#FF0000"><a href="match106-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_58.gif"/></a>

    else if(polja[x][y] == Polje::BlokiranoMina)
        polja[x][y] = Polje::Mina;
}
void OcistiTablu(Tabla &amp;polja)
{
    int n = polja.size();
    for(int i(0); i &lt; n; i++)
        for(int j(0); j &lt; n; j++)
            polja[i][j] = Polje::Prazno;
}
bool ProvjeriPraznaPolja(Tabla &amp;polja)
{
    int n = polja.size();
    for(int i(0); i &lt; n; i++)
        for(int j(0); j &lt; n; j++)
            if(polja[i][j] == Polje::Prazno)
                return false;
    return true;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
    polja[x][y] = Polje::Posjeceno;
    if(smjer == Smjerovi::GoreLijevo)
    {
        x--; y--;
        if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size())
        {
            x++; y++;
            throw std::out_of_range("Izlazak van igrace table");
        }
        else if(polja[x][y] == Polje::BlokiranoPosjeceno || polja[x][y] == Polje::BlokiranoPrazno || polja[x][y] == Polje::BlokiranoMina)
        {
            x++; y++;
            throw std::logic_error("Blokirano polje");
        }
        
    }
    else if(smjer == Smjerovi::Gore)
    {
        x--;
        if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size())
        {
            x++;
            throw std::out_of_range("Izlazak van igrace table");
        }
        else if(polja[x][y] == Polje::BlokiranoPosjeceno || polja[x][y] == Polje::BlokiranoPrazno || polja[x][y] == Polje::BlokiranoMina)
        {
            x++;
            throw std::logic_error("Blokirano polje");
        }
    }
    else if(smjer == Smjerovi::GoreDesno)
    {
        x--; y++;
        if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size())
        {
            x++; y--;
            throw std::out_of_range("Izlazak van igrace table");
        }
        else if(polja[x][y] == Polje::BlokiranoPosjeceno || polja[x][y] == Polje::BlokiranoPrazno || polja[x][y] == Polje::BlokiranoMina)
        {
            x++; y--;
            throw std::logic_error("Blokirano polje");
        }
    }
    else if(smjer == Smjerovi::Desno)
    {
        y++;
        if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size())
        {
            y--;
            throw std::out_of_range("Izlazak van igrace table");
        }
        else if(polja[x][y] == Polje::BlokiranoPosjeceno || polja[x][y] == Polje::BlokiranoPrazno || polja[x][y] == Polje::BlokiranoMina)
        {
            y--;
            throw std::logic_error("Blokirano polje");
        }
    }
    else if(smjer == Smjerovi::DoljeDesno)
    {
        x++; y++;
        if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size())
        {
            x--; y--;
            throw std::out_of_range("Izlazak van igrace table");
        }
        else if(polja[x][y] == Polje::BlokiranoPosjeceno || polja[x][y] == Polje::BlokiranoPrazno || polja[x][y] == Polje::BlokiranoMina)
        {
            x--; y--;
            throw std::logic_error("Blokirano polje");
        }
    }
    else if(smjer == Smjerovi::Dolje)
    {
        x++;
        if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size())
        {
            x--;
            throw std::out_of_range("Izlazak van igrace table");
        }
        else if(polja[x][y] == Polje::BlokiranoPosjeceno || polja[x][y] == Polje::BlokiranoPrazno || polja[x][y] == Polje::BlokiranoMina)
        {
            x--; 
            throw std::logic_error("Blokirano polje");
        }
    }
    else if(smjer == Smjerovi::DoljeLijevo)
    {
        x++; y--;
        if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size())
        {
            x--; y++;
            throw std::out_of_range("Izlazak van igrace table");
        }
        else if(polja[x][y] == Polje::BlokiranoPosjeceno || polja[x][y] == Polje::BlokiranoPrazno || polja[x][y] == Polje::BlokiranoMina)
        {
            x--; y++;
            throw std::logic_error("Blokirano polje");
        }
    }
    else if(smjer == Smjerovi::Lijevo)
    {
        y--;
        if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size())
        {
            y++;
            throw std::out_of_range("Izlazak van igrace table");
        }
        else if(polja[x][y] == Polje::BlokiranoPosjeceno || polja[x][y] == Polje::BlokiranoPrazno || polja[x][y] == Polje::BlokiranoMina)
        {
            y++;
            throw std::logic_error("Blokirano polje");
        }
    }
    
    if(polja[x][y] == Polje::Mina)
    {
        OcistiTablu(polja);
        return Status::KrajPoraz;
    }
    if(ProvjeriPraznaPolja(polja))
        return Status::KrajPobjeda;
        
    return Status::NijeKraj;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
    polja[x][y] = Polje::Posjeceno;
    if(novi_x &lt; 0 || novi_y &lt; 0 || novi_x &gt;= polja.size() || novi_y &gt;= polja.size())
        throw std::out_of_range("Izlazak van igrace table");
    else if(polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno || 
    polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoMina)
        throw std::logic_error("Blokirano polje");
    x = novi_x;
    y = novi_y;
    if(polja[x][y] == Polje::Mina)
    {
        OcistiTablu(polja);
        return Status::KrajPoraz;
    }
    if(ProvjeriPraznaPolja(polja))
        return Status::KrajPobjeda;
    return Status::NijeKraj;
}
void PrijaviGresku(KodoviGresaka greska)
{
    if(greska == KodoviGresaka::PogresnaKomanda)
        std::cout &lt;&lt; "Nerazumljiva komanda!";
    else if(greska == KodoviGresaka::NedostajeParmetar)
        std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!";
    else if(greska == KodoviGresaka::NeispravanParametar)
        std::cout &lt;&lt; "Parametar komande nije ispravan!";
    else if(greska == KodoviGresaka::SuvisanParametar)
        std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!";    
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
    std::cout &lt;&lt; "Unesite komandu: "
    std::string s;
    std::getline(std::cin, s);
    std::string temp;
    int brojac = 0;
    while(1)
    {
        if(s[brojac] == ' ')
            brojac++;
        else 
            break;
    }
    for(; brojac &lt; s.size(); brojac++)
        temp += s[brojac];
    s = temp;    
    if(s == "K")
    {
        std::cout &lt;&lt; "Unesite broj polja: ";
        int n;
        std::cin &gt;&gt; n;
        
    }
}
int main ()
</font>{
	return 0;
}</pre>
</body>
</html>
