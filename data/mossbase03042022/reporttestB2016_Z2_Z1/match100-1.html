<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6364.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4770.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

enum class Polje {
 Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
enum class Smjerovi {
<a name="1"></a><font color="#00FF00"><a href="match100-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
    for(int i = 0; i &lt; mine.size(); i++)
    {
        if(mine[i].size() != 2) throw std::domain_error("Ilegalan format zadavanja mina");    
    }
    for(int i = 0; i &lt; mine.size(); i++)
    {
        for(int j = 0; j &lt; 2; j++)
            if(mine[i][j] &gt;= n || mine[i][j] &lt; 0) throw std::domain_error("Ilegalne pozicije mina");
    }
    Tabla ploca(n, std::vector&lt;Polje&gt; (n));
    for(int i = 0; i &lt; n; i++)
    {
        for(int j = 0; j &lt; n; j++)
            ploca[i][j] = Polje::Prazno;
    }
    for(int i = 0; i &lt; mine.size(); i++)
    {
            ploca[mine[i][0]][mine[i][1]] = Polje::Mina;
    }
    return ploca;
}
void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
    if(x &gt;= polja.size() || y &gt;= polja.size() || x &lt; 0 || y &lt; 0) throw std::domain_error("Polje ("+ std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
    if(polja[x][y] == Polje::Prazno)
</font>        polja[x][y] = Polje::BlokiranoPrazno;
    else if(polja[x][y] == Polje::Posjeceno)
        polja[x][y] = Polje::BlokiranoPosjeceno;
    else if(polja[x][y] == Polje::Mina)
<a name="2"></a><font color="#0000FF"><a href="match100-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

        polja[x][y] = Polje::BlokiranoMina;
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
        if(x &gt;= polja.size() || y &gt;= polja.size() || x &lt; 0 || y &lt; 0) throw std::domain_error("Polje ("+ std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
        if(polja[x][y] == Polje::BlokiranoPrazno)
</font>            polja[x][y] = Polje::Prazno;
        else if(polja[x][y] == Polje::BlokiranoPosjeceno)
            polja[x][y] = Polje::Posjeceno;
        else if(polja[x][y] == Polje::BlokiranoMina)
<a name="0"></a><font color="#FF0000"><a href="match100-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_77.gif"/></a>

            polja[x][y] = Polje::Mina;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
    Status vrati = Status::KrajPobjeda;
    int n = polja.size();
    switch(int(smjer))
    {
        case 0: 
            if(x == 0 || y == 0) throw std::out_of_range("Izlazak van igrace table");
            else if(polja[x-1][y-1] == Polje::BlokiranoPosjeceno || polja[x-1][y-1] == Polje::BlokiranoPrazno || polja[x-1][y-1] == Polje::BlokiranoMina)
            { 
                throw std::logic_error("Blokirano polje");
                vrati = Status::KrajPoraz;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                        polja[i][j] = Polje::Prazno;
                }
            }
            else {
                polja[x][y] = Polje::Posjeceno;
                x -= 1;
                y -= 1;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                    {
                        if(polja[i][j] == Polje::Prazno)
                        {
                            vrati = Status::NijeKraj;
                            return vrati;
                        }
                    }
                }
            } break;
        case 1:
            if(x == 0) throw std::out_of_range("Izlazak van igrace table");
            else if(polja[x-1][y] == Polje::BlokiranoPosjeceno || polja[x-1][y] == Polje::BlokiranoPrazno || polja[x-1][y] == Polje::BlokiranoMina)
            { 
                throw std::logic_error("Blokirano polje");
                vrati = Status::KrajPoraz;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                        polja[i][j] = Polje::Prazno;
                }
            }
            else {
                polja[x][y] = Polje::Posjeceno;
                x -= 1;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                    {
                        if(polja[i][j] == Polje::Prazno)
                        {
                            vrati = Status::NijeKraj;
                            return vrati;
                        }
                    }
                }
            } break;
        case 2:
            if(x == 0 || y == polja.size()-1) throw std::out_of_range("Izlazak van igrace table");
            else if(polja[x-1][y+1] == Polje::BlokiranoPosjeceno || polja[x-1][y+1] == Polje::BlokiranoPrazno || polja[x-1][y+1] == Polje::BlokiranoMina)
            { 
                throw std::logic_error("Blokirano polje");
                vrati = Status::KrajPoraz;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                        polja[i][j] = Polje::Prazno;
                }
            }
            else {
                polja[x][y] = Polje::Posjeceno;
                x -= 1;
                y += 1;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                    {
                        if(polja[i][j] == Polje::Prazno)
                        {
                            vrati = Status::NijeKraj;
                            return vrati;
                        }
                    }
                }
            } break;
        case 3: 
            if(y == polja.size()-1) throw std::out_of_range("Izlazak van igrace table");
            else if(polja[x][y+1] == Polje::BlokiranoPosjeceno || polja[x][y+1] == Polje::BlokiranoPrazno || polja[x][y+1] == Polje::BlokiranoMina)
            { 
                throw std::logic_error("Blokirano polje");
                vrati = Status::KrajPoraz;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                        polja[i][j] = Polje::Prazno;
                }
            }
            else {
                polja[x][y] = Polje::Posjeceno;
                y += 1;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                    {
                        if(polja[i][j] == Polje::Prazno)
                        {
                            vrati = Status::NijeKraj;
                            return vrati;
                        }
                    }
                }
            }
        case 4: 
            if(x == polja.size()-1 || y == polja.size()-1) throw std::out_of_range("Izlazak van igrace table");
            else if(polja[x+1][y+1] == Polje::BlokiranoPosjeceno || polja[x+1][y+1] == Polje::BlokiranoPrazno || polja[x+1][y+1] == Polje::BlokiranoMina)
            { 
                throw std::logic_error("Blokirano polje");
                vrati = Status::KrajPoraz;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                        polja[i][j] = Polje::Prazno;
                }
            }
                polja[x][y] = Polje::Posjeceno;
                x += 1;
                y += 1;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                    {
                        if(polja[i][j] == Polje::Prazno)
                        {
                            vrati = Status::NijeKraj;
                            return vrati;
                        }
                    }
                } break;
        case 5:
            if(x == polja.size()-1) throw std::out_of_range("Izlazak van igrace table");
            else if(polja[x+1][y] == Polje::BlokiranoPosjeceno || polja[x+1][y] == Polje::BlokiranoPrazno || polja[x+1][y] == Polje::BlokiranoMina)
            { 
                throw std::logic_error("Blokirano polje");
                vrati = Status::KrajPoraz;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                        polja[i][j] = Polje::Prazno;
                }
            }
            else {
                polja[x][y] = Polje::Posjeceno;
                x += 1;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                    {
                        if(polja[i][j] == Polje::Prazno)
                        {
                            vrati = Status::NijeKraj;
                            return vrati;
                        }
                    }
                }
            } break;
        case 6:
            if(x == polja.size()-1 || y == 0) throw std::out_of_range("Izlazak van igrace table");
            else if(polja[x+1][y-1] == Polje::BlokiranoPosjeceno || polja[x+1][y-1] == Polje::BlokiranoPrazno || polja[x+1][y-1] == Polje::BlokiranoMina)
            { 
                throw std::logic_error("Blokirano polje");
                vrati = Status::KrajPoraz;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                        polja[i][j] = Polje::Prazno;
                }
            }
            else {
                polja[x][y] = Polje::Posjeceno;
                x += 1;
                y -= 1;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                    {
                        if(polja[i][j] == Polje::Prazno)
                        {
                            vrati = Status::NijeKraj;
                            return vrati;
                        }
                    }
                }
            } break;
        case 7:     
            if(y == 0) throw std::out_of_range("Izlazak van igrace table");
            else if(polja[x][y-1] == Polje::BlokiranoPosjeceno || polja[x][y-1] == Polje::BlokiranoPrazno || polja[x][y-1] == Polje::BlokiranoMina)
            { 
                throw std::logic_error("Blokirano polje");
                vrati = Status::KrajPoraz;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                        polja[i][j] = Polje::Prazno;
                }
            }
            else {
                polja[x][y] = Polje::Posjeceno;
                y -= 1;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                    {
                        if(polja[i][j] == Polje::Prazno)
                        {
                            vrati = Status::NijeKraj;
                            return vrati;
                        }
                    }
                }
            } break;
        }
    return vrati;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
    Status vrati = Status::KrajPobjeda;
    int n = polja.size();
    if(novi_x &gt;= n || novi_y &gt;= n || novi_x &lt; 0 || novi_y &lt; 0) throw std::out_of_range("Izlazak van igrace table");
    else if(polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno || polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoMina)
            { 
                throw std::logic_error("Blokirano polje");
                vrati = Status::KrajPoraz;
                for(int i = 0; i &lt; n; i++)
                {
                    for(int j = 0; j &lt; n; j++)
                        polja[i][j] = Polje::Prazno;
                }
            }
    else {
        polja[x][y] = Polje::Posjeceno;
        x = novi_x;
        y = novi_y;                
        for(int i = 0; i &lt; n; i++)
        {
            for(int j = 0; j &lt; n; j++)
            {
                if(polja[i][j] == Polje::Prazno)
                {
                    vrati = Status::NijeKraj;
                    return vrati;
                }
            }
        }
    } return vrati;
}
enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar
};
void PrijaviGresku (KodoviGresaka greska)
{
    if(greska == KodoviGresaka::PogresnaKomanda) std::cout&lt;&lt;"Nerazumljiva komanda!";
    else if(greska == KodoviGresaka::NedostajeParmetar) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!";
    else if(greska == KodoviGresaka::SuvisanParametar) std::cout&lt;&lt;"Parametar komande nije ispravan!";
    else if(greska == KodoviGresaka::NeispravanParametar) std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!";
}
enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};
/*std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
    if(x &gt;= polja.size() || y &gt;= polja.size() || x &lt; 0 || y &lt; 0) throw std::domain_error("Polje ("+ std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
    std::vector&lt;std::vector&lt;int&gt;&gt; mat (3, std::vector&lt;int&gt;(3));
    std::vector&lt;int&gt; brojaci(9, 0);
    int n = polja.size();
    for(int i = x-1; i &lt;= x+1; i++)
    {
        for(int j = y-1; j &lt;= y+1; j++)
        {
            if()
        }
    }
}
*/
int main ()
{	
	return 0;
</font>}</pre>
</body>
</html>
