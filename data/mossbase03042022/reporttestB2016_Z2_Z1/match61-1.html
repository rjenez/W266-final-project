<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4495.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6913.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

//GLOBALNE DEKLARACIJE 
enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi {
 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};

<a name="1"></a><font color="#00FF00"><a href="match61-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;


//FUNKCIJE...
Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	
	for(int i=0;i&lt;mine.size();i++){
		if(mine[i].size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
	}
	
	for(int i=0;i&lt;mine.size();i++){
		for(int j=0;j&lt;2;j++){
			if(mine[i][j]&gt;=n) throw std::domain_error("Ilegalne pozicije mina");
		}
	}
	
	Tabla Tabla1(n,std::vector&lt;Polje&gt;(n,Polje::Prazno));
	for(int i=0; i&lt; mine.size();i++){
		int x=mine[i][0];
		int y=mine[i][1];
		Tabla1[x][y]=Polje::Mina;
	}
	
	return Tabla1;
}


std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	if(x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	
	
	std::vector&lt;std::vector&lt;int&gt;&gt;  StatusMine(3);
	int i=0;
	for(int X1=x-1;X1&lt;=x+1;X1++){
		for(int Y1=y-1;Y1&lt;=y+1;Y1++){
				int UkupnoMina(0);
			for(int X2=X1-1;X2&lt;=X1+1;X2++){
				for(int Y2=Y1-1;Y2&lt;=Y1+1;Y2++){
					if(X2&gt;=0 &amp;&amp; X2&lt; polja.size() &amp;&amp; Y2&gt;=0 &amp;&amp; Y2&lt;polja.size() &amp;&amp; !(X2==X1 &amp;&amp; Y2==Y1))																									//------
						if (polja[X2][Y2]==Polje::Mina)
							UkupnoMina++;
				}
				
			}
			
			StatusMine[i].push_back(UkupnoMina);
			
		}
		i++;
	}
	
	return StatusMine;
	
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	
	if(polja[x][y]==Polje::Prazno)
</font>		polja[x][y]=Polje::BlokiranoPrazno;
	else if (polja[x][y]==Polje::Posjeceno)
		polja[x][y]=Polje::BlokiranoPosjeceno; 
	else if (polja[x][y]==Polje::Mina)
<a name="11"></a><font color="#00FF00"><a href="match61-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		polja[x][y]=Polje::BlokiranoMina;
	
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&lt;0 || x&gt;=polja.size() || y&lt;0 || y&gt;=polja.size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	
	if(polja[x][y]==Polje::BlokiranoPrazno)
</font>		polja[x][y]=Polje::Prazno;
	else if (polja[x][y]==Polje::BlokiranoPosjeceno)
		polja[x][y]=Polje::Posjeceno; 
	else if (polja[x][y]==Polje::BlokiranoMina)
<a name="3"></a><font color="#00FFFF"><a href="match61-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

		polja[x][y]=Polje::Mina;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	
	int novi_x;
	int novi_y;
	
	switch(smjer){
		case Smjerovi::GoreLijevo:
			
			novi_x=x-1;novi_y=y-1;
				if(novi_x&lt;0 || novi_x&gt;=polja.size() ||  novi_y&lt;0 ||  novi_y&gt;=polja.size()) throw std::out_of_range  ("Izlazak van igrace table");
				if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno ||polja[novi_x][novi_y]==Polje::BlokiranoMina || polja[novi_x][novi_y]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
</font><a name="7"></a><font color="#0000FF"><a href="match61-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

				polja[x][y]=Polje::Posjeceno;
			x=novi_x;y=novi_y;
			
			break;
		case Smjerovi::Gore:
			
			novi_x=x-1;
			if( novi_x&lt;0 ||  novi_x&gt;=polja.size()) throw std::out_of_range  ("Izlazak van igrace table");
			if(polja[novi_x][y]==Polje::BlokiranoPosjeceno ||polja[novi_x][y]==Polje::BlokiranoMina || polja[novi_x][y]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
</font><a name="4"></a><font color="#FF00FF"><a href="match61-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

			polja[x][y]=Polje::Posjeceno;
			x=novi_x;
			
			break;
		case Smjerovi::GoreDesno:
			
			novi_x=x-1;novi_y=y+1;
			if(novi_x&lt;0 || novi_x&gt;=polja.size() ||  novi_y&lt;0 ||  novi_y&gt;=polja.size()) throw std::out_of_range  ("Izlazak van igrace table");
			if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno ||polja[novi_x][novi_y]==Polje::BlokiranoMina || polja[novi_x][novi_y]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
</font><a name="8"></a><font color="#00FFFF"><a href="match61-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			polja[x][y]=Polje::Posjeceno;
			x=novi_x;y=novi_y;		
			break;
		case Smjerovi::Desno: 
			
			novi_y=y+1;
			if( novi_y&lt;0 ||  novi_y&gt;=polja.size()) throw std::out_of_range  ("Izlazak van igrace table");
			if(polja[x][novi_y]==Polje::BlokiranoPosjeceno ||polja[x][novi_y]==Polje::BlokiranoMina || polja[x][novi_y]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
</font><a name="5"></a><font color="#FF0000"><a href="match61-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

			polja[x][y]=Polje::Posjeceno;
			y=novi_y;
			break;
		case Smjerovi::DoljeDesno:
				
				novi_x=x+1;novi_y=y+1;
					if(novi_x&lt;0 || novi_x&gt;=polja.size() ||  novi_y&lt;0 ||  novi_y&gt;=polja.size()) throw std::out_of_range  ("Izlazak van igrace table");
			if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno ||polja[novi_x][novi_y]==Polje::BlokiranoMina || polja[novi_x][novi_y]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
</font><a name="9"></a><font color="#FF00FF"><a href="match61-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

			polja[x][y]=Polje::Posjeceno;
			x=novi_x;y=novi_y;
			break;
		case Smjerovi::Dolje:
				
				novi_x=x+1;
				if( novi_x&lt;0 ||  novi_x&gt;=polja.size()) throw std::out_of_range  ("Izlazak van igrace table");
			if(polja[novi_x][y]==Polje::BlokiranoPosjeceno ||polja[novi_x][y]==Polje::BlokiranoMina || polja[novi_x][y]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
</font><a name="6"></a><font color="#00FF00"><a href="match61-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

			polja[x][y]=Polje::Posjeceno;
			x=novi_x;
			break;
		case Smjerovi::DoljeLijevo:
				
				novi_x=x+1;novi_y=y+1;
					if(novi_x&lt;0 || novi_x&gt;=polja.size() ||  novi_y&lt;0 ||  novi_y&gt;=polja.size()) throw std::out_of_range  ("Izlazak van igrace table");
					if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno ||polja[novi_x][novi_y]==Polje::BlokiranoMina || polja[novi_x][novi_y]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
</font><a name="10"></a><font color="#FF0000"><a href="match61-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

			polja[x][y]=Polje::Posjeceno;
			x=novi_x;y=novi_y;
			break;
		case Smjerovi::Lijevo:
				
				novi_y=y-1;
					if( novi_y&lt;0 ||  novi_y&gt;=polja.size()) throw std::out_of_range  ("Izlazak van igrace table");
					if(polja[x][novi_y]==Polje::BlokiranoPosjeceno ||polja[x][novi_y]==Polje::BlokiranoMina || polja[x][novi_y]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
</font><a name="2"></a><font color="#0000FF"><a href="match61-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

			polja[x][y]=Polje::Posjeceno;
			y=novi_y;
			break;
	}
	
	
	//Provjera novog polja
	if(polja[x][y]==Polje::Mina){
			for(int i=0;i&lt;polja.size();i++){
				for(int j=0;j&lt;polja[i].size();j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno)
			return Status::NijeKraj;
		else if(polja[x][y]==Polje::Posjeceno){
			bool ImaPrazno(false);
			for(int i=0;i&lt;polja.size();i++){
				for(int j=0;j&lt;polja.size();j++){
					if(polja[i][j]==Polje::Prazno)
						ImaPrazno=true;
				}
			}
			if(ImaPrazno==true)
				return Status::NijeKraj;
			else
				return Status::KrajPobjeda;
		}
	
}


Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
		if(novi_x&lt;0 || novi_x&gt;=polja.size() ||  novi_y&lt;0 ||  novi_y&gt;=polja.size()) throw std::out_of_range  ("Izlazak van igrace table");
		if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno ||polja[novi_x][novi_y]==Polje::BlokiranoMina || polja[novi_x][novi_y]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
</font>		
<a name="0"></a><font color="#FF0000"><a href="match61-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_49.gif"/></a>

		polja[x][y]=Polje::Posjeceno;
		
		x=novi_x;
		y=novi_y;
		
		if(polja[x][y]==Polje::Mina){
			for(int i=0;i&lt;polja.size();i++){
				for(int j=0;j&lt;polja[i].size();j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno)
			return Status::NijeKraj;
		else if(polja[x][y]==Polje::Posjeceno){
			bool ImaPrazno(false);
			for(int i=0;i&lt;polja.size();i++){
				for(int j=0;j&lt;polja.size();j++){
					if(polja[i][j]==Polje::Prazno)
						ImaPrazno=true;
				}
			}
			if(ImaPrazno==true)
				return Status::NijeKraj;
			else
				return Status::KrajPobjeda;
		}
}

void PrijaviGresku (KodoviGresaka greska){
	if(greska==KodoviGresaka::PogresnaKomanda)
		std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl;
	else if(greska==KodoviGresaka::NedostajeParametar)
		std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
	else if(greska== KodoviGresaka::SuvisanParametar)
		std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt; std::endl;
	else
		std::cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; std::endl;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y,KodoviGresaka &amp;greska){
	char znak;
	for(;;){
	
		std::cin.get(znak);
		while(znak!='\n' &amp;&amp; znak== ' ') std::cin.get(znak);
		if(znak=='K'){
			//Kreiraj
			std::cin.get(znak);
			while(znak!='\n'){
				if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);
			}
			komanda=Komande::KreirajIgru;
			return true;
		}
		
		else if( znak=='Z'){
			std::cin.get(znak);
			while(znak!='\n'){
				if((znak&gt;='a' &amp;&amp; znak &lt;='z')|| (znak&gt;='A' &amp;&amp; znak&lt;='Z')){ greska =KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);		
			}
			komanda=Komande::ZavrsiIgru;
			return true;
		}
		
		else if(znak=='P' &amp;&amp; std::cin.peek()=='O'){
			std::cin.get(znak); std::cin.get(znak);
			while(znak!='\n'){
				if((znak &gt;='a' &amp;&amp; znak &lt;='z') || (znak &gt;='A' &amp;&amp; znak&lt;='Z')){greska=KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);
			}
			komanda=Komande::PrikaziOkolinu;
			return true;
		}
		
		else if(znak=='P' &amp;&amp; std::cin.peek()=='1'){
			std::cin.get(znak); std::cin.get(znak);
			while(znak!='\n' &amp;&amp; znak!='G' &amp;&amp; znak!='D' &amp;&amp; znak!='L') std::cin.get(znak);
			if(znak=='\n'){greska=KodoviGresaka::NedostajeParametar; return false;}
			else if(znak=='G'){
				if(std::cin.peek()=='L'){
					std::cin.get(znak);std::cin.get(znak);
				while(znak!='\n'){
					if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
					std::cin.get(znak);
				}
			komanda=Komande::PomjeriJednoMjesto;
			smjer=Smjerovi::GoreLijevo;
			return true;
				
				}
				
				else if(std::cin.peek()=='D'){
					std::cin.get(znak);std::cin.get(znak);
			while(znak!='\n'){
				if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);
			}
					komanda=Komande::PomjeriJednoMjesto;
			smjer=Smjerovi::GoreDesno;
			return true;
			}
			else if(std::cin.peek()==' ' || std::cin.peek()=='\n'){
				std::cin.get(znak);
				while(znak!='\n'){
				if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);
			}
					komanda=Komande::PomjeriJednoMjesto;
			smjer=Smjerovi::Gore;
			return true;
			}
			
			}
			else if(znak=='D'){
				
			if(std::cin.peek()==' ' || std::cin.peek()=='\n'){
				std::cin.get(znak);
				while(znak!='\n'){
					if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);
				}
				komanda=Komande::PomjeriJednoMjesto;
			smjer=Smjerovi::Desno;
			return true;
			}
			else if(std::cin.peek()=='o'){
				std::cin.get(znak);
				if(std::cin.peek()=='D'){
					std::cin.get(znak); std::cin.get(znak);
					while(znak!='\n'){
						if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::DoljeDesno;
				}
				else if(std::cin.peek()=='L'){std::cin.get(znak); std::cin.get(znak);
					while(znak!='\n'){
						if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::Lijevo;}
				else if(std::cin.peek()==' '|| std::cin.peek()=='\n'){
					std::cin.get(znak);
					while(znak!='\n'){
						if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);
					}
					komanda=Komande::PomjeriJednoMjesto;
					smjer=Smjerovi::Dolje;
					return true;
				}
				else {
							greska=KodoviGresaka::NeispravanParametar;
							return false;
						}
			}
			else{
				greska=KodoviGresaka::NeispravanParametar;
				return false;
			}
		
		
		
		
		
			
			
			}
			else if(znak=='L'){
					std::cin.get(znak);
			while(znak!='\n'){
				if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				std::cin.get(znak);
			}
			komanda=Komande::PomjeriJednoMjesto;
			smjer=Smjerovi::Lijevo;
			return true;
			}
		
			else {
				greska=KodoviGresaka::NeispravanParametar;
				return false;
			}
			
		}
		
		
			else if(znak=='P' &amp;&amp; std::cin.peek()=='&gt;'){
				int X(0),  Y(0),broj(0);
				while (znak!='\n') {
						if(znak&gt;='0' &amp;&amp; znak &lt;='9'){
							broj++;
							if(broj==1){
								while(znak&gt;='0' &amp;&amp; znak &lt;='9'){
									X=(int)znak-48;
									if(std::cin.peek()&gt;='0' &amp;&amp; std::cin.peek() &lt;='9') X=X*10;
								}}
							else 	if(broj==2){
								while(znak&gt;='0' &amp;&amp; znak &lt;='9'){
									Y=(int)znak-48;
									if(std::cin.peek()&gt;='0' &amp;&amp; std::cin.peek() &lt;='9') Y=Y*10;
								}
							}
							else if(broj &gt;2 ){greska =KodoviGresaka::SuvisanParametar; return false;}
						}
						if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				}
			komanda=Komande::PomjeriDalje;	x=X;y=Y;return true;
			}
			else if(znak=='B' ){	int X(0),  Y(0),broj(0);
				while (znak!='\n') {
						if(znak&gt;='0' &amp;&amp; znak &lt;='9'){
							broj++;
							if(broj==1){
								while(znak&gt;='0' &amp;&amp; znak &lt;='9'){
									X=(int)znak-48;
									if(std::cin.peek()&gt;='0' &amp;&amp; std::cin.peek() &lt;='9') X=X*10;
								}}
							else 	if(broj==2){
								while(znak&gt;='0' &amp;&amp; znak &lt;='9'){
									Y=(int)znak-48;
									if(std::cin.peek()&gt;='0' &amp;&amp; std::cin.peek() &lt;='9') Y=Y*10;
								}
							}
							else if(broj &gt;2 ){greska =KodoviGresaka::SuvisanParametar; return false;}
						}
						if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				}
					komanda=Komande::Blokiraj;
							x=X;y=Y;return true;
			}
			else if(znak=='D'  ){	int X(0),  Y(0),broj(0);
				while (znak!='\n') {
						if(znak&gt;='0' &amp;&amp; znak &lt;='9'){
							broj++;
							if(broj==1){
								while(znak&gt;='0' &amp;&amp; znak &lt;='9'){
									X=(int)znak-48;
									if(std::cin.peek()&gt;='0' &amp;&amp; std::cin.peek() &lt;='9') X=X*10;
								}}
							else 	if(broj==2){
								while(znak&gt;='0' &amp;&amp; znak &lt;='9'){
									Y=(int)znak-48;
									if(std::cin.peek()&gt;='0' &amp;&amp; std::cin.peek() &lt;='9') Y=Y*10;
								}
							}
							else if(broj &gt;2 ){greska =KodoviGresaka::SuvisanParametar; return false;}
						}
						if((znak&gt;='a' &amp;&amp; znak &lt;='z') || (znak&gt;='A' &amp;&amp; znak&lt;='Z')) {greska=KodoviGresaka::SuvisanParametar; return false;}
				}	komanda=Komande::Deblokiraj;
							x=X;y=Y;return true;
			}
		else {
				greska=KodoviGresaka::PogresnaKomanda; 
				return false;
			
			
		}
	}
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y =0){
	if(komanda==Komande::)
	
}

//MAIN...
int main ()
{
	
	Tabla polja;

	int x(0),y(0);
	Smjerovi smjer;
	Komande cmd;
	KodoviGresaka greska;
	try  {
	for(;;){
		std::cout &lt;&lt; "Unesite komandu: ";
	
	
		if(!UnosKomande(cmd,smjer,x,y,greska))
		{	PrijaviGresku(greska); std::cout &lt;&lt; "GRESKA" &lt;&lt; std::endl;
		std::cin.ignore(10000,'\n');
		}
		
		else {std::cout &lt;&lt; "Radi!" &lt;&lt; std::endl; IzvrsiKomandu(cmd,polja,x,y,smjer);
	
	
		}
			
	}
	}
	catch(std::runtime_error ){
		std::cout&lt;&lt;"Dovidjenja!";
</font>	}
	
	

	
	return 0;
}</pre>
</body>
</html>
