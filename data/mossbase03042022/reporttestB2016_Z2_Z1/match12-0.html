<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student9325.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student9325.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;limits&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

<a name="2"></a><font color="#0000FF"><a href="match12-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_19.gif"/></a>

template&lt;typename T&gt; std::string PretvoriUString(T x) {
	std::ostringstream s; s &lt;&lt; x; return s.str();
}

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina 
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

void Ispisi(Tabla m) {
	for(int i = 0; i &lt; m.size(); i++) {
		for(int j = 0; j &lt; m.size(); j++) {
			std::cout &lt;&lt; int(m[i][j]) &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
}
void Ispisi(std::vector&lt;std::vector&lt;int&gt;&gt; m) {
	for(int i = 0; i &lt; m.size(); i++) {
		for(int j = 0; j &lt; m.size(); j++) {
			std::cout &lt;&lt; m[i][j] &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	for(int i = 0; i &lt; mine.size(); i++) 
		if(mine[i].size() != 2) 
			throw std::domain_error("Ilegalan format zadavanja mina");
			
	for(int i = 0; i &lt; mine.size(); i++) {
		for(int j = 0; j &lt; mine[0].size(); j++) {
			if(mine[i][j] &gt; n)
				throw std::domain_error("Ilegalne pozicije mina");
		}
	}
	
	Tabla igraca_tabla(n, std::vector&lt;Polje&gt; (n, Polje::Prazno));
	
	for(int i = 0; i &lt; mine.size(); i++) {
		igraca_tabla[mine[i][0]][mine[i][1]] = Polje::Mina; 
	}
	
	return igraca_tabla;
}

int brojMina(Tabla m, int x, int y) {
	int broj_mina = 0;
	int vel = m.size() - 1;
	
	// PRVI RED
	if(x-1 &gt;= 0 &amp;&amp; y-1 &gt;= 0 &amp;&amp; x-1 &lt;= vel &amp;&amp; y-1 &lt;= vel) 
		if(m[x-1][y-1] == Polje::Mina) broj_mina++;
	if(x-1 &gt;= 0 &amp;&amp; y &gt;= 0  &amp;&amp; x-1 &lt;= vel &amp;&amp; y &lt;= vel) 
		if(m[x-1][y] == Polje::Mina) broj_mina++;
	if(x-1 &gt;= 0 &amp;&amp; y+1 &gt;= 0 &amp;&amp; x-1 &lt;= vel  &amp;&amp; y+1 &lt;= vel) 
		if(m[x-1][y+1] == Polje::Mina) broj_mina++;
		
	// DRUGI RED
	if(x &gt;= 0 &amp;&amp; y-1 &gt;= 0 &amp;&amp; x &lt;= vel &amp;&amp; y &lt;= vel) 
		if(m[x][y-1] == Polje::Mina) broj_mina++;
	if(x &gt;= 0 &amp;&amp; y+1 &gt;= 0  &amp;&amp; x &lt;= vel &amp;&amp; y+1 &lt;= vel) 
		if(m[x][y+1] == Polje::Mina) broj_mina++;
		
	// TRECI RED
	if(x+1 &gt;= 0 &amp;&amp; y-1 &gt;= 0 &amp;&amp; x+1 &lt;= vel &amp;&amp; y-1 &lt;= vel) 
		if(m[x+1][y-1] == Polje::Mina) broj_mina++;
	if(x+1 &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x+1 &lt;= vel &amp;&amp; y &lt;= vel) 
		if(m[x+1][y] == Polje::Mina) broj_mina++;
	if(x+1 &gt;= 0 &amp;&amp; x+1 &gt;= 0 &amp;&amp; x+1 &lt;= vel &amp;&amp; y+1 &lt;= vel) 
		if(m[x+1][y+1] == Polje::Mina) broj_mina++;
	
	return broj_mina;
}
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	if(x &gt; polja.size() - 1 || y &gt; polja.size() - 1 || x &lt; 0 || y &lt; 0) {
		std::string izuzetak = "Polje (" + PretvoriUString(x) + "," + PretvoriUString(y) + ") ne postoji";
		throw std::domain_error(izuzetak);
	}
		
	std::vector&lt;std::vector&lt;int&gt;&gt; m(3, std::vector&lt;int&gt;(3));
	
	for(int i = 0, brojac_redova = x - 1; i &lt; 3; i++, brojac_redova++) {
		for(int j = 0, brojac_kolona = y - 1; j &lt; 3; j++, brojac_kolona++) {
			m[i][j] = brojMina(polja, brojac_redova, brojac_kolona);
		}
	}
	
	return m;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x &gt; polja.size() - 1 || y &gt; polja.size() - 1 || x &lt; 0 || y &lt; 0) {
		std::string izuzetak = "Polje (" + PretvoriUString(x) + "," + PretvoriUString(y) + ") ne postoji";
		throw std::domain_error(izuzetak);
	}
	
	if(polja[x][y] == Polje::Prazno) {
		polja[x][y] = Polje::BlokiranoPrazno;
</font>	}
	else if(polja[x][y] == Polje::Posjeceno) {
		polja[x][y] = Polje::BlokiranoPosjeceno;
	}
	else if(polja[x][y] == Polje::Mina) {
<a name="3"></a><font color="#00FFFF"><a href="match12-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		polja[x][y] = Polje::BlokiranoMina;
	}
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x &gt; polja.size() - 1 || y &gt; polja.size() - 1 || x &lt; 0 || y &lt; 0) {
		std::string izuzetak = "Polje (" + PretvoriUString(x) + "," + PretvoriUString(y) + ") ne postoji";
		throw std::domain_error(izuzetak);
	}
		
	if(polja[x][y] == Polje::BlokiranoPrazno) {
		polja[x][y] = Polje::Prazno;
</font>	}
	else if(polja[x][y] == Polje::BlokiranoPosjeceno) {
		polja[x][y] = Polje::Posjeceno;
	}
<a name="1"></a><font color="#00FF00"><a href="match12-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_21.gif"/></a>

	else if(polja[x][y] == Polje::BlokiranoMina) {
		polja[x][y] = Polje::Mina;
	}
}

enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	int vel = polja.size() - 1;
	
	if(smjer == Smjerovi::GoreLijevo &amp;&amp; x-1 &gt;= 0 &amp;&amp; y-1 &gt;= 0) {
		if(polja[x-1][y-1] == Polje::BlokiranoMina || polja[x-1][y-1] == Polje::BlokiranoPosjeceno || polja[x-1][y-1] == Polje::BlokiranoPrazno)
			throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x -= 1; y -= 1;
	}
	else if(smjer == Smjerovi::Gore &amp;&amp; x-1 &gt;= 0) {
		if(polja[x-1][y] == Polje::BlokiranoMina || polja[x-1][y] == Polje::BlokiranoPosjeceno || polja[x-1][y] == Polje::BlokiranoPrazno)
			throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x -= 1;
	}
	else if(smjer == Smjerovi::GoreDesno &amp;&amp; x-1 &gt;= 0 &amp;&amp; y+1 &lt;= vel) {
		if(polja[x-1][y+1] == Polje::BlokiranoMina || polja[x-1][y+1] == Polje::BlokiranoPosjeceno || polja[x-1][y+1] == Polje::BlokiranoPrazno)
			throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x -= 1; y += 1;
	}
	else if(smjer == Smjerovi::Desno &amp;&amp; y+1 &lt;= vel) {
		if(polja[x][y+1] == Polje::BlokiranoMina || polja[x][y+1] == Polje::BlokiranoPosjeceno || polja[x][y+1] == Polje::BlokiranoPrazno)
			throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		y += 1;
	}
	else if(smjer == Smjerovi::DoljeDesno &amp;&amp; x+1 &lt;= vel &amp;&amp; y+1 &lt;= vel) {
		if(polja[x+1][y+1] == Polje::BlokiranoMina || polja[x+1][y+1] == Polje::BlokiranoPosjeceno || polja[x+1][y+1] == Polje::BlokiranoPrazno)
			throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x += 1; y += 1;
	}
	else if(smjer == Smjerovi::Dolje &amp;&amp; x+1 &lt;= vel ) {
		if(polja[x+1][y] == Polje::BlokiranoMina || polja[x+1][y] == Polje::BlokiranoPosjeceno || polja[x+1][y] == Polje::BlokiranoPrazno)
			throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x += 1;
	}
	else if(smjer == Smjerovi::DoljeLijevo &amp;&amp; x+1 &lt;= vel &amp;&amp; y-1 &gt;= 0) {
		if(polja[x+1][y-1] == Polje::BlokiranoMina || polja[x+1][y-1] == Polje::BlokiranoPosjeceno || polja[x+1][y-1] == Polje::BlokiranoPrazno)
			throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x += 1; y -= 1;
	}
	else if(smjer == Smjerovi::Lijevo &amp;&amp; y-1 &gt;= 0) {
		if(polja[x][y-1] == Polje::BlokiranoMina || polja[x][y-1] == Polje::BlokiranoPosjeceno || polja[x][y-1] == Polje::BlokiranoPrazno)
			throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		y -= 1;
	} 
	else throw std::out_of_range("Izlazak van igrace table");
	
	if(polja[x][y] == Polje::Mina) {
		for(int i = 0; i &lt; polja.size(); i++) {
			for(int j = 0; j &lt; polja.size(); j++) {
				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	bool ImaLiPraznih = false;
	for(int i = 0; i &lt; polja.size(); i++) {
		for(int j = 0; j &lt; polja.size(); j++) {
			if(i == x &amp;&amp; j == y) continue;
			if(polja[i][j] == Polje::Prazno) {
				ImaLiPraznih = true;
			}
		}
	}
	if(ImaLiPraznih == false) return Status::KrajPobjeda;
	return Status::NijeKraj;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	if(novi_x &lt; 0 || novi_y &lt; 0 || novi_x &gt; polja.size() - 1 || novi_y &gt; polja.size() - 1)
		throw std::out_of_range("Izlazak van igrace table");
	if(polja[novi_x][novi_y] == Polje::BlokiranoMina || polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno || polja[novi_x][novi_y] == Polje::BlokiranoPrazno)
</font>		throw std::logic_error("Blokirano polje");
	
<a name="0"></a><font color="#FF0000"><a href="match12-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_54.gif"/></a>

	polja[x][y] = Polje::Posjeceno;
	x = novi_x;
	y = novi_y;
		
	if(polja[x][y] == Polje::Mina) {
		for(int i = 0; i &lt; polja.size(); i++) {
			for(int j = 0; j &lt; polja.size(); j++) {
				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	bool ImaLiPraznih = false;
	for(int i = 0; i &lt; polja.size(); i++) {
		for(int j = 0; j &lt; polja.size(); j++) {
			if(i == x &amp;&amp; j == y) continue;
			if(polja[i][j] == Polje::Prazno) {
				ImaLiPraznih = true;
			}
		}
	}
	if(ImaLiPraznih == false) return Status::KrajPobjeda;
	return Status::NijeKraj;
}

enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
void PrijaviGresku(KodoviGresaka greska) {
	if(greska == KodoviGresaka::PogresnaKomanda)
		std::cout &lt;&lt; "Nerazumljiva komanda!\n";
	else if(greska == KodoviGresaka::NedostajeParametar) 
		std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!\n";
	else if(greska == KodoviGresaka::SuvisanParametar)
		std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!\n";
	else if(greska == KodoviGresaka::NeispravanParametar)
		std::cout &lt;&lt; "Parametar komande nije ispravan!\n";
}

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, 
	ZavrsiIgru, KreirajIgru
};

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
	std::string k;
	std::getline(std::cin, k);
	
	std::string p1 = "";
	bool usao = false;
	int brojac = 0;
	
	for(int i = 0; i &lt; k.length(); i++) {
		if(k[i] == ' ') continue;
		
		if(k[i] == 'P' &amp;&amp; i+1 &lt; k.length() &amp;&amp; k[i+1] == '1') {
			for(int j = i+2; j &lt; k.length(); j++) {
				if(k[j] == ' ') continue;
				usao = true;
				
				if(k[j] == 'G' &amp;&amp; j+1 &lt; k.length() &amp;&amp; k[j+1] == 'D') {
					for(int l = j+2; l &lt; k.length(); l++) {
						if(k[l] == ' ') continue;
						else {
							greska = KodoviGresaka::SuvisanParametar;
							goto izlaz;
						}
					}
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::GoreDesno;
					return true;
				}
				else if(k[j] == 'G' &amp;&amp; j+1 &lt; k.length() &amp;&amp; k[j+1] == 'L') {
					for(int l = j+2; l &lt; k.length(); l++) {
						if(k[l] == ' ') continue;
						else {
							greska = KodoviGresaka::SuvisanParametar;
							goto izlaz;
						}
					}
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::GoreLijevo;
					return true;;
				}
				else if(k[j] == 'G') {
					for(int l = j+1; l &lt; k.length(); l++) {
						if(k[l] == ' ') continue;
						else {
							greska = KodoviGresaka::SuvisanParametar;
							goto izlaz;
						}
					}
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::Gore;
					return true;
				}
				
				else if(k[j] == 'D' &amp;&amp; j+2 &lt; k.length() &amp;&amp; k[j+1] == 'o' &amp;&amp; k[j+2] == 'D') {
					for(int l = j+3; l &lt; k.length(); l++) {
						if(k[l] == ' ') continue;
						else {
							
							greska = KodoviGresaka::SuvisanParametar;
							goto izlaz;
						}
					}
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::DoljeDesno;
					return true;
				}
				else if(k[j] == 'D' &amp;&amp; j+2 &lt; k.length() &amp;&amp; k[j+1] == 'o' &amp;&amp; k[j+2] == 'L') {
					for(int l = j+3; l &lt; k.length(); l++) {
						if(k[l] == ' ') continue;
						else {
							greska = KodoviGresaka::SuvisanParametar;
							goto izlaz;
						}
					}
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::DoljeLijevo;
					return true;
				}
				else if(k[j] == 'D' &amp;&amp; j+1 &lt; k.length() &amp;&amp; k[j+1] == 'o') {
					
					for(int l = j+2; l &lt; k.length(); l++) {
						if(k[l] == ' ') continue;
						else {
							
							greska = KodoviGresaka::SuvisanParametar;
							goto izlaz;
						}
					}
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::Dolje;
					
					return true;
				}
			
				else if(k[j] == 'D') {
					for(int l = j+1; l &lt; k.length(); l++) {
						if(k[l] == ' ') continue;
						else {
							greska = KodoviGresaka::SuvisanParametar;
							goto izlaz;
						}
					}
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::Desno;
					return true;
				}
				else if(k[j] == 'L') {
					for(int l = j+1; l &lt; k.length(); l++) {
						if(k[l] == ' ') continue;
						else {
							greska = KodoviGresaka::SuvisanParametar;
							goto izlaz;
						}
					}
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::Lijevo;
					return true;
				}
				else if(k[j] == 'D' &amp;&amp; j+2 &lt; k.length() &amp;&amp; k[j+1] == 'o') {
					
					for(int l = j+2; l &lt; k.length(); l++) {
						if(k[l] == ' ') continue;
						else {
							
							greska = KodoviGresaka::SuvisanParametar;
							goto izlaz;
						}
					}
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::Dolje;
					
					return true;
				}
				else {
					greska = KodoviGresaka::NeispravanParametar;
					goto izlaz;
				}
			}
			if(usao == false) {
				greska = KodoviGresaka::NedostajeParametar;
				goto izlaz;
			}
		}
		else if(k[i] == 'K') {
			for(int j = i+1; j &lt; k.length(); j++) {
				if(k[j] == ' ') continue;
				else {
					greska = KodoviGresaka::SuvisanParametar;
					goto izlaz;
				}
			}
			komanda = Komande::KreirajIgru;
			return true;
		}
		else if(k[i] == 'P' &amp;&amp; i+1 &lt; k.length() &amp;&amp; k[i+1] == 'O') {
			for(int j = i+2; j &lt; k.length(); j++) {
				if(k[j] == ' ') continue;
				else {
					greska = KodoviGresaka::SuvisanParametar;
					goto izlaz;
				}
			}
			komanda = Komande::PrikaziOkolinu;
			return true;
		}
		else if(k[i] == 'Z') {
			for(int j = i+1; j &lt; k.length(); j++) {
				if(k[j] == ' ') continue;
				else {
					greska = KodoviGresaka::SuvisanParametar;
					goto izlaz;
				}
			}
			komanda = Komande::ZavrsiIgru;
			return true;
		}
		else if(k[i] == 'B') {
			for(int j = i+1; j &lt; k.length(); j++) {
				if(k[j] == ' ') continue;
				
				usao = true;
				p1.erase(p1.begin(), p1.end());
				
				if(brojac &gt; 1) {
					greska = KodoviGresaka::SuvisanParametar;
					goto izlaz;
				}
				
				if(k[j] &gt;= '0' &amp;&amp; k[j] &lt;= '9') {
					while(j &lt; k.length() &amp;&amp; k[j] &gt;= '0' &amp;&amp; k[j] &lt;= '9') {
						p1 += k[j++];
					}
					if(brojac == 0) {
						x = std::stoi(p1);
						brojac++;
					}
					else if(brojac == 1) {
						y = std::stoi(p1);
						brojac++;
					}
				}
				else {
					greska = KodoviGresaka::NeispravanParametar;
					goto izlaz;
				}
			}
			
			if(usao == false) {
				greska = KodoviGresaka::NedostajeParametar;
				goto izlaz;
			} 
			
			komanda = Komande::Blokiraj;
			return true;
		}
		else if(k[i] == 'D') {
			for(int j = i+1; j &lt; k.length(); j++) {
				if(k[j] == ' ') continue;
				
				usao = true;
				p1.erase(p1.begin(), p1.end());
				
				if(brojac &gt; 1) {
					greska = KodoviGresaka::SuvisanParametar;
					goto izlaz;
				}
				
				if(k[j] &gt;= '0' &amp;&amp; k[j] &lt;= '9') {
					while(j &lt; k.length() &amp;&amp; k[j] &gt;= '0' &amp;&amp; k[j] &lt;= '9') {
						p1 += k[j++];
					}
					if(brojac == 0) {
						x = std::stoi(p1);
						brojac++;
					}
					else if(brojac == 1) {
						y = std::stoi(p1);
						brojac++;
					}
				}
				else {
					greska = KodoviGresaka::NeispravanParametar;
					goto izlaz;
				}
			}
			
			if(usao == false) {
				greska = KodoviGresaka::NedostajeParametar;
				goto izlaz;
			}
			
			komanda = Komande::Deblokiraj;
			return true;
		}
		else if(k[i] == 'P' &amp;&amp; i+1 &lt; k.length() &amp;&amp; k[i+1] == '&gt;') {
			for(int j = i+2; j &lt; k.length(); j++) {
				if(k[j] == ' ') continue;
				usao = true;
				p1.erase(p1.begin(), p1.end());
				if(brojac &gt; 1) {
					greska = KodoviGresaka::SuvisanParametar;
					goto izlaz;
				}
				
				if(k[j] &gt;= '0' &amp;&amp; k[j] &lt;= '9') {
					while(j &lt; k.length() &amp;&amp; k[j] &gt;= '0' &amp;&amp; k[j] &lt;= '9') {
						p1 += k[j++];
					}
					if(brojac == 0) {
						x = std::stoi(p1);
						brojac++;
					}
					else if(brojac == 1) {
						y = std::stoi(p1);
						brojac++;
					}
				}
				else {
					greska = KodoviGresaka::NeispravanParametar;
					goto izlaz;
				}
				
			}
			if(usao == false) {
				greska = KodoviGresaka::NedostajeParametar;
				goto izlaz;
			}
			
			komanda = Komande::PomjeriDalje;
			return true;
		}
		else {
			greska = KodoviGresaka::PogresnaKomanda;
			goto izlaz;
		}
	}
	
izlaz:
	return false;
	
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y,
Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
	if(komanda == Komande::PomjeriJednoMjesto) {
		Status s;
		s = Idi(polja, x, y, p_smjer);
		
		if(s == Status::KrajPobjeda) {
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja\n";
			for(int i = 0; i &lt; polja.size(); i++) {
				for(int j = 0; j &lt; polja.size(); j++) {
					polja[i][j] = Polje::Prazno;
				}
			}
			throw std::runtime_error("Igra zavrsena\n");
		}
		else if(s == Status::KrajPoraz) {
			std::cout &lt;&lt; "Nagazili ste na minu\n";
			for(int i = 0; i &lt; polja.size(); i++) {
				for(int j = 0; j &lt; polja.size(); j++) {
					polja[i][j] = Polje::Prazno;
				}
			}
			throw std::runtime_error("Igra zavrsena\n");			
		}
		
		std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")\n";
	}
	else if(komanda == Komande::PomjeriDalje) {
		Status s;
		s = Idi(polja, x, y, p_x, p_y);	
		
		if(s == Status::KrajPobjeda) {
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja\n";
			for(int i = 0; i &lt; polja.size(); i++) {
				for(int j = 0; j &lt; polja.size(); j++) {
					polja[i][j] = Polje::Prazno;
				}
			}
			throw std::runtime_error("Igra zavrsena");
		}
		else if(s == Status::KrajPoraz) {
			std::cout &lt;&lt; "Nagazili ste na minu\n";
			for(int i = 0; i &lt; polja.size(); i++) {
				for(int j = 0; j &lt; polja.size(); j++) {
					polja[i][j] = Polje::Prazno;
				}
			}
			throw std::runtime_error("Igra zavrsena\n");			
		}
		
		std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")\n";
	}
	else if(komanda == Komande::Blokiraj) {
		BlokirajPolje(polja, p_x, p_y);
	}
	else if(komanda == Komande::Deblokiraj) {
		DeblokirajPolje(polja, p_x, p_y);
	}
	else if(komanda == Komande::PrikaziOkolinu) {
		auto m = PrikaziOkolinu(polja, x, y);
		Ispisi(m);
	}
	else if(komanda == Komande::ZavrsiIgru) {
		for(int i = 0; i &lt; polja.size(); i++) {
			for(int j = 0; j &lt; polja.size(); j++) {
				polja[i][j] = Polje::Prazno;
			}
		}
		throw std::runtime_error("Igra zavrsena");
	}
	else if(komanda == Komande::KreirajIgru) {
		int broj_polja;
		std::cout &lt;&lt; "Unesite broj polja: ";
		std::cin &gt;&gt; broj_polja;
		std::string unos;
		
		std::vector&lt;std::vector&lt;int&gt;&gt; mine;
		std::vector&lt;int&gt; pomocni;
		
		std::cin.clear();
		std::cin.ignore(10000,'\n');
		
		std::cout &lt;&lt; "Unesite pozicije mina: ";
		while(true) {
			std::getline(std::cin, unos);
			
			if(unos == ".") break;
			if(unos[0] != '(') {
				std::cout &lt;&lt; "Greska, unesite ponovo!\n";
				continue;
			}
			std::string p1;
			std::string p2;
			for(int i = 1; i &lt; unos.length(); i++) {
				while(i &lt; unos.length() &amp;&amp; unos[i] != ',' &amp;&amp; unos[i] &gt;= '0' &amp;&amp; unos[i] &lt;= '9') {
					p1+=unos[i];
					i++;
				}
				if(unos[i] != ',') {
					std::cout &lt;&lt; "Greska, unesite ponovo!\n";
					break;
				}
				else {
					pomocni.push_back(std::stoi(p1));
					i++;
					while(i &lt; unos.length() &amp;&amp; unos[i] != ')' &amp;&amp; unos[i] &gt;= '0' &amp;&amp; unos[i] &lt;= '9') {
						p2+=unos[i];
						i++;
					}
					if(unos[i] != ')') {
						std::cout &lt;&lt; "Greska, unesite ponovo!\n";
						pomocni.erase(pomocni.begin(), pomocni.end());
						break;
					}
					else {
						if(std::stoi(p1) &gt; broj_polja-1 || std::stoi(p2) &gt; broj_polja-1 || std::stoi(p1) &lt; 0 || std::stoi(p2) &lt; 0) {
							std::cout &lt;&lt; "Greska, unesite ponovo!\n";
							pomocni.erase(pomocni.begin(), pomocni.end());
							break;							
						}
						pomocni.push_back(std::stoi(p2));
						mine.push_back(pomocni);
						pomocni.erase(pomocni.begin(), pomocni.end());
					}
				}
			}
		}
		polja = KreirajIgru(broj_polja, mine);
	}
}

int main() {
	bool daLiJeIspravanUnos;
	Komande komanda;
	Smjerovi smjer;
	int x = 0; int y = 0;
	KodoviGresaka greska;
	Tabla polja;
	int p_x = 0, p_y = 0;
	
	while(true) {
		std::cout &lt;&lt; "Unesite komandu: ";
		
		daLiJeIspravanUnos = UnosKomande(komanda, smjer, p_x, p_y, greska);
		
		if(daLiJeIspravanUnos == false) {
			PrijaviGresku(greska);
		}
		else {
			try {
				IzvrsiKomandu(komanda, polja, x, y, smjer, p_x, p_y);
			}
			catch(std::runtime_error) {
				std::cout &lt;&lt; "Dovidjenja!";
				return 0;
			}
			catch(std::domain_error izuzetak) {
				std::cout &lt;&lt; izuzetak.what();
				std::cout &lt;&lt; std::endl;
			}
			catch(std::logic_error izuzetak) {
				std::cout &lt;&lt; izuzetak.what();
				std::cout &lt;&lt; std::endl;
			}
			catch(std::out_of_range izuzetak) {
				std::cout &lt;&lt; izuzetak.what();
				std::cout &lt;&lt; std::endl;
			}
		}
	}
	return 0;
</font>}</pre>
</body>
</html>
