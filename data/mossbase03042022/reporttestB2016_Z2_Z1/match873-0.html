<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4628.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4628.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1

	NAPOMENA: i javni ATo-vi su dio postavke

	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba

*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;

enum class Komande
{
    PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

enum class KodoviGresaka
{
    PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar
};

enum class Status
{
    NijeKraj, KrajPoraz, KrajPobjeda
};

enum class Smjerovi
{
    GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Polje
{
    Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

using std::cout;
using std::cin;
using std::endl;
using std::string;
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;
typedef std::vector&lt;int&gt; Vektor;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine)
{
	for(int i = 0; i &lt; mine.size() - 1; i++) {
		if(mine.at(i).size() != mine.at(i + 1).size())
			throw std::domain_error ("Ilegalan format zadavanje mina");
		for(int j = 0; j &lt; mine.at(0).size(); j++) {
			if(mine.at(i).at(j) &gt; n)
				throw std::domain_error("Ilegalne pozicije mina");
		}
	}

	Tabla polja(n, std::vector&lt;Polje&gt; (n, Polje::Prazno));

	for(int i = 0; i &lt; n; i++) {
		for(int j = 0; j &lt; n; j++) {
			for(int k = 0; k &lt; mine.size(); k++) {
				for(int l = 0; l &lt; mine.at(0).size() - 1; l++) {
					if(i == mine.at(k).at(l)) {
						if(j == mine.at(k).at(l + 1)) {
							polja.at(i).at(j) = Polje::Mina;
							break;
						}
					} else break;
				}
			}
		}
	}

	return polja;
}

<a name="10"></a><font color="#FF0000"><a href="match873-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

Matrica PrikaziOkolinu (const Tabla &amp;polja, int x, int y)
{
	if(x &gt;= polja.size() || y &gt;= polja[0].size() || x &lt; 0 || y &lt; 0)
		throw std::domain_error("Polje (x,y) ne postoji");
</font>
	Matrica mat;
	Vektor temp;
	for(int i = x - 1; i &lt;= x + 1; i++) {
		for(int j = y - 1; j &lt;= y + 1; j++) {
			int br(0);
			for(int k = i - 1; k &lt;= i + 1; k++) {
				for(int l = j - 1; l &lt;= j + 1; l++) {
					if(k == i &amp;&amp; l == j) continue;
					if(k &lt; 0 || k &gt;= polja.size() || l &lt; 0 || l &gt;= polja[0].size() || polja[k][l] == Polje::Prazno )
						continue;
					else br += 1;
				}
			}
			temp.push_back(br);
			br = 0;
		}
		mat.push_back(temp);
		temp.clear();
	}
	return mat;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x &gt;= polja.size() || x &lt; 0 || y &gt;= polja[0].size() || y &lt; 0)
		throw std::domain_error ("Polje (x,y) ne postoji");

<a name="5"></a><font color="#FF0000"><a href="match873-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

	for(int i = 0; i &lt; polja.size(); i++) {
		for(int j = 0; j &lt; polja[0].size(); j++) {
			if(i == x &amp;&amp; j == y) {
				if(polja[i][j] == Polje::Prazno) polja[i][j] = Polje::BlokiranoPrazno;
</font>				if(polja[i][j] == Polje::Mina) polja[i][j] = Polje::BlokiranoMina;
<a name="11"></a><font color="#00FF00"><a href="match873-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

				if(polja[i][j] == Polje::Posjeceno) polja[i][j] = Polje::BlokiranoPosjeceno;
			}
		}
	}
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x &gt;= polja.size() || x &lt; 0 || y &gt;= polja[0].size() || y &lt; 0)
</font>		throw std::domain_error ("Polje (x,y) ne postoji");

<a name="6"></a><font color="#00FF00"><a href="match873-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	for(int i = 0; i &lt; polja.size(); i++) {
		for(int j = 0; j &lt; polja[0].size(); j++) {
			if(i == x &amp;&amp; j == y) {
				if(polja[i][j] == Polje::BlokiranoPrazno) polja[i][j] = Polje::Prazno;
</font>				if(polja[i][i] == Polje::BlokiranoPosjeceno) polja[i][j] = Polje::Posjeceno;
				if(polja[i][j] == Polje::BlokiranoMina) polja[i][j] = Polje::Mina;
			}
		}
	}
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
<a name="0"></a><font color="#FF0000"><a href="match873-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	int i(x), j(y);
	if(smjer == Smjerovi::GoreLijevo) {
		if(i - 1 &lt; 0 || j - 1 &lt; 0) throw std::out_of_range ("Izlazak van igrace table");
		else {
			if(polja[i - 1][j - 1] == Polje::BlokiranoPrazno || polja[i - 1][j - 1] == Polje::BlokiranoMina || polja[i - 1][j - 1] == Polje::BlokiranoPosjeceno)
				throw std::logic_error("Blokirano polje");
</font>			if(polja[i - 1][j - 1] == Polje::Mina) return Status::KrajPoraz;
			polja[i][j] = Polje::Posjeceno;
			x = x - 1;
			y = y - 1;
		}
	}
<a name="3"></a><font color="#00FFFF"><a href="match873-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

	if(smjer == Smjerovi::Gore) {
		if(i - 1 &lt; 0) throw std::out_of_range ("Izlazak van igrace table");
		else {
			if(polja[i - 1][j] == Polje::BlokiranoPrazno || polja[i - 1][j] == Polje::BlokiranoMina || polja[i - 1][j] == Polje::BlokiranoPosjeceno)
				throw std::logic_error("Blokirano polje");
</font>			if(polja[i - 1][j] == Polje::Mina) return Status::KrajPoraz;
			polja[i][j] = Polje::Posjeceno;
			x = x - 1;
		}
	}
	if(smjer == Smjerovi::GoreDesno) {
<a name="4"></a><font color="#FF00FF"><a href="match873-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

		if(i - 1 &lt; 0 || j + 1 == polja[0].size()) throw std::out_of_range ("Izlazak van igrace table");
		else {
			if(polja[i - 1][j + 1] == Polje::BlokiranoPrazno || polja[i - 1][j + 1] == Polje::BlokiranoMina || polja[i - 1][j + 1] == Polje::BlokiranoPosjeceno)
				throw std::logic_error("Blokirano polje");
</font>			if(polja[i - 1][j + 1] == Polje::Mina) return Status::KrajPoraz;
			polja[i][j] = Polje::Posjeceno;
			x = x - 1;
			y = y + 1;
		}
	}
	if(smjer == Smjerovi::Desno) {
<a name="7"></a><font color="#0000FF"><a href="match873-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		if(j + 1 == polja[0].size()) throw std::out_of_range ("Izlazak van igrace table");
		else {
			if(polja[i][j + 1] == Polje::BlokiranoPrazno || polja[i][j + 1] == Polje::BlokiranoMina || polja[i][j + 1] == Polje::BlokiranoPosjeceno)
				throw std::logic_error("Blokirano polje");
</font>			if(polja[i][j + 1] == Polje::Mina) return Status::KrajPoraz;
			polja[i][j] = Polje::Posjeceno;
			y = y + 1;
		}
	}
	if(smjer == Smjerovi::DoljeDesno) {
		if(i + 1 == polja.size() || j + 1 == polja[0].size()) throw std::out_of_range ("Izlazak van igrace table");
		else {
<a name="9"></a><font color="#FF00FF"><a href="match873-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

			if(polja[i + 1][j + 1] == Polje::BlokiranoPrazno || polja[i + 1][j + 1] == Polje::BlokiranoMina || polja[i + 1][j + 1] == Polje::BlokiranoPosjeceno)
				throw std::logic_error("Blokirano polje");
</font>			if(polja[i + 1][j + 1] == Polje::Mina) return Status::KrajPoraz;
			polja[i][j] = Polje::Posjeceno;
			x = x + 1;
			y = y + 1;
		}
	}
	if(smjer == Smjerovi::Dolje) {
<a name="8"></a><font color="#00FFFF"><a href="match873-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

		if(i + 1 == polja.size()) throw std::out_of_range ("Izlazak van igrace table");
		else {
			if(polja[i + 1][j] == Polje::BlokiranoPrazno || polja[i + 1][j] == Polje::BlokiranoMina || polja[i + 1][j] == Polje::BlokiranoPosjeceno)
				throw std::logic_error("Blokirano polje");
</font>			if(polja[i + 1][j] == Polje::Mina) return Status::KrajPoraz;
			polja[i][j] = Polje::Posjeceno;
			x = x + 1;
		}
	}
	if(smjer == Smjerovi::DoljeLijevo) {
<a name="1"></a><font color="#00FF00"><a href="match873-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

		if(i + 1 == polja.size() || j - 1 &lt; 0) throw std::out_of_range ("Izlazak van igrace table");
		else {
			if(polja[i + 1][j - 1] == Polje::BlokiranoPrazno || polja[i + 1][j - 1] == Polje::BlokiranoMina || polja[i + 1][j - 1] == Polje::BlokiranoPosjeceno)
				throw std::logic_error("Blokirano polje");
</font>			if(polja[i + 1][j - 1] == Polje::Mina) return Status::KrajPoraz;
			polja[i][j] = Polje::Posjeceno;
			x = x + 1;
			y = y - 1;
		}
	}
<a name="2"></a><font color="#0000FF"><a href="match873-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

	if(smjer == Smjerovi::Lijevo) {
		if(j - 1 &lt; 0) throw std::out_of_range ("Izlazak van igrace table");
		else {
			if(polja[i][j - 1] == Polje::BlokiranoPrazno || polja[i][j - 1] == Polje::BlokiranoMina || polja[i][j - 1] == Polje::BlokiranoPosjeceno)
				throw std::logic_error("Blokirano polje");
</font>			if(polja[i][j - 1] == Polje::Mina) return Status::KrajPoraz;
			polja[i][j] = Polje::Posjeceno;
			y = y - 1;
		}
	}
	bool prazno = false;
<a name="12"></a><font color="#0000FF"><a href="match873-1.html#12" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	for(int i = 0; i &lt; polja.size(); i++) {
		for(int j = 0; j &lt; polja[0].size(); j++)
			if(polja[i][j] == Polje::Prazno) prazno = true;
</font>	}
	if(prazno == false) return Status::KrajPobjeda;

	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if(x &lt; 0 || x &gt; polja.size() || y &lt; 0 || y &gt; polja[0].size())
		throw std::out_of_range ("Izlazak van igrace table");
	if(novi_x &lt; 0 || novi_x &gt; polja.size() || y &lt; 0 || y &gt; polja[0].size())
		throw std::out_of_range ("Izlazak van igrace table");
	if(polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoMina || polja[novi_x][novi_x] == Polje::BlokiranoPosjeceno)
		throw std::logic_error ("Blokirano polje");
	if(polja[novi_x][novi_y] == Polje::Mina) return Status::KrajPoraz;

	x = novi_x;
	y = novi_y;

	bool prazno = false;
<a name="13"></a><font color="#00FFFF"><a href="match873-1.html#13" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	for(int i = 0; i &lt; polja.size(); i++) {
		for(int j = 0; j &lt; polja[0].size(); j++)
			if(polja[i][j] == Polje::Prazno) prazno = true;
</font>	}
	if(prazno == false) return Status::KrajPobjeda;

	return Status::NijeKraj;
}

void PrijaviGresku(KodoviGresaka greska)
{
	if(greska == KodoviGresaka::PogresnaKomanda)
		cout &lt;&lt; "Nerazumljiva komanda!";
	if(greska == KodoviGresaka::NedostajeParmetar)
		cout &lt;&lt; "Komanda trazi parametar koji nije naveden!";
	if(greska == KodoviGresaka::NeispravanParametar)
		cout &lt;&lt; "Parametar komande nije ispravan!";
	if(greska == KodoviGresaka::SuvisanParametar)
		cout &lt;&lt; "Zadan je suvisan parametar nakon komande!";
}

/*bool UnosKomande (Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;kod_greska)
{
	string s;
	getline(cin, s);

	for(int i = 0; i &lt; s.length(); i++) {
		if(s[i] == ' ') i++;

		if(s[i] == 'P' &amp;&amp; s[i + 1] == '1') {
			komanda = Komande::PomjeriJednoMjesto;
			i += 2;
			while(s[i] == ' ') i++;

			if(s[i] == 'G') {
				if(s[i + 1] == 'L') {
					i += 2;
					while(s[i] == ' ') i++;
					if(s[i] != ' ' || s[i] != s.length())
						kod_greska = KodoviGresaka::SuvisanParametar;
					else smjer = Smjerovi::GoreLijevo;
				} else if(s[i +1] == 'D') {
					i += 2;
					while(s[i] == ' ') i++;
					if(s[i] != ' ' || s[i] != s.length())
						kod_greska = KodoviGresaka::SuvisanParametar;
					else smjer = Smjerovi::GoreDesno;
				} else if(s[i + 1] == ' ' || s[i + 1] == s.length()) {
					i++;
					while(s[i] == ' ') i++;
					if(s[i] != ' ' || s[i] != s.length())
						kod_greska = KodoviGresaka::SuvisanParametar;
					else smjer = Smjerovi::Gore;
				}
			}

			if(s[i] == 'L') {
				i++;
				while(s[i] == ' ') i++;
				if(s[i] != ' ' || s[i] != s.length())
					kod_greska = KodoviGresaka::SuvisanParametar;
				else smjer = Smjerovi::Lijevo;
			}

			if(s[i] == 'D') {
				if(s[i + 1] == 'o') {
					i += 2;

					if(s[i + 1] == 'D') {
						while(s[i] == ' ') i++;
						if(s[i] != ' ' || s[i] != s.length())
							kod_greska = KodoviGresaka::SuvisanParametar;
						else smjer = Smjerovi::DoljeDesno;
					}

					else if(s[i + 1] == 'L') {
						while(s[i] == ' ') i++;
						if(s[i] != ' ' || s[i] != s.length())
							kod_greska = KodoviGresaka::SuvisanParametar;
						else smjer = Smjerovi::DoljeLijevo;
					} else {
						while(s[i] == ' ') i++;
						if(s[i] != ' ' || s[i] != s.length())
							kod_greska = KodoviGresaka::SuvisanParametar;
						else smjer = Smjerovi::Dolje;
					}
				} else {
					while(s[i] == ' ') i++;
					if(s[i] != ' ' || s[i] != s.length())
						kod_greska = KodoviGresaka::SuvisanParametar;
					else smjer = Smjerovi::Desno;

				}
			}
			
		//	else if(s[i + 1] == '&gt;')
		}
		
	}
}
*/
int main ()
{
	try {
		int n;
		cout &lt;&lt; "Unesite broj polja: ";
		cin &gt;&gt; n;

	} catch(std::domain_error e) {
		cout &lt;&lt; e.what();
	} catch(std::out_of_range e){
		cout &lt;&lt; e.what();
	} catch(std::logic_error e){
		cout &lt;&lt; e.what();
	}
	return 0;
}</pre>
</body>
</html>
