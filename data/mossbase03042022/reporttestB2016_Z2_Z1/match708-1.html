<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student2908.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3776.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

enum class Polje {Prazno,Mina,Posjeceno,BlokiranoPrazno,BlokiranoPosjeceno,BlokiranoMina};
enum class Smjerovi {
GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status {
NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar
};

enum class Komande {
PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
ZavrsiIgru, KreirajIgru
};

<a name="1"></a><font color="#00FF00"><a href="match708-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_36.gif"/></a>

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	if(mine[0].size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
	int max(0);
	for(int i(0);i&lt;mine.size();i++){
		for(int j(0);j&lt;mine[0].size();j++){
			if(mine[i][j]&gt;max) max=mine[i][j];
		}
	}
	if(max&gt;(n-1)) throw std::domain_error("Ilegalne pozicije mina");
	std::vector&lt;std::vector&lt;Polje&gt;&gt;mat(n,std::vector&lt;Polje&gt;(n,Polje::Prazno));
	for(int i(0);i&lt;mine.size();i++){
		for(int j(0);j&lt;mine[0].size();j++){
   	mat[mine[i][0]][mine[i][mine[0].size()-1]]=Polje::Mina;
   		}
	}
   	return mat;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	for(int i=0;i&lt;polja.size();i++){
		if(x&gt;=polja.size() or x&lt;0 or y&gt;=polja[i].size() or y&lt;0) throw std::domain_error ("Polje ne postoji");
	}
	std::vector&lt;std::vector&lt;int&gt;&gt;Okolina(3,std::vector&lt;int&gt;(3,0));
	for(int poc(x-1),i(0);poc&lt;x+2,i&lt;3;poc++,i++){
		for(int kol(y-1),j(0);kol&lt;y+2,j&lt;3;kol++,j++){
			if( kol-1&lt;=0  or poc-1&lt;=0  ) Okolina[i][j]+=0;
			if( kol-1&gt;=0 &amp;&amp; polja[poc][kol-1]==Polje::Mina) Okolina[i][j]+=1;
			if(kol-1&gt;=0 &amp;&amp; poc-1&gt;=0 and polja[poc-1][kol-1]==Polje::Mina) Okolina[i][j]+=1;
			if(kol&gt;=0 &amp;&amp; poc-1&gt;=0 and polja[poc-1][kol]==Polje::Mina) Okolina[i][j]+=1;// samo za 2. red radi ooj boze
			if( poc-1&gt;=0 and polja[poc-1][kol+1]==Polje::Mina) Okolina[i][j]+=1;
			if( polja[poc][kol+1]==Polje::Mina) Okolina[i][j]+=1;
			if( polja[poc+1][kol+1]==Polje::Mina) Okolina[i][j]+=1;
			if( polja[poc+1][kol]==Polje::Mina) Okolina[i][j]+=1;
			if(kol-1&gt;=0  and polja[poc+1][kol-1]==Polje::Mina) Okolina[i][j]+=1;
		}
	}
	return Okolina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	for(int i=0;i&lt;polja.size();i++){
		if(x&gt;=polja.size() or x&lt;0 or y&gt;=polja[i].size() or y&lt;0) throw std::domain_error ("Polje ne postoji");//+za duplo blokanje??
	}
		
	for(int i(0);i&lt;polja.size();i++){
		for(int j(0);j&lt;polja[i].size();j++){
			if(polja[x][y]==Polje::Prazno) polja[x][y]=Polje::BlokiranoPrazno;
			if(polja[x][y]==Polje::Mina) polja[x][y]=Polje::BlokiranoMina;
</font><a name="2"></a><font color="#0000FF"><a href="match708-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

			if(polja[x][y]==Polje::Posjeceno) polja[x][y]=Polje::BlokiranoPosjeceno;
		}
	}
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	for(int i(0);i&lt;polja.size();i++){
		for(int j(0);j&lt;polja[i].size();j++){
			if(polja[x][y]==Polje::BlokiranoPrazno) polja[x][y]=Polje::Prazno;
			if(polja[x][y]==Polje::BlokiranoMina) polja[x][y]=Polje::Mina;
</font><a name="0"></a><font color="#FF0000"><a href="match708-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_51.gif"/></a>

			if(polja[x][y]==Polje::BlokiranoPosjeceno) polja[x][y]=Polje::Posjeceno;
		}
	}
	
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	
		if(smjer==Smjerovi::GoreLijevo) polja[x-1][y-1]=Smjerovi::GoreLijevo; polja[x][y]=Polje::Posjeceno;
		if(smjer==Smjerovi::Gore) polja[x-1][y]=Smjerovi::Gore; polja[x][y]=Polje::Posjeceno;
		if(smjer==Smjerovi::GoreDesno) polja[x-1][y+1]=Smjerovi::GoreDesno; polja[x][y]=Polje::Posjeceno;
		if(smjer==Smjerovi::Desno)  polja[x][y+1]=Smjerovi::Desno;  polja[x][y]=Polje::Posjeceno;
		if(smjer==Smjerovi::DoljeDesno) polja[x+1][y+1]=Smjerovi::DoljeDesno;  polja[x][y]=Polje::Posjeceno;
		if(smjer==Smjerovi::Dolje )  polja[x+1][y]=Smjerovi::Dolje; polja[x][y]=Polje::Posjeceno;
		if(smjer==Smjerovi::DoljeLijevo) polja[x+1][y-1]=Smjerovi::DoljeLijevo; polja[x][y]=Polje::Posjeceno;
		if(smjer==Smjerovi::Lijevo)  polja[x][y-1]=Smjerovi::Lijevo; polja[x][y]=Polje::Posjeceno;
		
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	if(novi_x&gt;=polja.size() or novi_x&lt;0 or novi_y&gt;=polja[i].size() or novi_y&lt;0) throw std::out_of_range ("Izlazak van igrace table");
	for(int i(0);i&lt;polja.size();i++){
		for(int j(0);j&lt;polja[i].size();j++){
			if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno || polja[novi_x][novi_y]==Polje::BlokiranoPrazno || polja[novi_x][novi_y]==Polje::BlokiranoMina ){
				throw std::logic_error("Blokirano polje");
			}
		if(polja[novi_x][novi_y]==Polje::Mina){
			return KrajPoraz;
			for(int i(0);i&lt;polja.size();i++){
				for(int j(0);j&lt;polja[i].size();j++){
						polja[i][j]==Polje::Prazno;
				}
			}
		}
		if(polja[novi_x][novi_y]!=Polje::Mina &amp;&amp; polja[novi_x][novi_y]!=Polje::Prazno &amp;&amp; polja[novi_x][novi_y]!=Polje::Posjeceno) {
			return KrajPobjeda;
		}
		else return NijeKraj;
		}
	}
}

void PrijaviGresku (KodoviGresaka StatusPar){
	switch(StatusPar){
		case 0: std::cout&lt;&lt;"Nerazumljiva komanda!"; break;
		case 1: std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"; break;
		case 2: std::cout&lt;&lt;"Parametar komande nije ispravan!"; break;
		case 3: std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"; break;
	}
} 

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y,KodoviGresaka &amp;greska){
		std::string Komandee[8]={"GL","G","GD","D","DoD","Do","DoL","L"};
		char komandica[100];
		char parametar[100];
		std::cin&gt;&gt;komandica&gt;&gt;std::ws;
		std::cin&gt;&gt;parametar;
		for(int i(0);i&lt;Komandee.size();i++){
			if(komandica=="P1" &amp;&amp; parametar==Komandee[i]) komanda=Komande::PomjeriJednoMjesto;
		}
		if((komandica=="P&gt;"  &amp;&amp; sizeof parametar==2 )		parametar[0]=x; 	parametar[1]=y; komanda=Komande::PomjeriDalje; return true;
		if( komandica=="D"  &amp;&amp; sizeof parametar==2 )	parametar[0]=x; 	parametar[1]=y; komanda=Komande::Deblokiraj; return true;
		if(komandica=="B" &amp;&amp; sizeof parametar==2)   	parametar[0]=x; 	parametar[1]=y; komanda=Komande::Blokiraj; return true;
		if(komandica=="K" &amp;&amp; sizeof parametar==0)  komanda=Komande::ZavrsiIgru; return true;
		if(komandica=="PO" &amp;&amp; sizeof parametar==0) komanda=Komande::KreirajIgru; return true;
return false;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y,Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0){
	if(komanda==Komande::PomjeriJednoMjesto)
}





int main ()
{
	int n;
	std::cin&gt;&gt;n;
	Tabla matrica (n,std::vector&lt;Polje&gt;(n,Polje::Prazno));
	
	try{
	matrica = KreirajIgru(n,{{0,0,}, {0,2}, {1,3}});
	}
	catch(std::domain_error izuzetak){
		std::cout&lt;&lt;izuzetak.what();
	}
	try{
		
		 std::vector&lt;std::vector&lt;int&gt;&gt;  matrica2 (3,std::vector&lt;int&gt;(3));
		matrica2=PrikaziOkolinu(matrica,1,3);
	}
	catch(std::domain_error e){
		std::cout&lt;&lt;e.what();
	}
	BlokirajPolje(matrica,0,1);
	DeblokirajPolje(matrica,0,1);
		for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;n;j++){
			std::cout&lt;&lt;static_cast&lt;int&gt;(matrica[i][j]);
		}
		std::cout&lt;&lt;"\n";
</font>	}
	
	return 0;
}</pre>
</body>
</html>
