<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student8776.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6790.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};
enum class Polje {
 Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
enum class Smjerovi {
 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;


Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	
	Tabla tabla (n, std::vector&lt;Polje&gt;(n));                      //deklaracija promjenjive tipa Tabla(vektor vektora)
	for(int i=0; i&lt;n; i++) 
		for(int j=0; j&lt;n; j++)
			tabla[i][j]=Polje::Prazno;                          //inicijalizacija svih el. vektora na prazno
			
	for(int i=0; i&lt;mine.size(); i++) {
		for(int j=0; j&lt;mine[i].size(); j++) {                                                //bacanje izuzetaka
			if(mine[i].size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
			if(mine[i][j]&gt;=n) throw std::domain_error("Ilegalne pozicije mina");
		}
	}
	
	for(int i=0; i&lt;mine.size(); i++) {
		tabla[mine[i][0]][mine[i][1]]=Polje::Mina;
	}		
	return tabla;
}

int brojac_mina(int i, int j, const Tabla &amp;polja) {								//pomocna funkcija!!
	int brojac=0;
	int n=polja.size();
	if (i&gt;=0 &amp;&amp; i&lt;n &amp;&amp; (j-1)&gt;=0 &amp;&amp; (j-1)&lt;n &amp;&amp; polja[i][j-1]==Polje::Mina) brojac++;
	if (i&gt;=0 &amp;&amp; i&lt;n &amp;&amp; (j+1)&gt;=0 &amp;&amp; (j+1)&lt;n &amp;&amp; polja[i][j+1]==Polje::Mina) brojac++;
	if ((i+1)&gt;=0 &amp;&amp; (i+1)&lt;n &amp;&amp; (j-1)&gt;=0 &amp;&amp; (j-1)&lt;n &amp;&amp; polja[i+1][j-1]==Polje::Mina) brojac++;
	if ((i+1)&gt;=0 &amp;&amp; (i+1)&lt;n &amp;&amp; j&gt;=0 &amp;&amp; j&lt;n &amp;&amp; polja[i+1][j]==Polje::Mina) brojac++;
	if ((i+1)&gt;=0 &amp;&amp; (i+1)&lt;n &amp;&amp; (j+1)&gt;=0 &amp;&amp; (j+1)&lt;n &amp;&amp; polja[i+1][j+1]==Polje::Mina) brojac++;
	if ((i-1)&gt;=0 &amp;&amp; (i-1)&lt;n &amp;&amp; (j-1)&gt;=0 &amp;&amp; (j-1)&lt;n &amp;&amp; polja[i-1][j-1]==Polje::Mina) brojac++;
	if ((i-1)&gt;=0 &amp;&amp; (i-1)&lt;n &amp;&amp; j&gt;=0 &amp;&amp; j&lt;n &amp;&amp; polja[i-1][j]==Polje::Mina) brojac++;
	if ((i-1)&gt;=0 &amp;&amp; (i-1)&lt;n &amp;&amp; (j+1)&gt;=0 &amp;&amp; (j+1)&lt;n &amp;&amp; polja[i-1][j+1]==Polje::Mina) brojac++;
	
	return brojac;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	if (x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size()) {
		const std::string s("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
		throw std::domain_error(s);}
		
	std::vector&lt;std::vector&lt;int&gt;&gt; matrica3 (3, std::vector&lt;int&gt;(3, 0));
	for(int i=0; i&lt;3; i++) 
		for(int j=0; j&lt;3; j++) 
	matrica3[i][j]=brojac_mina(x+(i-1), y+(j-1), polja);
	
	return matrica3;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	if (x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size()) {
		const std::string s("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
		throw std::domain_error(s);}
		
	if(polja[x][y]==Polje::Prazno) polja[x][y]=Polje::BlokiranoPrazno;
	if(polja[x][y]==Polje::Posjeceno) polja[x][y]=Polje::BlokiranoPosjeceno;
	if(polja[x][y]==Polje::Mina) polja[x][y]=Polje::BlokiranoMina;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if (x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size()) {
		const std::string s("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
		throw std::domain_error(s);}
		
	if(polja[x][y]==Polje::BlokiranoPrazno) polja[x][y]=Polje::Prazno;
	if(polja[x][y]==Polje::BlokiranoPosjeceno) polja[x][y]=Polje::Posjeceno;
	if(polja[x][y]==Polje::BlokiranoMina) polja[x][y]=Polje::Mina;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	
	if(smjer==Smjerovi::Desno) {
<a name="7"></a><font color="#0000FF"><a href="match910-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		if((x)&lt;0 || (x)&gt;=polja.size() || (y+1)&lt;0 || (y+1)&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if (polja[x][y+1]==Polje::BlokiranoPosjeceno || polja[x][y+1]==Polje::BlokiranoPrazno  || polja[x][y+1]==Polje::BlokiranoMina) 
		 throw std::logic_error("Blokirano polje");
		 polja[x][y]=Polje::Posjeceno;
</font>		 y=y+1;
	}
	if(smjer==Smjerovi::Lijevo) {
<a name="4"></a><font color="#FF00FF"><a href="match910-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		if((x)&lt;0 || (x)&gt;=polja.size() || (y-1)&lt;0 || (y-1)&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if (polja[x][y-1]==Polje::BlokiranoPosjeceno || polja[x][y-1]==Polje::BlokiranoPrazno  || polja[x][y-1]==Polje::BlokiranoMina) 
		 throw std::logic_error("Blokirano polje");
		 polja[x][y]=Polje::Posjeceno;
</font>		 y=y-1;
	}
	if(smjer==Smjerovi::GoreLijevo) {
<a name="1"></a><font color="#00FF00"><a href="match910-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if((x-1)&lt;0 || (x-1)&gt;=polja.size() || (y-1)&lt;0 || (y-1)&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if (polja[x-1][y-1]==Polje::BlokiranoPosjeceno || polja[x-1][y-1]==Polje::BlokiranoPrazno  || polja[x-1][y-1]==Polje::BlokiranoMina) 
		 throw std::logic_error("Blokirano polje");
		 polja[x][y]=Polje::Posjeceno;
</font>		 x=x-1;
		 y=y-1;
	}
	if(smjer==Smjerovi::GoreDesno) {
<a name="2"></a><font color="#0000FF"><a href="match910-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		if((x-1)&lt;0 || (x-1)&gt;=polja.size() || (y+1)&lt;0 || (y+1)&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if (polja[x-1][y+1]==Polje::BlokiranoPosjeceno || polja[x-1][y+1]==Polje::BlokiranoPrazno  || polja[x-1][y+1]==Polje::BlokiranoMina) 
		 throw std::logic_error("Blokirano polje");
		 polja[x][y]=Polje::Posjeceno;
</font>		 x=x-1;
		 y=y+1;
	}
	if(smjer==Smjerovi::Gore) {
<a name="5"></a><font color="#FF0000"><a href="match910-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		if((x-1)&lt;0 || (x-1)&gt;=polja.size() || (y)&lt;0 || (y)&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if (polja[x-1][y]==Polje::BlokiranoPosjeceno || polja[x-1][y]==Polje::BlokiranoPrazno  || polja[x-1][y]==Polje::BlokiranoMina) 
		 throw std::logic_error("Blokirano polje");
		 polja[x][y]=Polje::Posjeceno;
</font>		 x=x-1;
		
	}
	if(smjer==Smjerovi::DoljeDesno) {
<a name="3"></a><font color="#00FFFF"><a href="match910-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		if((x+1)&lt;0 || (x+1)&gt;=polja.size() || (y+1)&lt;0 || (y+1)&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if (polja[x+1][y+1]==Polje::BlokiranoPosjeceno || polja[x+1][y+1]==Polje::BlokiranoPrazno  || polja[x+1][y+1]==Polje::BlokiranoMina) 
		 throw std::logic_error("Blokirano polje");
		 polja[x][y]=Polje::Posjeceno;
</font>		 x=x+1;
		 y=y+1;
	}
	if(smjer==Smjerovi::DoljeLijevo) {
<a name="0"></a><font color="#FF0000"><a href="match910-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		if((x+1)&lt;0 || (x+1)&gt;=polja.size() || (y-1)&lt;0 || (y-1)&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if (polja[x+1][y-1]==Polje::BlokiranoPosjeceno || polja[x+1][y-1]==Polje::BlokiranoPrazno  || polja[x+1][y-1]==Polje::BlokiranoMina) 
		 throw std::logic_error("Blokirano polje");
		 polja[x][y]=Polje::Posjeceno;
</font>		 x=x+1;
		 y=y-1;
	}
	if(smjer==Smjerovi::Dolje) {
<a name="6"></a><font color="#00FF00"><a href="match910-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if((x+1)&lt;0 || (x+1)&gt;=polja.size() || (y)&lt;0 || (y)&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if (polja[x+1][y]==Polje::BlokiranoPosjeceno || polja[x+1][y]==Polje::BlokiranoPrazno  || polja[x+1][y]==Polje::BlokiranoMina) 
		 throw std::logic_error("Blokirano polje");
		 polja[x][y]=Polje::Posjeceno;
</font>		 x=x+1;
	}
	if(polja[x][y]==Polje::Mina){
		for(int i=0; i&lt;polja.size(); i++) 
		for(int j=0; j&lt;polja.size(); j++)
			polja[i][j]=Polje::Prazno;
		return Status::KrajPoraz;
	} 
	for(int i=0; i&lt;polja.size(); i++) 
		for(int j=0; j&lt;polja.size(); j++)
		if(polja[i][j]==Polje::Prazno) return Status::NijeKraj; //Provjeravamo je li ima i jedno prazno polje, ako ima nije kraj igre

	return Status::KrajPobjeda;
}

<a name="11"></a><font color="#00FF00"><a href="match910-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	if(novi_x&lt;0 || novi_x&gt;=polja.size() || novi_y&lt;0 || novi_y&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
</font>		if (polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno || polja[novi_x][novi_y]==Polje::BlokiranoPrazno  || polja[novi_x][novi_y]==Polje::BlokiranoMina) 
		 throw std::logic_error("Blokirano polje");
		 polja[x][y]=Polje::Posjeceno;
		 x=novi_x;
		 y=novi_y;
	if(polja[x][y]==Polje::Mina){
		for(int i=0; i&lt;polja.size(); i++) 
		for(int j=0; j&lt;polja.size(); j++)
			polja[i][j]=Polje::Prazno;
		return Status::KrajPoraz;
	} 
	for(int i=0; i&lt;polja.size(); i++) 
		for(int j=0; j&lt;polja.size(); j++)
<a name="9"></a><font color="#FF00FF"><a href="match910-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

		if(polja[i][j]==Polje::Prazno) return Status::NijeKraj; //Provjeravamo je li ima i jedno prazno polje, ako ima nije kraj igre

	return Status::KrajPobjeda;
}

void PrijaviGresku(KodoviGresaka k)  {
	if(k==KodoviGresaka::PogresnaKomanda) std::cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;std::endl;
	if(k==KodoviGresaka::NedostajeParametar) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;std::endl;
</font><a name="8"></a><font color="#00FFFF"><a href="match910-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	if(k==KodoviGresaka::NeispravanParametar) std::cout&lt;&lt;"Parametar komande nije ispravan!"&lt;&lt;std::endl;
	if(k==KodoviGresaka::SuvisanParametar) std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;std::endl;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
</font>	char komand[1000];
	std::cin.getline(komand, 100);
	char *kom=komand;
	char *kom1=kom;
	while(*kom1!='\0') {kom1++;}
	while(*kom==' ') kom++;
	if(*kom=='P') {
		kom++;
		while(*kom==' ') kom++;
		if(*(kom)=='1') {
			kom++;
			while(*kom==' ') kom++;
			if(*kom=='G' &amp;&amp; *(kom+1)=='L') {
				kom++;
				kom++;
				while(*kom==' ') kom++;
				if(kom!=kom1) {greska=KodoviGresaka::SuvisanParametar; return false;}
				smjer=Smjerovi::GoreLijevo; 
				komanda=Komande::PomjeriJednoMjesto;
			}
			else if(*kom=='G' &amp;&amp; *(kom+1)=='D') {
				kom++;
				kom++;
				while(*kom==' ') kom++;
				if(kom!=kom1) {greska=KodoviGresaka::SuvisanParametar; return false;}
				smjer=Smjerovi::GoreDesno; komanda=Komande::PomjeriJednoMjesto;}
			else if(*kom=='G') {
				kom++;
				while(*kom==' ') kom++;
				if(kom!=kom1) {greska=KodoviGresaka::SuvisanParametar; return false;}
				smjer=Smjerovi::Gore; komanda=Komande::PomjeriJednoMjesto;}
			else if(*kom=='D' &amp;&amp; *(kom+1)=='o' &amp;&amp; *(kom+2)=='D') {
				kom=kom+3;
				while(*kom==' ') kom++;
				if(kom!=kom1) {greska=KodoviGresaka::SuvisanParametar; return false;}
				smjer=Smjerovi::DoljeDesno; komanda=Komande::PomjeriJednoMjesto;}
			else if(*kom=='D' &amp;&amp; *(kom+1)=='o' &amp;&amp; *(kom+2)=='L') {
				kom=kom+3;
				while(*kom==' ') kom++;
				if(kom!=kom1) {greska=KodoviGresaka::SuvisanParametar; return false;}
				smjer=Smjerovi::DoljeLijevo; komanda=Komande::PomjeriJednoMjesto;}
			else if(*kom=='D' &amp;&amp; *(kom+1)=='o') {
				kom++;
				kom++;
				while(*kom==' ') kom++;
				if(kom!=kom1) {greska=KodoviGresaka::SuvisanParametar; return false;}
				smjer=Smjerovi::Dolje; komanda=Komande::PomjeriJednoMjesto;}
			else if(*kom=='L') {
				kom++;
				while(*kom==' ') kom++;
				if(kom!=kom1) {greska=KodoviGresaka::SuvisanParametar; return false;}
				smjer=Smjerovi::Lijevo; komanda=Komande::PomjeriJednoMjesto;}
			else if(*kom=='D') {
				kom++;
				while(*kom==' ') kom++;
				if(kom!=kom1) {greska=KodoviGresaka::SuvisanParametar; return false;}
				smjer=Smjerovi::Desno; komanda=Komande::PomjeriJednoMjesto;}
			else if(kom==kom1) {greska=KodoviGresaka::NedostajeParametar; return false;}
			else {greska=KodoviGresaka::NeispravanParametar; return false;}
		}
	
		else if(*kom=='&gt;') {
			kom++;
			while(*kom==' ') kom++;
			int brojac=0;
			if(kom==kom1) {greska=KodoviGresaka::NedostajeParametar; return false;}
			if(*kom&gt;='0' &amp;&amp; *kom&lt;='9') {
				while (*kom&gt;='0' &amp;&amp; *kom&lt;='9') {kom++; brojac++;}
				x=0;
				while(brojac!=0) {
					x=pow(10,(brojac-1))*(*(kom-brojac)-'0')+x;
					brojac--;
				}	
			}
			else if(kom==kom1) {greska=KodoviGresaka::NedostajeParametar; return false;}
			else {greska=KodoviGresaka::NeispravanParametar; return false;}
		while(*kom==' ') kom++;
			brojac=0;
			if(*kom&gt;='0' &amp;&amp; *kom&lt;='9') {
				while (*kom&gt;='0' &amp;&amp; *kom&lt;='9') {kom++; brojac++;}
				y=0;
				while(brojac!=0) {
					y=pow(10,(brojac-1))*(*(kom-brojac)-'0')+y;
					brojac--;
				}
			/*	std::cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y;*/
			}

			else {greska=KodoviGresaka::NeispravanParametar; return false;}
			komanda=Komande::PomjeriDalje;
		}
		else if(*kom=='O') {
			kom++;
			while(*kom==' ') kom++;
			if(kom==kom1) komanda=Komande::PrikaziOkolinu;
			else {greska=KodoviGresaka::PogresnaKomanda; return false;}
		}
		else {greska=KodoviGresaka::PogresnaKomanda; return false;}
	}
	else if(*kom=='B') {
		kom++;
			while(*kom==' ') kom++;
			int brojac=0;
			if(kom==kom1) {greska=KodoviGresaka::NedostajeParametar; return false;}
			if(*kom&gt;='0' &amp;&amp; *kom&lt;='9') {
				while (*kom&gt;='0' &amp;&amp; *kom&lt;='9') {kom++; brojac++;}
				x=0;
				while(brojac!=0) {
					x=pow(10,(brojac-1))*(*(kom-brojac)-'0')+x;
					brojac--;
				}	
			}
			else if(kom==kom1) {greska=KodoviGresaka::NedostajeParametar; return false;}
			else {greska=KodoviGresaka::PogresnaKomanda; return false;}
			while(*kom==' ') kom++;
			brojac=0;
			if(*kom&gt;='0' &amp;&amp; *kom&lt;='9') {
				while (*kom&gt;='0' &amp;&amp; *kom&lt;='9') {kom++; brojac++;}
				y=0;
				while(brojac!=0) {
					y=pow(10,(brojac-1))*(*(kom-brojac)-'0')+y;
					brojac--;
				}
			}
			else {greska=KodoviGresaka::PogresnaKomanda; return false;}
			komanda=Komande::Blokiraj;
		}
		else if(*kom=='D') {
		kom++;
			while(*kom==' ') kom++;
			int brojac=0;
			if(kom==kom1) {greska=KodoviGresaka::NedostajeParametar; return false;}
			if(*kom&gt;='0' &amp;&amp; *kom&lt;='9') {
				while (*kom&gt;='0' &amp;&amp; *kom&lt;='9') {kom++; brojac++;}
				x=0;
				while(brojac!=0) {
					x=pow(10,(brojac-1))*(*(kom-brojac)-'0')+x;
					brojac--;
				}	
			}
			else if(kom==kom1) {greska=KodoviGresaka::NedostajeParametar; return false;}
			else {greska=KodoviGresaka::PogresnaKomanda; return false;}
			while(*kom==' ') kom++;
			brojac=0;
			if(*kom&gt;='0' &amp;&amp; *kom&lt;='9') {
				while (*kom&gt;='0' &amp;&amp; *kom&lt;='9') {kom++; brojac++;}
				y=0;
				while(brojac!=0) {
					y=pow(10,(brojac-1))*(*(kom-brojac)-'0')+y;
					brojac--;
				}
			}
			else {greska=KodoviGresaka::PogresnaKomanda; return false;}
			komanda=Komande::Deblokiraj;
		}
		else if(*kom=='Z') {
			kom++;
			while(*kom==' ') kom++;
			if(kom==kom1) komanda=Komande::ZavrsiIgru;
			else {greska=KodoviGresaka::PogresnaKomanda; return false;}
		}
		else if(*kom=='K') {
			kom++;
			while(*kom==' ') kom++;
			if(kom!=kom1) {greska=KodoviGresaka::SuvisanParametar; return false;}
<a name="10"></a><font color="#FF0000"><a href="match910-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

			if(kom==kom1) komanda=Komande::KreirajIgru;
			
		}
		else {greska=KodoviGresaka::PogresnaKomanda; return false;}
	
	
	return true;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
</font>	
	if(komanda==Komande::PomjeriJednoMjesto) {
		Status s=Idi(polja, x, y, p_smjer);
		if (s==Status::KrajPobjeda) {std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;std::endl;
		for(int i=0; i&lt;polja.size(); i++) 
		for(int j=0; j&lt;polja.size(); j++)
			polja[i][j]=Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
		}
		else if(s==Status::KrajPoraz) {std::cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;std::endl;
		for(int i=0; i&lt;polja.size(); i++) 
		for(int j=0; j&lt;polja.size(); j++)
			polja[i][j]=Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
		}
		std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
	}
	else if(komanda==Komande::PomjeriDalje) {
		Status s=Idi(polja, x, y, p_x, p_y);
		if (s==Status::KrajPobjeda) {std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;std::endl;
		for(int i=0; i&lt;polja.size(); i++) 
		for(int j=0; j&lt;polja.size(); j++)
			polja[i][j]=Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
		}
		else if(s==Status::KrajPoraz) {std::cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;std::endl;
		for(int i=0; i&lt;polja.size(); i++) 
		for(int j=0; j&lt;polja.size(); j++)
			polja[i][j]=Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
		}
		std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
	}
	
	else if(komanda==Komande::Blokiraj) {
		BlokirajPolje(polja, x, y);
	}
	else if(komanda==Komande::Deblokiraj) {
		DeblokirajPolje(polja, x, y);
	}
	else if(komanda==Komande::ZavrsiIgru) {
		for(int i=0; i&lt;polja.size(); i++) 
			for(int j=0; j&lt;polja.size(); j++)
				polja[i][j]=Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
	}
	else if(komanda==Komande::PrikaziOkolinu) {
		std::vector&lt;std::vector&lt;int&gt;&gt; mat=PrikaziOkolinu(polja, x, y);
		for(int i=0; i&lt;mat.size();i++) {
			for(int j=0; j&lt;mat[0].size(); j++) {
				std::cout&lt;&lt;mat[i][j]&lt;&lt;" ";
			}
			std::cout&lt;&lt;std::endl;
		}
	}
<a name="12"></a><font color="#0000FF"><a href="match910-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

	else if(komanda==Komande::KreirajIgru) {
		std::cout&lt;&lt;"Unesite broj polja: ";
		int n;
		std::cin&gt;&gt;n;
		std::cin.ignore(1000, '\n');
		std::cin.clear();
</font>		std::cout&lt;&lt;"Unesite pozicije mina: ";
		char string[100];
		char* s=string;
		int red=0;
		int prvi, drugi;
		std::vector&lt;std::vector&lt;int&gt;&gt; mine;
	for(;;) {
	a:	std::cin.getline(s,100);
		while(*s==' ') s++;
		if(*s=='.') break;
		if(*s!='(') {std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl; goto a;}
		else s++;
		if(*s&lt;'0' || *s&gt;'9') {std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl; goto a;}
		else{
			int brojac=0;
			while (*s&gt;='0' &amp;&amp; *s&lt;='9') {s++; brojac++;}
				prvi=0;
				while(brojac!=0) {
					prvi=pow(10,(brojac-1))*(*(s-brojac)-'0')+prvi;								//PROMJENA
					brojac--;
				}	
		}
		if(*s!=',') {std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl; goto a;}
		else s++;
		if(*s&lt;'0' || *s&gt;'9') {std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl; goto a;}
		else{
			int brojac=0;
			while (*s&gt;='0' &amp;&amp; *s&lt;='9') {s++; brojac++;}
				drugi=0;
				while(brojac!=0) {
					drugi=pow(10,(brojac-1))*(*(s-brojac)-'0')+drugi;							//PROMJENA
					brojac--;
				}	
		}
		if(*s!=')') {std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl; goto a;}
		else s++;
		while(*s==' ') s++;
		if(*s=='\0') {
			if(prvi&gt;=n || drugi&gt;=n) {std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl; s++; goto a;}
			else {
			mine.resize(red+1);
			mine[red].resize(2);
			mine[red][0]=prvi;
			mine[red][1]=drugi;
			red++;
	
			goto a; }
		}
		else {std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl; goto a;}
		
	}
	polja=KreirajIgru(n, mine);
	}

}



int main ()
{
	try {

	Komande kom; 
	Smjerovi smjer;
	int x=0; 
	int y=0;
	int x1, y1;
	Tabla polja;
	KodoviGresaka greska;
	for(;;){
	std::cout&lt;&lt;"Unesite komandu: ";
	try{
	bool a=UnosKomande(kom, smjer, x, y, greska);
	x1=x; y1=y;
	if (a==false) {PrijaviGresku(greska);}
	else IzvrsiKomandu(kom, polja, x, y, smjer, x1, y1);
	}
	catch(std::logic_error m){std::cout&lt;&lt;m.what()&lt;&lt;std::endl;}
	catch(std::domain_error m){std::cout&lt;&lt;m.what()&lt;&lt;std::endl;}
		}		
			
		}
	catch(std::runtime_error) { std::cout&lt;&lt;"Dovidjenja!"; }
	return 0;
	
}
	
	
	</pre>
</body>
</html>
