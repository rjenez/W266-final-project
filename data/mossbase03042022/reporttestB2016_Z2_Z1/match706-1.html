<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6981.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student2142.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

<a name="1"></a><font color="#00FF00"><a href="match706-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_27.gif"/></a>

using std::cout;
using std::cin;
using std::endl;
using std::vector;

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina	
};

enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParametar, SuvisniParametar, NeispravanParametar
};

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

vector&lt;vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, const vector&lt;vector&lt;int&gt;&gt; &amp;mine)
{
	Tabla tabla(n, vector&lt;Polje&gt;(n, Prazno));
	for(int i=0; i&lt;mine.size(); i++)
	{
		if(mine[i].size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
		tabla[mine[i][0]][mine[i][1]]=Mina;
	}
	return tabla;
}

vector&lt;vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size()) throw std::domain_error("Polje ("x", "y") ne postoji");
	if(polja.size()!=0)
		if(y&gt;=polja[0].size()) throw std::domain_error("Polje ("x", "y") ne postoji");
	vector&lt;vector&lt;int&gt;&gt; br_mina(3, vector&lt;int&gt;(3));
	/*int i(0), j(0);
	for(int m=x-1; m&lt;x+1; m++)
	{
		for(int n=y-1; n&lt;y+1; n++)
		{
			for(int k=m-1; k&lt;m+1; k++)
			{
				for(int l=n-1; l&lt;n+1; l++)
				{
					if(polja[k][l]==Mina)br_mina[i][j]++;
				}
			}
			j++;
		}
		i++;
	}
}*/
	int i(0), j(0), m, m_kraj;
	if(x==0)m=x;
	else m=x-1;
	if(x==polja.size())m_kraj=x;
	else m_kraj=x+1;
	while(m&lt;=m_kraj)
	{
		int n, n_kraj;
		if(y==0)n=y;
		else n=y-1;
		if(y==polja[x].size())n_kraj==y;
		else n_kraj;
		while(n&lt;=n_kraj)
		{
			int k, k_kraj;
			if(m==0)k==m;
			else k=m-1;
			if(k==polja.size())k_kraj=m;
			else k_kraj=m+1;
			while(k&lt;=k_kraj)
			{
				int l, l_kraj;
				if(n==0)l=n;
				else l=n-1;
				if(n==polja[m].size()) l=n;
				else l=n+1;
				while(l&lt;=l_kraj)
				{
					if(polja[k][l]==Polje::Mina)br_mina[i][j]++;
					l++
				}
				k++;
			}
			n++;
			j++;
		}
		m++;
		i++;
	}
}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size()) throw std::domain_error("Polje ("x", "y") ne postoji");
	if(polja.size()!=0)
		if(y&gt;=polja[0].size()) throw std::domain_error("Polje ("x", "y") ne postoji");
	if(polja[x][y]==Polje::Prazno)polja[x][y]=Polje::BlokiranoPrazno;
	if(polja[x][y]==Polje::Posjeceno)polja[x][y]=Polje::BlokiranoPosjeceno;
</font><a name="4"></a><font color="#FF00FF"><a href="match706-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

	if(polja[x][y]==Polje::Mina)polja[x][y]=Polje::BlokiranoMina;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size()) throw std::domain_error("Polje ("x", "y") ne postoji");
	if(polja.size()!=0)
		if(y&gt;=polja[0].size()) throw std::domain_error("Polje ("x", "y") ne postoji");
	if(polja[x][y]==Polje::BlokiranoPrazno)polja[x][y]=Polje::Prazno;
	if(polja[x][y]==Polje::BlokiranoPosjeceno)polja[x][y]=Polje::Posjeceno;
</font><a name="2"></a><font color="#0000FF"><a href="match706-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_10.gif"/></a>

	if(polja[x][y]==Polje::BlokiranoMina)polja[x][y]=Polje::Mina;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
	if(smjer==Smjerovi::GoreLijevo){ x-=1; y-=1; }
	if(smjer==Smjerovi::Gore) x-=1;
	if(smjer==Smjerovi::GoreDesno){ x-=1; y+=1; }
	if(smjer==Smjerovi::Desno) y+=1;
	if(smjer==Smjerovi::DoljeDesno){ x+=1; y+=1; }
	if(smjer==Smjerovi::Dolje) x+=1;
	if(smjer==Smjerovi::DoljeLijevo){ x+=1; y-=1; }
	if(smjer==Smjerovi::Lijevo) y-=1;
	
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
	if(polja.size()!=0)
		if(y&gt;=polja[0].size()) throw std::out_of_range("Izlazak van igrace table");
		
	if(polja[x][y]==Polje::BlokiranoPrazno || polja[x][y]==Polje::BlokiranoPosjeceno || polja[x][y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font><a name="5"></a><font color="#FF0000"><a href="match706-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	
	if(polja[x][y]==Polje::Mina)
	{
		for(int i=0; i&lt;polja.size(); i++)
</font><a name="3"></a><font color="#00FFFF"><a href="match706-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_8.gif"/></a>

			for(int j=0; j&lt;polja[0].size(); j++)
				polja[i][j]=Polje::Prazno;
		return Status::KrajPoraz;
	}
	
	for(int i=0; i&lt;polja.size(); i++)
		for(int j=0; j&lt;polja[0].size(); j++)
			if(polja[i][j]==Polje::Prazno)return Status::NijeKraj;
			
	return Status::KrajPobjeda;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	if(novi_x&lt;0 || novi_y&gt;0 || novi_x&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
	if(polja.size()!=0)
		if(y&gt;=polja[0].size()) throw std::out_of_range("Izlazak van igrace table");
		
		x=x_novi;
		y=y_novi;
		
	if(polja[x][y]==Polje::BlokiranoPrazno || polja[x][y]==Polje::BlokiranoPosjeceno || polja[x][y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font><a name="6"></a><font color="#00FF00"><a href="match706-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	
	if(polja[x][y]==Polje::Mina)
	{
		for(int i=0; i&lt;polja.size(); i++)
</font><a name="0"></a><font color="#FF0000"><a href="match706-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_38.gif"/></a>

			for(int j=0; j&lt;polja[0].size(); j++)
				polja[x][y]=Polje::Prazno;
		return Status::KrajPoraz;
	}
	
	for(int i=0 i&lt;polja.size(); i++)
		for(int j=0; j&lt;polja[0].size(); j++)
			if(polja[i][j]==Polje::Prazno)return Status::NijeKraj;
			
	return Status::KrajPobjeda;
}

void PrijaviGresku(KodoviGresaka greska)
{
	if(greska==KodoviGresaka::PogresnaKomanda)cout&lt;&lt;"Nerazumljiva komanda!";
	else if(greska==KodoviGresaka::NedostajeParametar)cout&lt;&lt;"Komanda trazi parametar koji nije naveden!";
	else if(greska==KodoviGresaka::NeispravanParametar)cout&lt;&lt;"Parametar komande nije ispravan!";
	else if(greska==KodoviGresaka::SuvisniParametar)cout&lt;&lt;"Zadan je suvisan parametar nakon komande!";
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0)
{
	if(komanda==Komande::PomjeriJednoMjesto)
	{
		try
		{
			Status s=Idi(polja, x, y, p_smjer);
			cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;", "&lt;&lt;y&lt;&lt;")";
			if(s==Status::KrajPobjeda)
				cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;endl;
			else if(s==Status::KrajPoraz)
				cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;endl;
			if(s==Status::KrajPobjeda || s==Status::KrajPoraz)
			{
				if(polja.size()!=0)
					for(int i=0; i&lt;polja.size(); i++)
						for(int j=0; j&lt;polja[0].size(); j++)
							polja[i][j]=Polje::Prazno;
				throw std::runtime_error("Igra zavrsena");
			}
		}
		catch(std::out_of_range izuzetak)
		{
			cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
		}
		catch(std::logic_error izuzetak)
		{
			cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
		}
	}
	else if(komanda==Komande::PomjeriDalje)
	{
		try
		{
			Status s=Idi(polja, x, y, p_x, p_y)
			cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;", "&lt;&lt;y&lt;&lt;")";
			if(s==Status::KrajPobjeda)
				cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;endl;
			else if(s==Status::KrajPoraz)
				cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;endl;
			if(s==Status::KrajPobjeda || s==Status::KrajPoraz)
			{
				if(polja.size!=0)
					for(int i=0; i&lt;polja.size(); i++)
						for(int j=0; j&lt;polja[0].size(); j++)
							polja[i][j]=Polje::Prazno;
				throw std::runtime_error("Igra zavrsena");
			}
		}
		catch(std::out_of_range izuzetak)
		{
			cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
		}
		catch(std::logic_error izuzetak)
		{
			cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
		}
	}
	else if(komanda==Komande::Blokiraj)
	{
		try
		{
			BlokirajPolje(polja, x, y);
		}
		catch(std::domain_error izuzetak)
		{
			cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
		}
	}
	else if(komanda==Komande::Deblokiraj)
	{
		try
		{
			DeblokirajPolje(polja, x, y);
		}
		catch(std::domain_error izuzetak)
		{
			cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
		}
	}
	else if(komanda==Komande::PrikaziOkolinu)
	{
		try
		{
			vector&lt;vector&lt;int&gt;&gt; okolina(PrikaziOkolinu(polja, x, y));
			if(okolina.size()!=0)
				for(int i=0; i&lt;okolina.size(); i++)
				{
					for(int j=0; j&lt;okolina[0].size(); j++)
						cout&lt;&lt;okolina[i][j]&lt;&lt;" ";
					cout&lt;&lt;endl;
				}
		}
		catch(std::domain_error izuzetak)
		{
			cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
		}
	}
	else if(komanda==Komande::ZavrsiIgru)
	{
		if(polja.size!=0)
			for(int i=0; i&lt;polja.size(); i++)
				for(int j=0; j&lt;polja[0].size(); j++)
					polja[i][j]==Polje::Prazno;
		throw std::runtime_error("Igra zavrsena");
	}
	else if(komanda==Komande::KreirajIgru)
	{
		int n;
		cout&lt;&lt;"Unesite broj polja: ";
		cin&gt;&gt;n;
		vector&lt;vector&lt;int&gt;&gt; mine;
		while(1)
		{
			if()
</font>		}
	}
}

int main ()
{
	return 0;
}</pre>
</body>
</html>
