<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6571.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3313.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
enum class Polje { Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};

enum class Smjerovi { GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};

enum class Status { NijeKraj, KrajPoraz, KrajPobjeda};

enum class KodoviGresaka { PogresnaKomanda, NedostajeParametar,  SuvisanParametar, NeispravanParametar};

<a name="1"></a><font color="#00FF00"><a href="match11-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_45.gif"/></a>

enum class Komande { PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;

Tabla KreirajMatricu(int br_redova, int br_kolona) {
	return Tabla(br_redova,std::vector&lt;Polje&gt;(br_kolona));
	
}
Matrica Kreiraj(int br_redova, int br_kolona){
	return Matrica(br_redova, std::vector&lt;int&gt;(br_kolona));
}
Matrica UnesiMatricu(int br_redova, int br_kolona) {

	Matrica m(br_redova, std::vector&lt;int&gt;(br_kolona));
	for(int i=0; i&lt;20; i++){
		for(int j=0; j&lt;2; j++){
			std::cin&gt;&gt;m[i][j];
			if(m[i][j]=='.') break;
		}
	}
	return m;
}
Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	
	Tabla A=KreirajMatricu(n,n);
	
	for(int i=0; i&lt;A.size(); i++){
		for(int j=0; j&lt;A[i].size(); j++){
			A[i][j]=Polje::Prazno;
		}
	}
	
	Tabla Polja=KreirajMatricu(n,n);
	
	for(int i=0; i&lt;A.size(); i++){
		for(int j=0; j&lt;A[i].size(); j++){
			for(int k=0; k&lt;mine.size(); k++){
				if(i==mine[k][0] &amp;&amp; j==mine[k][1]){
					Polja[i][j]=Polje::Mina;
				}
				
			}
		}
	}

	return Polja;
	
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
		std::vector&lt;int&gt; niz_okolina;
	if(x==1 &amp;&amp; y==1){
	
		int glh=x-1, glv=y-1;
		int gsh=x-1, gsv=y;
		int gdh=x-1, gdv=y+1;
		
		int slh=x, slv=y-1;
		int tth=x,ttv=y;
		int sdh=x, sdv=y+1;
		
		int dlh=x+1,dlv=y-1;
		int dsh=x+1, dsv=y;
		int ddh=x+1, ddv=y+1;
		
		int brojac1=0,brojac2=0,brojac3=0,brojac4=0,brojac5=0,brojac6=0,brojac7=0,brojac8=0,brojac9=0;
		
		for(int i=glh; i&lt;glh+2; i++){
			for(int j=glv; j&lt;glv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac1++;
				
				if(i==glh &amp;&amp; j==glv &amp;&amp; polja[i][j]==Polje::Mina) brojac1 = brojac1 - 1;
			}
		}
		niz_okolina.push_back(brojac1);
		
		for(int i=gsh; i&lt;gsh+2; i++){
			for(int j=gsv-1; j&lt;gsv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac2++;
				if(i==gsh &amp;&amp; j==gsv &amp;&amp; polja[i][j]==Polje::Mina) brojac2 = brojac2 - 1;
			}
		}
		niz_okolina.push_back(brojac2);
	
		for(int i=gdh; i&lt;gdh+2; i++){
			for(int j=gdv-1; j&lt;gdv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac3++;
				
				if(i==gdh &amp;&amp; j==gdv &amp;&amp; polja[i][j]==Polje::Mina) brojac3 = brojac3-1;
			}
		}
		niz_okolina.push_back(brojac3);
		
		for(int i=slh-1; i&lt;slh+2; i++){
			for(int j=slv; j&lt;slv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac4 ++;
				
				if(i==slh &amp;&amp; j==slv &amp;&amp; polja[i][j]==Polje::Mina) brojac4 = brojac4 - 1;
			}
		}
		niz_okolina.push_back(brojac4);
		
		for(int i=tth-1; i&lt;tth+2; i++){
			for(int j=ttv-1; j&lt;ttv+2; j++){
				if( polja[i][j]==Polje::Mina) brojac5 ++;
				
				if(i==tth &amp;&amp; j==ttv &amp;&amp; polja[i][j]==Polje::Mina) brojac5 = brojac5-1;
			}
		}
		niz_okolina.push_back(brojac5);
		
		for(int i=sdh-1; i&lt;sdh+2; i++){
			for(int j=sdv-1; j&lt;sdv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac6++;
				
				if(i==sdh &amp;&amp; j==sdv &amp;&amp; polja[i][j]==Polje::Mina) brojac6 = brojac6-1;
			}
		}
		niz_okolina.push_back(brojac6);
		
		for(int i=dlh-1; i&lt;dlh+2; i++){
			for(int j=dlv; j&lt;dlv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac7 ++;
				
				if(i==dlh &amp;&amp; j==dlv &amp;&amp; polja[i][j]==Polje::Mina) brojac7 = brojac7 - 1;
			}
		}
		niz_okolina.push_back(brojac7);
		
		for(int i=dsh-1; i&lt;dsh+2; i++){
			for(int j=dsv-1; j&lt;dsv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac8 ++;
				
				if(i==dsh &amp;&amp; j==dsv &amp;&amp; polja[i][j]==Polje::Mina) brojac8 = brojac8 - 1;
			}
		}
		niz_okolina.push_back(brojac8);
		
		for(int i=ddh-1; i&lt;ddh+2; i++){
			for(int j=ddv-1; j&lt;ddv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac9 ++;
				
				if(i==ddh &amp;&amp; j==ddv &amp;&amp; polja[i][j]==Polje::Mina) brojac9 = brojac9-1;
			}
		}
		niz_okolina.push_back(brojac9);
		
		Matrica MatricaPonavljanja=Kreiraj(3,3);
		int c(0);
		for(int i=0; i&lt;3; i++){
			for(int j=0; j&lt;3; j++){
				MatricaPonavljanja[i][j]=niz_okolina[c];
				c++;
				
				
			}
		}
		return MatricaPonavljanja;
		
	}
	
	if(x&gt;=2 &amp;&amp; y&gt;=2){
		int glh=x-1, glv=y-1;
		int gsh=x-1, gsv=y;
		int gdh=x-1, gdv=y+1;
		
		int slh=x,slv=y-1;
		int tth=x,ttv=y;
		int sdh=x, sdv=y+1;
		
		int dlh=x+1,dlv=y-1;
		int dsh=x+1,dsv=y;
		int ddh=x+1,ddv=y+1;
		
		int brojac1=0,brojac2=0,brojac3=0,brojac4=0,brojac5=0,brojac6=0,brojac7=0,brojac8=0,brojac9=0;
		
		for(int i=glh-1; i&lt;glh+2; i++){
			for(int j=glv-1; j&lt;glv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac1 ++;
				
				if(i==glh &amp;&amp; j==glv &amp;&amp; polja[i][j]==Polje::Mina) brojac1 = brojac1-1;
			}
		}
		niz_okolina.push_back(brojac1);
		
		for(int i=gsh-1; i&lt;gsh+2; i++){
			for(int j=gsv-1; j&lt;gsv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac2 ++;
				
				if(i==gsh &amp;&amp; j==gsv &amp;&amp; polja[i][j]==Polje::Mina) brojac2 = brojac2-1;
			}
		}
		niz_okolina.push_back(brojac2);
		
		for(int i=gdh-1; i&lt;gdh+2; i++){
			for(int j=gdv-1; j&lt;gdv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac3++;
				
				if(i==gdh &amp;&amp; j==gdv &amp;&amp; polja[i][j]==Polje::Mina) brojac3 = brojac3 -1;
			}
		}
		niz_okolina.push_back(brojac3);
		
		for(int i=slh-1; i&lt;slh+2; i++){
			for(int j=slv-1; j&lt;slv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac4 ++;
				
				if(i==slh &amp;&amp; j==slv &amp;&amp; polja[i][j]==Polje::Mina) brojac4 = brojac4 - 1;
			}
		}
		niz_okolina.push_back(brojac4);
		
		for(int i=tth-1; i&lt;tth+2; i++){
			for(int j=ttv-1; j&lt;ttv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac5++;
				
				if(i==tth &amp;&amp; j==ttv &amp;&amp; polja[i][j]==Polje::Mina) brojac5 = brojac5 - 1;
			}
		}
		niz_okolina.push_back(brojac5);
		
		for(int i=sdh-1; i&lt;sdh+2; i++){
			for(int j=sdv-1; j&lt;sdv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac6 ++;
				
				if(i==sdh &amp;&amp; j==sdv &amp;&amp; polja[i][j]==Polje::Mina) brojac6 = brojac6-1;
			}
		}
		niz_okolina.push_back(brojac6);
		
		for(int i=dlh-1; i&lt;dlh+2; i++){
			for(int j=dlv-1; j&lt;dlv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac7++;
				
				if(i==dlh &amp;&amp; j==dlv &amp;&amp; polja[i][j]==Polje::Mina) brojac7 = brojac7-1;
			}
		}
		niz_okolina.push_back(brojac7);
		
		for(int i=dsh-1; i&lt;dsh+2; i++){
			for(int j=dsv-1; j&lt;dsv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac8 ++;
				
				if(i==dsh &amp;&amp; j==dsv &amp;&amp; polja[i][j]==Polje::Mina) brojac8 = brojac8 - 1;
			}
		}
		niz_okolina.push_back(brojac8);
		
		for(int i=ddh-1; i&lt;ddh+2; i++) {
			for(int j=ddv-1; j&lt;ddv+2; j++){
				if(polja[i][j]==Polje::Mina) brojac9 ++;
				
				if(i==ddh &amp;&amp; j==ddv &amp;&amp; polja[i][j]==Polje::Mina) brojac9 = brojac9 - 1;
			}
		}
		niz_okolina.push_back(brojac9);
		
		Matrica MatricaPonavljanja=Kreiraj(3,3);
		int c(0);
		for(int i=0; i&lt;3; i++){
			for(int j=0; j&lt;3; j++){
				MatricaPonavljanja[i][j]=niz_okolina[c];
				c++;
			}
		}
		return MatricaPonavljanja;
		
		
	}
	
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&lt;0 || x&gt;polja.size() || y&lt;0 || y&gt;polja[0].size()) throw std::domain_error("Polje (x,y) ne postoji");
	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja[i].size(); j++){
			if(i==x &amp;&amp; j==y){
				if(polja[i][j]==Polje::Prazno) polja[i][j]=Polje::BlokiranoPrazno;
</font>				
				if(polja[i][j]==Polje::Posjeceno) polja[i][j]=Polje::BlokiranoPosjeceno;
				
<a name="2"></a><font color="#0000FF"><a href="match11-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

				if(polja[i][j]==Polje::Mina) polja[i][j]=Polje::BlokiranoMina;
			}
		}
	}
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&lt;0 || x&gt;polja.size() || y&lt;0 || y&gt;polja[0].size()) throw std::domain_error("Polje (x,y) ne postoji");
	
	for(int i=0; i&lt;polja.size(); i++){
		for(int j=0; j&lt;polja[i].size(); j++){
			if(i==x &amp;&amp; j==y){
				if(polja[i][j]==Polje::BlokiranoPrazno) polja[i][j]=Polje::Prazno;
</font>				
<a name="0"></a><font color="#FF0000"><a href="match11-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_49.gif"/></a>

				if(polja[i][j]==Polje::BlokiranoPosjeceno) polja[i][j]=Polje::Posjeceno;
				
				if(polja[i][j]==Polje::BlokiranoMina) polja[i][j]=Polje::Mina;
			}
		}
	}
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	Status s;
	for(int i=0; i&lt;polja.size(); i++){
		for(int j=0; j&lt;polja[i].size(); j++){
			if(i==x &amp;&amp; j==y){ polja[i][j]=Polje::Posjeceno;
		  }
	   }
	}
	for(int i=0; i&lt;polja.size(); i++){
		for(int j=0; j&lt;polja[i].size(); j++){
			if(smjer==Smjerovi::GoreLijevo) {
				if(polja[i][j]==Polje::Mina){
					s=Status::KrajPoraz;
					return s;
				}
				else if(polja[i][j]==Polje::Prazno){
				x=x-1;
				y=y-1;
				s=Status::NijeKraj;
				return s;
			
			    }
			    else if((i==polja.size()-1||j==polja[i].size()-1)&amp;&amp;polja[i][j]==Polje::Prazno){
			    	s=Status::KrajPobjeda;
			    	return s;
			    }
		   }
			else if(smjer==Smjerovi::Gore){
				if(polja[i][j]==Polje::Mina){
					s=Status::KrajPoraz;
					return s;
				}
				else if(polja[i][j]==Polje::Prazno){
					x=x-1;
					s=Status::NijeKraj;
					return s;
				}
				 else if((i==polja.size()-1||j==polja[i].size()-1)&amp;&amp;polja[i][j]==Polje::Prazno){
			    	s=Status::KrajPobjeda;
			    	return s;
			    }
				
			}
			else if(smjer==Smjerovi::GoreDesno){
				if(polja[i][j]==Polje::Mina){
					s=Status::KrajPoraz;
					return s;
				}
				else if(polja[i][j]==Polje::Prazno){
					x+1;
					y+1;
					s=Status::NijeKraj;
					return s;
				}
				 else if((i==polja.size()-1||j==polja[i].size()-1)&amp;&amp;polja[i][j]==Polje::Prazno){
			    	s=Status::KrajPobjeda;
			    	return s;
			    }
				
			}
			else if(smjer==Smjerovi::Lijevo){
				if(polja[i][j]==Polje::Mina){
					s=Status::KrajPoraz;
					return s;
				}
				else if(polja[i][j]==Polje::Prazno){
				y=y-1;
				s=Status::NijeKraj;
				return s;
				}
				 else if((i==polja.size()-1||j==polja[i].size()-1)&amp;&amp;polja[i][j]==Polje::Prazno){
			    	s=Status::KrajPobjeda;
			    	return s;
			    }
			}
			else if(smjer==Smjerovi::Desno){
				if(polja[i][j]==Polje::Mina){
					s=Status::KrajPoraz;
					return s;
				}
				else if(polja[i][j]==Polje::Prazno){
				x=x+1;
				s=Status::NijeKraj;
				return s;
				}
				 else if((i==polja.size()-1||j==polja[i].size()-1)&amp;&amp;polja[i][j]==Polje::Prazno){
			    	s=Status::KrajPobjeda;
			    	return s;
			    }
			}
			else if(smjer==Smjerovi::DoljeLijevo){
				if(polja[i][j]==Polje::Mina){
					s=Status::KrajPoraz;
					return s;
				}
				else if(polja[i][j]==Polje::Prazno){
				x=x+1;
				y=y-1;
				s=Status::NijeKraj;
				return s;
				}
				 else if((i==polja.size()-1||j==polja[i].size()-1)&amp;&amp;polja[i][j]==Polje::Prazno){
			    	s=Status::KrajPobjeda;
			    	return s;
			    }
			}
			else if(smjer==Smjerovi::Dolje){
				if(polja[i][j]==Polje::Mina){
					s=Status::KrajPoraz;
					return s;
				}
				else if(polja[i][j]==Polje::Prazno){
				x=x+1;
				s=Status::NijeKraj;
				return s;
				}
				 else if((i==polja.size()-1||j==polja[i].size()-1)&amp;&amp;polja[i][j]==Polje::Prazno){
			    	s=Status::KrajPobjeda;
			    	return s;
			    }
		
			}
			else if(smjer==Smjerovi::DoljeDesno){
				if(polja[i][j]==Polje::Mina){
					s=Status::KrajPoraz;
					return s;
				}
				else if(polja[i][j]==Polje::Prazno){
				x=x+1;
				y=y+1;
				s=Status::NijeKraj;
				return s;
					
					}
					 else if((i==polja.size()-1||j==polja[i].size()-1)&amp;&amp;polja[i][j]==Polje::Prazno){
			    	s=Status::KrajPobjeda;
			    	return s;
			    }
		   	}
	   	}
	
   	}
}


Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	if(novi_x&lt;0 || novi_x&gt;polja.size() || novi_y&lt;0 || novi_y&gt;polja[0].size()) throw std::out_of_range ("Izlazak van igrace table");
	
	for(int i=0; i&lt;polja.size(); i++){
		for(int j=0; j&lt;polja[i].size(); j++){
			if(i==novi_x &amp;&amp; j==novi_y){
				if (polja[i][j]==Polje::BlokiranoPrazno) throw std::logic_error ("Blokirano polje");
				
				if( polja[i][j]==Polje::BlokiranoPosjeceno) throw std::logic_error ("Blokirano polje");
				
				if(polja[i][j]==Polje::BlokiranoMina) throw std::logic_error ("Blokirano polje");
				x=novi_x;
				y=novi_y;
			
				

			}  
			
			
		}
	}
}

bool UnesiKomandu(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	std::string kkomanda;
	std::string novakomanda;
	std::getline(std::cin, kkomanda);
	for(int i=0; i&lt;kkomanda.length(); i++){
		while(kkomanda[i]==' ') i++;
		
		while(kkomanda[i]!=' '&amp;&amp; i&lt;kkomanda.length()){
			novakomanda.push_back(kkomanda[i]);
			i++;
		}
	}
	for(int i=0; i&lt;novakomanda.length(); i++){
		if(novakomanda[i]=='P'&amp;&amp;novakomanda[i+1]=='1'){
			komanda=Komande::PomjeriJednoMjesto;
			if(novakomanda[i+2]=='G'&amp;&amp;novakomanda[i+3]=='L'){
				smjer=Smjerovi::GoreLijevo;
				return true;
			}
			else if(novakomanda[i+2]=='G') {
				smjer=Smjerovi::Gore;
				return true;
			}
			else if(novakomanda[i+2]=='G'&amp;&amp;novakomanda[i+3]=='D'){
				smjer=Smjerovi::GoreDesno;
				return true;
			}
			else if(novakomanda[i+2]=='D'){
				smjer=Smjerovi::Desno;
				return true;
			}
			else if(novakomanda[i+2]=='D'&amp;&amp;novakomanda[i+3]=='o'&amp;&amp;novakomanda[i+4]=='D'){
				smjer=Smjerovi::DoljeDesno;
				return true;
			}
			else if(novakomanda[i+2]=='D'&amp;&amp;novakomanda[i+3]=='o'){
				smjer=Smjerovi::Dolje;
				return true;
			}
			else if(novakomanda[i+2]=='D'&amp;&amp;novakomanda[i+3]=='o'&amp;&amp;novakomanda[i+4]=='L'){
				smjer=Smjerovi::DoljeLijevo;
				return true;
			}
			else if(novakomanda[i+2]=='L'){
				smjer=Smjerovi::Lijevo;
				return true;
			}
			else{
				greska=KodoviGresaka::PogresnaKomanda;
				return false;
			}
		}
		else if(novakomanda[i]=='P'&amp;&amp;novakomanda[i+1]=='&gt;'){
			komanda=Komande::PomjeriDalje;
			if(novakomanda[i+2]&gt;='0'&amp;&amp;novakomanda[i+2]&lt;'9' &amp;&amp; novakomanda[i+3]&gt;='0'&amp;&amp; novakomanda[i+3]&lt;='9'){
				x=novakomanda[i+2];
				y=novakomanda[i+3];
				return true;
			}
			else if(!(novakomanda[i+2]&gt;='0'&amp;&amp;novakomanda[i+2]&lt;='9')||!(novakomanda[i+3]&gt;='0'&amp;&amp;novakomanda[i+3]&lt;='9')){
				greska=KodoviGresaka::NeispravanParametar;
				return false;
			}
			else{
				greska=KodoviGresaka::NedostajeParametar;
				return false;
			}
		}
		else if(novakomanda[i]=='B'){
			komanda=Komande::Blokiraj;
			if(novakomanda[i+1]&gt;='0' &amp;&amp; novakomanda[i+1]&lt;='9' &amp;&amp; novakomanda[i+2]&gt;='0' &amp;&amp; novakomanda[i+2]&lt;='9'){
				x=novakomanda[i+1];
				y=novakomanda[i+2];
				return true;
			}
			else if(!(novakomanda[i+1]&gt;='0'&amp;&amp;novakomanda[i+1]&lt;='9')||!(novakomanda[i+2]&gt;='0'&amp;&amp;novakomanda[i+2]&lt;='9')){
				greska=KodoviGresaka::NeispravanParametar;
				return false;
			}
			else{
				greska=KodoviGresaka::NedostajeParametar;
				return false;
			}
		}
		else if(novakomanda[i]=='D'){
			komanda=Komande::Deblokiraj;
			if(novakomanda[i+1]&gt;='0' &amp;&amp; novakomanda[i+1]&lt;='9' &amp;&amp; novakomanda[i+2]&gt;='0'&amp;&amp;novakomanda[i+2]&lt;='9'){
				x=novakomanda[i+1];
				y=novakomanda[i+2];
				return true;
			}
			else if(!(novakomanda[i+1]&gt;='0'&amp;&amp;novakomanda[i+1]&lt;='9')||!(novakomanda[i+2]&gt;='0'&amp;&amp;novakomanda[i+2]&lt;='9')){
				greska=KodoviGresaka::NeispravanParametar;
				return false;
			}
			else{
				greska=KodoviGresaka::NedostajeParametar;
				return false;
			}
		}
		if(novakomanda[i]=='P'&amp;&amp;novakomanda[i+1]=='O'){
			komanda=Komande::PrikaziOkolinu;
			if((novakomanda[i+2]&gt;='A'&amp;&amp;novakomanda[i+2]&lt;='Z')||(novakomanda[i+2]&gt;='0'&amp;&amp;novakomanda[i+2]&lt;='9')){
				greska=KodoviGresaka::SuvisanParametar;
			}
		}
		if(novakomanda[i]=='Z'){
			komanda=Komande::ZavrsiIgru;
			if(novakomanda[i+1]=='\0'){
				return true;
			}
			else if((novakomanda[i+1]&gt;='A'&amp;&amp;novakomanda[i+1]&lt;='Z')||(novakomanda[i+1]&gt;='0'&amp;&amp;novakomanda[i+1]&lt;='9')){
				greska=KodoviGresaka::SuvisanParametar;
				return false;
			}
		}
		if(novakomanda[i]=='K'){
			komanda=Komande::KreirajIgru;
			if(novakomanda[i+1]=='\0'){
				return true;
			}
			else if((novakomanda[i+1]&gt;='A'&amp;&amp;novakomanda[i+1]&lt;='Z')||(novakomanda[i+1]&gt;='0'&amp;&amp;novakomanda[i+1]&lt;='9')){
				greska=KodoviGresaka::SuvisanParametar;
				return false;
			}
		}
	}
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0) {
	
	if(komanda==Komande::PomjeriJednoMjesto || komanda==Komande::PomjeriDalje) {
		std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
		Status status=Idi(polja, x,y,p_smjer);
		if(status==Status::KrajPobjeda) std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja";
		
		if(status==Status::KrajPoraz){ 
			std::cout&lt;&lt;"Nagazili ste na minu";
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[i].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
	    }
    }
    else if(komanda==Komande::PrikaziOkolinu){
    	Matrica P= PrikaziOkolinu(polja,x,y);
    	for(int i=0; i&lt;P.size(); i++){
    		for(int j=0; j&lt;P[i].size(); j++){
    			std::cout&lt;&lt;P[i][j];
    		}
    		std::cout&lt;&lt;std::endl;
    	}
    }
    else if(komanda==Komande::ZavrsiIgru){
    	for(int i=0; i&lt;polja.size(); i++){
    		for(int j=0; j&lt;polja[i].size(); j++){
    			polja[i][j]=Polje::Prazno;
    		}
    	}
    	throw std::runtime_error ("Igra zavrsena");
    }
    else if(komanda==Komande::KreirajIgru){
    	std::complex&lt;int&gt; z;
    	std::vector&lt;std::complex&lt;int&gt;&gt; v;
    	int n;
    	std::cout&lt;&lt;"Unesite broj polja: "&lt;&lt;std::endl;
    	std::cin&gt;&gt;n;
    	std::cout&lt;&lt;"Unesite pozicije mina: "&lt;&lt;std::endl;
    	while(std::cin.peek()!='.'){
    		std::cin&gt;&gt;z;
    		if(z.real()&gt;n || z.imag()&gt;n){
    			std::cout&lt;&lt;"Greska, unesite ponovo!";
    		}
    	}
    	
    
    }


}



int main ()
{
	return 0;
</font>}</pre>
</body>
</html>
