<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student7834.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student7834.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
<a name="0"></a><font color="#FF0000"><a href="match40-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_36.gif"/></a>

using namespace std;
enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar,Null
};

enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};
enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};
enum  class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina,

};
enum  class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo

};
typedef vector&lt;vector&lt;int&gt;&gt; Matrica;
typedef vector&lt;vector&lt;Polje&gt;&gt;Tabla;
Tabla KreirajTablu(int broj_redova, int broj_kolona){
return Tabla(broj_redova, vector&lt;Polje&gt;(broj_kolona));	
}
Matrica KreirajMatricu(int broj_redova, int broj_kolona){
return Matrica(broj_redova, vector&lt;int&gt;(broj_kolona));	
}
int StringUInt(string s){
	int broj{};
	for(int i=s.size()-1;i&gt;=0;i--)broj+=(s[i]-'0')*pow(10,s.size()-1-i);
	return broj;
}
bool Ispravnost(string x_y,int &amp;x,int &amp;y,KodoviGresaka &amp;greska){
	int razmak{-1};
	for(unsigned int i=0;i&lt;x_y.size();i++){
		if(x_y[i]==' ')razmak=i;
		else if(x_y[i]&lt;'0' || x_y[i]&gt;'9'){
			greska=KodoviGresaka::NeispravanParametar;
			return false;
		}
	}
	if(greska==KodoviGresaka::NeispravanParametar || razmak==-1){
		greska=KodoviGresaka::NeispravanParametar;
		return false;
	}
	else {
		string xS{x_y.substr(0,razmak)};
		string yS{x_y.substr(razmak+1)};
		x=StringUInt(xS);
		y=StringUInt(yS);
		
	}
	return true;
}
int SumaOkoline(const Tabla &amp;polja,int x,int y){
	int suma=0;
	for(int k=0;k&lt;3;k++){
		if(y&gt;0 &amp;&amp; y&lt;polja[0].size()-1){
			if(x&gt;0 &amp;&amp; polja[x-1][y-1+k]==Polje::Mina)suma+=1;
			if(k!=1 &amp;&amp; polja[x][y-1+k]==Polje::Mina)suma+=1;
			if(x&lt;polja.size()-1 &amp;&amp; polja[x+1][y-1+k]==Polje::Mina)suma+=1;
			
		}
		else if(y==polja[0].size()-1){
			if(x&gt;0 &amp;&amp; k&gt;2 &amp;&amp; polja[x-1][y-1+k]==Polje::Mina)suma+=1;
			if(k==0 &amp;&amp; polja[x][y-1+k]==Polje::Mina)suma+=1;
			if(k&lt;2 &amp;&amp; x&lt;polja.size()-1 &amp;&amp; polja[x+1][y-1+k]==Polje::Mina)suma+=1;
			
		}
		else if(y==0){
			if(x&gt;0 &amp;&amp; k&gt;0 &amp;&amp; polja[x-1][y-1+k]==Polje::Mina)suma+=1;
			if(k&gt;1 &amp;&amp; polja[x][y-1+k]==Polje::Mina)suma+=1;
			if(k&gt;0 &amp;&amp; x&lt;polja.size()-1 &amp;&amp; polja[x+1][y-1+k]==Polje::Mina)suma+=1;
		}
	}
	return suma;

}
Tabla KreirajIgru(int n,const vector&lt;vector&lt;int&gt; &gt; &amp;mine){
	for(int i=0;i&lt;mine.size();i++){
		for(int j=0;j&lt;mine[0].size();j++){
			if(mine[i].size()!=2)throw domain_error("Ilegalan format zadavanja mina");
			if(mine[i][j]&gt;n-1 || mine[i][j]&lt;0) throw domain_error("Ilegalne pozicije mina");
			
		}
	}
	Tabla v=KreirajTablu(n,n);
	for(int i=0;i&lt;v.size();i++){
		for(int j=0;j&lt;v.size();j++){
			v[i][j]=Polje::Prazno;
		}
	}
	for(int i=0;i&lt;mine.size();i++){
		v[mine[i][0]][mine[i][1]]=Polje::Mina;
	}
	return v;
}
void ZavrsiIgru(Tabla &amp;polja){
	for(int i=0;i&lt;polja.size();i++){
		for(int j=0;j&lt;polja.size();j++){
			polja[i][j]=Polje::Prazno;
		}
	}
	cout&lt;&lt;"Dovidjenja!";
}
Matrica PrikaziOkolinu(const Tabla &amp;polja,int x,int y){
	Matrica v=KreirajMatricu(3,3);
	string prvi("Polje (");
	string zarez(",");
	string drugi(") ne postoji");
	string eror=prvi+(char)(x+48)+zarez+(char)(y+48)+drugi;
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size()) throw domain_error(eror);
	for(int k=0;k&lt;3;k++){
		if(y&gt;0 &amp;&amp; y&lt;polja[0].size()-1){
			if(x&gt;0)v[0][k]=SumaOkoline(polja,x-1,y-1+k);
			v[1][k]=SumaOkoline(polja,x,y-1+k);
			if(x&lt;polja.size()-1)v[2][k]=SumaOkoline(polja,x+1,y-1+k);
		}
		else if(y==0){
			if(x&gt;0)v[0][k]=SumaOkoline(polja,x-1,y+k);
			if(k&gt;1)v[1][k]=SumaOkoline(polja,x,y-1+k);
			if(x&lt;polja.size()-1)v[2][k]=SumaOkoline(polja,x+1,y+k);
			
		}
		else if(y==polja.size()-1){
			if(x&gt;0 &amp;&amp; k&lt;2)v[0][k]=SumaOkoline(polja,x-1,y-1+k);
			if(k==0)v[1][k]=SumaOkoline(polja,x,y-1+k);
			if(k&lt;2 &amp;&amp; x&lt;polja.size()-1)v[2][k]=SumaOkoline(polja,x+1,y-1+k);
		}
	}
	return v;
}
void BlokirajPolje(Tabla &amp;polja,int x,int y){
	string prvi("Polje (");
	string zarez(",");
	string drugi(") ne postoji");
	string eror=prvi+(char)(x+48)+zarez+(char)(y+48)+drugi;
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size()) throw domain_error(eror);
			if(polja[x][y]==Polje::Prazno)polja[x][y]=Polje::BlokiranoPrazno;
</font>			if(polja[x][y]==Polje::Posjeceno)polja[x][y]=Polje::BlokiranoPosjeceno;
<a name="3"></a><font color="#00FFFF"><a href="match40-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

			if(polja[x][y]==Polje::Mina)polja[x][y]=Polje::BlokiranoMina;
}
void DeblokirajPolje(Tabla &amp;polja,int x,int y){
	string prvi("Polje (");
	string zarez(",");
	string drugi(") ne postoji");
	string eror=prvi+(char)(x+48)+zarez+(char)(y+48)+drugi;
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size()) throw domain_error(eror);
			if(polja[x][y]==Polje::BlokiranoPrazno)polja[x][y]=Polje::Prazno;
</font><a name="1"></a><font color="#00FF00"><a href="match40-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_34.gif"/></a>

			if(polja[x][y]==Polje::BlokiranoPosjeceno)polja[x][y]=Polje::Posjeceno;
			if(polja[x][y]==Polje::BlokiranoMina)polja[x][y]=Polje::Mina;
}
Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,Smjerovi smjer){
	polja[x][y]=Polje::Posjeceno;
if(smjer==Smjerovi::GoreLijevo &amp;&amp; x&gt;0 &amp;&amp; y&gt;0){
	x=x-1;
	y=y-1;
}	
else if(smjer==Smjerovi::Gore &amp;&amp; x&gt;0)x=x-1;
else if(smjer==Smjerovi::GoreDesno &amp;&amp; x&gt;0 &amp;&amp; y&lt;polja.size()-1){
x=x-1;
y=y+1;
}	
else if(smjer==Smjerovi::Desno  &amp;&amp; y&lt;polja.size()-1){
	y=y+1;
}	
else if(smjer==Smjerovi::DoljeDesno &amp;&amp; x&lt;polja.size()-1 &amp;&amp; y&lt;polja[0].size()-1){
	x=x+1;
	y=y+1;
}	
else if(smjer==Smjerovi::Dolje &amp;&amp; x&lt;polja.size()-1){
	x=x+1;
}	
else if(smjer==Smjerovi::DoljeLijevo &amp;&amp; x&lt;polja.size()-1 &amp;&amp; y&gt;0){
	x=x+1;
	y=y-1;
}	
else if(smjer==Smjerovi::Lijevo &amp;&amp; y&gt;0){
	y=y-1;
}	
else throw out_of_range("Izlazak van igrace table");
if(polja[x][y]==Polje::BlokiranoPrazno || polja[x][y]==Polje::BlokiranoMina || polja[x][y]==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
int br=0;
for(int i=0;i&lt;polja.size();i++){
	for(int j=0;j&lt;polja[0].size();j++){
		if(polja[i][j]!=Polje::Prazno || polja[i][j]==Polje::Posjeceno || polja[i][j]==Polje::Mina)br++;
}
}
if(polja[x][y]==Polje::Mina){
	for(int i=0;i&lt;polja.size();i++){
		for(int j=0;j&lt;polja[0].size();j++){
			polja[i][j]=Polje::Prazno;
		}
	}
	return Status::KrajPoraz;
}
else if(br==polja.size()*polja.size()-1)return Status::KrajPobjeda;
else return Status::NijeKraj;
}
Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,int novi_x,int novi_y){
	if(novi_x&lt;0 || novi_y&lt;0 || novi_x&gt;=polja.size() || novi_y&gt;=polja.size())throw out_of_range("Izlazak van igrace table");
	polja[x][y]=Polje::Posjeceno;
	x=novi_x;
	y=novi_y;
	if(polja[x][y]==Polje::BlokiranoPrazno || polja[x][y]==Polje::BlokiranoMina || polja[x][y]==Polje::BlokiranoPosjeceno) throw logic_error("Blokirano polje");
	int br=0;
for(int i=0;i&lt;polja.size();i++){
	for(int j=0;j&lt;polja[0].size();j++){
		if(polja[i][j]!=Polje::Prazno || polja[i][j]==Polje::Posjeceno || polja[i][j]==Polje::Mina)br++;
}
}
if(polja[x][y]==Polje::Mina){
	for(int i=0;i&lt;polja.size();i++){
		for(int j=0;j&lt;polja[0].size();j++){
			polja[i][j]=Polje::Prazno;
		}
	}
	return Status::KrajPoraz;
}
else if(br==polja.size()*polja.size()-1)return Status::KrajPobjeda;
else return Status::NijeKraj;
}
void PrijaviGresku(KodoviGresaka greska){
	if(greska==KodoviGresaka::PogresnaKomanda)cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;endl;
	else if(greska==KodoviGresaka::NedostajeParametar)cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;endl;
	else if(greska==KodoviGresaka::NeispravanParametar)cout&lt;&lt;"Parametar komande nije ispravan!"&lt;&lt;endl;
	else if(greska==KodoviGresaka::SuvisanParametar)cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;endl;
}
bool UnosKomande(Komande &amp;komanda,Smjerovi &amp;smjer,int &amp;x,int &amp;y,KodoviGresaka &amp;greska){
	string unos;
	getline(cin&gt;&gt;ws,unos);
	if(unos[0]=='K'){
		if(unos.size()==1)komanda=Komande::KreirajIgru;
		else greska=KodoviGresaka::SuvisanParametar;
	}
	else if(unos[0]=='Z'){
		if(unos.size()==1)komanda=Komande::ZavrsiIgru;
		else greska=KodoviGresaka::SuvisanParametar;
	}
	else if(unos.substr(0,2)=="PO"){
		if(unos.size()==2)komanda=Komande::PrikaziOkolinu;
		else greska=KodoviGresaka::SuvisanParametar;
	}
	else if(unos.substr(0,2)=="B " || unos.substr(0,2)=="D "){
		if(unos.size()&gt;2){
			string x_y{unos.substr(2)};
			if(isspace(x_y[3]) &amp;&amp; x_y.length()&gt;3)greska=KodoviGresaka::SuvisanParametar;
			else if(Ispravnost(x_y,x,y,greska)){
				if(unos[0]=='B')komanda=Komande::Blokiraj;
				else if(unos[0]=='D')komanda=Komande::Deblokiraj;
			}
		}
		else greska=KodoviGresaka::NedostajeParametar;
	}
	else if(unos.substr(0,1)=="B" || unos.substr(0,1)=="D"){
		if(unos.substr(1,1)!=" " || unos.substr(1,1)!=" ")greska=KodoviGresaka::NedostajeParametar;
	}
	else if(unos[0]=='P'){
		if(unos[1]=='&gt;'){
			if(unos.size()==2)greska=KodoviGresaka::NedostajeParametar;
			else{
				string x_y{unos.substr(3)};
				if(isspace(x_y[3]) &amp;&amp; x_y.length()&gt;3)greska=KodoviGresaka::SuvisanParametar;
				else if(Ispravnost(x_y,x,y,greska))komanda=Komande::PomjeriDalje;
			}
		}
		else if(unos[1]=='1'){
			komanda=Komande::PomjeriJednoMjesto;
			if(unos.size()==2)greska=KodoviGresaka::NedostajeParametar;
		else{
			string pravac{unos.substr(3)};
			pravac+="abc";
			if((isspace(pravac[1]) || isspace(pravac[2]) || isspace(pravac[3])) &amp;&amp; pravac.length()&gt;3)greska=KodoviGresaka::SuvisanParametar;
			pravac={unos.substr(3)};
			if(pravac=="GL")smjer=Smjerovi::GoreLijevo;
			else if(pravac=="G")smjer=Smjerovi::Gore;
			else if(pravac=="GD")smjer=Smjerovi::GoreDesno;
</font>			else if(pravac=="D")smjer=Smjerovi::Desno;
			else if(pravac=="DoD")smjer=Smjerovi::DoljeDesno;
			else if(pravac=="Do")smjer=Smjerovi::Dolje;
<a name="2"></a><font color="#0000FF"><a href="match40-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_23.gif"/></a>

			else if(pravac=="DoL")smjer=Smjerovi::DoljeLijevo;
			else if(pravac=="L")smjer=Smjerovi::Lijevo;
			else greska=KodoviGresaka::NeispravanParametar;
		}
			
		}
		else if(unos[1]!='1' || unos[1]!='&gt;')greska=KodoviGresaka::PogresnaKomanda;
		else greska=KodoviGresaka::NedostajeParametar;
		
	}
	else greska=KodoviGresaka::PogresnaKomanda;
	if((int)greska&lt;4)return false;
	else return true;
}
void IzvrsiKomandu(Komande komanda,Tabla &amp;polja,int &amp;x,int &amp;y,Smjerovi p_smjer=Smjerovi::Gore,int p_x=0,int p_y=0){
	if(komanda==Komande::PomjeriJednoMjesto){
		try{
		Status idi=Idi(polja,x,y,p_smjer);
		if(idi==Status::KrajPobjeda){
			
		cout&lt;&lt;"Bravo,obisli ste sva sigurna polja"&lt;&lt;endl;
		ZavrsiIgru(polja);
		throw runtime_error("Igra zavrsena");
		}
	else if(idi==Status::KrajPoraz){
		cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;endl;
		ZavrsiIgru(polja);
		throw runtime_error("Igra zavrsena");
	}
	else {
		cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"""&lt;&lt;endl;
	}
		}
		catch(out_of_range vani){
			cout&lt;&lt;vani.what()&lt;&lt;endl;
		}
		catch(logic_error izuzetak){
			cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
		}
	}

else if(komanda==Komande::PomjeriDalje){
	try{
	Status idi=Idi(polja,x,y,p_x,p_y);
	if(idi==Status::KrajPobjeda){
		cout&lt;&lt;"Bravo,obisli ste sva sigurna polja"&lt;&lt;endl;	
		ZavrsiIgru(polja);
		throw runtime_error("Igra zavrsena");
	}
	else if(idi==Status::KrajPoraz){
		cout&lt;&lt;"Nagazili ste na minu"&lt;&lt;endl;
		ZavrsiIgru(polja);
		throw runtime_error("Igra zavrsena");
	}
	else cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"""&lt;&lt;endl;
	}
	catch(out_of_range vani){
		cout&lt;&lt;vani.what()&lt;&lt;endl;
	}
	catch(logic_error izuzetak){
		cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
	}
}

else if(komanda==Komande::Blokiraj){
	try{
		BlokirajPolje(polja,p_x,p_y);
	}
	catch(domain_error izuzetak){
		cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
	}
}
else if(komanda==Komande::Deblokiraj){
	try{
		DeblokirajPolje(polja,p_x,p_y);
	}
	catch(domain_error izuzetak){
		cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
	}
}
else if(komanda==Komande::PrikaziOkolinu){
	Matrica v=PrikaziOkolinu(polja,x,y);
	for(int i=0;i&lt;v.size();i++){
		for(int j=0;j&lt;v.size();j++){
			cout&lt;&lt;v[i][j]&lt;&lt;" ";
		}
		cout&lt;&lt;endl;
	}
}
else if(komanda==Komande::ZavrsiIgru){
	ZavrsiIgru(polja);
    throw runtime_error("Igra zavrsena");
	
}
else if(komanda==Komande::KreirajIgru){
	int n;
	Matrica zadnja;
	cout&lt;&lt;"Unesite broj polja: ";
	cin&gt;&gt;n;
	int a,b;
	cout&lt;&lt;"Unesite pozicije mina: ";
	char znak1,znak2,znak3;
	while(1){
		vector&lt;int&gt;v;
		v={};
		cin&gt;&gt;znak1;
		if(znak1=='.')break;
		else if(znak1!='('){
			cin.ignore(1000,'\n');
			cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
			continue;
		}
		cin&gt;&gt;a;
		if(!cin || a&gt;=n || a&lt;0){
			cin.clear();
			cin.ignore(1000,'\n');
			cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
			continue;
		}
		cin&gt;&gt;znak2;
		if(znak2!=','){
			cin.ignore(1000,'\n');
			cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
			continue;
		}
		cin&gt;&gt;b;
		if(!cin || b&gt;=n || b&lt;0){
			cin.clear();
			cin.ignore(1000,'\n');
			cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
			continue;
		}
		cin&gt;&gt;znak3;
		if(znak3!=')'){
			cin.ignore(1000,'\n');
			cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
			continue;
		}
		v.push_back((int)a);
		v.push_back((int)b);
		zadnja.push_back(v);
}
polja=KreirajIgru(n,zadnja);
}
}
int main ()
{
	int x=0,y=0,p_x,p_y;
	Smjerovi smjer=Smjerovi(0);
	Tabla polja;
	Komande komanda=Komande(0);
	int br=0;
	while(1){
		cout&lt;&lt;"Unesite komandu: ";
		KodoviGresaka greska=KodoviGresaka(4);
		if(UnosKomande(komanda,smjer,p_x,p_y,greska)){
			if(komanda==Komande::ZavrsiIgru){
				try{IzvrsiKomandu(komanda,polja,x,y,smjer,p_x,p_y);
				}
				catch(runtime_error kraj){
				break;
				}
			}
			if(komanda==Komande::PomjeriDalje || komanda==Komande::PomjeriJednoMjesto){
				try{
					IzvrsiKomandu(komanda,polja,x,y,smjer,p_x,p_y);
				}
				catch(runtime_error kraj){
					break;
				}
			}
			else IzvrsiKomandu(komanda,polja,x,y,smjer,p_x,p_y);
		}
		else{
			PrijaviGresku(greska);
			continue;
		}
		if(br==0){
		cin.ignore(1000,'\n');
	}
		
	br++;
	}

	return 0;
</font>}</pre>
</body>
</html>
