<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3594.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student8638.cpp<p></p><pre>

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;


enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi {
<a name="3"></a><font color="#00FFFF"><a href="match78-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};



typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

void PrijaviGresku(KodoviGresaka greska){
	if(greska == KodoviGresaka::PogresnaKomanda)
		std::cout &lt;&lt; "Nerazumljiva komanda!"&lt;&lt;std::endl;
	if(greska == KodoviGresaka::NedostajeParametar)
		std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!"&lt;&lt;std::endl;
</font>	if(greska == KodoviGresaka::NeispravanParametar)
<a name="1"></a><font color="#00FF00"><a href="match78-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_25.gif"/></a>

		std::cout &lt;&lt; "Parametar komande nije ispravan!"&lt;&lt;std::endl;
	if(greska == KodoviGresaka::SuvisanParametar)
		std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!"&lt;&lt;std::endl;
}

Tabla KreirajIgru (int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){

	
	for(int i=0; i&lt;mine.size(); i++){
		int brojac(0);
		
		for(int j=0; j&lt;mine[i].size(); j++){
			brojac++;
			if(mine[i][j] &gt;= n){
				throw std::domain_error ("Ilegalne pozicije mina");
			}
		}
		
		if(brojac != 2 ){
			throw std::domain_error ("Ilegalan format zadavanja mina");
		}
	}


	Tabla a;
	a.resize(n);

	for(int i=0; i&lt;n; i++){
		a[i].resize(n);
		for(int j=0; j&lt;n; j++){
			a[i][j]=(Polje::Prazno);						
		}
	}
	int prvi, drugi;
	
	for(int i=0; i&lt;mine.size(); i++){
			prvi = mine[i][0];
			drugi = mine[i][1] ;
			a[prvi][drugi] = Polje::Mina;
	}
	
	return a;
}

int IspitajOkolinu(Tabla polja, int x, int y){
	int brojac(0);
	std::vector&lt;std::vector&lt;int&gt;&gt; smijer{ {-1,-1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}}; 
	
	for(int k=0; k&lt;smijer.size(); k++){
		int i = x + smijer[k][0];
		int j = y + smijer[k][1];
		
		if(i &gt;= 0 &amp;&amp; i &lt; polja.size()-1 &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; polja[i].size()-1){
			if(polja[i][j] == Polje::Mina)
				brojac++;
		}
	}
	return brojac;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
		
	if(x &gt;= polja.size() || y &gt;= polja[0].size() || y &lt; 0 || x &lt; 0){
	std::string greska1("Polje ("), greska2(","), greska3(") ne postoji"), greska_x(std::to_string(x)), greska_y(std::to_string(y));
	std::string greska = greska1 + greska_x + greska2 + greska_y + greska3;
		throw std::domain_error(greska);
	}
	Tabla polja_kopija = polja;
	std::vector&lt;std::vector&lt;int&gt;&gt; Okolina ;
	std::vector&lt;std::vector&lt;int&gt;&gt; smijer{ {-1,-1}, {-1, 0}, {-1, 1}, {0, -1}, {0,0},  {0, 1}, {1, -1}, {1, 0}, {1, 1}};
	std::vector&lt;int&gt; temp;
	
			
			for(int k=0; k&lt;smijer.size(); k++){
						int a = x + smijer[k][0];
						int b = y + smijer[k][1];
						int brojac = IspitajOkolinu(polja_kopija, a, b);
						temp.push_back(brojac);
						if(temp.size() == 3){
							Okolina.push_back(temp);
							temp.clear();
						}
			}
	
	return Okolina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	
	if(x &gt;= polja.size() || y &gt;= polja[0].size() || y &lt; 0 || x &lt; 0){
	std::string greska1("Polje ("), greska2(","), greska3(") ne postoji"), greska_x(std::to_string(x)), greska_y(std::to_string(y));
	std::string greska = greska1 + greska_x + greska2 + greska_y + greska3;
		throw std::domain_error(greska);
	}
	
	if(polja[x][y] == Polje::Prazno)
		polja[x][y] = Polje::BlokiranoPrazno;
</font>	if(polja[x][y] == Polje::Posjeceno)
		polja[x][y] = Polje::BlokiranoPosjeceno;
	if(polja[x][y] == Polje::Mina)
<a name="2"></a><font color="#0000FF"><a href="match78-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

		polja[x][y] = Polje::BlokiranoMina;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	
	if(x &gt;= polja.size() || y &gt;= polja[0].size() || y &lt; 0 || x &lt; 0){
	std::string greska1("Polje ("), greska2(","), greska3(") ne postoji"), greska_x(std::to_string(x)), greska_y(std::to_string(y));
	std::string greska = greska1 + greska_x + greska2 + greska_y + greska3;
		throw std::domain_error(greska);
	}
	
	if(polja[x][y] == Polje::BlokiranoPrazno)
		polja[x][y] = Polje::Prazno;
</font>	if(polja[x][y] == Polje::BlokiranoPosjeceno)
<a name="0"></a><font color="#FF0000"><a href="match78-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_62.gif"/></a>

		polja[x][y] = Polje::Posjeceno;
	if(polja[x][y] == Polje::BlokiranoMina)
		polja[x][y] = Polje::Mina;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	
	if(x+1 &gt;= polja.size() || y+1 &gt;= polja.size() || x &lt; 0 || y &lt; 0 )
		throw std::out_of_range("Izlazak van igrace table");
	
	if (x == 0 &amp;&amp; y == 0 &amp;&amp; (smjer != Smjerovi::Desno &amp;&amp; smjer != Smjerovi::Dolje &amp;&amp; smjer != Smjerovi::DoljeDesno))
		throw std::out_of_range("Izlazak van igrace table");
		
	if(smjer == Smjerovi::Gore){
		if(polja[x-1][y] == Polje::BlokiranoPrazno || polja[x-1][y] == Polje::BlokiranoMina || polja[x-1][y] == Polje::BlokiranoPosjeceno) throw std::logic_error("Blokirano polje");
		x = x-1;
	}
	if(smjer == Smjerovi::Desno){
		if(polja[x][y+1] == Polje::BlokiranoPrazno || polja[x][y+1] == Polje::BlokiranoMina || polja[x][y+1] == Polje::BlokiranoPosjeceno) throw std::logic_error("Blokirano polje");
		y = y+1;
	}
	if(smjer == Smjerovi::Dolje){
		if(polja[x+1][y] == Polje::BlokiranoPrazno || polja[x+1][y] == Polje::BlokiranoMina || polja[x+1][y] == Polje::BlokiranoPosjeceno) throw std::logic_error("Blokirano polje");
		x = x+1;
	}
	if(smjer == Smjerovi::Lijevo){
		if(polja[x][y-1] == Polje::BlokiranoPrazno || polja[x][y-1] == Polje::BlokiranoMina || polja[x][y-1] == Polje::BlokiranoPosjeceno) throw std::logic_error("Blokirano polje");
		y = y-1;
	}
	if(smjer == Smjerovi::GoreLijevo){
		if(polja[x-1][y-1] == Polje::BlokiranoPrazno || polja[x-1][y-1] == Polje::BlokiranoMina || polja[x-1][y-1] == Polje::BlokiranoPosjeceno) throw std::logic_error("Blokirano polje");
		x = x-1;
		y = y-1;
	}
	if(smjer == Smjerovi::GoreDesno){
		if(polja[x-1][y+1] == Polje::BlokiranoPrazno || polja[x-1][y+1] == Polje::BlokiranoMina || polja[x-1][y+1] == Polje::BlokiranoPosjeceno) throw std::logic_error("Blokirano polje");
		x = x-1;
		y = y+1;
	}
	if(smjer == Smjerovi::DoljeDesno){
		if(polja[x+1][y+1] == Polje::BlokiranoPrazno || polja[x+1][y+1] == Polje::BlokiranoMina || polja[x+1][y+1] == Polje::BlokiranoPosjeceno) throw std::logic_error("Blokirano polje");
		x = x+1;
		y = y+1;
	}
	if(smjer == Smjerovi::DoljeLijevo){
		if(polja[x+1][y-1] == Polje::BlokiranoPrazno || polja[x+1][y-1] == Polje::BlokiranoMina || polja[x+1][y-1] == Polje::BlokiranoPosjeceno) throw std::logic_error("Blokirano polje");
		x = x+1;
		y = y-1;
	}
	
	polja[x][y] = Polje::Posjeceno;

	int status(0);	
	if(polja[x][y] == Polje::Mina) status = -1;
	if(polja[x][y] == Polje::Posjeceno) status = 1;
	
	if(status == 0)
		return Status::NijeKraj;
	if(status == -1){
		for(int i=0; i&lt;polja.size(); i++){
			for(int j=0; j&lt;polja[i].size(); j++){
				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	else{
	bool Kraj(true);
		for(int i=0; i&lt;polja.size(); i++){
			for(int j=0; j&lt;polja[i].size(); j++){
				if(polja[i][j] != Polje::Posjeceno){
					Kraj = false;
					break;
				}
			}
		}
	if(Kraj) return Status::KrajPobjeda;
	else return Status::NijeKraj;
	}
}



Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	if(novi_x &gt;= polja.size() || novi_y &gt;= polja[0].size() || novi_x &lt; 0 || novi_y &lt; 0)
		throw std::out_of_range("Izlazak van igrace table");
		
	if(polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno || polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoMina)
		throw std::logic_error("Blokirano polje");
		
	x = novi_x;
	y = novi_y;
	polja[x][y] = Polje::Posjeceno;
	
	
	
	int status(0);	
	if(polja[x][y] == Polje::Mina) status = -1;
	if(polja[x][y] == Polje::Posjeceno) status = 1;
	
	if(status == 0)
		return Status::NijeKraj;
	if(status == -1){
		for(int i=0; i&lt;polja.size(); i++){
			for(int j=0; j&lt;polja[i].size(); j++){
				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	else{
	bool Kraj(true);
		for(int i=0; i&lt;polja.size(); i++){
			for(int j=0; j&lt;polja[i].size(); j++){
				if(polja[i][j] != Polje::Posjeceno){
					Kraj = false;
					break;
				}
			}
		}
	if(Kraj) return Status::KrajPobjeda;
	else return Status::NijeKraj;
	}
}

enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0){
	
	bool kraj (false);
	
	if(komanda == Komande::Blokiraj)
		BlokirajPolje(polja, p_x, p_y);
		
	if(komanda == Komande::Deblokiraj)
		DeblokirajPolje(polja, p_x, p_y);
		
	if(komanda == Komande::PomjeriJednoMjesto){
		Status stat;
		stat = Idi(polja, x, y, p_smjer);
		std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
		if(stat == Status::KrajPobjeda){
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
			kraj = true;
		}
		if(stat == Status::KrajPoraz){
			std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
			kraj = true;
		}
	}
	
	if(komanda == Komande::PomjeriDalje){
		Status stat;
		stat = Idi(polja, x, y, p_x, p_y);
		std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
		if(stat == Status::KrajPobjeda){
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
			kraj = true;
		}
		if(stat == Status::KrajPoraz){
			std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
			kraj = true;
		}
	}
	
	if(komanda == Komande::ZavrsiIgru)
		kraj = true;
	
	if(komanda == Komande::PrikaziOkolinu){
		std::vector&lt;std::vector&lt;int&gt;&gt; okolina;
		okolina = PrikaziOkolinu(polja, p_x, p_y);
		for(int i=0; i&lt;okolina.size(); i++){
			for(int j=0; j&lt;okolina[i].size(); j++){
				std::cout &lt;&lt; okolina[i][j] &lt;&lt; " ";
			}
			std::cout &lt;&lt; std::endl;
		}
	}
	
	if(komanda == Komande::KreirajIgru){
		int n;
		std::cout &lt;&lt; "Unesite broj polja: ";
		std::cin &gt;&gt; n;
		std::vector&lt;std::vector&lt;int&gt;&gt; mine (n, std::vector&lt;int&gt; (2,0));
		std::vector&lt;int&gt; temp;
		
		std::cout &lt;&lt; "Unesite pozicije mina: ";
		int broj1, broj2;
		char zagrada1, zagrada2, zarez, enter;
		
		std::cin &gt;&gt; zagrada1 &gt;&gt; broj1 &gt;&gt; zarez &gt;&gt; broj2 &gt;&gt; zagrada2;
		std::cin &gt;&gt; enter;
		
		temp.push_back(broj1);
		temp.push_back(broj2);
		mine.push_back(temp);
		temp.clear();
		while(enter != '.'){
			std::cin &gt;&gt; zagrada1 &gt;&gt; broj1 &gt;&gt; zarez &gt;&gt; broj2 &gt;&gt; zagrada2;
			std::cin &gt;&gt; enter;
			temp.push_back(broj1);
			temp.push_back(broj2);
			mine.push_back(temp);
			temp.clear();
		}
		
	
	}
	
	if(kraj == true){
		for(int i=0; i&lt;polja.size(); i++){
			for(int j=0; j&lt;polja[i].size(); j++){
				polja[i][j] = Polje::Prazno;
			}
		}
		throw std::runtime_error ("Igra zavrsena");
	}
	
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	
}


int main ()
{	
	/*
	std::cout &lt;&lt; "Unesite komandu: ";
	char Komanda;
	std::cin &gt;&gt; Komanda;
	*/
	try{

	}
	catch(const std::exception&amp; e){
		std::cout &lt;&lt; e.what();
</font>	}
	
	return 0;
}
</pre>
</body>
</html>
