<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student8986.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student8986.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

enum class Polje {
<a name="0"></a><font color="#FF0000"><a href="match712-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Lijevo, Desno=5, DoljeLijevo, Dolje, DoljeDesno
};

enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka{
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokira, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

int brojac_praznih;

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;

//n&gt;=0 uslov treba dodat
Tabla KreirajIgru(int n, const Matrica &amp;mine) {
	for(int i(0); i&lt;mine.size(); i++) {
		if(mine[i].size()!=2)
			throw std::domain_error ("Ilegalan format zadavanja mina");
			
	}
	
	Tabla T;
	T.resize(n);
	for(int i(0); i&lt;T.size(); i++)
		T[i].resize(n);
		
	for(int i(0); i&lt;T.size(); i++) {
		for(int j(0); j&lt;T[0].size(); j++)
			T[i][j]=Polje::Prazno;
	}
	for(int i=0; i&lt;mine.size(); i++) {
		if(mine[i][0]&gt;=n || mine[i][0]&lt;0 || mine[i][1]&gt;=n || mine[i][1]&lt;0)
			throw std::domain_error ("Ilegalne pozicije mina");
		else
			T[mine[i][0]][mine[i][1]]=Polje::Mina;
	}
	brojac_praznih=n*n-int(mine.size());
	return T;
}

Matrica PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	if(x&gt;=polja.size() || x&lt;0 || y&gt;polja.size() || y&lt;0) {
		std::string s("Polje (");
		s+=std::to_string(x);
		s+=",";
		s+=std::to_string(y);
		s+=") ne postoji";
		throw std::domain_error (s);
	}
	Matrica m(3, std::vector&lt;int&gt; (3,0));
	
	int R(0), K(0);
	for(int i=x-1; i&lt;=x+1; i++) {
		for(int j=y-1; j&lt;=y+1; j++) {
			int brojac(0);
			for(int a=i-1; a&lt;=i+1; a++) {
				for(int b=j-1; b&lt;=j+1; b++) {
					try {
						if(polja.at(a).at(b)==Polje::Mina)
							brojac++;
					}
					catch(...) {
						continue;
					}
				}
			}try {
			if(polja.at(i).at(j)==Polje::Mina)
				brojac--;
			m.at(R).at(K)=brojac; }
			catch(...) {}
			K++;
			if(K==3) {
				R++;
				K=0;
			}
		}
	}
	
	return m;
	
}

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	try {
	for(int i=0; i&lt;3; i++) {
		if(int(polja.at(x).at(y))==i)
			polja.at(x).at(y)=Polje(i+3);
	}
	}
	catch(...) {
		std::string s("Polje (");
		s+=std::to_string(x);
		s+=",";
		s+=std::to_string(y);
		s+=") ne postoji";
		throw std::domain_error (s);
	}
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	try {
	for(int i=3; i&lt;6; i++) {
		if(int(polja.at(x).at(y))==i)
			polja.at(x).at(y)=Polje(i-3);
	}
	}
	catch(...) {
		std::string s("Polje (");
		s+=std::to_string(x);
		s+=",";
		s+=std::to_string(y);
		s+=") ne postoji";
		throw std::domain_error (s);
	}
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	int pomx=x-1, pomy=y-1;
	for(int i=0; i&lt;3; i++) {
		
		for(int j=0; j&lt;3; j++) {
			if(int(smjer)==i*3+j) {
				if(pomx&gt;=polja.size() || pomx&lt;0 || pomy&lt;0 || pomy&gt;=polja.size())
					throw std::out_of_range ("Izlazak van igrace table");
				if(polja.at(pomx).at(pomy)==Polje::BlokiranoPosjeceno || polja.at(pomx).at(pomy)==Polje::BlokiranoPrazno || polja.at(pomx).at(pomy)==Polje::BlokiranoMina)
					throw std::logic_error ("Blokirano polje");
				if(polja.at(pomx).at(pomy)==Polje::Mina) {
					polja=Tabla(polja.size(), std::vector&lt;Polje&gt; (polja.size(), Polje::Prazno));
					return Status::KrajPoraz;
				}
				polja.at(x).at(y)=Polje::Posjeceno;
				
				x=pomx;
				y=pomy;
				brojac_praznih--;
				break;
			}
			pomy++;
			if(j==2) {
				pomx++;
				pomy=y-1;
			}
			
		}
	}
	if(brojac_praznih==1)
		return Status::KrajPobjeda;
	
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	if(novi_x&gt;=polja.size() || novi_x&lt;0 || novi_y&lt;0 || novi_y&gt;=polja.size())
		throw std::out_of_range ("Izlazak van igrace table");
	if(polja.at(novi_x).at(novi_y)==Polje::BlokiranoPosjeceno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoPrazno || polja.at(novi_x).at(novi_y)==Polje::BlokiranoMina)
		throw std::logic_error ("Blokirano polje");
	if(polja.at(novi_x).at(novi_y)==Polje::Mina) {
		polja=Tabla(polja.size(), std::vector&lt;Polje&gt; (polja.size(), Polje::Prazno));
		return Status::KrajPoraz;
	}
	polja.at(x).at(y)=Polje::Posjeceno;
				
	x=novi_x;
	y=novi_y;
	brojac_praznih--;
	if(brojac_praznih==1)
		return Status::KrajPobjeda;
	
	return Status::NijeKraj;
	
}

void PrijaviGresku(KodoviGresaka kod) {
	std::vector&lt;std::string&gt; prijave { {"Nerazumljiva komanda!"}, {"Komanda trazi parametar koji nije naveden!"}, {"Zadan je suvisan parametar nakon komande!"}, {"Parametar komande nije ispravan!"} };
	
	for(int i=0; i&lt;prijave.size(); i++) {
		if(int(kod)==i)
			std::cout&lt;&lt;prijave[i]&lt;&lt;std::endl;
	}
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
	std::vector&lt;std::string&gt; komande { {"P1"}, {"P&gt;"}, {"B"}, {"D"}, {"PO"}, {"Z"}, {"K"} };
	std::vector&lt;std::string&gt; parametri { {"GL"}, {"G"}, {"GD"}, {"L"}, {""}, {"D"}, {"DoL"}, {"Do"}, {"DoD"} };
	std::string k, unos, p;
	std::getline(std::cin, unos);
	int i;
	for(i=0; i&lt;unos.length(); i++) {
		if(unos[i]==' ') continue;
		k+=unos[i];
		for(int j=0; j&lt;komande.size(); j++) {
			if(k==komande[j]) {
				komanda=Komande(j);
				break;
			}
		}
		
	}
	if(i==unos.length()) {
		greska=KodoviGresaka::PogresnaKomanda;
		return false;
	}
	if(int(komanda)&gt;3)
		return true;
	else {
		if(int(komanda)==0) {
			for(;i&lt;unos.length(); i++) {
				if(unos[i]==' ') continue;
				p+=unos[i];
				for(int j=0; j&lt;parametri.size(); j++) {
					if(j==4) continue;
					if(p==parametri[j]) {
						smjer=Smjerovi(j);
						break;
					}
				}
			}
		}
	}
	return true;
	
}


int main ()
{
int n(4);	
Tabla T;
Matrica mine{{0,0}, {0,2},{1,3} };
try{
	
T=KreirajIgru(n, mine);
BlokirajPolje(T, 0,1);

int x(2), y(2);
Status nesto;
nesto=Idi(T, x,y, Smjerovi::Gore);
std::cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;std::endl;
for(int i=0; i&lt;n; i++) {
	for(int j=0; j&lt;n; j++)
		std::cout&lt;&lt;int(T[i][j])&lt;&lt;" ";
	std::cout&lt;&lt;std::endl;
}
Matrica m(PrikaziOkolinu(T,0,1));
for(int i=0; i&lt;3; i++) {
		for(int j=0; j&lt;3; j++)
			std::cout&lt;&lt;m[i][j]&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}
PrijaviGresku(KodoviGresaka::NedostajeParametar);

}
catch(std::domain_error greska) {
	std::cout&lt;&lt;greska.what();
}
catch(std::out_of_range greska) {
	std::cout&lt;&lt;greska.what();
}
catch(std::logic_error greska) {
	std::cout&lt;&lt;greska.what();
</font>}

	return 0;
}</pre>
</body>
</html>
