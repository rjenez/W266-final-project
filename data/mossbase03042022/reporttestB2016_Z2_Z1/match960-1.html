<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student5834.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student2035.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

enum class Polje{Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoProsjecno, BlokiranoMina};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
enum class Smjerovi{GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class Status{NijeKraj, KrajPoraz, KrajPobjeda};
enum class KodoviGresaka{PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
enum class Komande{PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru}
Tabla KreirajIgru (int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	Tabla prazna;
	if(n==0) return prazna;
	Tabla a(n, std::vector&lt;Polje&gt; (n, Polje(0))); 

	
	/*PROVJERA ISPRAVNOSTI KOORDINATA MINA*/
	
	for(unsigned int i=0; i&lt;mine.size(); i++) {
		if(mine[i].size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
		if(i==mine.size()-1) break;
		
		}
	

	for(unsigned int i=0; i&lt;mine.size(); i++) {
		
		if(mine[i][0]&gt;n || mine[i][1]&gt;n) throw std::domain_error("Ilegalne pozicije mina");
			
			if(i==mine.size()-1) break;
	}
	
	for(unsigned int i=0; i&lt;mine.size(); i++) {
		int x;
		int y;
		x=mine[i][0];
		y=mine[i][1];
		a[x][y]=Polje(2);
		if(i==mine.size()-1) break;
	}
	
	return a;
	}



std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) { 
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina(3, std::vector&lt;int&gt; (3,0));
	if(x&gt;=polja.size() || y&gt;=polja[0].size() || x&lt;0 || y&lt;0) throw std::domain_error("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji");// pretposatavila sam da je pravilna matrica a ne grbava, provjeri jel to ok
// mogao bi biti problem ako su polja prazna matrica jer pristupam elementu kog nema 
				int brojac(0);
				
				for(int k=0; k&lt;3; k++) {
					for(int l=0; l&lt;3; l++) {
			
							int a;
							a=x+k-1;
							int b;
							b=y+l-1;
						a=a-1; 	
						b=b-1;	
						for(int o=a; o&lt;=a+2; o++) {
						if(o&lt;0 || o&gt;polja.size()) continue;
						
						for(int p=b; p&lt;=b+2; p++) {
								if( p&lt;0 || p&gt;polja.size()) continue; 
								else {
									if(o==x+k-1 &amp;&amp; p==y+l-1)  continue;
								else if(polja[o][p]==Polje(2))  brojac++;   } } }
							
							okolina[k][l]=brojac;
							brojac=0;
		
					}
				}
	
return okolina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
<a name="1"></a><font color="#00FF00"><a href="match960-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

	if(x&gt;=polja.size() || x&lt;0 || y&lt;0 || y&gt;=polja[0].size()) throw std::domain_error("Polje (" + std::to_string(x) + "," + std::to_string(y)+") ne postoji");
	/*ovo sve moze u petlju*/
	// ovo polja[0] bi moglo stavarat problem ako se posalje prazna matrica
	if(polja[x][y]==Polje(0)) polja[x][y]=Polje(3);
	if(polja[x][y]==Polje(1)) polja[x][y]=Polje(4);
	if(polja[x][y]==Polje(2)) polja[x][y]=Polje(5);
	
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x&gt;=polja.size() || x&lt;0 || y&gt;=polja[0].size() || y&lt;0) throw std::domain_error("Polje (" + std::to_string(x) + "," + std::to_string(y)+ ") ne postoji");
</font><a name="0"></a><font color="#FF0000"><a href="match960-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

	// opet problem ako je matrica prazna
	/*opet sve je moglo u petlju*/
	if(polja[x][y]==Polje(3)) polja[x][y]=Polje(0);
	if(polja[x][y]==Polje(4)) polja[x][y]=Polje(1);
	if(polja[x][y]==Polje(5)) polja[x][y]=Polje(2);
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
</font>	polja[x][y]=Polje(1);
	if(smjer==Smjerovi(0)) {
		if (x-1&lt;0 || y-1&lt;0) throw std::out_of_range("Izlazak van granica table");
<a name="5"></a><font color="#FF0000"><a href="match960-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

		if(polja[x-1][y-1]==Polje(3) || polja[x-1][y-1]==Polje(4) || polja[x-1][y-1]==Polje(5)) throw std::logic_error("Blokirano polje");
</font>	
		x=x-1;
		y=y-1;
	}
	if(smjer==Smjerovi(1)) {
		if(x-1&lt;0) throw std::out_of_range("Izlazak van granica table");
<a name="6"></a><font color="#00FF00"><a href="match960-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

		if(polja[x-1][y]==Polje(3) || polja[x-1][y]==Polje(4) || polja[x-1][y]==Polje(5)) throw std::logic_error("Blokirano polje");
	
		x=x-1;
</font>		}
	if(smjer==Smjerovi(2)) {
		if(x-1&lt;0 || y+1&gt;=polja.size()) throw std::out_of_range("Izvan granica table");
<a name="3"></a><font color="#00FFFF"><a href="match960-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

		if(polja[x-1][y+1]==Polje(3) || polja[x-1][y+1]==Polje(4) || polja[x-1][y+1]==Polje(5)) throw std::logic_error("Blokirano polje");
	
		x=x-1;
</font>		y=y+1;
	}

	if(smjer==Smjerovi(3)) {
		if(y+1&gt;=polja.size()) throw std::out_of_range("Izvan granica table");
<a name="9"></a><font color="#FF00FF"><a href="match960-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

		if(polja[x][y+1]==Polje(3) || polja[x][y+1]==Polje(4) || polja[x][y+1]==Polje(5) ) throw std::logic_error("Blokirano polje");
</font>	
		y=y+1;
	}
	
	if(smjer==Smjerovi(4)) {
		if(x+1&gt;=polja.size() || y&gt;=polja.size()) throw std::out_of_range("Izvan granica table");
<a name="7"></a><font color="#0000FF"><a href="match960-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		if(polja[x+1][y+1]==Polje(3) || polja[x+1][y+1]==Polje(4) || polja[x+1][y+1]==Polje(5)) throw std::logic_error("Blokirano polje");
</font>	
		x=x+1;
		y=y+1;
	}
	
	if(smjer==Smjerovi(5)) {
		if(x+1&gt;=polja.size()) throw std::out_of_range("Izvan granica table");
<a name="10"></a><font color="#FF0000"><a href="match960-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

		if(polja[x+1][y]==Polje(3) || polja[x+1][y]==Polje(4) || polja[x+1][y]==Polje(5)) throw std::logic_error("Blokirano polje");
		
		x=x+1;
</font>	}
	
	if(smjer==Smjerovi(6)) {
		if(x+1&gt;=polja.size() || y-1&lt;0) throw std::out_of_range("Izvan granica table");
<a name="4"></a><font color="#FF00FF"><a href="match960-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

		if(polja[x+1][y-1]==Polje(3) || polja[x+1][y-1]==Polje(4) || polja[x+1][y-1]==Polje(5)) throw std::out_of_range("Blokirano polje");
</font>		
		x=x+1;
		y=y-1;
	}
	
	if(smjer==Smjerovi(7)) {
		if(y-1&lt;0) throw std::out_of_range("Izvan granica table");
<a name="8"></a><font color="#00FFFF"><a href="match960-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

		if(polja[x][y-1]==Polje(3) || polja[x][y-1]==Polje(4) || polja[x][y-1]==Polje(5)) throw std::out_of_range("Blokirano polje");
</font>		
		y=y-1;
	}
		
		
		if(polja[x][y]==Polje(2)) {
			for(unsigned int i=0; i&lt;polja.size(); i++) {
				for(unsigned int j=0; j&lt;polja.size(); j++) // jer je kvadratna matrica
				polja[i][j]=Polje(0);
			}
			
			return Status(1);
		}
		
		for(unsigned int i=0; i&lt;polja.size(); i++) {
<a name="2"></a><font color="#0000FF"><a href="match960-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

			for(unsigned int j=0; j&lt;polja.size(); j++)
			if(polja[i][j]==Polje(0)) return Status(0);
		}
		
		return Status(2);
	}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	
	if(novi_x&lt;0 ||  novi_y&lt;0 || novi_x&gt;=polja.size() || novi_y&gt;=polja.size()) throw std::out_of_range("Izvan granica table");
</font>	if( polja[novi_x][novi_y]==Polje(3) || polja[novi_x][novi_y]==Polje(4) || polja[novi_x][novi_y]==Polje(5)) throw std::logic_error("Blokirano polje");
	polja[x][y]=Polje(1);
	x=novi_x;
	y=novi_y;
	if(polja[x][y]==Polje(2)) {
		for(unsigned int i=0; i&lt;polja.size(); i++) 
		for(unsigned int j=0; j&lt;polja.size(); j++) polja[i][j]=Polje(0);
		return Status(1);
		}
	for(unsigned int i=0; i&lt;polja.size(); i++) {
		for(unsigned j=0; j&lt;polja.size(); j++)
<a name="11"></a><font color="#00FF00"><a href="match960-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if(polja[i][j]==Polje(0)) return Status(0);
	}
	
	return Status(2);
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
</font>{
	
	
}

/*void ispisiTablu(std::vector&lt;std::vector&lt;Polje&gt;&gt; polja) {
	for(int i=0; i&lt;polja.size(); i++) {
		for(int j=0; j&lt;polja[i].size(); j++) {
			std::cout &lt;&lt; int(polja[i][j]) &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
}*/
	
	
	int main() {
	
	/*
	
	
	
	std::vector&lt;std::vector&lt;int&gt;&gt; mine={{0,2}, {1,3}, {1,5}, {4,2}, {5,1}, {5,5}};
	std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla=KreirajIgru(0, mine);
	ispisiTablu(tabla);*/ 

/*	
	try{
		std::vector&lt;std::vector&lt;int&gt;&gt; mine={{1,0}, {6,1}};
		std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla=KreirajIgru(5, mine);
	}
	
	catch (std::domain_error e) {
		std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
	}
	
	try {
		std::vector&lt;std::vector&lt;int&gt;&gt; mine={{1,0}, {6,1}};
		std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla=KreirajIgru(5, mine);
	}
		catch(std::domain_error e){
		std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
	}*/
	
/*	
	try {
		std::vector&lt;std::vector&lt;int&gt;&gt; mine={{1,0}, {1}};
		std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla=KreirajIgru(5, mine);
	}
	
	catch(std::domain_error e) {
		std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
	}
	
	
	try{
		std::vector&lt;std::vector&lt;int&gt;&gt; mine={{1,0}, {1,2,3}};
		std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla=KreirajIgru(5, mine);
	}
	
	catch(std::domain_error e) {
		std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
	} */
	
//AT	2 
/*
	std::vector&lt;std::vector&lt;int&gt;&gt; mine={{0,1}, {0,4}, {1,3}, {1,4}, {2,0}, {2,1}, {2,3}};
	std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla=KreirajIgru(5,mine);
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina=PrikaziOkolinu(tabla, 1, 1);
	for(int i=0; i&lt;okolina.size(); i++) {
		for(int j=0; j&lt;okolina[i].size(); j++) std::cout &lt;&lt; okolina[i][j] &lt;&lt; " ";
		std::cout &lt;&lt; std::endl;
	} */
	
//AT  10

std::vector&lt;std::vector&lt;int&gt;&gt; mine={{0,1}, {0,2}, {1,0}, {1,1}, {1,2}, {2,0}, {2,1 }, {2,2}};
std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla=KreirajIgru(3, mine);

try {
	auto okolina=PrikaziOkolinu(tabla, 3, 5);
}
catch(std::domain_error e) {
	std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
}
try {
	auto okolina=PrikaziOkolinu(tabla, 1, 5);
}
catch(std::domain_error e) {
	std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
}
try{
	auto okolina=PrikaziOkolinu(tabla, 3, 1); 
}
catch(std::domain_error e) {
	std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
}
	return 0;
	
}

</pre>
</body>
</html>
