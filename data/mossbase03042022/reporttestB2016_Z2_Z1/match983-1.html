<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4628.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student7802.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
using std::cin;
using std::cout;
using std::endl;
using std::string;

<a name="10"></a><font color="#FF0000"><a href="match983-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

enum class Smjerovi {GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
 
enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};

enum class Polje {Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};
</font>
enum class KodoviGresaka {PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};


typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;



void PrijaviGresku(KodoviGresaka x){
	
	if(x==KodoviGresaka::PogresnaKomanda) cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;endl;
	else if(x==KodoviGresaka::NedostajeParametar) cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;endl;
	else if(x==KodoviGresaka::SuvisanParametar) cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;endl;
	else if(x==KodoviGresaka::NeispravanParametar) cout&lt;&lt;"Parametar komande nije ispravan!"&lt;&lt;endl;
	
}

void OcistiTablu(Tabla &amp;polja){
	for(int i(0);i&lt;polja.size();i++)
		for(int j(0);j&lt;polja[i].size();j++)
			polja[i][j]=Polje::Prazno;
}


Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	for(int i(0);i&lt;mine.size();i++)
	if(mine.at(i).size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
	
	for(int i(0);i&lt;mine.size();i++)
		for(int j(0);j&lt;mine.at(i).size();j++)
			if(mine.at(i).at(j)&gt;=n || mine.at(i).at(j)&lt;0) throw std::domain_error("Ilegalne pozicije mina");
	Tabla tabla(n);
	for(int i(0);i&lt;n;i++)
		tabla[i].resize(n);
	
	for(int i(0);i&lt;mine.size();i++){
	for(int k(0);k&lt;n;k++)
		for(int j(0);j&lt;n;j++){
			std::vector&lt;int&gt; sklj{k,j};
			if(sklj==mine[i]) {
				tabla[k][j]=Polje::Mina;
			}
		
		}}
	for(int k(0);k&lt;n;k++)
		for(int j(0);j&lt;n;j++){
			if(tabla[k][j]!=Polje::Mina) {
				tabla[k][j]=Polje::Prazno;
			}
		
		}
	return tabla;
} 
int BrojMina(int x, int y,const Tabla &amp;polja){
	int br(0);
	int brojac(0);
		for(int i(x-1);brojac&lt;3;i++){
			int brojac1(0);
			for(int j(y-1);brojac1&lt;3;j++){
			if(i==x &amp;&amp; j==y){}
			else{
				if(i&lt;0 || j&lt;0 || i&gt;=polja.size() || j&gt;=polja[i].size()){}
				else if(polja[i][j]==Polje::Mina){br++;}
				else{}
			}
			brojac1++;
			}
		brojac++;
		}
	return br;
}
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	std::vector&lt;std::vector&lt;int&gt;&gt; mat(3,std::vector&lt;int&gt; (3));
		if(x&gt;=polja.size() || y&gt;=polja[0].size() || x&lt;0 || y&lt;0) {
			
			int h(x);
			int m(y);
			string iks;
			string ipsilon;
			while(h!=0){
				iks.push_back(h%10 + '0');
				h=h/10;
			}
			while(m!=0){
				ipsilon.push_back(m%10 + '0');
			
				m=m/10;
			}
			
			string s;
			string a{"Polje ("};
			string b{","};
			string c{") ne postoji"};
			s=a+iks+b+ipsilon+c;
			throw std::domain_error(s);
			
		}
		int n(3);
		int m(3);
		int k(0);
		for(int i(x-1);k&lt;n;i++){
			int l(0);
			for(int j(y-1);l&lt;m;j++){
				mat[k][l]=BrojMina(i,j,polja);
				l++;	
			}
		k++;}
	return mat;
}

<a name="8"></a><font color="#00FFFF"><a href="match983-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&gt;=polja.size() || y&gt;=polja[0].size() || x&lt;0 || y&lt;0) {
</font>			int h(x);
			int m(y);
			string iks;
			string ipsilon;
			while(h!=0){
				iks.push_back(h%10 + '0');
				h=h/10;
			}
			while(m!=0){
				ipsilon.push_back(m%10 + '0');
			
				m=m/10;
			}
			string s;
			string a{"Polje ("};
			string b{","};
			string c{") ne postoji"};
			s=a+iks+b+ipsilon+c;
			throw std::domain_error(s);
		}
	if(polja[x][y]==Polje::BlokiranoMina || polja[x][y]==Polje::BlokiranoPrazno){}
	else{
	if(polja[x][y]==Polje::Mina) polja[x][y]=Polje::BlokiranoMina;
<a name="11"></a><font color="#00FF00"><a href="match983-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

		else polja[x][y]=Polje::BlokiranoPrazno;
}
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&gt;=polja.size() || y&gt;=polja[0].size() || x&lt;0 || y&lt;0) {
</font>			
			int h(x);
			int m(y);
			string iks;
			string ipsilon;
			while(h!=0){
				iks.push_back(h%10 + '0');
				h=h/10;
			}
			while(m!=0){
				ipsilon.push_back(m%10 + '0');
			
				m=m/10;
			}
			
			string s;
			string a{"Polje ("};
			string b{","};
			string c{") ne postoji"};
			s=a+iks+b+ipsilon+c;
			throw std::domain_error(s);
			
		}
	if(polja[x][y]==Polje::Mina || polja[x][y]==Polje::Prazno || polja[x][y]==Polje::Posjeceno){}
	else{
	if(polja[x][y]==Polje::BlokiranoMina) polja[x][y]=Polje::Mina;
		else polja[x][y]=Polje::Prazno;
}
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
		
		polja[x][y]=Polje::Posjeceno;
		int br(0);
		for(int i(0);i&lt;polja.size();i++){
			for(int j(0);j&lt;polja[i].size();j++){
			if(polja[i][j]==Polje::Prazno)br++;	
			}
		}
			if(smjer==Smjerovi::Gore){
			if(x-1&lt;0) throw std::out_of_range("Izlazak van igrace table");
<a name="4"></a><font color="#FF00FF"><a href="match983-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

			if(polja[x-1][y]==Polje::BlokiranoPosjeceno || polja[x-1][y]==Polje::BlokiranoPrazno || polja[x-1][y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
			
			if(polja[x-1][y]==Polje::Mina){
				OcistiTablu(polja);return Status::KrajPoraz;
</font>			}
			else if(polja[x-1][y]==Polje::Prazno){
				if(polja[x-1][y]==Polje::Prazno &amp;&amp; br==1) return Status:: KrajPobjeda;
				else {
					
					x-=1;
					return Status::NijeKraj;
				}
			}
			
		}
		else if(smjer==Smjerovi::GoreDesno){

				if(x-1&lt;0||y+1&gt;=polja.size() ) throw std::out_of_range("Izlazak van igrace table");
<a name="5"></a><font color="#FF0000"><a href="match983-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

				if(polja[x-1][y+1]==Polje::BlokiranoPosjeceno || polja[x-1][y+1]==Polje::BlokiranoPrazno || polja[x-1][y+1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
				
			if(polja[x-1][y+1]==Polje::Mina){
</font>				OcistiTablu(polja);return Status::KrajPoraz;
			}
			else if(polja[x-1][y+1]==Polje::Prazno){
				if(polja[x-1][y+1]==Polje::Prazno &amp;&amp; br==1) return Status ::KrajPobjeda;
				else {
					
					y+=1;
					x-=1;
					return Status::NijeKraj;
				}
			}
		}
		else if(smjer==Smjerovi::GoreLijevo){
			

			if(y-1&lt;0 || x-1&lt;0) throw std::out_of_range("Izlazak van igrace table");
<a name="0"></a><font color="#FF0000"><a href="match983-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

			if(polja[x-1][y-1]==Polje::BlokiranoPosjeceno || polja[x-1][y-1]==Polje::BlokiranoPrazno || polja[x-1][y-1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
			
			if(polja[x-1][y-1]==Polje::Mina){
				OcistiTablu(polja);return Status::KrajPoraz;
</font>			}
			else if(polja[x-1][y-1]==Polje::Prazno){
				if(polja[x-1][y-1]==Polje::Prazno &amp;&amp; br==1) return Status ::KrajPobjeda;
				else {
					
					y-=1;
					x-=1;
					return Status::NijeKraj;
				}
			}
		}
		else if(smjer==Smjerovi::Lijevo){
			if(y-1&lt;0) throw std::out_of_range("Izlazak van igrace table");
<a name="6"></a><font color="#00FF00"><a href="match983-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

			if(polja[x][y-1]==Polje::BlokiranoPosjeceno || polja[x][y-1]==Polje::BlokiranoPrazno || polja[x][y-1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
			
			if(polja[x][y-1]==Polje::Mina){
</font>				OcistiTablu(polja); return Status::KrajPoraz;
			}
			else if(polja[x][y-1]==Polje::Prazno){
				if(polja[x][y-1]==Polje::Prazno &amp;&amp; br==1) return Status::KrajPobjeda;
				else {
					
					y-=1;
					return Status::NijeKraj;
				}
			}
		}
		else if(smjer==Smjerovi::Desno){
			
			if(y+1&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
<a name="3"></a><font color="#00FFFF"><a href="match983-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

			if(polja[x][y+1]==Polje::BlokiranoPosjeceno || polja[x][y+1]==Polje::BlokiranoPrazno || polja[x][y+1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
			
			if(polja[x][y+1]==Polje::Mina){
</font>				OcistiTablu(polja);return Status::KrajPoraz;
			}
			else if(polja[x][y+1]==Polje::Prazno){
				if(polja[x][y+1]==Polje::Prazno &amp;&amp; br==1) return Status ::KrajPobjeda;
				else {
					
					y+=1;
					return Status::NijeKraj;
				}
			}
		}
		else if(smjer==Smjerovi::DoljeDesno){
				if(x+1&gt;=polja[0].size() || y+1&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
<a name="2"></a><font color="#0000FF"><a href="match983-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

				if(polja[x+1][y+1]==Polje::BlokiranoPosjeceno || polja[x+1][y+1]==Polje::BlokiranoPrazno || polja[x+1][y+1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
				
			
			if(polja[x+1][y+1]==Polje::Mina){
				OcistiTablu(polja);
</font>				return Status::KrajPoraz;
			}
			else if(polja[x+1][y+1]==Polje::Prazno){
				if(polja[x+1][y+1]==Polje::Prazno &amp;&amp; br==1) return Status:: KrajPobjeda;
				else {
					
					y+=1;
					x+=1;
					return Status::NijeKraj;
				}
			}
		}
		else if(smjer==Smjerovi::DoljeLijevo){
			if(y-1&lt;0 || x+1&gt;=polja[0].size()) throw std::out_of_range("Izlazak van igrace table");
<a name="1"></a><font color="#00FF00"><a href="match983-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

			if(polja[x+1][y-1]==Polje::BlokiranoPosjeceno || polja[x+1][y-1]==Polje::BlokiranoPrazno || polja[x+1][y-1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
			
			
			if(polja[x+1][y-1]==Polje::Mina){
				OcistiTablu(polja);return Status::KrajPoraz;
</font>			}
			else if(polja[x+1][y-1]==Polje::Prazno){
				if(polja[x+1][y-1]==Polje::Prazno &amp;&amp; br==1) return Status ::KrajPobjeda;
				else {
					
					y-=1;
					x+=1;
					return Status::NijeKraj;
				}
			}
		}
		else{
			if(x+1&gt;=polja[0].size()) throw std::out_of_range("Izlazak van igrace table");
<a name="7"></a><font color="#0000FF"><a href="match983-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

			if(polja[x+1][y]==Polje::BlokiranoPosjeceno || polja[x+1][y]==Polje::BlokiranoPrazno || polja[x+1][y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
			
			if(polja[x+1][y]==Polje::Mina){
</font>				OcistiTablu(polja);
				return Status::KrajPoraz;
			}
			else if(polja[x+1][y]==Polje::Prazno){
				if(polja[x+1][y]==Polje::Prazno &amp;&amp; br==1) return Status ::KrajPobjeda;
				else {
				
					x+=1;
					return Status::NijeKraj;
				}
			}
		}
	
	
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){

		
		polja[x][y]=Polje::Posjeceno;
		int br(0);
		for(int i(0);i&lt;polja.size();i++){
			for(int j(0);j&lt;polja[i].size();j++){
			if(polja[i][j]==Polje::Prazno)br++;	
			}
		}
		
<a name="9"></a><font color="#FF00FF"><a href="match983-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		if(novi_x&lt;0 || novi_y&lt;0 || novi_x&gt;=polja.size() || novi_y&gt;=polja[0].size()) throw std::out_of_range("Izlazak van igrace table");
		if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno || polja[novi_x][novi_y]==Polje::BlokiranoPrazno || polja[novi_x][novi_y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font><a name="12"></a><font color="#0000FF"><a href="match983-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

		
		if(polja[novi_x][novi_y]==Polje::Mina){
				OcistiTablu(polja);
</font>				return Status::KrajPoraz;
			}
			else if(polja[novi_x][novi_y]==Polje::Prazno){
				if(polja[novi_x][novi_y]==Polje::Prazno &amp;&amp; br==1) return Status ::KrajPobjeda;
				else {
				
					x=novi_x;
					y=novi_y;
					return Status::NijeKraj;
				}
			}
		
	return Status::NijeKraj;
}




int main ()
{	
	
	cout&lt;&lt;"Unesite broj polja: ";
	int n;
	cin&gt;&gt;n;
	cout&lt;&lt;"Unesite pozicije mina: \n";
	auto tabla(KreirajIgru(n, {{0,1}, {0,4}, {1,3}, {1,4}, {2,0}, {2,1}, {2,3}}));
		for(int i(0);i&lt;tabla.size();i++){
		for(int j(0);j&lt;tabla[i].size();j++)
			if(tabla[i][j]==Polje::Mina)cout&lt;&lt;"1 ";
				else cout&lt;&lt;"0 ";
		cout&lt;&lt;endl;
	}


	cout&lt;&lt;"\nUnesite koordinate neke tacke: ";
	try{
	auto m(PrikaziOkolinu(tabla,0,0));
	for(int i(0);i&lt;m.size();i++){
		for(int j(0);j&lt;m[i].size();j++)
			cout&lt;&lt;m[i][j]&lt;&lt;" ";
	
	
	
	
	
		cout&lt;&lt;endl;
	}}catch(...){
		cout&lt;&lt;"ahaa";
		
	}
    return 0;
}</pre>
</body>
</html>
