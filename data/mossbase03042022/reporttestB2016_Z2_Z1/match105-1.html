<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student7320.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4780.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

#define pb push_back

enum class Polje {
 Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
enum class Smjerovi {
 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar
};
enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};

<a name="0"></a><font color="#FF0000"><a href="match105-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_43.gif"/></a>

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine);
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y);
void BlokirajPolje(Tabla &amp;polja, int x, int y);
void DeblokirajPolje(Tabla &amp;polja, int x, int y);
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer);
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y);
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y);
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska);

int setamX[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};
int setamY[] = {-1, 0,   1,-1, 0, 1,-1, 0, 1};
int main ()
{
	std::vector&lt;std::vector&lt;int&gt;&gt; mine{{0,0}, {0,2}, {1,3}};
	
	auto TablaIgre = KreirajIgru(4, mine);
	
	for (int i = 0; i &lt; TablaIgre.size(); i++) {
		for (int j = 0; j &lt; TablaIgre.at(i).size(); j++)
			if (Polje::Mina == TablaIgre[i][j]) std::cout &lt;&lt; 1 &lt;&lt; " ";
			else std::cout &lt;&lt; "0 ";
		std::cout &lt;&lt; "\n";
	}
	auto okolina = PrikaziOkolinu(TablaIgre, 1, 1);
	for (int i = 0; i &lt; 3; i++) {
		for (int j = 0; j &lt; 3; j++)
			std::cout &lt;&lt; okolina[i][j] &lt;&lt; " ";
		std::cout &lt;&lt; "\n";
	}
	return 0;
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	Tabla ret;
	ret.resize(n);
	for (int i = 0; i &lt; n; i++) {
		ret.at(i).resize(n);
		for (int j = 0; j &lt; ret.at(i).size(); j++)
			ret[i][j] = Polje::Prazno;
	}
	for (int i = 0; i &lt; mine.size(); i++) {
		if (mine.at(i).size() != 2) throw std::domain_error("Ilegalan format zadavanja mina");
		for (int j = 0; j &lt; mine.at(i).size(); j++) {
			int value_polja = mine.at(i).at(j);
			if (value_polja &lt; 0 || value_polja &gt;= n) throw std::domain_error("Ilegalne pozicije mina");
		}
	}
	for (int i = 0; i &lt; mine.size(); i++) {
		ret[mine[i][0]][mine[i][1]] = Polje::Mina;
	}
	return ret;
}
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	std::string zaIzuzetak = "(";
	zaIzuzetak += (x + '0'); zaIzuzetak += ','; zaIzuzetak += (y + '0'); zaIzuzetak += ')';
	if (x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size()) throw std::domain_error("Polje " + zaIzuzetak + " ne postoji");
	std::vector&lt;std::vector&lt;int&gt;&gt; ret;
	std::vector&lt;int&gt; pusham;
	
	int n  = polja.size();
	int dodajem = 0;
	for (int d1 = 0; d1 &lt; 9; d1++) {
		int xko = x + setamX[d1];
		int yko = y + setamY[d1];
		int br_susjeda = 0;
		if (xko &lt; 0 || xko &gt;= n || yko &lt; 0 || yko &gt;= n) br_susjeda = 0;
		else {
			for (int d2 = 0; d2 &lt; 9; d2++) {
				int x1 = xko + setamX[d2];
				int y1 = yko + setamY[d2];
				if (!(x1 &lt; 0 || x1 &gt;= n || y1 &lt; 0 || y1 &gt;= n))
				if (polja[x1][y1] == Polje::Mina) br_susjeda++;
			}
			//std::cout &lt;&lt; xko &lt;&lt;" , " &lt;&lt; yko &lt;&lt; " = " &lt;&lt;br_susjeda &lt;&lt; "\n";
			dodajem++;
			if (polja[xko][yko] == Polje::Mina) {
				if (br_susjeda != 0) br_susjeda--;
			}
			pusham.pb(br_susjeda);
			if (dodajem == 3) {
				dodajem = 0;
				ret.pb(pusham);
				pusham.clear();
			}
		}
	}
	ret.pb(pusham);
	pusham.clear();
	dodajem = 0;
	return ret;
}
void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	std::string zaIzuzetak = "(";
	zaIzuzetak += (x + '0'); zaIzuzetak += ','; zaIzuzetak += (y + '0'); zaIzuzetak += ')';
	if (x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size()) throw std::domain_error("Polje " + zaIzuzetak + " ne postoji");
	
	if (polja[x][y] == Polje::Mina) polja[x][y] = Polje::BlokiranoMina;
</font>	if (polja[x][y] == Polje::Posjeceno) polja[x][y] = Polje::BlokiranoPosjeceno;
<a name="4"></a><font color="#FF00FF"><a href="match105-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

	if (polja[x][y] == Polje::Prazno) polja[x][y] = Polje::BlokiranoPrazno;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	std::string zaIzuzetak = "(";
	zaIzuzetak += (x + '0'); zaIzuzetak += ','; zaIzuzetak += (y + '0'); zaIzuzetak += ')';
	if (x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size()) throw std::domain_error("Polje " + zaIzuzetak + " ne postoji");
	
	if (polja[x][y] == Polje::BlokiranoMina) polja[x][y] = Polje::Mina;
</font><a name="3"></a><font color="#00FFFF"><a href="match105-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_10.gif"/></a>

	if (polja[x][y] == Polje::BlokiranoPosjeceno) polja[x][y] = Polje::Posjeceno;
	if (polja[x][y] == Polje::BlokiranoPrazno) polja[x][y] = Polje::Prazno;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	int idx = 4;
	/*
		int setamX[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};
		int setamY[] = {-1, 0,   1,-1, 0, 1,-1, 0, 1};
	*/
	if (smjer == Smjerovi::GoreLijevo) idx = 0;
	else if (smjer == Smjerovi::Gore) idx = 1;
	else if (smjer == Smjerovi::GoreDesno) idx = 2;
	else if (smjer == Smjerovi::Lijevo) idx = 3;
	else if (smjer == Smjerovi::Desno) idx = 5;
	else if (smjer == Smjerovi::DoljeLijevo) idx = 6;
	else if (smjer == Smjerovi::Dolje) idx = 7;
	else if (smjer == Smjerovi::DoljeDesno) idx = 8;
	
	polja[x][y] = Polje::Posjeceno;
	
	Status ret;
	int nX, nY;
	nX = x + setamX[idx]; nY = y + setamY[idx];
	
	if (nX &lt; 0 || nX &gt;= polja.size() || nY &lt; 0 || nY &gt;= polja.size()) throw std::out_of_range("Izlazak van igrace table");
	x = nX;
	y = nY;
	if (polja[nX][nY] == Polje::BlokiranoPosjeceno || polja[nX][nY] == Polje::BlokiranoPrazno || polja[nX][nY] == Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font><a name="2"></a><font color="#0000FF"><a href="match105-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_10.gif"/></a>

	if (polja[nX][nY] == Polje::Mina) {
		for (int i = 0; i &lt; polja.size(); i++)
			for (int j = 0; j &lt; polja[i].size(); j++)
				polja[i][j] == Polje::Prazno;
		ret = Status::KrajPoraz;
		return ret;
	}
	
	int brojPraznih = 0;
	ret = Status::NijeKraj;
	for (int i = 0; i &lt; polja.size(); i++)
		for (int j = 0; j &lt; polja[i].size(); j++)
			if (polja[i][j] == Polje::Prazno) brojPraznih++;
	if (brojPraznih == 0) ret = Status::KrajPobjeda;
	
	return ret;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	int nX, nY;
	nX = novi_x;
	nY = novi_y;
	Status ret;
	
	if (nX &lt; 0 || nX &gt;= polja.size() || nY &lt; 0 || nY &gt;= polja.size()) throw std::out_of_range("Izlazak van igrace table");
	x = nX;
	y = nY;
	if (polja[nX][nY] == Polje::BlokiranoPosjeceno || polja[nX][nY] == Polje::BlokiranoPrazno || polja[nX][nY] == Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
</font><a name="1"></a><font color="#00FF00"><a href="match105-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_22.gif"/></a>

	if (polja[nX][nY] == Polje::Mina) {
		for (int i = 0; i &lt; polja.size(); i++)
			for (int j = 0; j &lt; polja[i].size(); j++)
				polja[i][j] == Polje::Prazno;
		ret = Status::KrajPoraz;
		return ret;
	}
	
	int brojPraznih = 0;
	ret = Status::NijeKraj;
	for (int i = 0; i &lt; polja.size(); i++)
		for (int j = 0; j &lt; polja[i].size(); j++)
			if (polja[i][j] == Polje::Prazno) brojPraznih++;
	if (brojPraznih == 0) ret = Status::KrajPobjeda;
	
	return ret;
	
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
	std::string unos, s1, s2;
	getline(std::cin, unos);
	s1 = s2 = "";
	
	int koji_char = 0;
	char c1, c2;
	int idx2 = -1;
	
	for (int i = 0; i &lt; unos.length(); i++) {
		if (unos.at(i) != ' ') {
			if (koji_char == 0) {
				c1 = unos.at(i);
				koji_char++;
			}
			else if (koji_char == 1) {
				c2 = unos.at(i);
				idx2 = i;
				koji_char++;
			}
			
		}
	}
	bool bio_char = 0;
	koji_char = 0;
	for (int i = idx2; i &lt; unos.length(); i++) {
		if (unos[i] != ' ') bio_char = 1;
		if (!bio_char) continue;
		else {
			if (koji_char == 0) {
				for (int j = i; j &lt; unos.length(); j++)
					if (unos[j] != ' ') s1 += unos[j];
					else break;
				koji_char++;
			}
			else if (koji_char == 1) {
				for (int j = i; j &lt; unos.length(); j++)
					if (unos[j] != ' ') s1 += unos[j];
					else break;
				koji_char++;
			}
		}
	}
	
	if (c1 == 'P') {
		if (c2 == '&gt;') {
			int br1, br2;
			br1 = br2 = 0;
			for (int i = s1.length() - 1; i &gt;= 0; i--) br1 = br1 * 10 + (s1[i] - '0');
			for (int i = s2.length() - 1; i &gt;= 0; i--) br2 = br2 * 10 + (s2[i] - '0');
			x = br1;
			y = br2;
			komanda = Komande::PomjeriDalje;
			return 1;
		}
		else if (c2 == '1')
	
		else {
			
		}
	}
	else if (c1 == 'B') {
		
	}
	else if (c1 == 'D') {
		
	}
	else if (c1 == 'Z') {
		
	}
	else if (c1 == 'K') {
</font>		
	}
	return 1;
}</pre>
</body>
</html>
