<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4473.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4473.cpp<p></p><pre>
/*B 16/17, Zadaća 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

enum class Polje { Prazno = 0, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina };
enum class Smjerovi { GoreLijevo = 0, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo };
enum class Status { NijeKraj = 0, KrajPoraz, KrajPobjeda };
enum class KodoviGresaka { PogresnaKomanda = 0, NedostajeParametar, SuvisanParametar, NeispravanParametar };
enum class Komande { PomjeriJednoMjesto = 0, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru };




typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

bool NijeDva( std::vector&lt;std::vector&lt;int&gt;&gt; mine ) {
	for( int i=0; i&lt; mine.size(); i++ ) {
		if( mine[i].size() != 2 ) return true;
	}
	return false;
}

bool IzlazilIzOpsega(std::vector&lt;std::vector&lt;int&gt;&gt; mine, int n) {
	for(int i=0; i&lt; mine.size(); i++) {
		for(int j=0; j&lt;mine[i].size(); j++)
		if(!(mine[i][j] &gt;= 0 &amp;&amp; mine[i][j] &lt; n)) return true;
}
return false;
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	if(NijeDva(mine)) throw std::domain_error("Ilegalan format zadavanja mina");
	if(IzlazilIzOpsega(mine,n)) throw std::domain_error("Ilegalne pozicije mina");
	Tabla igraca (n, std::vector&lt;Polje&gt;(n,Polje::Prazno)) ;
	
	for(int i=0; i&lt;mine.size(); i++) {
		for(int j=0; j&lt; mine[0].size()-1; j++)
			igraca[mine[i][j]][mine[i][j+1]] = Polje::Mina;
	}
		
		
		return igraca;
}


std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	if( x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja[0].size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	std::vector&lt;std::vector&lt;int&gt;&gt; mjestaMina(3,std::vector&lt;int&gt;(3,0));
	
	int brojacMina=0,red=0,kolona=0;
    int vel=x+2,kol=y+2,vel1=0,kol1=0;
   //donji rubni
	for(int i=x-1; i&lt;vel; i++ ) {
		if(i &lt; 0 ) i+= std::abs(i);
	//	if( i &gt;= polja.size()){ i = polja.size()-1; vel = polja.size();}
		for(int j=y-1; j&lt; kol; j++) {
		
			brojacMina =0;
			if( j &lt; 0) j+= std::abs(j);
		//	if( j &gt;= polja[0].size()){ j = polja[0].size()-1; kol = polja[0].size(); }
	       // else if(i == polja.size() || j == polja[0].size()) break;
		    vel1 = i+2;
		    kol1 = j+2;
			for(int k=i-1; k&lt;vel1; k++) {
				if(k &lt; 0) k+= std::abs(k);
			//	if(k &gt;= polja.size()){ k= polja.size()-1; vel1 = polja.size();}
				for(int l = j-1; l &lt;kol1; l++) {
					
					if( l &lt; 0)  l+= std::abs(l);
				//	if(l &gt;= polja[0].size()){ l = polja[0].size()-1; kol1 = polja[0].size(); }
				  
					
<a name="8"></a><font color="#00FFFF"><a href="match907-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

					 if(k == i &amp;&amp; l== j) continue;
				//	 else if(k == polja.size() || l == polja[0].size()) break;
				   	 else if(polja[k][l] == Polje::Mina) brojacMina++;
				}
			}
			mjestaMina[red][kolona] = brojacMina;
			kolona++;
</font>			
		}
		red++;
		kolona=0;
	
		
	}
	
	return mjestaMina;
	
}

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	if( x&lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja[0].size()) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	
	if( polja[x][y] == Polje::Posjeceno )   polja[x][y] = Polje::BlokiranoPosjeceno;
	else if( polja[x][y] == Polje::Mina )   polja[x][y] = Polje::BlokiranoMina;
	else if( polja[x][y] == Polje::Prazno ) polja[x][y] = Polje::BlokiranoPrazno;
	
} // porbat blkirat blkirano

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if( x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja[0].size() ) throw std::domain_error("Polje ("+std::to_string(x)+","+std::to_string(y)+") ne postoji");
	
	if( polja[x][y] == Polje::BlokiranoPosjeceno )   polja[x][y] = Polje::Posjeceno;
	else if( polja[x][y] == Polje::BlokiranoPrazno ) polja[x][y] = Polje::Prazno;
	else if( polja[x][y] == Polje::BlokiranoMina )   polja[x][y] = Polje::Mina;
	
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	Status update = Status::NijeKraj;
	
	if( smjer == Smjerovi::Gore ) { 
<a name="3"></a><font color="#00FFFF"><a href="match907-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

		if( x-1 &lt; 0 ) throw std::out_of_range("Izlazak van igrace table");
		if( polja[x-1][y] == Polje::BlokiranoPosjeceno || polja[x-1][y] == Polje::BlokiranoPrazno || polja[x-1][y] == Polje::BlokiranoMina ) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x = x-1; 
	}
	else if( smjer == Smjerovi::GoreDesno ) {
		if( x-1 &lt; 0 || y+1 &gt;= polja[0].size() ) throw std::out_of_range("Izlazak van igrace table");
</font><a name="1"></a><font color="#00FF00"><a href="match907-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

		if( polja[x-1][y+1] == Polje::BlokiranoPosjeceno || polja[x-1][y+1] == Polje::BlokiranoPrazno || polja[x-1][y+1] == Polje::BlokiranoMina ) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x = x-1; y = y+1;
	}
	else if( smjer == Smjerovi::GoreLijevo ) {
</font><a name="2"></a><font color="#0000FF"><a href="match907-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

		if( x-1 &lt; 0 || y-1 &lt; 0 ) throw std::out_of_range("Izlazak van igrace table");
		if( polja[x-1][y-1] == Polje::BlokiranoPosjeceno || polja[x-1][y-1] == Polje::BlokiranoPrazno || polja[x-1][y-1] == Polje::BlokiranoMina ) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x = x-1; y = y-1;
	}
	else if( smjer == Smjerovi::Desno ) {
</font><a name="6"></a><font color="#00FF00"><a href="match907-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

		if( y+1 &gt;= polja[0].size() ) throw std::out_of_range("Izlazak van igrace table");
		if( polja[x][y+1] == Polje::BlokiranoPosjeceno || polja[x][y+1] == Polje::BlokiranoPrazno || polja[x][y+1] == Polje::BlokiranoMina ) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		y = y+1;
	}
	else if( smjer == Smjerovi::Lijevo ) {
		if( y-1 &lt; 0 ) throw std::out_of_range("Izlazak van igrace table");
</font><a name="5"></a><font color="#FF0000"><a href="match907-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

		if( polja[x][y-1] == Polje::BlokiranoPosjeceno || polja[x][y-1] == Polje::BlokiranoPrazno || polja[x][y-1] == Polje::BlokiranoMina ) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		y = y-1;
	}
	else if( smjer == Smjerovi::Dolje ) {
		if( x+1 &gt;= polja.size() ) throw std::out_of_range("Izlazak van igrace table");
</font><a name="4"></a><font color="#FF00FF"><a href="match907-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

		if( polja[x+1][y] == Polje::BlokiranoPosjeceno || polja[x+1][y] == Polje::BlokiranoPrazno || polja[x+1][y] == Polje::BlokiranoMina ) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x = x+1;
		
	}
	else if( smjer == Smjerovi::DoljeLijevo ) {
		if( x+1 &gt;= polja.size() || y-1 &lt; 0 ) throw std::out_of_range("Izlazak van igrace table");
</font><a name="0"></a><font color="#FF0000"><a href="match907-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

		if( polja[x+1][y-1] == Polje::BlokiranoPosjeceno || polja[x+1][y-1] == Polje::BlokiranoPrazno || polja[x+1][y-1] == Polje::BlokiranoMina ) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
		x = x+1; y = y-1;
	}
	else if( smjer == Smjerovi::DoljeDesno ) {
		if( x+1 &gt;= polja.size() || y+1 &gt;= polja[0].size() ) throw std::out_of_range("Izlazak van igrace table");
</font><a name="7"></a><font color="#0000FF"><a href="match907-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		if( polja[x+1][y+1] == Polje::BlokiranoPosjeceno || polja[x+1][y+1] == Polje::BlokiranoPrazno || polja[x+1][y+1] == Polje::BlokiranoMina ) throw std::logic_error("Blokirano polje");
		polja[x][y] = Polje::Posjeceno;
</font>		x = x+1; y = y+1;
	}
	
	int suma = 0;
	for(auto red = polja.begin(); red != polja.end(); red++) {
	auto br = std::count_if(red-&gt;begin(), red-&gt;end(), [](Polje v) { return v == Polje::Prazno;});
	suma += br;
	}
	
	if( polja[x][y] == Polje::Mina ) update = Status::KrajPoraz;
	else if( suma == 0 ) update = Status::KrajPobjeda;
	else update = Status::NijeKraj;
	
	return update;
	
} //provjerit kad su sva pređena

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	Status status = Status::NijeKraj;
	if( novi_x &lt; 0 || novi_x &gt;= polja.size() || novi_y &lt; 0 || novi_y &gt;= polja[0].size() ) throw std::out_of_range("Izlazak van igrace table");
	if( polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno || polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoMina ) throw std::logic_error("Blokirano polje");
	polja[x][y] = Polje::Posjeceno;
	x = novi_x;
	y = novi_y;
	
	
	int suma = 0;
	for( auto red = polja.begin(); red != polja.end(); red++ ) {
		auto br = std::count_if(red-&gt;begin(), red-&gt;end(), [](Polje v) { return v == Polje::Prazno;});
		suma+=br;
	}
	if( polja[x][y] == Polje::Mina ) status = Status::KrajPoraz;
	else if( suma == 0 ) status = Status::KrajPobjeda;
	else status = Status::NijeKraj;
	
	return status;
}

void PrijaviGresku( KodoviGresaka greska ) {
	
	if( greska == KodoviGresaka::PogresnaKomanda ) std::cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;std::endl;
	else if( greska == KodoviGresaka::NedostajeParametar ) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;std::endl;
	else if( greska == KodoviGresaka::NeispravanParametar ) std::cout&lt;&lt;"Parametar komande nije ispravan!"&lt;&lt;std::endl;
	else if( greska == KodoviGresaka::SuvisanParametar ) std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;std::endl;
}

/*bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
	
	std::string s; // P1 2 3
	std::cin&gt;&gt;s;
	int i=0;
	while( i&lt; s.length()) {
		if(s[i] == ' ') i++;
		if( i!= 0 &amp;&amp; s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z' &amp;&amp; s[i-1] != 'D' ) { kod_greske = KodoviGresaka::NeispravanParametar; break; }
		if( i == 0 &amp;&amp; s[i]&gt;= 'a' &amp;&amp; s[i] &lt;= 'z' ) { kod_greske = KodoviGresaka::NeispravanParametar; break; }
	//	if( !( (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') || s[i] == ' ' ) ) { kod_greske = KodoviGresaka::SuvisanParametar; break; }
		if( s[i] = 'P' &amp;&amp; i+1 &lt; s.length() &amp;&amp; (s[i+1] == '&gt;'  || s[i+1] == '1' ) ) {
			std::string kom;
			kom.push_back(s[i]);
			kom.push_back(s[i+1]);
			if( kom == "P1" ){
			    std::string cijel;
			    i+=2;
			    while ( i &lt; s.length() ) {
			        if( ( s[i]&gt;='A' &amp;&amp; s[i] &lt;= 'Z') || (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') ){
			        while( ( s[i]&gt;='A' &amp;&amp; s[i] &lt;= 'Z') || (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') ){ cijel.push_back(s[i]); i++; }
			        std::cout&lt;&lt;cijeli;
			        }
			        if( s[i] == ' ') {i++; cijel.resize(0); }
			        else kod_greske = KodoviGresaka::NeispravanParametar;
			    }
		}
		else if( kom == "P&gt;") {
			std::string nov;
			i+=2;
			while (i &lt; s.length() ) { // jedan razmak između parametara
				if( s[i] != ' ' &amp;&amp; !(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')) kod_greske = KodoviGresaka::NedostajeParmetar;
			}
		}
		
	}
	else if( s[i] == 'P' &amp;&amp; i+1 &lt; s.length() &amp;&amp; s[i+1] == 'O' ) {
		i+=2;
		while (i &lt; s.length() ) {
			if(s[i] != ' ' ) kod_greske = KodoviGresaka::NeispravanParametar;
			
		}
		//inace sve sto treba
	}
	else if( s[i] == 'Z' ){
		i++;
		while (i &lt; s.length() ) {
			if(s[i] != ' ') kod_greske = KodoviGresaka::NeispravanParametar;
		}
	}
	else if( s[i] == 'K') {
		i++;
		while (i &lt; s.length() ) {
			if(s[i] != ' ') kod_greske = KodoviGresaka::NeispravanParametar;
		}	
	}else if( s[i] == 'B')
	
	
		
	}
	else {
		kod_greske == KodoviGresaka::NeispravanParametar;
	}
}*/



int main ()
{
	try{
	std::cout&lt;&lt;"Unesite broj polja: ";
	int n;
	std::cin&gt;&gt;n;
	std::cout&lt;&lt;"Unesite pozicije mina: ";
	std::vector&lt;std::vector&lt;int&gt;&gt; mine(n, std::vector&lt;int&gt;(2));

	for(int i=0; i&lt;n; i++) {
		std::cout&lt;&lt;"Iduca mina: ";
		for(int j=0; j&lt;2; j++ )
		std::cin&gt;&gt;mine[i][j];
		
	}
	
	auto plocica = KreirajIgru(n,mine);
	for(std::vector&lt;Polje&gt; red: plocica){
	for(Polje p : red) std::cout&lt;&lt;(int)p&lt;&lt;" ";
	std::cout&lt;&lt;std::endl;
	}
	
/*	auto minee = PrikaziOkolinu(plocica,2,2);
	for(std::vector&lt;int&gt; red: minee){
	for(int p : red) std::cout&lt;&lt;p&lt;&lt;" ";
	std::cout&lt;&lt;std::endl;
	}*/
/*	BlokirajPolje(plocica,2,2);
	for(std::vector&lt;Polje&gt; red: plocica){
		for(Polje p : red) std::cout&lt;&lt;(int)p&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}
	DeblokirajPolje(plocica,2,2);
	for(std::vector&lt;Polje&gt; red: plocica){
		for(Polje p : red) std::cout&lt;&lt;(int)p&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}*/
	int x=2,y=2;
	auto st = Idi(plocica,x,y,Smjerovi::Gore);
	for( std::vector&lt;Polje&gt; red : plocica) {
		for( Polje p : red) std::cout&lt;&lt;(int)p&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;(int)st&lt;&lt;x&lt;&lt;"-"&lt;&lt;y;
	
	
	
	
	
	
	}catch( std::domain_error d ) {
		std::cout &lt;&lt; d.what() &lt;&lt; std::endl;
	}catch( std::logic_error e ) {
		std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
		
	}
	
	
	
	
	
	return 0;
}</pre>
</body>
</html>
