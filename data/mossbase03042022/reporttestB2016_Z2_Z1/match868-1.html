<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student7713.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student9935.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;stdexcept&gt;
#include&lt;string&gt;

enum class Polje {
 Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

enum class Smjerovi {
 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
enum class Komande {
 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska);
void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0);

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y);
void BlokirajPolje(Tabla &amp;polja, int x, int y);
void DeblokirajPolje(Tabla &amp;polja, int x, int y);
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer);
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y);
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y);

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	std::vector&lt;std::vector&lt;Polje&gt;&gt; ploha(n, std::vector&lt;Polje&gt;(n, Polje::Prazno));
	for(int i=0; i&lt;ploha.size(); i++){
		for(int j=0; j&lt;ploha[0].size(); j++){
			for(int k=0; k&lt;mine.size(); k++){
				if(mine[k].size()!=2)
					throw std::domain_error("Ilegalan format zadavanja mina");
					// naredna linija ili &gt; ili &gt;= (zadnja izmjena, ako bude padalo vise od 12at izbrisati =)
				else if(mine[k][0]&lt;0 || mine[k][0]&gt;=ploha[0].size() || mine[k][1]&lt;0 || mine[k][1]&gt;=ploha[0].size())	
					throw std::domain_error("Ilegalne pozicije mina");
				else if(i==mine[k][0] &amp;&amp; j==mine[k][1])
<a name="11"></a><font color="#00FF00"><a href="match868-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

					ploha[i][j]=Polje::Mina;
			}
		}
	}
	return ploha;
} //odradzeno

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
</font>	std::vector&lt;std::vector&lt;int&gt;&gt; matrica(3, std::vector&lt;int&gt;(3));
	int brojac(0);
	for(int i=0; i&lt;x+2; i++){
		for(int j=0; j&lt;y+2; j++){
			if(i==x-1 &amp;&amp; j==y-1){
				if(j&lt;polja[0].size() &amp;&amp; polja[i][j+1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; polja[i+1][j]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i+1][j+1]==Polje::Mina)
					brojac++;
				matrica[i][j]=brojac;
				brojac=0;
			}
			else if(i==x-1 &amp;&amp; j==y+1){
				if(j&gt;0 &amp;&amp; polja[i][j-1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&gt;0 &amp;&amp; polja[i+1][j-1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; polja[i+1][j]==Polje::Mina)
					brojac++;
				if(j&lt;polja[0].size() &amp;&amp; polja[i][j+1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i+1][j+1]==Polje::Mina)
					brojac++;
				
				matrica[i][j]=brojac;
				brojac=0;
			}
			else if(i==x-1 &amp;&amp; j==y){
				if(j&gt;0 &amp;&amp; polja[i][j-1]==Polje::Mina)
					brojac++;
				if(j&lt;polja[0].size() &amp;&amp; polja[i][j+1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&gt;0 &amp;&amp; polja[i+1][j-1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; polja[i+1][j]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i+1][j+1]==Polje::Mina)
					brojac++;
				matrica[i][j]=brojac;
				brojac=0;
			}
			else if(i==x &amp;&amp; j==y-1){
				if(i&gt;0 &amp;&amp; polja[i-1][j]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i-1][j+1]==Polje::Mina)
					brojac++;
				if(j&lt;polja[0].size() &amp;&amp; polja[i][j+1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; polja[i+1][j]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i+1][j+1]==Polje::Mina)
					brojac++;
				matrica[i][j]=brojac;
				brojac=0;
			}
			else if(i==x &amp;&amp; j==y){
				if(i&gt;0 &amp;&amp; j&gt;0 &amp;&amp; polja[i-1][j-1]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; polja[i-1][j]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i-1][j+1]==Polje::Mina)
					brojac++;
				if(j&gt;0 &amp;&amp; polja[i][j-1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i+1][j+1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i+1][j-1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; polja[i+1][j]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i+1][j+1]==Polje::Mina)
					brojac++;
				matrica[i][j]=brojac;
				brojac=0;
			}
			else if(i==x &amp;&amp; j==y+1){
				if(i&gt;0 &amp;&amp; j&gt;0 &amp;&amp; polja[i-1][j-1]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; polja[i-1][j]==Polje::Mina)
					brojac++;
				if(j&gt;0 &amp;&amp; polja[i][j-1]==Polje::Mina)
					brojac++;
				if(j&gt;0 &amp;&amp; i&lt;polja.size() &amp;&amp; polja[i+1][j-1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; polja[i+1][j]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i-1][j+1]==Polje::Mina)
					brojac++;
				if(j&lt;polja[0].size() &amp;&amp; polja[i][j+1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i+1][j+1]==Polje::Mina)
					brojac++;
				matrica[i][j]=brojac;
				brojac=0;
			}
			else if(i==x+1 &amp;&amp; j==y-1){
				if(i&gt;0 &amp;&amp; polja[i-1][j]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i-1][j+1]==Polje::Mina)
					brojac++;
				if(j&lt;polja[0].size() &amp;&amp; polja[i][j+1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&gt;0 &amp;&amp; polja[i+1][j-1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; polja[i+1][j]==Polje::Mina)
					brojac++;
				matrica[i][j]=brojac;
				brojac=0;
			}
			else if(i==x+1 &amp;&amp; j==y){
				if(i&gt;0 &amp;&amp; j&gt;0 &amp;&amp; polja[i-1][j-1]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; polja[i-1][j]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i-1][j+1]==Polje::Mina)
					brojac++;
				if(j&gt;0 &amp;&amp; polja[i][j-1]==Polje::Mina)
					brojac++;
				if(j&lt;polja[0].size() &amp;&amp; polja[i][j+1]==Polje::Mina)
					brojac++;
				matrica[i][j]=brojac;
				brojac=0;
			}
			else if(i==x+1 &amp;&amp; j==y+1){
				if(i&gt;0 &amp;&amp; j&gt;0 &amp;&amp; polja[i-1][j-1]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; polja[i-1][j]==Polje::Mina)
					brojac++;
				if(j&gt;0 &amp;&amp; polja[i][j-1]==Polje::Mina)
					brojac++;
				if(i&gt;0 &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i-1][j+1]==Polje::Mina)
					brojac++;
				if(j&lt;polja[0].size() &amp;&amp; polja[i][j+1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; j&lt;polja[0].size() &amp;&amp; polja[i+1][j+1]==Polje::Mina)
					brojac++;
				if(i&lt;polja.size() &amp;&amp; polja[i+1][j]==Polje::Mina)
					brojac++;
				matrica[i][j]=brojac;
				brojac=0;
			}
			else{
				throw std::domain_error("Polje ("+ std::to_string(x) +","+ std::to_string(y)+") ne postoji");
			}
		}
	}
	return matrica;
} //zavrseno

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&gt;=polja.size() || y&gt;=polja[0].size() || x&lt;0 || y&lt;0)
		throw std::domain_error("Polje ("+ std::to_string(x) +","+ std::to_string(y)+") ne postoji");
	for(int i=0; i&lt;polja.size(); i++){
		for(int j=0; j&lt;polja[0].size(); j++){
			if(i==x &amp;&amp; j==y){
				if(polja[i][j]==Polje::Prazno)
					polja[i][j]=Polje::BlokiranoPrazno;
				else if(polja[i][j]==Polje::Posjeceno)
					polja[i][j]=Polje::BlokiranoPosjeceno;
				else if(polja[i][j]==Polje::Mina)
<a name="12"></a><font color="#0000FF"><a href="match868-0.html#12" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

					polja[i][j]=Polje::BlokiranoMina;
			}
		}
	}
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&gt;=polja.size() || y&gt;=polja[0].size() || x&lt;0 || y&lt;0)
</font>		throw std::domain_error("Polje ("+ std::to_string(x) +","+ std::to_string(y)+") ne postoji");
	for(int i=0; i&lt;polja.size(); i++){
		for(int j=0; j&lt;polja[0].size(); j++){
			if(i==x &amp;&amp; j==y){
				if(polja[i][j]==Polje::BlokiranoPrazno)
					polja[i][j]=Polje::Prazno;
				else if(polja[i][j]==Polje::BlokiranoPosjeceno)
					polja[i][j]=Polje::Posjeceno;
				else if(polja[i][j]==Polje::BlokiranoMina)
					polja[i][j]=Polje::Mina;
			}
		}
	}
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
<a name="2"></a><font color="#0000FF"><a href="match868-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	if(smjer==Smjerovi::GoreLijevo){
		if(x-1&lt;0 || y-1&lt;0)
			throw std::out_of_range("Izlazak van igrace table");
		else if(polja[x-1][y-1]==Polje::BlokiranoPosjeceno || polja[x-1][y-1]==Polje::BlokiranoPrazno || polja[x-1][y-1]==Polje::BlokiranoMina)
			throw std::logic_error("Blokirano polje");
</font>		polja[x][y]=Polje::Posjeceno;
		x-=1;
		y-=1;
		if(polja[x][y]==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno){
			polja[x][y]=Polje::Posjeceno;
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					if(polja[i][j]==Polje::Prazno)
						return Status::NijeKraj;
				}
			}
			return Status::KrajPobjeda;
		}
	}
<a name="6"></a><font color="#00FF00"><a href="match868-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	else if(smjer==Smjerovi::Gore){
		if(x-1&lt;0)
			throw std::out_of_range("Izlazak van igrace table");
		else if(polja[x-1][y]==Polje::BlokiranoPosjeceno || polja[x-1][y]==Polje::BlokiranoPrazno || polja[x-1][y]==Polje::BlokiranoMina)
			throw std::logic_error("Blokirano polje");
</font>		polja[x][y]=Polje::Posjeceno;
		x-=1;
		if(polja[x][y]==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno){
			polja[x][y]=Polje::Posjeceno;
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					if(polja[i][j]==Polje::Prazno)
						return Status::NijeKraj;
				}
			}
			return Status::KrajPobjeda;
		}
	}
<a name="0"></a><font color="#FF0000"><a href="match868-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	else if(smjer==Smjerovi::GoreDesno){
		if(x-1&lt;0 || y+1&gt;=polja[0].size())
			throw std::out_of_range("Izlazak van igrace table");
		else if(polja[x-1][y+1]==Polje::BlokiranoPosjeceno || polja[x-1][y+1]==Polje::BlokiranoPrazno || polja[x-1][y+1]==Polje::BlokiranoMina)
			throw std::logic_error("Blokirano polje");
		polja[x][y]=Polje::Posjeceno;
</font>		x-=1;
		y+=1;
		if(polja[x][y]==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno){
			polja[x][y]=Polje::Posjeceno;
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					if(polja[i][j]==Polje::Prazno)
						return Status::NijeKraj;
				}
			}
			return Status::KrajPobjeda;
		}
	}
<a name="3"></a><font color="#00FFFF"><a href="match868-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	else if(smjer==Smjerovi::Desno){
		if(y+1&gt;=polja[0].size())
			throw std::out_of_range("Izlazak van igrace table");
		else if(polja[x][y+1]==Polje::BlokiranoPosjeceno || polja[x][y+1]==Polje::BlokiranoPrazno || polja[x][y+1]==Polje::BlokiranoMina)
			throw std::logic_error("Blokirano polje");
</font>		polja[x][y]=Polje::Posjeceno;
		y+=1;
		if(polja[x][y]==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno){
			polja[x][y]=Polje::Posjeceno;
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					if(polja[i][j]==Polje::Prazno)
						return Status::NijeKraj;
				}
			}
			return Status::KrajPobjeda;
		}
	}
<a name="10"></a><font color="#FF0000"><a href="match868-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

	else if(smjer==Smjerovi::DoljeDesno){
		if(x+1&gt;=polja.size() || y+1&gt;=polja[0].size())
			throw std::out_of_range("Izlazak van igrace table");
		else if(x+1&lt;polja.size() &amp;&amp; y+1&lt;polja[0].size() &amp;&amp; (polja[x+1][y+1]==Polje::BlokiranoPosjeceno || polja[x+1][y+1]==Polje::BlokiranoPrazno || polja[x+1][y+1]==Polje::BlokiranoMina))
</font><a name="8"></a><font color="#00FFFF"><a href="match868-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

			throw std::logic_error("Blokirano polje");
</font>		polja[x][y]=Polje::Posjeceno;
		x+=1;
		y+=1;
		if(polja[x][y]==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno){
			polja[x][y]=Polje::Posjeceno;
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					if(polja[i][j]==Polje::Prazno)
						return Status::NijeKraj;
				}
			}
			return Status::KrajPobjeda;
		}
	}
<a name="5"></a><font color="#FF0000"><a href="match868-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	else if(smjer==Smjerovi::Dolje){
		if(x+1&gt;=polja.size())
			throw std::out_of_range("Izlazak van igrace table");
		else if(polja[x+1][y]==Polje::BlokiranoPosjeceno || polja[x+1][y]==Polje::BlokiranoPrazno || polja[x+1][y]==Polje::BlokiranoMina)
			throw std::logic_error("Blokirano polje");
</font>		polja[x][y]=Polje::Posjeceno;
		x+=1;
		if(polja[x][y]==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno){
			polja[x][y]=Polje::Posjeceno;
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					if(polja[i][j]==Polje::Prazno)
						return Status::NijeKraj;
				}
			}
			return Status::KrajPobjeda;
		}
	}
<a name="1"></a><font color="#00FF00"><a href="match868-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	else if(smjer==Smjerovi::DoljeLijevo){
		if(x+1&gt;=polja.size() || y-1&lt;0)
			throw std::out_of_range("Izlazak van igrace table");
		else if(polja[x+1][y-1]==Polje::BlokiranoPosjeceno || polja[x+1][y-1]==Polje::BlokiranoPrazno || polja[x+1][y-1]==Polje::BlokiranoMina)
			throw std::logic_error("Blokirano polje");
		polja[x][y]=Polje::Posjeceno;
</font>		x+=1;
		y-=1;
		if(polja[x][y]==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno){
			polja[x][y]=Polje::Posjeceno;
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					if(polja[i][j]==Polje::Prazno)
						return Status::NijeKraj;
				}
			}
			return Status::KrajPobjeda;
		}
	}
<a name="4"></a><font color="#FF00FF"><a href="match868-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	else if(smjer==Smjerovi::Lijevo){
		if(y-1&lt;0)
			throw std::out_of_range("Izlazak van igrace table");
		else if(polja[x][y-1]==Polje::BlokiranoPosjeceno || polja[x][y-1]==Polje::BlokiranoPrazno || polja[x][y-1]==Polje::BlokiranoMina)
			throw std::logic_error("Blokirano polje");
		polja[x][y]=Polje::Posjeceno;
</font>		y-=1;
		if(polja[x][y]==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno){
			polja[x][y]=Polje::Posjeceno;
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					if(polja[i][j]==Polje::Prazno)
						return Status::NijeKraj;
				}
			}
			return Status::KrajPobjeda;
		}
	}
	return Status::KrajPoraz; 
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	if(novi_x&gt;=polja.size() || novi_y&gt;=polja[0].size())
		throw std::out_of_range("Izlazak van igrace table");
	else if(polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno || polja[novi_x][novi_y]==Polje::BlokiranoPrazno || polja[novi_x][novi_y]==Polje::BlokiranoMina)
		throw std::logic_error("Blokirano polje");
	else{
		x=novi_x;
		y=novi_y;
		if(polja[x][y]==Polje::Mina){
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					polja[i][j]=Polje::Prazno;
				}
			}
			return Status::KrajPoraz;
		}
		else if(polja[x][y]==Polje::Prazno){
			polja[x][y]=Polje::Posjeceno;
			for(int i=0; i&lt;polja.size(); i++){
				for(int j=0; j&lt;polja[0].size(); j++){
					if(polja[i][j]==Polje::Prazno)
<a name="9"></a><font color="#FF00FF"><a href="match868-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

						return Status::NijeKraj;
				}
			}
			return Status::KrajPobjeda;
		}
	}
	return Status::KrajPoraz;
}
void PrijaviGresku(KodoviGresaka greska){
	if(greska==KodoviGresaka::PogresnaKomanda)
		std::cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;std::endl;
	else if(greska==KodoviGresaka::NedostajeParametar)
		std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;std::endl;
</font>	else if(greska==KodoviGresaka::NeispravanParametar)
<a name="7"></a><font color="#0000FF"><a href="match868-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

		std::cout&lt;&lt;"Parametar komande nije ispravan!"&lt;&lt;std::endl;
	else if(greska==KodoviGresaka::SuvisanParametar)
		std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;std::endl;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	std::cout&lt;&lt;"Unesite komandu: ";
</font>	
	return true;
}

int main (){
	std::cout&lt;&lt;"Pokretanje bi moglo potrajati malo duze, molimo sacekajte!!!";
	return 0;
}</pre>
</body>
</html>
