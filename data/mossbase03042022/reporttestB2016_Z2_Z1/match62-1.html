<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student7589.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student8580.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande {
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

<a name="1"></a><font color="#00FF00"><a href="match62-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	Tabla igrica(n, std::vector&lt;Polje&gt;(n, Polje::Prazno));
	
	for(int i = 0; i &lt; mine.size(); i++) {
		if(mine[i].size() != 2) throw std::domain_error("Ilegalan format zadavanja mina");
		if(mine[i][1] &gt;= n) throw std::domain_error("Ilegalne pozicije mina");
	}
	
	for(int i = 0; i &lt; n; i++)
		for(int j = 0; j &lt; n; j++)
			for(int k = 0; k &lt; mine.size(); k++)
				if(i == mine[k][0] &amp;&amp; j == mine[k][1]) igrica[i][j] = Polje::Mina;
	
	return igrica;
}

void ZavrsiIgru(Tabla &amp;tabla) {
	for(int i = 0; i &lt; tabla.size(); i++) {
		for(int j = 0; j &lt; tabla[i].size(); j++)
			tabla[i][j] = Polje::Prazno;
	}
	
	throw std::runtime_error("Igra zavrsena");
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina(3);
	if(x &gt;= polja.size() || y &gt;= polja.size() || x &lt; 0 || y &lt; 0) throw std::domain_error("Polje (x,y) ne postoji");
	
	int m = 0;
	
	for(int i = x - 1; i &lt;= x + 1; i++) {
		for(int j = y - 1; j &lt;= y + 1; j++) {
			int brojac = 0;
			for(int k = i - 1; k &lt;= i + 1; k++) {
				for(int l = j - 1; l &lt;= j + 1; l++) {
					if(i &gt;= 0 &amp;&amp; i &lt; polja.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; polja[i].size() &amp;&amp; k &gt;= 0 &amp;&amp; k &lt; polja.size() &amp;&amp; l &gt;= 0 &amp;&amp; l &lt; polja[i].size() &amp;&amp; !(k == i &amp;&amp; j == l) &amp;&amp; polja[k][l] == Polje::Mina)
						brojac++;
				}
			}
			
			okolina[m].push_back(brojac);
		}
		m++;
	}


	return okolina;
	
}

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size()) throw std::domain_error("Polje (x,y) ne postoji");
	
	if(polja[x][y] == Polje::Prazno) polja[x][y] = Polje::BlokiranoPrazno;	
	else if(polja[x][y] == Polje::Posjeceno) polja[x][y] = Polje::BlokiranoPosjeceno;
</font><a name="2"></a><font color="#0000FF"><a href="match62-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

	else if(polja[x][y] == Polje::Mina) polja[x][y] = Polje::BlokiranoMina;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if(x &lt; 0 || y &lt; 0 || x &gt;= polja.size() || y &gt;= polja.size()) throw std::domain_error("Polje (x,y) ne postoji");
	
	if(polja[x][y] == Polje::BlokiranoPrazno) polja[x][y] = Polje::Prazno;
	else if(polja[x][y] == Polje::BlokiranoPosjeceno) polja[x][y] == Polje::Posjeceno;
	else if(polja[x][y] == Polje::BlokiranoMina) polja[x][y] == Polje::Mina;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	int novi_x = x;
	int novi_y = y;
	
	switch(smjer) {
		case Smjerovi::Gore:
			novi_x--;
			break;
		case Smjerovi::Desno:
			novi_y++;
			break;
		case Smjerovi::Dolje:
			novi_x++;
			break;
		case Smjerovi::Lijevo:
			novi_y--;
			break;
		case Smjerovi::GoreDesno:
			novi_x--;
			novi_y++;
			break;
		case Smjerovi::DoljeDesno:
			novi_x++;
			novi_y++;
			break;
		case Smjerovi::DoljeLijevo:
			novi_x++;
			novi_y--;
			break;
		case Smjerovi::GoreLijevo:
			novi_x--;
			novi_y--;
			break;
	}
	
	if(novi_x &lt; 0 || novi_y &lt; 0 || novi_x &gt;= polja.size() || novi_y &gt;= polja[0].size())
		throw std::out_of_range("Izlazak van igrace table");
	if(polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno || polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoMina)
</font><a name="4"></a><font color="#FF00FF"><a href="match62-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		throw std::logic_error("Blokirano polje");
	
	//krajPoraz
	if(polja[novi_x][novi_y] == Polje::Mina) {
		for(int i = 0; i &lt; polja.size(); i++) {
</font><a name="3"></a><font color="#00FFFF"><a href="match62-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

			for(int j = 0; j &lt; polja[i].size(); j++) 
				polja[i][j] = Polje::Prazno;
		}
		return Status::KrajPoraz;
	}
	
	//krajPobjeda
	
	bool prazno = false;
	for(int i = 0; i &lt; polja.size(); i++)
		for(int j = 0; j &lt; polja[i].size(); j++)
			if(polja[i][j] == Polje::Prazno) prazno = true;
	
	if(!prazno) return Status::KrajPobjeda;
	
	//ni poraz ni pobjeda
	
	
	polja[x][y] = Polje::Posjeceno;
	x = novi_x;
	y = novi_y;
	
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	if(novi_x &gt;= polja.size() || novi_y &gt;= polja.size() || novi_x &lt; 0 || novi_y &lt; 0) throw std::out_of_range("Izlazak van igrace table");
	if(polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno || polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoMina) 
</font><a name="5"></a><font color="#FF0000"><a href="match62-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		throw std::logic_error("Blokirano polje");
	//ako je mina - poraz
	if(polja[novi_x][novi_y] ==  Polje::Mina) {
			for(int i = 0; i &lt; polja.size(); i++)
</font><a name="0"></a><font color="#FF0000"><a href="match62-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_62.gif"/></a>

				for(int j = 0; j &lt; polja[i].size(); j++) polja[i][j] = Polje::Prazno;
			return Status::KrajPoraz;
	}
	//ako su sva posjecena - pobjeda
	bool prazno = false;
	for(int i = 0; i &lt; polja.size(); i++) 
		for(int j = 0; j &lt; polja[i].size(); j++) 
			if(polja[i][j] == Polje::Prazno) prazno = true;
	
	if(!prazno) return Status::KrajPobjeda;
	
	//ako nije ni poraz ni pobjeda, postavi nove koordinate, vrati NijeKraj
	polja[x][y] = Polje::Posjeceno;
	x = novi_x;
	y = novi_y;
	return Status::NijeKraj;
}

void PrijaviGresku(KodoviGresaka greska) {
	switch(greska) {
		case KodoviGresaka::PogresnaKomanda:
			std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl; 
			break;
		case KodoviGresaka::NedostajeParametar:
			std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
			break;
		case KodoviGresaka::NeispravanParametar:
			std::cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; std::endl;
			break;
		case KodoviGresaka::SuvisanParametar:
			std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt; std::endl;
			break;
	}
}

void IzbrisiRazmak(std::string &amp;s, int i) {
	while(i &lt; s.length())
	{
		if(s[i] == ' ') s.erase(i,1);
		if(s[i] != ' ') break;
		i++;
	}
}

void VratiXY(std::string unos, int m, int &amp;x, int &amp;y) {
	for(int k = 0; k &lt; 2; k++) {
		int broj = 0;
		while(m &lt; unos.length() &amp;&amp; (unos[m] &gt;= '0' &amp;&amp; unos[m] &lt;= '9')) {
			broj += unos[m] - '0';
			broj *= 10;
			m++;
		}
		broj /= 10;
		if(k == 0) x = broj;
		if(k == 1) y = broj;
		IzbrisiRazmak(unos,m);
	}
}

bool IspravanParametar(std::string unos, int m, KodoviGresaka &amp;greska) {
	bool ima_razmak = false;
	while(m &lt; unos.length()) {
		if(unos[m] == ' ') ima_razmak = true;
		if(!((unos[m] &gt;= '0' &amp;&amp; unos[m] &lt;= '9') || unos[m] == ' ')) {
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
		m++;
	}
	if(!ima_razmak) {
		greska = KodoviGresaka::NedostajeParametar;
		return false;
	}
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
	std::string unos;
	std::vector&lt;std::string&gt; tabela = {"P1", "P&gt;", "B", "D", "PO", "Z", "K"};
	
	std::getline(std::cin, unos);
	IzbrisiRazmak(unos,0);
	
	for(int i = 0; i &lt; tabela.size(); i++) {
		std::string pomocni = tabela[i];
		int j = 0;
		int brojac = 0;
		while(j &lt; pomocni.length()) {
			if(pomocni[j] == unos[j]) brojac++;
			j++;
		}
		IzbrisiRazmak(unos,j);
		
		if(brojac == pomocni.length()) {
			if(unos.length() != brojac) {
				if(i == 0) {
					std::vector&lt;std::string&gt; pomijeranja = {"GL", "G", "GD", "D", "DoD", "Do", "DoL", "L"};
					int n = 2;
					while(n &lt; unos.length()) {
						if(unos[n] != 'G' &amp;&amp; unos[n] != 'L' &amp;&amp; unos[n] != 'D' &amp;&amp; unos[n] != 'o' &amp;&amp; unos[n] != ' ') {
							greska = KodoviGresaka::NeispravanParametar;
							return false;
						}
						n++;
					}
					
					komanda = Komande::PomjeriJednoMjesto;
					
					std::string pom_za_pomijeranje;
					n = 2;
					while(n &lt; unos.length() &amp;&amp; unos[n] != ' ') {
						pom_za_pomijeranje.push_back(unos[n]);
						n++;
					}
					
					int index;
					for(index = 0; index &lt; pomijeranja.size(); index++) 
						if(pom_za_pomijeranje == pomijeranja[index]) break;
					
					switch(index) {
						case 0:
							smjer = Smjerovi::GoreLijevo;
							return true;
						case 1:
							smjer = Smjerovi::Gore;
							return true;
						case 2:
							smjer = Smjerovi::GoreDesno;
							return true;
						case 3:
							smjer = Smjerovi::Desno;
							return true;
						case 4:
							smjer = Smjerovi::DoljeDesno;
							return true;
						case 5:
							smjer = Smjerovi::Dolje;
							return true;
						case 6:
							smjer = Smjerovi::DoljeLijevo;
							return true;
						case 7:
							smjer = Smjerovi::Lijevo;
							return true;
					}
				}
				
				else if(i == 1 || i == 2 || i == 3) {
					if((i != 1 &amp;&amp; unos.length() == 1) || (i == 1 &amp;&amp; unos.length() == 2)) {
						greska = KodoviGresaka::NedostajeParametar;
						return false;
					}
					
					int m;
					if(i == 1) m = 2;
					else m = 1;
					
					if(!IspravanParametar(unos, m, greska)) return false;
					
					if(i == 1) m = 2;
					else m = 1;
					
					VratiXY(unos, m, x, y);
					
					if(i == 1) komanda = Komande::PomjeriDalje;
					if(i == 2) komanda = Komande::Blokiraj;
					if(i == 3) komanda = Komande::Deblokiraj;
					return true;
				}
				
				else {
					greska = KodoviGresaka::SuvisanParametar;
					return false;
				}
			}
			else {
				if(i == 0 || i == 1 || i == 2 || i == 3) {
					greska = KodoviGresaka::NedostajeParametar;
					return false;
				}
				
				switch(i) {
					case 4:
						komanda = Komande::PrikaziOkolinu;
						return true;
					case 5:
						komanda = Komande::ZavrsiIgru;
						return true;
					case 6:
						komanda = Komande::KreirajIgru;
						return true;
				}
			}
		}
	}
	
	greska = KodoviGresaka::PogresnaKomanda;
	return false;
}

std::vector&lt;std::vector&lt;int&gt;&gt; UnesiMine(int n) {
	std::vector&lt;std::vector&lt;int&gt;&gt; mine;
	int x, y;
	char znak;
	std::vector&lt;int&gt; baza_x;
	std::vector&lt;int&gt; baza_y;
	
	std::cout &lt;&lt; "Unesite pozicije mina: ";
	
	for(;;) {
		std::cin.clear();
		std::cin.ignore(10000, '\n');
		std::cin &gt;&gt; znak;
		if(znak == '.') break;
		if(!std::cin || znak != '(' || std::cin.peek() == '\n' || std::cin.peek() == ' ') {
			std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
			std::cin.clear();
			std::cin.ignore(100000,'\n');
			continue;
		}
		std::cin &gt;&gt; x;
		if(!std::cin || x &lt; 0 || x &gt; n || std::cin.peek() == '\n' || std::cin.peek() == ' ' || std::cin.peek() != ',') {
			std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
			std::cin.clear();
			std::cin.ignore(100000, '\n');
			continue;
		}
		std::cin &gt;&gt; znak;
		if(!std::cin || znak != ',' || std::cin.peek() == '\n' || std::cin.peek() == ' ') {
			std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
			std::cin.clear();
			std::cin.ignore(100000, '\n');
			continue;
		}
		std::cin &gt;&gt; y;
		if(!std::cin || y &lt; 0 || y &gt; n || std::cin.peek() == '\n' || std::cin.peek() == ' ' || std::cin.peek() != ')') {
			std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
			std::cin.clear();
			std::cin.ignore(10000, '\n');
			continue;
		}
		std::cin &gt;&gt; znak;
		bool tacka = false;
		if(std::cin.peek() == '.') tacka = true;
		if(!std::cin || znak != ')' || std::cin.peek() != '\n' || tacka) {
			if(tacka) break;
			std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
			std::cin.clear();
			std::cin.ignore(100000, '\n');
			continue;
		}
		baza_x.push_back(x);
		baza_y.push_back(y);
		if(std::cin.peek() == '.') break;
		std::cin.clear();
		std::cin.ignore(10000,'\n');
	}
	
	mine.resize(baza_x.size());
	for(int i = 0; i &lt; mine.size(); i++)
		mine[i].resize(2);
		
	for(int i = 0; i &lt; mine.size(); i++) {
		mine[i][0] = baza_x[i];
		mine[i][1] = baza_y[i];
	}
	
	return mine;

}

void IspisiOkolinu(std::vector&lt;std::vector&lt;int&gt;&gt; okolina) {
	for(int i = 0; i &lt; okolina.size(); i++) {
		for(int j = 0; j &lt; okolina[i].size(); j++)
			std::cout &lt;&lt; okolina[i][j] &lt;&lt; " ";
		std::cout &lt;&lt; std::endl;
	}
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
	Status trenutni;
	
	try {
	switch(komanda){
		case Komande::PomjeriJednoMjesto: {	
			trenutni = Idi(polja, x, y, p_smjer);
			if(trenutni == Status::NijeKraj) {
				std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
			}
			else if(trenutni == Status::KrajPoraz) {
				std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
				ZavrsiIgru(polja);
			}
			else if(trenutni == Status::KrajPobjeda) {
				std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
				ZavrsiIgru(polja);
			}
		}
			break;
		case Komande::PomjeriDalje: {
			trenutni = Idi(polja, x, y, p_x, p_y);
			if(trenutni == Status::NijeKraj) {
				std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
			}
			else if(trenutni == Status::KrajPoraz) {
				std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
				ZavrsiIgru(polja);
			}
			else if(trenutni == Status::KrajPobjeda) {
				std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
				ZavrsiIgru(polja);
			}
		}		
			break;
		case Komande::Blokiraj: {
			BlokirajPolje(polja, x, y);
		}
			break;
		case Komande::Deblokiraj: {
			DeblokirajPolje(polja, x, y);
		}
			break;
		case Komande::PrikaziOkolinu: {
			std::vector&lt;std::vector&lt;int&gt;&gt; okolina;
			okolina = PrikaziOkolinu(polja, x, y);
			IspisiOkolinu(okolina);
		}
			break;
		case Komande::ZavrsiIgru: {
			ZavrsiIgru(polja);
		}
			break;
		case Komande::KreirajIgru: {
			int n; 
			std::cout &lt;&lt; "Unesite broj polja: ";
			std::cin &gt;&gt; n;
			std::vector&lt;std::vector&lt;int&gt;&gt; mine;
			mine = UnesiMine(n);
			polja = KreirajIgru(n, mine);
		}	
			break;
		}
	}
	catch(std::runtime_error izuzetak) {
		throw std::runtime_error(izuzetak.what());
	}
	catch(std::domain_error izuzetak) {
		std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
	}
	catch(std::out_of_range izuzetak) {
		std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
	}
	catch(std::logic_error izuzetak) {
		std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
	}
	
	
}

int main ()
{
	Komande komanda;
	Smjerovi smjer;
	int x, y;
	KodoviGresaka greska;
	bool unos;
	Tabla polja;
	
	
	for(;;)
	{
		try {
			std::cout &lt;&lt; "Unesi komandu: ";
			unos = UnosKomande(komanda, smjer, x, y, greska);
			if(!unos) {
				PrijaviGresku(greska);
			}
			else {
				IzvrsiKomandu(komanda, polja, x, y, smjer);
			}
		}
		catch(std::runtime_error izuzetak) {
			std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl &lt;&lt; "Dovidjenja!";
			return 0;
		}
		catch(...) {
			std::cout &lt;&lt; "Neki drugi izuzetak";
		}
		
		
	}
	return 0;
</font>}</pre>
</body>
</html>
