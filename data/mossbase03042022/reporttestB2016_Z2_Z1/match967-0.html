<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6198.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6198.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
enum class Polje { Prazno, Posjeceno, Mina, BlokiranoPrazno,BlokiranoPosjeceno, BlokiranoMina};
enum class Smjerovi {GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno,Dolje,DoljeLijevo,Lijevo};
enum class Status{ NijeKraj, KrajPoraz, KrajPobjeda};
enum class KodoviGresaka { PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
enum class Komande{PomjeriJednoMjesto,PomjeriDalje,Blokiraj,Deblokiraj,PrikaziOkolinu,ZavrsiIgru,KreirajIgru};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla;
tabla.resize(n,std::vector&lt;Polje&gt; (n));
	for(int i=0; i&lt;mine.size();i++){
		if(mine[i].size()!=2) throw std::domain_error("Ilegalan format zadavanja mina");
		for(int j=0;j&lt;mine[0].size();j++){
			if(mine[i][j]&gt;n) throw std::domain_error("Ilegalne pozicije mina");
		}
		
	}
	
	for(int i=0; i&lt;tabla.size();i++)
	   for(int j=0;j&lt;tabla[0].size();j++) tabla[i][j]=Polje::Prazno;
	int x, y;
	for(int i=0; i&lt;mine.size(); i++){
	
			x=mine[i][0];
			y=mine[i][1];
			tabla[x][y]=Polje::Mina;
		
	}
	return tabla;
	   
}
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	std::vector&lt;std::vector&lt;int&gt;&gt; matrica(3,std::vector&lt;int&gt;(3));
	int vel=polja.size();
	if(x&gt;vel || y&gt;vel) throw std::domain_error("Polje (x,y) ne postoji");
	return matrica;
}
void BlokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&gt;polja.size() || y&gt;polja.size()) throw std::domain_error("Polje (x,y) ne postoji");
<a name="8"></a><font color="#00FFFF"><a href="match967-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	for(int i=0; i&lt;polja.size();i++){
		for(int j=0; j&lt;polja[i].size();j++){
			if(i==x &amp;&amp; j==y){
				if(polja[x][y]==Polje::Prazno) polja[x][y]=Polje::BlokiranoPrazno;
</font>				else if(polja[x][y]==Polje::Posjeceno) polja[x][y]=Polje::BlokiranoPosjeceno;
<a name="10"></a><font color="#FF0000"><a href="match967-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

				else if(polja[x][y]==Polje::Mina) polja[x][y]=Polje::BlokiranoMina;
			
			}
		}
	}
	
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y){
		if(x&gt;polja.size() || y&gt;polja.size()) throw std::domain_error("Polje (x,y) ne postoji");
</font><a name="9"></a><font color="#FF00FF"><a href="match967-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

	for(int i=0; i&lt;polja.size();i++){
		for(int j=0; j&lt;polja[i].size();j++){
			if(i==x &amp;&amp; j==y){
				if(polja[x][y]==Polje::BlokiranoPrazno) polja[x][y]=Polje::Prazno;
</font>				else if(polja[x][y]==Polje::BlokiranoPosjeceno) polja[x][y]=Polje::Posjeceno;
				else if(polja[x][y]==Polje::BlokiranoMina) polja[x][y]=Polje::Mina;
			
			}
		}
	}
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	polja[x][y]=Polje::Posjeceno;
	if(smjer==Smjerovi::GoreLijevo){
<a name="3"></a><font color="#00FFFF"><a href="match967-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

		if(x-1&lt;0 || y-1&lt;0) throw std::out_of_range("Izlazak van igrace table");
		if(polja[x-1][y-1]==Polje::BlokiranoPrazno || polja[x-1][y-1]==Polje::BlokiranoPosjeceno || polja[x-1][y-1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
		x=x-1;y=y-1;
</font>	}
	else if(smjer==Smjerovi::Gore){
<a name="5"></a><font color="#FF0000"><a href="match967-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

		if(x-1&lt;0)throw std::out_of_range("Izlazak van igrace table");
		if(polja[x-1][y]==Polje::BlokiranoPrazno || polja[x-1][y]==Polje::BlokiranoPosjeceno || polja[x-1][y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
		x=x-1;
</font>	}
	else if(smjer==Smjerovi::GoreDesno){
<a name="2"></a><font color="#0000FF"><a href="match967-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

		if(x-1&lt;0 || y+1&gt;polja.size())throw std::out_of_range("Izlazak van igrace table");
		if(polja[x-1][y+1]==Polje::BlokiranoPrazno || polja[x-1][y+1]==Polje::BlokiranoPosjeceno || polja[x-1][y+1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
		x=x-1; y=y+1;
</font>	}
	else if(smjer==Smjerovi::Desno){
<a name="7"></a><font color="#0000FF"><a href="match967-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		if(y+1&gt;polja.size())throw std::out_of_range("Izlazak van igrace table");
		if(polja[x][y+1]==Polje::BlokiranoPrazno || polja[x][y+1]==Polje::BlokiranoPosjeceno || polja[x][y+1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
		y=y+1;
</font>	}
	else if(smjer==Smjerovi::DoljeDesno){
<a name="0"></a><font color="#FF0000"><a href="match967-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

		if(x+1&gt;polja.size() || y+1&gt;polja.size())throw std::out_of_range("Izlazak van igrace table");
		if(polja[x+1][y+1]==Polje::BlokiranoPrazno || polja[x+1][y+1]==Polje::BlokiranoPosjeceno || polja[x+1][y+1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
		x=x+1;y=y+1;
</font>	}
	else if(smjer==Smjerovi::Dolje){
<a name="4"></a><font color="#FF00FF"><a href="match967-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

		if(x+1&gt;polja.size())throw std::out_of_range("Izlazak van igrace table");
		if(polja[x+1][y]==Polje::BlokiranoPrazno || polja[x+1][y]==Polje::BlokiranoPosjeceno || polja[x+1][y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
		x=x+1;
</font>	}
	else if(smjer==Smjerovi::DoljeLijevo){
<a name="1"></a><font color="#00FF00"><a href="match967-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

		if(x+1&gt;polja.size() || y-1&lt;0) throw std::out_of_range("Izlazak van igrace table");
		if(polja[x+1][y-1]==Polje::BlokiranoPrazno || polja[x+1][y-1]==Polje::BlokiranoPosjeceno || polja[x+1][y-1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
		x=x+1;y=y-1;
</font>	}
	else if(smjer==Smjerovi::Lijevo){
		if(y+1&gt;polja.size()) throw std::out_of_range("Izlazak van igrace table");
		if(polja[x][y+1]==Polje::BlokiranoPrazno || polja[x][y+1]==Polje::BlokiranoPosjeceno || polja[x][y+1]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
		y=y+1;
	}
		int i=0;
	for(i=0; i&lt;polja.size(); i++){
		for(int j=0; j&lt;polja[0].size(); j++){
			if(polja[i][j]==Polje::Prazno) return Status::NijeKraj;
		}
	}
	if(i==polja.size()-1)return Status::KrajPobjeda;
	
	
	return Status::NijeKraj;
	
	
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	polja[x][y]=Polje::Posjeceno;
	if(novi_x&gt;polja.size() || novi_y&gt;polja.size()) throw std::out_of_range("Izlazak van igrace table");
	if(polja[novi_x][novi_y]==Polje::BlokiranoPrazno || polja[novi_x][novi_y]==Polje::BlokiranoPosjeceno || polja[novi_x][novi_y]==Polje::BlokiranoMina) throw std::logic_error("Blokirano polje");
	x=novi_x;
	y=novi_y;
	if(polja[x][y]==Polje::Mina){
	for(int i=0; i&lt;polja.size();i++)
	   for(int j=0;j&lt;polja.size();j++) polja[i][j]=Polje::Prazno;
		return Status::KrajPoraz;
	} 
	int i=0;
	for(i=0; i&lt;polja.size(); i++){
		for(int j=0; j&lt;polja[0].size(); j++){
			if(polja[i][j]==Polje::Prazno) return Status::NijeKraj;
		}
	}
	if(i==polja.size()-1)return Status::KrajPobjeda;
	
	
	return Status::NijeKraj;
	
	
	
}
void PrijaviGresku(KodoviGresaka greska){
	if(greska==KodoviGresaka::PogresnaKomanda) {
		std::cout&lt;&lt;"Nerazumljiva komanda!";
		return;
	}
	else if(greska==KodoviGresaka::NedostajeParametar) {
		std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!";
		return;
		
	}
	else if(greska==KodoviGresaka::NeispravanParametar){
		std::cout&lt;&lt;"Parametar komande nije ispravan!";
		return;
	}
	else if(greska==KodoviGresaka::SuvisanParametar){
		std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!";
		return;
	}
	
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
/*	if(komanda=="P1" || komanda==" P1" || komanda=="P1 " || komanda==" P1 ") komanda=Komande::PomjeriJednoMjesto;
	else if(komanda=="P&gt;" || komanda==" P&gt;" || komanda=="P&gt; " || komanda==" P&gt; ") komanda=Komande::PomjeriDalje;
	else if(komanda=="B" || komanda==" B" || komanda=="B "|| komanda==" B ") komanda=Komande::Blokiraj;
	else if(komanda=="D" || komanda==" D" || komanda=="D " || komanda==" D ") komanda=Komande::Deblokiraj;
	else if(komanda=="PO" || komanda==" PO" || komanda=="PO " || komanda==" PO ") komanda=Komande::PrikaziOkolinu;
	else if(komanda=="Z" || komanda==" Z" || komanda=="Z " || komanda==" Z ") komanda=Komande::ZavrsiIgru;
	else if(komanda=="K" || komanda==" K" || komanda=="K " || komanda==" K ") komanda=Komande::KreirajIgru;*/
	return true;
}
void IzvrsiKomanu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0){
	if(komanda==Komande::PomjeriJednoMjesto){ 
		Status s=Idi(polja,x,y,p_smjer);
		std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
		if(s==Status::KrajPobjeda) std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja";
		else if(s==Status::KrajPoraz) {std::cout&lt;&lt;"Nagazili ste na minu"; return;}
	}
	else if(komanda==Komande::PomjeriDalje) {
		Status s=Idi(polja,x,y,p_x,p_y);
			std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
		if(s==Status::KrajPobjeda) std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja";
		else if(s==Status::KrajPoraz) {std::cout&lt;&lt;"Nagazili ste na minu"; return;}
	
	}
	else if(komanda==Komande::Blokiraj) BlokirajPolje(polja,x,y);
	else if(komanda==Komande::Deblokiraj) DeblokirajPolje(polja,x,y);
	else if(komanda==Komande::PrikaziOkolinu) {
<a name="6"></a><font color="#00FF00"><a href="match967-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

		std::vector&lt;std::vector&lt;int&gt;&gt; mat=PrikaziOkolinu(polja,x,y);
		for(int i=0; i&lt;mat.size(); i++)
		for(int j=0; j&lt;mat[i].size();j++)
		std::cout&lt;&lt;mat[i][j];
</font>		std::cout&lt;&lt;std::endl;
	}
	else if(komanda==Komande::ZavrsiIgru) {
		for(int i=0; i&lt;polja.size();i++)
	   for(int j=0;j&lt;polja[0].size();j++) polja[i][j]=Polje::Prazno;
	   throw std::runtime_error("Igra zavrsena");
	} 
	else if(komanda==Komande::KreirajIgru) {
		std::cout&lt;&lt;"Unesite broj polja :";
		int n;
		std::cin&gt;&gt;n;
		std::string p; 
		std::vector&lt;std::string&gt; mine;
		std::cout&lt;&lt;"Unesite pozicije mina: ";
		for(;;){
			std::cin&gt;&gt;p;
			if(p==".")break;
			//break;
			mine.push_back(p);
		}
	}
}

int main ()
{
	return 0;
}</pre>
</body>
</html>
