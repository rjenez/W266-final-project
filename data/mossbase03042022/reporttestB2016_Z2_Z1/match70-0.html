<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3634.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3634.cpp<p></p><pre>
/*B 16/17, Zadaća 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;string&gt; //zbog to_string??

<a name="4"></a><font color="#FF00FF"><a href="match70-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

using std::domain_error;
using std::cout; using std::cin; using std::ws; using std::endl; using std::to_string;
enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
enum class Smjerovi {
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
</font>};
enum class Status {
	NijeKraj, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka {
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
enum class Komande {
<a name="2"></a><font color="#0000FF"><a href="match70-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_18.gif"/></a>

	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

void Brisi(Tabla &amp;polja){
	for(int i{}; i &lt; polja.size(); i++){
		for(int j{}; j &lt; polja.size(); j++){
			polja[i][j] = Polje::Prazno;
		}
	}
}
Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	Tabla T(n, std::vector&lt;Polje&gt;(n));
	//inicijalizujem vrijednosti u cijeloj tabli na "Prazno"
	for(int i{}; i &lt; n; i++){
		for(int j{}; j &lt; n; j++){
			T[i][j] = Polje::Prazno;
		}
	}
	
	for( int j{}; j &lt; mine.size(); j++){
		if (mine[j].size() != 2) throw domain_error("Ilegalan format zadavanja mina");
		
			int vrV(mine[j][1]), vrH(mine[j][0]); //vrijednosti (vertikalne i horizontalne koordinate)
			
			for( int k{}; k &lt; n; k++){
				for( int l{}; l &lt; n; l++){
					if(vrH == k &amp;&amp; vrV == l) T[vrH][vrV] = Polje::Mina;	
				}
			}
			//pošto se na 0,0 ne smije nalaziti mina
			T[0][0] = Polje::Prazno;
			if (vrV &gt;= n || vrH &gt;=n) throw domain_error("Ilegalne pozicije mina");	
		
	}
	return T;
}


std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	std::vector&lt;std::vector&lt;int&gt;&gt; mat(3, std::vector&lt;int&gt; (3, 0));
	if(x &gt;= polja.size() || y &gt;= polja.size()) {
		throw domain_error("Polje (" + to_string(x) + "," + to_string(y) +") ne postoji");
		
	}
	int br; //brojač
	for(int i{x-1}; i &lt; x; i++){
		for(int j{y-1}; j &lt; y; j++){
			br = 0;
			if(i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; i &lt; polja.size() &amp;&amp; j &lt; polja.size()){
				if (polja[i-1][j-1] == Polje::Mina) br++;
				if (polja[i][j-1] == Polje::Mina) br++;
				if (polja[i+1][j-1] == Polje::Mina) br++;
				if (polja[i+1][j] == Polje::Mina) br++;
				if (polja[i-1][j] == Polje::Mina) br++;
				if (polja[i][j+1] == Polje::Mina) br++;
				if (polja[i-1][j+1] == Polje::Mina) br++;
				if (polja[i+1][j+1] == Polje::Mina) br++;
			}
			
		}
		mat[i].push_back(br);
	}
	
	return mat;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	if(x &gt;= polja.size() || y &gt;= polja.size() || x &lt; 0 || y &lt; 0/*??*/) {
		throw domain_error("Polje (" + to_string(x) + "," + to_string(y) + ") ne postoji");
	}
	if (polja[x][y] == Polje::Mina) polja[x][y] = Polje::BlokiranoMina;
</font>	else if(polja[x][y] == Polje::Posjeceno) polja[x][y] = Polje::BlokiranoPosjeceno; 
<a name="3"></a><font color="#00FFFF"><a href="match70-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	else if (polja[x][y] == Polje::Prazno) polja[x][y] = Polje::BlokiranoPrazno;
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	if (x &gt;= polja.size() || y &gt;= polja.size()) {
		throw domain_error("Polje (" + to_string(x) + "," + to_string(y) +") ne postoji");
		
	}
	if(polja[x][y] == Polje::BlokiranoMina) polja[x][y] = Polje::Mina;
</font>	else if(polja[x][y] == Polje::BlokiranoPosjeceno) polja[x][y] = Polje::Posjeceno;
<a name="1"></a><font color="#00FF00"><a href="match70-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_26.gif"/></a>

	else if(polja[x][y] == Polje::BlokiranoPrazno) polja[x][y] = Polje::Prazno;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	polja[x][y] = Polje::Posjeceno;
	int p(polja.size());
	if( ((y+1 &gt;= p) &amp;&amp; (smjer == Smjerovi::Desno || smjer == Smjerovi::GoreDesno || smjer == Smjerovi::GoreLijevo))
	 || ((y-1 &lt; 0) &amp;&amp; (smjer == Smjerovi::Lijevo || smjer == Smjerovi::GoreLijevo || smjer == Smjerovi::GoreLijevo))
	 || ((x+1 &gt;= p) &amp;&amp; (smjer == Smjerovi::Dolje || smjer == Smjerovi::DoljeDesno || smjer == Smjerovi::DoljeLijevo))
	 || ((x-1 &lt; 0) &amp;&amp; (smjer == Smjerovi::Gore || smjer == Smjerovi::GoreDesno || smjer == Smjerovi::GoreLijevo)) )
	 throw std::out_of_range("Izlazak van igrace table");
	 if( ((smjer == Smjerovi::Desno) &amp;&amp; (polja[x][y+1] == Polje::BlokiranoPrazno || polja[x][y+1] == Polje::BlokiranoMina || polja[x][y+1] == Polje::BlokiranoPosjeceno))
	 || (smjer == Smjerovi::Lijevo &amp;&amp; (polja[x][y-1] == Polje::BlokiranoPrazno || polja[x][y-1] == Polje::BlokiranoMina || polja[x][y-1] == Polje::BlokiranoPosjeceno))
	 || (smjer == Smjerovi::Gore &amp;&amp; (polja[x-1][y] == Polje::BlokiranoPrazno || polja[x-1][y] == Polje::BlokiranoMina || polja[x-1][y] == Polje::BlokiranoPosjeceno))
	 || (smjer == Smjerovi::Dolje &amp;&amp; (polja[x+1][y] == Polje::BlokiranoPrazno || polja[x+1][y] == Polje::BlokiranoMina || polja[x+1][y] == Polje::BlokiranoPosjeceno))
	 || (smjer == Smjerovi::GoreDesno &amp;&amp; (polja[x-1][y+1] == Polje::BlokiranoPrazno || polja[x-1][y+1] == Polje::BlokiranoMina || polja[x-1][y+1] == Polje::BlokiranoPosjeceno))
	 || (smjer == Smjerovi::GoreLijevo &amp;&amp; (polja[x-1][y-1] == Polje::BlokiranoPrazno || polja[x-1][y-1] == Polje::BlokiranoMina || polja[x-1][y-1] == Polje::BlokiranoPosjeceno))
	 || (smjer == Smjerovi::DoljeDesno &amp;&amp; (polja[x+1][y+1] == Polje::BlokiranoPrazno || polja[x+1][y+1] == Polje::BlokiranoMina || polja[x+1][y+1] == Polje::BlokiranoPosjeceno))
	 || (smjer == Smjerovi::DoljeLijevo &amp;&amp; (polja[x+1][y-1] == Polje::BlokiranoPrazno || polja[x+1][y-1] == Polje::BlokiranoMina || polja[x+1][y-1] == Polje::BlokiranoPosjeceno)) )
	 throw std::logic_error("Blokirano polje");
	 
	switch (smjer){
		case Smjerovi::Desno : y++; break;
		case Smjerovi::Lijevo : y--; break;
		case Smjerovi::Gore : x--; break;
		case Smjerovi::Dolje : x++; break;
		case Smjerovi::DoljeDesno : {x++; y++; break;}
		case Smjerovi::DoljeLijevo : {x++; y--; break;}
		case Smjerovi::GoreDesno : {x--; y++; break;}
		case Smjerovi::GoreLijevo : {x--; y--;}
	}
	
	if (polja[x][y] == Polje::Mina) {
		Brisi(polja); 
		return Status::KrajPoraz;
	}//..
	
	bool kraj_igre(true);
	for(int i{}; i &lt; polja.size(); i++){
		for(int j{}; j &lt; polja.size(); j++){
			if(polja[i][j] != Polje::Mina || polja[i][j] != Polje::Posjeceno ) {kraj_igre = false; break;}
		}
	}
	if (kraj_igre == true) return Status::KrajPobjeda; // ?? ??
	
	return Status::NijeKraj;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){

	if(novi_x &lt; 0 || novi_x &gt;= polja.size() || novi_y &lt; 0 || novi_y &gt;= polja.size()) throw std::out_of_range("Izlazak van igrace table");
	
	if (polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno || polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoMina) throw std::logic_error("Blokirano polje"); //?? ??
</font><a name="0"></a><font color="#FF0000"><a href="match70-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_45.gif"/></a>

	if (polja[novi_x][novi_y] == Polje::Mina) { 
		Brisi(polja); 
		return Status::KrajPoraz;
	} //..
	x = novi_x;
	y = novi_y;
	bool kraj_igre(true);
	for(int i{}; i &lt; polja.size(); i++){
		for(int j{}; j &lt; polja.size(); j++){
			if(polja[i][j] != Polje::Mina || polja[i][j] != Polje::Posjeceno ) {kraj_igre = false; break;}
		}
	}
	if (kraj_igre == true) return Status::KrajPobjeda;
	return Status::NijeKraj;
}
void PrijaviGresku(KodoviGresaka greska){
	switch(greska){
		case KodoviGresaka::PogresnaKomanda : cout &lt;&lt; "Nerazumljiva komanda!\n"; break;
		case KodoviGresaka::NedostajeParametar : cout &lt;&lt; "Komanda trazi parametar koji nije naveden!\n"; break;
		case KodoviGresaka::NeispravanParametar : cout &lt;&lt; "Parametar komande nije ispravan!\n"; break;
		case KodoviGresaka::SuvisanParametar : cout &lt;&lt; "Zadan je suvisan parametar nakon komande!\n"; break;
	}
}
bool UnosKomande (Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	cin &gt;&gt; ws;
	char znak(cin.get());
//	cin &gt;&gt; ws;
	if (!cin) greska = KodoviGresaka::PogresnaKomanda;
	if (znak == 'P') {
		char znak2 ( cin.get());
		if (znak2 == '1') komanda = Komande::PomjeriJednoMjesto;
		else if (znak2 == '&gt;') komanda = Komande::PomjeriDalje;
		else if (znak2 == 'O') komanda = Komande::PrikaziOkolinu;
		else {greska = KodoviGresaka::PogresnaKomanda; cin.ignore(10000, '\n'); return false;}
	}
	else if(znak == 'B') komanda = Komande::Blokiraj;
	else if(znak == 'D') komanda = Komande::Deblokiraj;
	else if(znak == 'Z') komanda = Komande::ZavrsiIgru;
	else if(znak == 'K') komanda = Komande::KreirajIgru;
	else {cin.ignore(10000, '\n'); greska = KodoviGresaka::PogresnaKomanda; return false;}
	
	if (komanda == Komande::PomjeriJednoMjesto) {
		cin &gt;&gt; ws;
		znak = cin.get();
		if (znak == '\n') {greska = KodoviGresaka::NedostajeParametar; /*???*/ return false;} //IZMIJENI
		else if (znak == 'L')  {
			 if (cin.peek() == ' '|| cin.peek()=='\n')  smjer = Smjerovi::Lijevo;
			 else {greska = KodoviGresaka::SuvisanParametar; return false;}
		}
		else if (znak == 'G' &amp;&amp; cin.peek() == 'L') {
			cin.get(); //kupim slovo da bih mogla peek-ovati
			if (cin.peek() == ' ' || cin.peek() == '\n') smjer = Smjerovi::GoreLijevo;
			else {greska = KodoviGresaka::SuvisanParametar; return false;}
		}
		else if (znak == 'G' &amp;&amp; cin.peek() == 'D') {
			cin.get(); //kupim slovo da bih mogla peek-ovati
			if (cin.peek() != ' '|| cin.peek()=='\n') smjer = Smjerovi::GoreDesno;
			else {greska = KodoviGresaka::SuvisanParametar; return false;}
		}
		else if (znak == 'G') {
			if (cin.peek() == ' ' || cin.peek() == '\n')  {smjer = Smjerovi::Gore; cin.get();}
			else {greska = KodoviGresaka::SuvisanParametar; return false;}
		}
		else if (znak == 'D' &amp;&amp; cin.peek() == 'o'){
			cin.get(); 
			if (cin.peek() == 'D'){
				cin.get();
				if(cin.peek() == ' ' || cin.peek() == '\n')  {smjer = Smjerovi::DoljeDesno; /*char znak3 = ??*/cin.get();}
				else {greska = KodoviGresaka::SuvisanParametar; return false;}
			}
			else if (cin.peek() == 'L') {
				cin.get(); //kupim slovo da bih mogla peek-ovati
				if (cin.peek() == ' ' || cin.peek() == '\n')  {smjer = Smjerovi::DoljeLijevo; /*char znak3 = ??*/cin.get();}
				else {greska = KodoviGresaka::SuvisanParametar; return false;}
			}
			else if (cin.peek() == ' ' || cin.peek() == '\n') {
				cin.get(); //kupim slovo da bih mogla peek-ovati
				smjer = Smjerovi::Dolje;
			}
			else {greska = KodoviGresaka::NeispravanParametar; return false;}
		}
		else if (znak == 'D' &amp;&amp; (cin.peek() == ' ' || cin.peek() == '\n')/*??*/) smjer = Smjerovi::Desno;
		else {greska = KodoviGresaka::NeispravanParametar; /*?? */ return false;}
	}
			
	else if (komanda == Komande::PomjeriDalje || komanda == Komande::Blokiraj /*??*/ || komanda == Komande::Deblokiraj /*??*/) {
		bool ind(true); //indikator za petlju
		do{
			
			//cin &gt;&gt; ws;
			double broj;
			cin &gt;&gt; broj;
			
			if ( !cin || broj != int(broj) || cin.peek() != ' ' || cin.peek() != '\n'/*??zbog y*/) {greska = KodoviGresaka::PogresnaKomanda; /*?? return false;*/}
			else if (ind == false) {y = int(broj); ind = true;}
			else {x = int(broj); ind = false;}
		} while(greska != KodoviGresaka::NedostajeParametar &amp;&amp; ind); //logička greška moguća.. ??
		/*	pretp da je ind true
			(u petlju se uđe svakako-do while je)
			petlja se vrti sve dok 
				ili unos ne bude pogresan ili 
				dok indikator ne kaze da je i y uneseno (tj ind postavljen na true [pa ako je ind true prekida se petlja])
		*/
		
	}
			
	else if ((komanda == Komande::PrikaziOkolinu || komanda == Komande::ZavrsiIgru || komanda == Komande::KreirajIgru) &amp;&amp; ( cin.peek() != '\n') ) {
		greska = KodoviGresaka::SuvisanParametar;
		PrijaviGresku(greska);
	}
	
	else if (greska == KodoviGresaka::PogresnaKomanda || greska == KodoviGresaka::NedostajeParametar || greska == KodoviGresaka::SuvisanParametar || greska == KodoviGresaka::NeispravanParametar ) return false;
	else greska = KodoviGresaka::PogresnaKomanda; //??recimo
	//}while( /*cin.peek() == ' ' /*|| cin.get() == ' */ ); 
	return true;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0){ // početni .. :P
		try {
			if (komanda == Komande::PomjeriJednoMjesto)
			if (komanda == Komande::PomjeriDalje) {
				if (Status::KrajPobjeda == Idi(polja, x, y, p_smjer))  cout &lt;&lt; "Tekuca pozicija igraca je (" + to_string(x) + "," + to_string(y) + ")\n" &lt;&lt; "Bravo, obisli ste sva sigurna polja\n";
				else if (Status::KrajPoraz == Idi(polja, x, y, p_smjer)) {cout &lt;&lt;  "Tekuca pozicija igraca je (" + to_string(x) + "," + to_string(y) + ")\n" &lt;&lt; "Nagazili ste minu\n"; komanda = Komande::ZavrsiIgru;}
				else if (Status::KrajPobjeda == Idi(polja, x, y, p_x, p_y))  cout &lt;&lt; "Bravo, obisli ste sva sigurna polja";
				else if (Status::KrajPoraz == Idi(polja, x, y, p_x, p_y)) cout &lt;&lt; "Nagazili ste minu";
				
			}
			if (komanda == Komande::Blokiraj) BlokirajPolje(polja, x, y);
			if (komanda == Komande::Deblokiraj) DeblokirajPolje(polja, x, y);
			if (komanda == Komande::PrikaziOkolinu){
				std::vector&lt;std::vector&lt;int&gt;&gt; v(PrikaziOkolinu(polja, x, y));
				for (int i{}; i &lt; polja.size(); i++){
					for (int j{}; j &lt; polja.size(); j++){
						cout &lt;&lt; v[i][j] &lt;&lt; " ";
					}
					cout &lt;&lt; endl;
				}
			}
			if (komanda == Komande::ZavrsiIgru) {Brisi(polja); throw std::runtime_error("Igra zavrsena");}
			if (komanda == Komande::KreirajIgru) {
				
				cout &lt;&lt; "Unesite broj polja";
				int n;
				cin &gt;&gt; n;
				cout &lt;&lt; endl;
					/*	da ne komplikujem ako nema potrebe
				do{
					cout &lt;&lt; "Unesite broj polja: ";
					cin.ignore(10000, '\n');
				} while (cin &lt;&lt; n, !cin); //možda greška potencijalna ??
			*/	
				cout &lt;&lt; "Unesite pozicije mina: ";
				int p1,p2; //pozicije 1 i 2
				while(true){
					int unos;
					unos = cin.get();
					bool ind(false); //indikator za grešku
					
					if (unos != '(') ind = true;
					if (!ind) cin &gt;&gt; p1;
					if (!cin) ind = true;
					if (!ind) unos = cin.get(); //zarez
					if (unos != ',') ind = true;
					if (!ind) cin &gt;&gt; p2;
					if (!cin) ind = true;
					if (!ind) unos = cin.get();
					if (unos != ')') ind = true;
						
					
					
					if (ind == true) {
						cout &lt;&lt; "Greska, unesite ponovo!"; 
						cin.ignore(10000, '\n');
					}
					else break;
				};
				const std::vector&lt;std::vector&lt;int&gt;&gt; mine;
				KreirajIgru(n, mine); //???
				
			}
		}
		catch (domain_error de1){
			cout &lt;&lt; de1.what() &lt;&lt; endl;
		}
		catch (std::out_of_range our1){
			cout &lt;&lt; our1.what() &lt;&lt; endl;
		}
		catch (std::logic_error le1){
			cout &lt;&lt; le1.what() &lt;&lt; endl;
		}
		
	}


int main (){

//AT2 (c9) - funkcija Okolina primjer iz postavke
    std::vector&lt;std::vector&lt;int&gt;&gt; mine = {{0,1}, {0,4}, {1,3}, {1,4}, {2,0}, {2,1}, {2,3}} ;
    std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla = KreirajIgru(5, mine);
    std::vector&lt;std::vector&lt;int&gt;&gt; okolina = PrikaziOkolinu(tabla, 1, 1);
    for(int i = 0; i &lt; okolina.size(); i++)
    {
      for(int j = 0; j &lt; okolina[i].size(); j++) std::cout &lt;&lt; okolina[i][j] &lt;&lt; " ";
      std::cout &lt;&lt; std::endl;
    }

/*	Komande KI(Komande::KreirajIgru);
	Smjerovi SMJER(Smjerovi::Desno);
	KodoviGresaka KODOVI_GRESAKA;
	int x(0), y(0);
 	bool qw = UnosKomande (KI, SMJER, x, y, KODOVI_GRESAKA);*/
/*	while (true){
	//	Polje POLJE(Polje::Prazno); //inicijalizacija varijable POLJE tipa Polje na vr Polje::Prazno
		std::vector&lt;std::vector&lt;int&gt;&gt; mine = {{0,2}, {1,3}, {1,5}, {4,2}, {5,1}, {5,5}} ;
	
		Smjerovi SMJER(Smjerovi::Desno);
		Status STATUS;
	;
		 p1(Komande::PomjeriJednoMjesto), PD(Komande::PomjeriDalje), B(Komande::Blokiraj), D(Komande::Deblokiraj), PO(Komande::PrikaziOkolinu), Z(Komande::ZavrsiIgru)*/;
	//	typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
	/*	Tabla TABLA;
		int x(2), y(3), px(0), py(0);
		try{
			cout &lt;&lt; "Unesite komandu: ";
		
			if ((UnosKomande(K, SMJER, x, y, KODOVI_GRESAKA)) == true)	IzvrsiKomandu(K, TABLA, x, y, SMJER, px, py);
			else PrijaviGresku(KODOVI_GRESAKA);
		}
		catch(...){
			cout &lt;&lt; "HEHE";
		}
	}
	cout &lt;&lt; "Dovidjenja!";
	return 0;
	*/


return 0;
</font>	
}

</pre>
</body>
</html>
