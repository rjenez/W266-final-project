<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3736.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3736.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;

<a name="0"></a><font color="#FF0000"><a href="match53-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;

enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};
enum class Smjerovi{GoreLijevo, Gore, GoreDesno, Desno, 
	DoljeDesno, Dolje, DoljeLijevo, Lijevo };
enum class KodoviGresaka{ PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar };
enum class Polje { Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina };
enum class Komande { PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru };

typedef vector&lt;vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajTablu(int n)
{
	return Tabla(n, vector&lt;Polje&gt;(n));
}

Tabla KreirajIgru(int n, const vector&lt;vector&lt;int&gt;&gt; &amp;mine)
{
	for(unsigned int i=0; i &lt; mine.size(); i++)
	{
		if(mine[i].size()!=2)  throw domain_error("Ilegalan format zadavanja mina");
		else if(mine[i][0] &gt; n-1 || mine[i][0]&lt;0 || mine[i][1]&gt;n-1 || mine[i][1]&lt;0 )
				throw domain_error("Ilegalne pozicije mina");
	}
	
	vector&lt;vector&lt;Polje&gt;&gt; t{KreirajTablu(n)};
	for(int i=0;i&lt;n;i++) {
		for(int j=0;j&lt;n;j++)
			t[i][j]=Polje::Prazno;
	}
	
	for(unsigned int i=0;i&lt;mine.size();i++)
	{
		for(int j=0;j&lt;2;j++)
		{
			t[ mine[i][0] ][ mine[i][1] ] = Polje::Mina;
		}
	}
	return t;
}


vector&lt;vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
	if( x==0 || y==0 || x==int(polja.size()-1) || y==int(polja.size()-1) )
		throw domain_error("Polje (x,y) ne postoji");
		
	vector&lt;vector&lt;int&gt;&gt; okolina;
	int brojac{0};
	
	int n{ int(polja.size()) };
	
	for(int i=-1; i&lt;2; i++)
	{
		vector&lt;int&gt; m;
		for(int j=-1;j&lt;2;j++)
		{
			brojac=0;
			if(x+i&gt;=0  &amp;&amp;  y+j&gt;=0 &amp;&amp; x+i&lt;n  &amp;&amp;  y+j&lt;n)
			{
				//pristupili smo elementu ploca[x-i][y-j], jos da provjerimo kakva je njegova okolina
				for(int iPojedinacno=-1; iPojedinacno&lt;2; iPojedinacno++)
				{
					for(int jPojedinacno=-1; jPojedinacno&lt;2; jPojedinacno++)
					{
						if(iPojedinacno==0 &amp;&amp; jPojedinacno==0)  continue;
						if(x+i+iPojedinacno&gt;=0  &amp;&amp;  y+j+jPojedinacno&gt;=0 &amp;&amp; x+i+iPojedinacno&lt;n  
						  &amp;&amp;  y+j+jPojedinacno&lt;n &amp;&amp; polja[x+i+iPojedinacno][y+j+jPojedinacno]==Polje::Mina)
						  		brojac++;
					}
				}
			}
			m.push_back(brojac);	
		}
		okolina.push_back(m);
		m.clear();
	}
	/*
	for(int i=0;i&lt;3;i++)
	{
		for(int j=0;j&lt;3;j++)    cout&lt;&lt;okolina[i][j]&lt;&lt;" ";
		cout&lt;&lt;endl;
	}*/
	
	return okolina;	
}


void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 || y&lt;0 || x&gt;int(polja.size()-1) || y&gt;int(polja.size()-1)  )
		throw domain_error("Polje (x,y) ne postoji");
	for(int i=0;i&lt;3;i++)
	{
		if(polja[x][y]==Polje(i))    polja[x][y]=Polje(i+3);
	}
}


void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x&lt;0 || y&lt;0 || x&gt;int(polja.size()-1) || y&gt;int(polja.size()-1)  )
		throw domain_error("Polje (x,y) ne postoji");
	for(int i=0;i&lt;3;i++)
	{
		if(polja[x][y]==Polje(i+3))    polja[x][y]=Polje(i);
	}
}


Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer)
{
	int dimTable{ int(polja.size()) };
	polja[x][y] = Polje::Posjeceno;
	
	Status statusIgre{ Status::NijeKraj };
	
	bool mrtviSmo{false}, pobijediliSmo{false};
	
	if(smjer==Smjerovi::GoreLijevo)
	{
		if(x-1&lt;0 || y-1&lt;0 || x-1&gt;=dimTable || y-1&gt;=dimTable )
			throw out_of_range("Izlazak van igrace table");
		if(polja[x-1][y-1]&gt;Polje(2))   throw logic_error("Blokirano polje");
		x-=1;
		y-=1;
		if(polja[x][y]==Polje(2))   mrtviSmo=true;
	}
	
	else if(smjer==Smjerovi::Gore)
	{
		if(x-1&lt;0 || x-1&gt;=dimTable)
			throw out_of_range("Izlazak van igrace table");
		if(polja[x-1][y]&gt;Polje(2))   throw logic_error("Blokirano polje");
		x-=1;
		if(polja[x][y]==Polje(2))   mrtviSmo=true;
	}
	
	else if(smjer==Smjerovi::GoreDesno)
	{
		if(x-1&lt;0 || y+1&lt;0 || x-1&gt;=dimTable || y+1&gt;=dimTable)
			throw out_of_range("Izlazak van igrace table");
		if(polja[x-1][y+1]&gt;Polje(2))   throw logic_error("Blokirano polje");
		x-=1;
		y+=1;
		if(polja[x][y]==Polje(2))   mrtviSmo=true;
	}
	
	
	else if(smjer==Smjerovi::Desno)
	{
		if(y+1&lt;0 || y+1&gt;=dimTable)
			throw out_of_range("Izlazak van igrace table");
		if(polja[x][y+1]&gt;Polje(2))   throw logic_error("Blokirano polje");
		y+=1;
		if(polja[x][y]==Polje(2))   mrtviSmo=true;
	}
	
	else if(smjer==Smjerovi::DoljeDesno)
	{
		if(x+1&lt;0 || y+1&lt;0 || x+1&gt;=dimTable || y+1&gt;=dimTable)
			throw out_of_range("Izlazak van igrace table");
		if(polja[x+1][y+1]&gt;Polje(2))   throw logic_error("Blokirano polje");
		x+=1;
		y+=1;
		if(polja[x][y]==Polje(2))   mrtviSmo=true;
	}
	
	else if(smjer==Smjerovi::Dolje)
	{
		if(x+1&lt;0 || x+1&gt;=dimTable)
			throw out_of_range("Izlazak van igrace table");
		if(polja[x+1][y]&gt;Polje(2))   throw logic_error("Blokirano polje");
		x+=1;
		if(polja[x][y]==Polje(2))   mrtviSmo=true;
	}
	
	else if(smjer==Smjerovi::DoljeLijevo)
	{
		if(x+1&lt;0 || y-1&lt;0 || x+1&gt;=dimTable || y-1&gt;=dimTable)
			throw out_of_range("Izlazak van igrace table");
		if(polja[x+1][y-1]&gt;Polje(2))   throw logic_error("Blokirano polje");
		x+=1;
		y-=1;
		if(polja[x][y]==Polje(2))   mrtviSmo=true;
	}
	
	else if(smjer==Smjerovi::Lijevo)
	{
		if(y-1&lt;0 || y-1&gt;=dimTable)
			throw out_of_range("Izlazak van igrace table");
		if(polja[x][y-1]&gt;Polje(2))   throw logic_error("Blokirano polje");
		y-=1;
		if(polja[x][y]==Polje(2))   mrtviSmo=true;
	}
	
	if(mrtviSmo)
	{
		for(int i=0;i&lt;dimTable;i++)
		{
			for(int j=0;j&lt;dimTable;j++)  polja[i][j]=Polje::Prazno;
		}
		//polja.clear(); //???
		statusIgre = Status::KrajPoraz;
		return statusIgre;
	}
	
	if(pobijediliSmo)
	{
		statusIgre = Status::KrajPobjeda;
		return statusIgre;
	}
	
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y)
{
	int dimTable{ int(polja.size()) };
	polja[x][y]=Polje::Posjeceno;
	
	x=novi_x;
	y=novi_y;
	
	Status statusIgre{ Status::NijeKraj };
	bool mrtviSmo{false}, pobijediliSmo{false};
	
	if(novi_x&lt;0  ||  novi_y&lt;0  ||  novi_x&gt;=dimTable || novi_y&gt;=dimTable)
			throw out_of_range("Izlazak van igrace table");
	if(polja[novi_x][novi_y]&gt;Polje(2))  throw logic_error("Blokirano polje");
	if(polja[novi_x][novi_y]==Polje::Mina)  mrtviSmo=true;
	
	if(mrtviSmo)  //ako smo nagazili na minu
	{
		for(int i=0;i&lt;dimTable;i++)
		{
			for(int j=0;j&lt;dimTable;j++)    polja[i][j]=Polje::Prazno;
		}
		statusIgre = Status::KrajPoraz;
		return statusIgre;
	}
	
	for(int i=0;i&lt;dimTable;i++)
	{
		for(int j=0;j&lt;dimTable;j++)
		{
			if(polja[i][j]!=Polje::Posjeceno)
			{
				pobijediliSmo=false;
				return statusIgre;
			}
		}
	}
	
	if(pobijediliSmo)
	{
		statusIgre = Status::KrajPobjeda;
		return statusIgre;
	}
	
	return Status::NijeKraj;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;kod_greske)
{
	char prviZnak, drugiZnak, prvoSlovoSmjer;
	cin&gt;&gt;ws;
	
	prviZnak = cin.get();
	if(prviZnak=='P')
	{
		drugiZnak=cin.get();
		if(drugiZnak=='1')   //Uneseno je PomjeriJednoMjesto
		{
			komanda = Komande::PomjeriJednoMjesto;
			//while(cin.peek()!='\n' &amp;&amp; isspace(cin.peek()))  cin.get();
			while (cin.peek()!='\n' &amp;&amp; isspace(cin.peek())) cin.get();
			if(cin.peek()=='\n')
			{
				kod_greske=KodoviGresaka::NedostajeParametar;
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
			cin&gt;&gt;ws;
			if(cin.peek()=='\n')
			{
				kod_greske=KodoviGresaka::NedostajeParametar;
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
			if(cin.peek()=='G' &amp;&amp; cin.get()=='G')
			{
				prvoSlovoSmjer='G';
				if(cin.peek()=='L' &amp;&amp; cin.get()=='L')
				{
					
					smjer=Smjerovi::GoreLijevo;
					return true;
				}
				else if(cin.peek()=='D' &amp;&amp; cin.get()=='D')
				{
					smjer=Smjerovi::GoreDesno;
					return true;
				}
				else if(cin&gt;&gt;ws &amp;&amp; cin.get()=='\n')
				{
					smjer=Smjerovi::Gore;
					return true;
				}
				else{
					kod_greske=KodoviGresaka::NeispravanParametar;
					cin.clear();
					cin.ignore(10000,'\n');
					return false;
				}
			}
			
			else if(cin.peek()=='D' &amp;&amp; cin.get()=='D')
			{
				if(cin.peek()=='o' &amp;&amp; cin.get()=='o')
				{
					if(cin.peek()=='D' &amp;&amp; cin.get()=='D')
					{
						smjer = Smjerovi::DoljeDesno;
						return true;
					}
					else if(cin.peek()=='L' &amp;&amp; cin.get()=='L')
					{
						smjer = Smjerovi::DoljeLijevo;
						return true;
					}
					else if(cin&gt;&gt;ws &amp;&amp; cin.get()=='\n')
					{
						smjer=Smjerovi::Dolje;
						return true;
					}
					else{
						kod_greske=KodoviGresaka::NeispravanParametar;
						cin.clear();
						cin.ignore(10000,'\n');
						return false;
					}
				}
				else if(cin&gt;&gt;ws &amp;&amp; cin.get()=='\n')
				{
					smjer=Smjerovi::Desno;
					return true;
				}
				else
				{
					kod_greske=KodoviGresaka::NeispravanParametar;
					cin.clear();
					cin.ignore(10000,'\n');
					return false;	
				}
			}
			else if(cin.peek()=='L' &amp;&amp; cin.get()=='L')
			{
				smjer=Smjerovi::Lijevo;
				return true;
			}
			//ako nije ni gore ni dolje ni desno ni lijevo
			else
			{
				kod_greske = KodoviGresaka::NeispravanParametar;
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
			drugiZnak=0;
		}
		
		else if(drugiZnak=='&gt;')
		{
			while (cin.peek()!='\n' &amp;&amp; isspace(cin.peek())) cin.get();
			if(cin.peek()=='\n')
			{
				kod_greske=KodoviGresaka::NedostajeParametar;
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
			cin&gt;&gt;x&gt;&gt;ws;
			if(!cin)
			{
				cin.clear();
				cin.ignore(10000,'\n');
				kod_greske=KodoviGresaka::NeispravanParametar;
				return false;
			}
			
			while (cin.peek()!='\n' &amp;&amp; isspace(cin.peek())) cin.get();
			if(cin.peek()=='\n')
			{
				kod_greske=KodoviGresaka::NedostajeParametar;
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
			cin&gt;&gt;y&gt;&gt;ws;
			if(!cin)
			{
				cin.clear();
				cin.ignore(10000,'\n');
				kod_greske=KodoviGresaka::NeispravanParametar;
				return false;
			}
			while(cin.peek()!='\n')
			{
				if(!isspace(cin.get()))
				{
					kod_greske=KodoviGresaka::SuvisanParametar;
					cin.clear();
					cin.ignore(10000,'\n');
					return false;
				}
			}
			drugiZnak=0;
			komanda = Komande::PomjeriDalje;
			return true;
		}
		
		else if(drugiZnak=='O')
		{
			
			while(cin.peek()!='\n')
			{
				if(!isspace(cin.get()))
				{
					kod_greske=KodoviGresaka::SuvisanParametar;
					cin.clear();
					cin.ignore(10000,'\n');
					return false;
				}
			}
			drugiZnak=0;
			komanda=Komande::PrikaziOkolinu;
			return true;
		}
		
		//inace je pogresna komanda
		
		else
		{
			kod_greske = KodoviGresaka::PogresnaKomanda;
			cin.clear();
			cin.ignore(10000,'\n');
			return false;
		}
	}
	
	else if(prviZnak=='B')
	{
		cin&gt;&gt;ws;
		while(cin.peek()!='\n')
		{
			if(!isspace(cin.get()))
			{
				kod_greske=KodoviGresaka::NedostajeParametar;					
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
		}
		cin&gt;&gt;x&gt;&gt;y;
		if(!cin)
		{
			cin.clear();
			cin.ignore(10000,'\n');
			kod_greske=KodoviGresaka::NeispravanParametar;
			return false;
		}
		while(cin.peek()!='\n')
		{
			if(!isspace(cin.get()))
			{
				kod_greske=KodoviGresaka::SuvisanParametar;					
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
		}
		komanda = Komande::Blokiraj;
		return true;
	}
	
	else if(prviZnak=='D')
	{
		cin&gt;&gt;ws;
		while(cin.peek()!='\n')
		{
			if(!isspace(cin.get()))
			{
				kod_greske=KodoviGresaka::NedostajeParametar;					
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
		}
		cin&gt;&gt;x&gt;&gt;y;
		
		if(!cin)
		{
			cin.clear();
			cin.ignore(10000,'\n');
			kod_greske=KodoviGresaka::NeispravanParametar;
			return false;
		}
		cin&gt;&gt;ws;
		while (cin.peek()!='\n') 
		{	kod_greske=KodoviGresaka::SuvisanParametar;
			cin.clear();
			cin.ignore(10000,'\n');
			return false;
		}
		komanda = Komande::Deblokiraj;
		return true;
	}
		
	else if(prviZnak=='K')
	{
		while(cin.peek()!='\n')
		{
			if(!isspace(cin.get()))
			{
				kod_greske=KodoviGresaka::SuvisanParametar;
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
		}
		komanda = Komande::KreirajIgru;
		return true;
	}
	
	else if(prviZnak=='Z')
	{
		while(cin.peek()!='\n')
		{
			if(!isspace(cin.get()))
			{
				kod_greske=KodoviGresaka::SuvisanParametar;
				cin.clear();
				cin.ignore(10000,'\n');
				return false;
			}
		}
		komanda = Komande::ZavrsiIgru;
		return true;
	}
	
	//inace je pogresna komanda
	else
	{
		kod_greske=KodoviGresaka::PogresnaKomanda;
		cin.clear();
		cin.ignore(10000,'\n');
		return false;
	}
	return true;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y,
	Smjerovi p_smjer=Smjerovi::Gore, int p_x=0, int p_y=0)
{
	if(komanda==Komande::PomjeriJednoMjesto)
	{
		Status stat{Idi(polja,x,y,p_smjer)};
		if(stat==Status::NijeKraj)
			cout&lt;&lt;"Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt;")"&lt;&lt;endl;
		else if(stat==Status::KrajPobjeda)
			cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;endl;
		else  cout&lt;&lt;"Nagazili ste minu"&lt;&lt;endl;
	}
	
	else if(komanda==Komande::PomjeriDalje)
	{
		Status stat{Idi(polja,x,y,p_x,p_y)};
		if(stat==Status::NijeKraj)
			cout&lt;&lt;"Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt;")"&lt;&lt;endl;
		else if(stat==Status::KrajPobjeda)
			cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;endl;
		else  cout&lt;&lt;"Nagazili ste minu"&lt;&lt;endl;
	}
	
	else if(komanda==Komande::Blokiraj)  BlokirajPolje(polja,x,y);
	else if(komanda==Komande::Deblokiraj) DeblokirajPolje(polja,x,y);
	else if(komanda==Komande::PrikaziOkolinu) 
	{
		vector&lt;vector&lt;int&gt;&gt; prikaz{ PrikaziOkolinu(polja,x,y) };
		for(int i=0;i&lt;3;i++)
		{
			for(int j=0;j&lt;3;j++)    cout&lt;&lt;prikaz[i][j]&lt;&lt;" ";
			cout&lt;&lt;endl;
		}
	}
	else if(komanda==Komande::ZavrsiIgru)
	{
		for(int i=0;i&lt;polja.size();i++)
		{
			for(int j=0;j&lt;polja[i].size();j++)
			{
				polja[i][j]=Polje::Prazno;
			}
			//cout&lt;&lt;endl;
		}
		cout&lt;&lt;"Dovidjenja!";
		throw runtime_error("Igra zavrsena");
	}
	
	else if(komanda==Komande::KreirajIgru)
	{
		int n;
		cout&lt;&lt;"Unesite broj polja: ";
		cin&gt;&gt;n;
		vector&lt;vector&lt;int&gt;&gt; mine;
		int x,y;
		char znak{')'};
		cout&lt;&lt;"Unesite pozicije mina: ";
		while(znak==')')
		{
			cin&gt;&gt;znak;
			if(znak!='(')
			{
				if(znak=='.')   break;
				cin.clear();
				cin.ignore(10000,'\n');
				cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
				znak=')';
				continue;
			}
			cin&gt;&gt;x;
			cin&gt;&gt;znak;
			if(znak!=',' || x&gt;=n)
			{
				if(znak=='.')   break;
				cin.clear();
				cin.ignore(10000,'\n');
				cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
				znak=')';
				continue;
			}
			cin&gt;&gt;y;
			cin&gt;&gt;znak;
			if(znak==')' &amp;&amp; y&lt;n)
			{
				vector&lt;int&gt; m;
				m.push_back(x);
				m.push_back(y);
				mine.push_back(m);
				continue;
			}
			else
			{
				if(znak=='.')   break;
				cin.clear();
				cin.ignore(10000,'\n');
				cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;endl;
				znak=')';
				continue;
			}
		}
		
		polja = KreirajIgru(n,mine);
	}
}


void PrijaviGresku(KodoviGresaka kod)
{
	if(kod==KodoviGresaka::PogresnaKomanda)
		cout&lt;&lt;"Nerazumljiva komanda!"&lt;&lt;endl;
	else if(kod==KodoviGresaka::NedostajeParametar)
		cout&lt;&lt;"Komanda trazi parametar koji nije naveden!"&lt;&lt;endl;
	else if(kod==KodoviGresaka::NeispravanParametar)
		cout&lt;&lt;"Parametar komande nije ispravan!"&lt;&lt;endl;
	else
		cout&lt;&lt;"Zadan je suvisan parametar nakon komande!"&lt;&lt;endl;
}


int main ()
{
	
	Tabla tab;
	Komande komanda;
	Smjerovi smjer;
	int x{0}, y{0}, tren_x{0}, tren_y{0};
	KodoviGresaka kod;
	bool rez{true};
	while(rez &amp;&amp; cout&lt;&lt;"Unesite komandu: ")
	{
		rez=UnosKomande(komanda, smjer, x, x, kod);
		if(rez) {
			try {
				IzvrsiKomandu(komanda, tab, x, y, smjer, tren_x, tren_y);
			}
			catch(runtime_error e) {rez=false;}
			catch(exception e){
				cout&lt;&lt;e.what()&lt;&lt;endl;
			}
		}
		else {
</font>			PrijaviGresku(kod);
		}
	}
	
	return 0;
}</pre>
</body>
</html>
