<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4370.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4370.cpp<p></p><pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

<a name="5"></a><font color="#FF0000"><a href="match101-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

template &lt;typename T&gt; std::string PretvoriUString(T x){  
  std::ostringstream s; s &lt;&lt; x; 
  return s.str();
}

enum class Polje {Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};

enum class Smjerovi {GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
</font>
enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};

enum class KodoviGresaka {PogresnaKomanda, NedostajeParmetar, SuvisanParametar, NeispravanParametar};

<a name="0"></a><font color="#FF0000"><a href="match101-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_29.gif"/></a>

enum class Komande {PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

void IspisiTablu(Tabla igra){
	for(int i = 0; i &lt; igra.size(); i++){
		for(int j = 0; j &lt; igra.size(); j++){
			std::cout &lt;&lt; static_cast&lt;int&gt;(igra[i][j]) &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
}

int BrojMina(const Tabla &amp;polja, int x, int y){
	int rezultat(0);
	for(int i = 0; i &lt; polja.size(); i++){
		for(int j = 0; j &lt; polja[0].size(); j++){
			if(i==x-1 &amp;&amp; j==y-1 &amp;&amp; polja[i][j]==Polje::Mina) rezultat++;
			else if(i==x-1 &amp;&amp; j==y &amp;&amp; polja[i][j]==Polje::Mina) rezultat++;
			else if(i==x-1 &amp;&amp; j==y+1 &amp;&amp; polja[i][j]==Polje::Mina) rezultat++;
			else if(i==x &amp;&amp; j==y-1 &amp;&amp; polja[i][j]==Polje::Mina) rezultat++; 
			else if(i==x &amp;&amp; j==y+1 &amp;&amp; polja[i][j]==Polje::Mina) rezultat++; 
			else if(i==x+1 &amp;&amp; j==y-1 &amp;&amp; polja[i][j]==Polje::Mina) rezultat++; 
			else if(i==x+1 &amp;&amp; j==y &amp;&amp; polja[i][j]==Polje::Mina) rezultat++; 
			else if(i==x+1 &amp;&amp; j==y+1 &amp;&amp; polja[i][j]==Polje::Mina) rezultat++; 
		}
	}
	return rezultat;
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	bool format(true),pozicije(true);
	for(int i = 0; i &lt; mine.size(); i++){
		if(mine[i].size() != 2){
			format = false;
			break;
		}
	}
	for(int i = 0; i &lt; mine.size(); i++){
		if(mine[i][0] &gt; n-1 || mine[i][0] &lt; 0 || mine[i][1] &gt; n-1 || mine[i][1] &lt; 0){
			pozicije = false;
			break;
		}
	}
	if(!format) throw std::domain_error("Ilegalan format zadavanja mina");
	if(!pozicije) throw std::domain_error("Ilegalne pozicije mina");
	Tabla igra(n, std::vector&lt;Polje&gt; (n,Polje::Prazno));
	for(int i = 0; i &lt; mine.size(); i++){
		igra[mine[i][0]][mine[i][1]] = Polje::Mina;
	}
	return igra;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	bool uslov(true);
	if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja[0].size()) uslov = false;
	if(!uslov) throw std::domain_error(("Polje (" + PretvoriUString(x) + "," + PretvoriUString(y) + ") ne postoji"));
	if(polja[x][y] == Polje::Prazno) polja[x][y] = Polje::BlokiranoPrazno;
</font>	else if(polja[x][y] == Polje::Posjeceno) polja[x][y] = Polje::BlokiranoPosjeceno;
<a name="4"></a><font color="#FF00FF"><a href="match101-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

	else if(polja[x][y] == Polje::Mina) polja[x][y] = Polje::BlokiranoMina;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	bool uslov(true);
	if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja[0].size()) uslov = false;
	if(!uslov) throw std::domain_error(("Polje (" + PretvoriUString(x) + "," + PretvoriUString(y) + ") ne postoji"));
	if(polja[x][y] == Polje::BlokiranoPrazno) polja[x][y] = Polje::Prazno;
</font>	else if(polja[x][y] == Polje::BlokiranoPosjeceno) polja[x][y] = Polje::Posjeceno;
<a name="1"></a><font color="#00FF00"><a href="match101-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_28.gif"/></a>

	else if(polja[x][y] == Polje::BlokiranoMina) polja[x][y] = Polje::Mina;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	bool uslov(true);
	if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja[0].size()) uslov = false;
	if(!uslov) throw std::domain_error(("Polje (" + PretvoriUString(x) + "," + PretvoriUString(y) + ") ne postoji"));
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina(3,std::vector&lt;int&gt; (3));
	for(int i = 0; i &lt; polja.size(); i++){
		for(int j = 0; j &lt; polja[0].size(); j++){
			if(i==x-1 &amp;&amp; j==y-1) okolina[0][0]=BrojMina(polja,i,j);
			else if(i==x-1 &amp;&amp; j==y) okolina[0][1]=BrojMina(polja,i,j);
			else if(i==x-1 &amp;&amp; j==y+1) okolina[0][2]=BrojMina(polja,i,j);
			else if(i==x &amp;&amp; j==y-1) okolina[1][0]=BrojMina(polja,i,j);
			else if(i==x &amp;&amp; j==y) okolina[1][1]=BrojMina(polja,i,j);
			else if(i==x &amp;&amp; j==y+1) okolina[1][2]=BrojMina(polja,i,j);
			else if(i==x+1 &amp;&amp; j==y-1) okolina[2][0]=BrojMina(polja,i,j);
			else if(i==x+1 &amp;&amp; j==y) okolina[2][1]=BrojMina(polja,i,j);
			else if(i==x+1 &amp;&amp; j==y+1) okolina[2][2]=BrojMina(polja,i,j);
		}
	}
	return okolina;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	int n(0),m(0);
	if(smjer == Smjerovi::GoreLijevo || smjer == Smjerovi::GoreDesno || smjer == Smjerovi::Gore) n = -1;
	if(smjer == Smjerovi::DoljeLijevo || smjer == Smjerovi::DoljeDesno || smjer == Smjerovi::Dolje) n = 1;
	if(smjer == Smjerovi::GoreLijevo || smjer == Smjerovi::DoljeLijevo || smjer == Smjerovi::Lijevo) m = -1;
	if(smjer == Smjerovi::GoreDesno || smjer == Smjerovi::DoljeDesno || smjer == Smjerovi::Desno) m = 1;
	if(x+n &gt;= polja.size() || x+n &lt; 0 || y+m &gt;= polja[0].size() || y+m &lt; 0){
		throw std::out_of_range("Izlazak van igrace table");
	}
	if(static_cast&lt;int&gt;(polja[x+n][y+m]) &gt; 2) throw std::logic_error("Blokirano polje");
	x+=n;
	y+=m;
	if(polja[x][y] == Polje::Mina){
		for(int i = 0; i &lt; polja.size(); i++){
</font><a name="3"></a><font color="#00FFFF"><a href="match101-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_9.gif"/></a>

			for(int j = 0; j &lt; polja[0].size(); j++){
				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	else polja[x][y] = Polje::Posjeceno;
	bool pobjeda(true);
	for(int i = 0; i &lt; polja.size(); i++){
		for(int j = 0; j &lt; polja[0].size(); j++){
			if(polja[i][j] == Polje::Prazno){
				pobjeda = false;
				break;
			}
		}
	}
	if(pobjeda) return Status::KrajPobjeda;
	else return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	if(novi_x &gt;= polja.size() || novi_x &lt; 0 || novi_y &gt;= polja[0].size() || novi_y &lt; 0){
		throw std::out_of_range("Izlazak van igrace table");
	}
	if(static_cast&lt;int&gt;(polja[novi_x][novi_y]) &gt; 2) throw std::logic_error("Blokirano polje");
	x = novi_x;
	y = novi_y;
	if(polja[x][y] == Polje::Mina){
		for(int i = 0; i &lt; polja.size(); i++){
</font><a name="2"></a><font color="#0000FF"><a href="match101-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_18.gif"/></a>

			for(int j = 0; j &lt; polja[0].size(); j++){
				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	else polja[x][y] = Polje::Posjeceno;
	bool pobjeda(true);
	for(int i = 0; i &lt; polja.size(); i++){
		for(int j = 0; j &lt; polja[0].size(); j++){
			if(polja[i][j] == Polje::Prazno){
				pobjeda = false;
				break;
			}
		}
	}
	if(pobjeda) return Status::KrajPobjeda;
	else return Status::NijeKraj;
}

void PrijaviGresku(KodoviGresaka kod){
	if(kod == KodoviGresaka::PogresnaKomanda) std::cout &lt;&lt; "Nerazumljiva komanda! ";
	else if(kod == KodoviGresaka::NedostajeParmetar) std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!";
	else if(kod == KodoviGresaka::SuvisanParametar) std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!";
	else if(kod == KodoviGresaka::NeispravanParametar) std::cout &lt;&lt; "Parametar komande nije ispravan!";
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	char znak, x;
	znak = std::cin.get();
	x = std::cin.peek();
	if(znak == 'P'){
		if(x == '1') komanda = Komande::PomjeriJednoMjesto;
		else if(x == '&gt;') komanda = Komande::PomjeriDalje;
		else if(x == 'O') komanda = Komande::PrikaziOkolinu;
	}
	
}

int main ()
{
	std::vector&lt;std::vector&lt;int&gt;&gt; test{{0,1},{0,4},{1,3},{1,4},{2,0},{2,1},{2,3}};
	try{
		Tabla igrica = KreirajIgru(5,test);
		std::vector&lt;std::vector&lt;int&gt;&gt; okolina = PrikaziOkolinu(igrica,1,1);
		for(int i = 0; i &lt; okolina.size(); i++){
			for(int j = 0; j &lt; okolina[0].size(); j++){
				std::cout &lt;&lt; okolina[i][j] &lt;&lt; " ";
			}
			std::cout &lt;&lt; std::endl;
		}
	}
	catch(const std::exception &amp;izuzetak){
		std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
	}
	return 0;
</font>}</pre>
</body>
</html>
