<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student2210.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student2210.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
<a name="1"></a><font color="#00FF00"><a href="match821-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_33.gif"/></a>

using namespace std;
typedef vector&lt;vector&lt;int&gt;&gt; Cijeli;
enum class Polje{Prazno,Posjeceno,Mina,BlokiranoPrazno,BlokiranoPosjeceno,BlokiranoMina};
typedef vector&lt;vector&lt;Polje&gt;&gt; Tabla;
Tabla KreirajIgru(int n,const Cijeli &amp;mine){
	Tabla TABLICA(n);
	for(int i=0;i&lt;n;i++)  TABLICA[i].resize(n);
	for(int i=0;i&lt;mine.size();i++)
	for(int j=0;j&lt;mine[i].size();j++)
	if(mine[i][j]&lt;0 || mine[i][j]&gt;=n) throw domain_error("Ilegalne pozicije mina");
	for(int i=0;i&lt;mine.size();i++)
	if(mine[i].size()!=2) throw domain_error("Ilegalan format zadavanja mina");
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;n;j++) TABLICA[i][j]=Polje::Prazno;
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;n;j++)
	for(int k=0;k&lt;mine.size();k++)
	if(j==mine[k][1] &amp;&amp; i==mine[k][0]) TABLICA[i][j]=Polje::Mina;
	return TABLICA;
}
void BlokirajPolje(Tabla &amp;polja,int x,int y){
	if(x&gt;=polja.size() || y&gt;=polja.size()){
		string s1(to_string(x));
		string s2(to_string(y));
		throw domain_error("Polje ("+s1+","+s2+") ne postoji");
	}
	if(polja[x][y]==Polje::Posjeceno)
	polja[x][y]=Polje::BlokiranoPosjeceno;
</font>	else if(polja[x][y]==Polje::Prazno)
	polja[x][y]=Polje::BlokiranoPrazno;
	else if(polja[x][y]==Polje::Mina)
<a name="2"></a><font color="#0000FF"><a href="match821-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

	polja[x][y]=Polje::BlokiranoMina;
}
void DeblokirajPolje(Tabla &amp;polja,int x,int y){
	if(x&gt;=polja.size() || y&gt;=polja.size()){
		string s1(to_string(x));
		string s2(to_string(y));
		throw domain_error("Polje ("+s1+","+s2+") ne postoji");
	}
	if(polja[x][y]==Polje::BlokiranoPosjeceno)
	polja[x][y]=Polje::Posjeceno;
</font>	else if(polja[x][y]==Polje::BlokiranoPrazno)
	polja[x][y]=Polje::Prazno;
<a name="0"></a><font color="#FF0000"><a href="match821-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_49.gif"/></a>

	else if(polja[x][y]==Polje::BlokiranoMina)
	polja[x][y]=Polje::Mina;
}
enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};
Status StanjeNaPolju(Tabla polja){
	Status STANJE(Status::KrajPobjeda);
	for(int i=0;i&lt;polja.size();i++)
	for(int j=0;j&lt;polja[i].size();j++)
	if(polja[i][j]==Polje::BlokiranoPrazno || polja[i][j]==Polje::Prazno){
		STANJE=Status::NijeKraj;
		return STANJE;
	}
	return STANJE;
}
enum class Smjerovi {GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	polja[x][y]=Polje::Posjeceno;
	Status STANJE(StanjeNaPolju(polja));
	if(smjer==Smjerovi::Gore) x--;
	else if(smjer==Smjerovi::Dolje) x++;
	else if(smjer==Smjerovi::Lijevo) y--;
	else if(smjer==Smjerovi::Desno) y++;
	else if(smjer==Smjerovi::GoreLijevo){ x--; y--; }
	else if(smjer==Smjerovi::DoljeLijevo){ x++; y--; }
	else if(smjer==Smjerovi::GoreDesno){ x--; y++; }
	else if(smjer==Smjerovi::DoljeDesno){ x++; y++; }
	if(x&lt;0 || y&lt;0) throw out_of_range("Izlazak van igrace table");
	if(x&gt;=polja.size() || y&gt;=polja.size()) throw out_of_range("Izlazak van igrace table");
	if(polja[x][y]==Polje::BlokiranoPosjeceno || polja[x][y]==Polje::BlokiranoMina || polja[x][y]==Polje::BlokiranoPrazno) throw logic_error("Blokirano polje");
	if(polja[x][y]==Polje::Mina) STANJE=Status::KrajPoraz;
	return STANJE;
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	polja[x][y]=Polje::Posjeceno;
	Status STANJE(StanjeNaPolju(polja));
	x=novi_x;
	y=novi_y;
	if(x&lt;0 || y&lt;0) throw out_of_range("Izlazak van igrace table");
	if(x&gt;=polja.size() || y&gt;=polja.size()) throw out_of_range("Izlazak van igrace table");
	if(polja[x][y]==Polje::BlokiranoPosjeceno || polja[x][y]==Polje::BlokiranoMina || polja[x][y]==Polje::BlokiranoPrazno) throw logic_error("Blokirano polje");
	if(polja[x][y]==Polje::Mina) STANJE=Status::KrajPoraz;
	return STANJE;
</font>}
int main ()
{
	return 0;
}</pre>
</body>
</html>
