<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student5185.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student8089.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;complex&gt;

//Enumeracije
enum class Polje {Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};

enum class Smjerovi {GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};

enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};

enum class KodoviGresaka{PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};

<a name="0"></a><font color="#FF0000"><a href="match68-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_83.gif"/></a>

enum class Komande{PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

//Funkcije
bool TestSlobode  (Tabla polja){
	for (int i = 0; i &lt; polja.size(); i++) { 
		for (int j = 0; j &lt; polja[i].size(); j++) {
			if (static_cast&lt;int&gt;(polja[i][j]) == 0 || static_cast&lt;int&gt;(polja[i][j]) == 3 || static_cast&lt;int&gt;(polja[i][j]) == 4) return false;
		}
	}
	return true;
}

Tabla KreirajIgru (int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	Tabla trenutnaTabla;
	
	trenutnaTabla.resize(n); //Namjesta velicinu redova
	for (int i = 0; i &lt; n; i++) {
		trenutnaTabla[i].resize(n);
	} //Namjesta velicinu kolona
	
	for (int i = 0; i &lt; n; i++) { 
		for (int j = 0; j &lt; n; j++) {
			trenutnaTabla[i][j] = Polje(0);
		}
	}//inicijalizira tablu sa inicijaliziranim vrijednostima 0
	for (int i = 0; i &lt; mine.size(); i++) {
		if (mine[i].size() != 2) {
			throw std::domain_error ("Ilegalan format zadavanja mina");
		}
		else{
			int HorPozicijaMine (mine[i][0]), VerPozicijaMine(mine[i][1]);
			
			if (HorPozicijaMine &gt;= n || VerPozicijaMine &gt;= n) {
				throw std::domain_error ("Ilegalne pozicije mina");
			}
			else{
				trenutnaTabla[HorPozicijaMine][VerPozicijaMine] = Polje(2);
			}
		} 
	} //Postavlja mine

	return trenutnaTabla;
}

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu (const Tabla &amp;polja, int x, int y){

	if (!((x &gt;= 0 &amp;&amp; x &lt; polja.size()) &amp;&amp; (y &gt;= 0 &amp;&amp; y &lt; polja[0].size()))) throw std::domain_error ("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji"); // Baca izuzetak
	
	
	std::vector&lt;std::vector&lt;int&gt;&gt; Okolina(3, std::vector&lt;int&gt;(3,0));
	int o(0);
	for (int i = x-1; i &lt;= x+1; i++) {
		int p(0);
		for (int j = y-1; j &lt;= y+1; j++) { //Ove dvije petlje dobiju glavnu okolinu
			int brojac(0);
			
			for (int k = i-1; k &lt;= i+1; k++) for (int l = j-1; l &lt;= j+1; l++) if (k &gt;= 0 &amp;&amp; k &lt; polja.size() &amp;&amp; l &gt;= 0 &amp;&amp; l &lt; polja[0].size() &amp;&amp; (int)polja[k][l] == 2 &amp;&amp; !(k == i &amp;&amp; l == j)) brojac++; //PEtlje za podokoline
			
			Okolina[o][p++]=brojac;
		}
		o++;
	}

	return Okolina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y){
	if (x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja[0].size()) {
		throw std::domain_error ("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
	}
	
	if (static_cast&lt;int&gt;(polja[x][y]) &gt;= 3 &amp;&amp; static_cast&lt;int&gt;(polja[x][y]) &lt;= 5) return;
	
	else if (static_cast&lt;int&gt;(polja[x][y]) &gt;= 0 &amp;&amp; static_cast&lt;int&gt;(polja[x][y]) &lt;= 2) {
		polja[x][y] = Polje(static_cast&lt;int&gt;(static_cast&lt;int&gt;(polja[x][y]) + 3));
	}
	
	
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	if (x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja[0].size()) {
		throw std::domain_error ("Polje (" + std::to_string(x) + "," + std::to_string(y) + ") ne postoji");
	}
	
	if (static_cast&lt;int&gt;(polja[x][y]) &gt;= 0 &amp;&amp; static_cast&lt;int&gt;(polja[x][y]) &lt;= 2) return;
	
	else if (static_cast&lt;int&gt;(polja[x][y]) &gt;= 3 &amp;&amp; static_cast&lt;int&gt;(polja[x][y]) &lt;= 5) {
		polja[x][y] = Polje(static_cast&lt;int&gt;(static_cast&lt;int&gt;(polja[x][y]) - 3));
	}
	
	
}


Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	static int pocetniX(0), pocetniY(0); int o(0), p(0);
	
	if (smjer == Smjerovi::Gore){ o = -1; p = 0;}
	else if (smjer == Smjerovi::GoreLijevo){ o = -1; p = -1;}
	else if (smjer == Smjerovi::GoreDesno){ o = -1; p = 1;}
	else if (smjer == Smjerovi::Desno){ o = 0; p = 1;}
	else if (smjer == Smjerovi::DoljeDesno){ o = 1; p = 1;}
	else if (smjer == Smjerovi::Dolje){ o = 1; p = 0;}
	else if (smjer == Smjerovi::DoljeLijevo){ o = 1; p = -1;}
	else if (smjer == Smjerovi::Lijevo){ o = 0; p = -1;}
	
	 //Ako je izasao iz tablice
	if ((pocetniX + o &lt; 0 || pocetniX + o &gt;= polja.size()) || (pocetniY + p &lt; 0) || (pocetniY+p) &gt;= polja[0].size()) throw std::out_of_range ("Izlazak van igrace table");
		
	//Ako blokriano polje
	else if(static_cast&lt;int&gt;(polja[pocetniX+o][pocetniY+p])&gt;= 3 &amp;&amp; static_cast&lt;int&gt;(polja[pocetniX+o][pocetniY+p])&lt;= 5)	throw std::logic_error ("Blokirano polje");
		
	//ako stane na minu
	else if(polja[pocetniX+o][pocetniY+p] == Polje::Mina){
		for (int i = 0; i &lt; polja.size(); i++) { 
			for (int j = 0; j &lt; polja[0].size(); j++) {
				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	//dodati test slobode
	else{
		polja[pocetniX][pocetniY]=Polje(1);
		
		pocetniX = pocetniX+o;
		pocetniY = pocetniY+p;
		x = pocetniX;
		y = pocetniY;
	}
	
	Tabla kopija = polja;
	kopija [pocetniX][pocetniY] = Polje(1);
	if (TestSlobode(kopija)){
		return Status::KrajPobjeda;
	}
		
	
	
	
	return Status::NijeKraj;
} //Works

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	static int prosliX(novi_x),  prosliY(novi_y);
	
	if (x &lt; 0 || x &gt;= polja.size() || y&lt; 0 || y &gt;= polja[0].size()) {
		throw std::out_of_range ("Izlazak van igrace table");
	}
	
	else if(static_cast&lt;int&gt;(polja[x][y])&gt;= 3 &amp;&amp; static_cast&lt;int&gt;(polja[x][y])&lt;= 5){
			throw std::logic_error ("Blokirano polje");
	}
	else if (static_cast&lt;int&gt;(polja[x][y])== 2){
		//Sve vratiti na prazno
		for (int i = 0; i &lt; polja.size(); i++) { 
			for (int j = 0; j &lt; polja[0].size(); j++) {
				polja[i][j] = Polje::Prazno;
			}
		}
		return Status::KrajPoraz;
	}
	
	else {
		polja[prosliX][prosliY]=Polje(1);
	
		prosliX = x;
		prosliY = y;
		x = novi_x;
		y = novi_y;
	}
	
	Tabla kopija = polja;
	kopija [x][y] = Polje(1);
	if (TestSlobode(kopija)){
		return Status::KrajPobjeda;
	}
	
	return Status::NijeKraj;
} //Works like a charm :D

void PrijaviGresku (KodoviGresaka x){
	if (static_cast&lt;int&gt; (x) == 0) std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl;
	else if (static_cast&lt;int&gt; (x) == 1) std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
	else if (static_cast&lt;int&gt; (x) == 3) std::cout &lt;&lt; "Parametar komande nije ispravan!"&lt;&lt; std::endl;
	else if (static_cast&lt;int&gt; (x) == 2) std::cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt; std::endl;
} //Works

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	std::string input;

	getline(std::cin, input);
	//var za pelju
	int i(0), o(0);
	bool bioRazmak(true);
	std::vector&lt;int&gt; brojaci(2,0);
	
	while (i &lt; input.length()) {
		if (input[i] == ' ' || input[i] == '\n' || input[i] == '\t') {
			input = input.substr(0, i) + input.substr(i+1, (input.length()-i));
			if (!bioRazmak) o++;
			
			bioRazmak = true;
			continue;
		}
		else if (input[i] &gt;= '0' &amp;&amp; input[i] &lt;= '9' &amp;&amp; o &lt; 2 &amp;&amp; !bioRazmak) brojaci[o]++;
		
		else if (input[i] &gt;= '0' &amp;&amp; input[i] &lt;= '9' &amp;&amp; o &lt; 2 &amp;&amp; bioRazmak) {
			bioRazmak = false;
			brojaci[o]++;
		}
		
		i++;
	} //RADI
	
	if (input.substr(0,2) == "PO") {
		if (input.length() == 2){
			komanda = Komande::PrikaziOkolinu;
			return true;
			//Komanda je uredu
		}
		else if (input.length()&gt;2) {
			//Suvisan parametar
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
	} // RADI
	
	else if (input.substr(0,1) == "Z") {
		if (input.length() == 1){
			komanda = Komande::ZavrsiIgru;
			return true;
			//Komanda je uredu
		}
		else if (input.length()&gt;1) {
			//Suvisan parametar
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
	} //RADI
	
	else if (input.substr(0,1) == "K") {
		if (input.length() == 1){
			komanda = Komande::KreirajIgru;
			return true;
			//Komanda je uredu
		}
		else if (input.length()&gt;1) {
			//Suvisan parametar
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
	} //RADI
	
	else if (input.substr(0,2) == "P1"){
		if (input.length() &lt; 3){
			greska = KodoviGresaka::NedostajeParametar;
			return false;
		}
		else if (input.length() == 3){
			if (input.substr(2,3) == "G") {
				smjer = Smjerovi::Gore;
				komanda = Komande::PomjeriJednoMjesto;
				return true;
			}
			else if (input.substr(2,3) == "L") {
				smjer = Smjerovi::Lijevo;
				komanda = Komande::PomjeriJednoMjesto;
				return true;
			}
			else if (input.substr(2,3) == "D") {
				smjer = Smjerovi::Desno;
				komanda = Komande::PomjeriJednoMjesto;
				return true;
			}
			else{
				greska = KodoviGresaka::NeispravanParametar;
				return false;
			}
		}
		else if (input.length() == 4){
			if (input.substr(2,4) == "GL") {
				komanda = Komande::PomjeriJednoMjesto;
				smjer = Smjerovi::GoreLijevo;
				return true;
			}
			else if (input.substr(2,4) == "GD") {
				smjer = Smjerovi::GoreDesno;
				komanda = Komande::PomjeriJednoMjesto;
				return true;
			}
			else if (input.substr(2,4) == "Do") {
				smjer = Smjerovi::Dolje;
				komanda = Komande::PomjeriJednoMjesto;
				return true;
			}
			else{
				greska = KodoviGresaka::NeispravanParametar;
				return false;
			}
		}
		else if (input.length() == 5){
			if (input.substr(2,5) == "DoL") {
				smjer = Smjerovi::DoljeLijevo;
				komanda = Komande::PomjeriJednoMjesto;
				return true;
			}
			else if (input.substr(2,5) == "DoD") {
				smjer = Smjerovi::DoljeDesno;
				komanda = Komande::PomjeriJednoMjesto;
				return true;
			}
			else{
				greska = KodoviGresaka::NeispravanParametar;
				return false;
			}
		}
		else if (input.length() &gt; 5){
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
	} //Radi
	
	else if (input.substr(0,2) == "P&gt;"){
		if (input.length() == 2) {
			greska = KodoviGresaka::NedostajeParametar;
			return false;
		}
		else if (input.length() == (2+brojaci[0]+brojaci[1])){
			x = std::stoi(input.substr(2, brojaci[0]));
			y = std::stoi(input.substr(2+brojaci[0], brojaci[1]));
			komanda = Komande::PomjeriDalje;
			return true;
		}
		else{
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
	} //RADI
	
	else if (input.substr(0,1) == "B" || input.substr(0,1) == "D"){
		if (input.length() == 1) {
			greska = KodoviGresaka::NedostajeParametar;
			return false;
		}
		else if (input.length() == (1+brojaci[0]+brojaci[1])){
	
			x = std::stoi(input.substr(1, brojaci[0]));
			y = std::stoi(input.substr(1+brojaci[0], brojaci[1]));
			if (input.substr(0,1) == "B") {
				komanda = Komande::Blokiraj;
			}
			else if (input.substr(0,1) == "D"){
				komanda = Komande::Deblokiraj;
			}
			
			return true;
		}
		else{
			greska = KodoviGresaka::NeispravanParametar;
			return false;
		}
	} //RADI
	else {
		greska = KodoviGresaka::PogresnaKomanda;
		return false;
	}
	
	return true;
} //Radi

void IzvrsiKomandu (Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y=0){
	int kopijaX=x, kopijaY=y;
	
	if (komanda == Komande::PomjeriJednoMjesto || komanda == Komande::PomjeriDalje) {
		Status staJeBilo(Status::NijeKraj);
		if (komanda == Komande::PomjeriJednoMjesto) {
			staJeBilo = Idi(polja, x, y, p_smjer);
		}
		else if (komanda == Komande::PomjeriDalje) {
			staJeBilo = Idi(polja, x, y, p_x, p_y);
		} // RADI
		
		if (staJeBilo == Status::KrajPoraz) {
			std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
			throw std::runtime_error ("Igra zavrsena");
		}
		else if (staJeBilo == Status::KrajPobjeda) {
			std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
			throw std::runtime_error ("Igra zavrsena");
		}
		else if (komanda == Komande::PomjeriJednoMjesto){
			std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
		}
		else if (komanda == Komande::PomjeriDalje){
			std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; kopijaX &lt;&lt; "," &lt;&lt; kopijaY &lt;&lt; ")" &lt;&lt; std::endl;
		}
		
	} // OSTALO ZA URADITI
	
	else if (komanda == Komande::ZavrsiIgru) {
		for (int i = 0; i &lt; polja.size(); i++) { 
			for (int j = 0; j &lt; polja.size(); j++) {
				polja[i][j] = Polje(0);
			}
		}
		
		throw std::runtime_error ("Igra zavrsena");
		
	} //Radi
	
	else if (komanda == Komande::PrikaziOkolinu) {
		std::vector&lt;std::vector&lt;int&gt;&gt; Okolina = PrikaziOkolinu(polja, x, y);
		
		for (int i = 0; i &lt; 3; i++) {
			for (int j = 0; j &lt; 3; j++) {
</font><a name="1"></a><font color="#00FF00"><a href="match68-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_13.gif"/></a>

				std::cout &lt;&lt; Okolina[i][j] &lt;&lt; " ";
			}
			std::cout &lt;&lt; std::endl;
		}
		
	} //Radi
	
	else if (komanda == Komande::Deblokiraj) {
		DeblokirajPolje(polja, x, y);
	} //Radi
	
	else if (komanda == Komande::Blokiraj) {
		BlokirajPolje(polja, x, y);
	} //Radi
	
	else if (komanda == Komande::KreirajIgru) {
		int n;
		std::cout &lt;&lt; "Unesite broj polja: ";
		std::cin &gt;&gt; n;
		
		std::cin.ignore(10000, '\n');
		
		
		std::cout &lt;&lt; "Unesite pozicije mina: ";
	
	std::vector&lt;std::vector&lt;int&gt;&gt; mine;
	std::complex&lt;int&gt; z;
	int i(0);
	
	bool izasaoSaTackom(false);
	
	if((std::cin &gt;&gt; std::ws).peek()=='.') {
		izasaoSaTackom = true;
	}
	

	
	while(!izasaoSaTackom){
	
        while (std::cin &gt;&gt; z) {
            mine.resize(i+1);
            if (z.real() &lt; 0 || z.real() &gt;= n || z.imag() &lt; 0 || z.imag() &gt;= n) break;
            
            mine[i].push_back(z.real());
            mine[i].push_back(z.imag());
            i++;
            if((std::cin &gt;&gt; std::ws).peek()=='.'){ izasaoSaTackom = true;break;}
        }
        
        if (!izasaoSaTackom) {
            std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
            std::cin.clear();
            std::cin.ignore(10000, '\n');
         }
	}
		std::cin.ignore(10000, '\n');
		polja = KreirajIgru(n, mine);
	} //OVO OSTALO ZA URADITI

}


int main (){
	 int x = 0, y = 0;
    std::vector&lt;std::vector&lt;int&gt;&gt; mine = {{0,2}, {1,0}, {1,1}, {1,2}, {2,0}, {2,1}, {2,2}};
    std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla = KreirajIgru(3, mine);
   try{
     Idi(tabla, x, y, x-1, y);
   }
   catch(std::out_of_range e){
     std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
   }
   BlokirajPolje(tabla, 0, 1);
   try{
     Idi(tabla, x, y, x, y+1);
   }
   catch(std::logic_error e){
     std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
</font>   }
	/*
	Komande komanda;
	Smjerovi smjer = Smjerovi::Gore; 
	int x=1, y=0;
	KodoviGresaka greska;
	Tabla polja;
	
	int p_x=0, p_y=0;
	
	
	for(;;){
		std::cout &lt;&lt; "Unesite komandu: ";
		if (UnosKomande(komanda, smjer, x, y, greska)) {
			try{
				IzvrsiKomandu( komanda, polja, x, y, smjer, p_x, p_y);
				std::cout &lt;&lt; "Tabla izgleda ovako" &lt;&lt; std::endl;
				for (int i = 0; i &lt; 5; i++) {
					for (int j = 0; j &lt; 5; j++) {
						std::cout &lt;&lt; int(polja[i][j]) &lt;&lt; " ";
					}
					std::cout &lt;&lt; std::endl;
				}
				
			}
			catch(std::domain_error e){
				std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
			}
			catch(std::out_of_range e){
				std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
			}
			catch(std::runtime_error e){
				
				std::cout &lt;&lt; "Dovidjenja!" &lt;&lt; std::endl;
				return 0;
			}
			catch(std::logic_error e){
				std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
			}
		}
		else{
			PrijaviGresku(greska);
		}
		
	}
	*/
	return 0;
}</pre>
</body>
</html>
