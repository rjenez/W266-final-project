<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student5496.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3807.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;stdexcept&gt;

// Zamjena za bagljivu std::to_string
<a name="9"></a><font color="#FF00FF"><a href="match723-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

template &lt;typename T&gt;
  std::string to_string(T x) {
    std::ostringstream s; s &lt;&lt; x; return s.str();
  }

enum class Polje {
  Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class Smjerovi {
  GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
</font>};

enum class Status {
  NijeKraj, KrajPoraz, KrajPobjeda
};

enum class KodoviGresaka {
  PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};

enum class Komande {
  PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
  ZavrsiIgru, KreirajIgru, Debug
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

<a name="3"></a><font color="#00FFFF"><a href="match723-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
  Tabla polja(n, std::vector&lt;Polje&gt;(n, Polje::Prazno));
  for(const auto &amp;v : mine) {
    if(v.size() != 2) throw std::domain_error("Ilegalan format zadavanja mina");
    if(v[0] &lt; 0 || v[0] &gt;= n || v[1] &lt; 0 || v[1] &gt;= n)
      throw std::domain_error("Ilegalne pozicije mina");
    polja[v[0]][v[1]] = Polje::Mina;
  }
  return polja;
}

bool LegalnoPolje(const Tabla &amp;polja, int x, int y) {
  return x &gt;= 0 &amp;&amp; x &lt; polja.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; polja[x].size();
}

void ValidirajPolje(const Tabla &amp;polja, int x, int y) {
  if(!LegalnoPolje(polja, x, y))
    throw std::domain_error("Polje (" + to_string(x) + "," + to_string(y) + ") ne postoji");
</font>}

int prebroj_mine(const Tabla &amp;polja,int x,int y) {
	int broj_mina = 0;
	for (int i = -1; i &lt;= 1; i++) {
		for (int j = -1; j &lt;= 1; j++) {
			if(i+x&lt;0 || i+x&gt;=polja.size())continue;
			if(j+y&lt;0 || j+y&gt;=polja.at(0).size())continue;
			if(polja.at(i+x).at(j+y)==Polje::Mina || polja.at(i+x).at(j+y)==Polje::BlokiranoMina)  {
				broj_mina++;
			}
		}
	}
	return broj_mina;
}
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja,int x,int y) {
  ValidirajPolje(polja, x, y);
	 std::vector&lt;std::vector&lt;int&gt;&gt; izlaz;
	izlaz.resize(3);
	for (int i = 0; i &lt; 3; i++) {
		izlaz.at(i).resize(3);
	}
	for (int i = 0; i &lt; 3; i++) {
		for (int j = 0; j &lt; 3; j++) {
			//moguce da van table moraju biti sve 0
			izlaz.at(i).at(j)=prebroj_mine(polja,i-1+x,j-1+y);
			if(polja.at(i).at(j)==Polje::Mina)izlaz.at(i).at(j)-=1;
		}
	}
	return izlaz;
}

std::vector&lt;std::vector&lt;int&gt;&gt; _PrikaziOkolinu(const Tabla &amp;polja, int x, int y) {
  std::vector&lt;std::vector&lt;int&gt;&gt; m(3, std::vector&lt;int&gt;(3));

<a name="8"></a><font color="#00FFFF"><a href="match723-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

  for(int i = x - 1; i &lt;= x + 1; i++)
    for(int j = y - 1; j &lt;= y + 1; j++) {
      int brojac(0);
      for(int p = i - 1; p &lt;= i + 1; p++)
        for(int q = j - 1; q &lt;= j + 1; q++)
          if(LegalnoPolje(polja, p, q) &amp;&amp; p != i &amp;&amp; q != j &amp;&amp;
</font><a name="0"></a><font color="#FF0000"><a href="match723-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_10.gif"/></a>

            (polja[p][q] == Polje::Mina || polja[p][q] == Polje::BlokiranoMina))
              brojac++;
      m[i - x + 1][j - y + 1] = brojac;
    }
  return m;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
  ValidirajPolje(polja, x, y);
  if(polja[x][y] &lt; Polje::BlokiranoPrazno)
    polja[x][y] = Polje(int(polja[x][y]) + 3);
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
  ValidirajPolje(polja, x, y);
  if(polja[x][y] &gt;= Polje::BlokiranoPrazno)
    polja[x][y] = Polje(int(polja[x][y]) - 3);
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
  if(!LegalnoPolje(polja, novi_x, novi_y))
    throw std::out_of_range("Izlazak van igrace table");
  if(polja[novi_x][novi_y] &gt;= Polje::BlokiranoPrazno)
    throw std::logic_error("Blokirano polje");
  polja[x][y] = Polje::Posjeceno;
  x = novi_x; y = novi_y;
  if(polja[x][y] == Polje::Mina || polja[x][y] == Polje::BlokiranoMina) {
    for(int i = 0; i &lt; polja.size(); i++)
</font><a name="2"></a><font color="#0000FF"><a href="match723-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

      for(int j = 0; j &lt; polja[i].size(); j++) polja[i][j] = Polje::Prazno;
    return Status::KrajPoraz;
  }
  bool ima_prazno(false);
  for(int i = 0; i &lt; polja.size(); i++)
    for(int j = 0; j &lt; polja[i].size(); j++)
      if(!(i == x &amp;&amp; j == y) &amp;&amp; polja[i][j] == Polje::Prazno) ima_prazno = true;
  if(!ima_prazno) return Status::KrajPobjeda;
  return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
  int dx[]{-1, -1, -1, 0, 1, 1, 1, 0};
  int dy[]{-1, 0, 1, 1, 1, 0, -1, -1};
  return Idi(polja, x, y, x + dx[int(smjer)], y + dy[int(smjer)]);
}

void PrijaviGresku(KodoviGresaka greska) {
  const char *tekstovi[] = {"Nerazumljiva komanda!", "Komanda trazi parametar koji nije naveden!",
	"Zadan je suvisan parametar nakon komande!", "Parametar komande nije ispravan!"};
  std::cout &lt;&lt; tekstovi[int(greska)] &lt;&lt; std::endl;
</font>}

void PreskociRazmake() {
<a name="4"></a><font color="#FF00FF"><a href="match723-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

  while(std::cin.peek() == ' ') std::cin.get();
}

bool ProcesirajGresku(KodoviGresaka &amp;gdje, KodoviGresaka kod) {
  std::cin.clear();
  std::cin.ignore(10000, '\n');
  gdje = kod;
  return false;
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska) {
  bool ima_greska(false);
  char znak;
  std::cin &gt;&gt; znak;
  if(znak == 'P') {
    char znak2(std::cin.get());
    if(znak2 == '1') komanda = Komande::PomjeriJednoMjesto;
    else if(znak2 == '&gt;') komanda = Komande::PomjeriDalje;
    else if(znak2 == 'O') komanda = Komande::PrikaziOkolinu;
    else ima_greska = true;
  }
  else if(znak == 'B') komanda = Komande::Blokiraj;
  else if(znak == 'D') komanda = Komande::Deblokiraj;
  else if(znak == 'Z') komanda = Komande::ZavrsiIgru;
  else if(znak == 'K') komanda = Komande::KreirajIgru;
</font>  else if(znak == '?') komanda = Komande::Debug;
  else ima_greska = true;
  if(ima_greska)
    return ProcesirajGresku(greska, KodoviGresaka::PogresnaKomanda);
  if(komanda == Komande::PomjeriJednoMjesto) {
    PreskociRazmake();
<a name="7"></a><font color="#0000FF"><a href="match723-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

    if(std::cin.peek() == '\n')
      return ProcesirajGresku(greska, KodoviGresaka::NedostajeParametar);
    std::string par, legalne[]{"GL", "G", "GD", "D", "DoD", "Do", "DoL", "L"};
    std::cin &gt;&gt; par;
    int gdje_je(-1);
    for(int i = 0; i &lt; 8; i++)
      if(legalne[i] == par) gdje_je = i;
    if(gdje_je == -1)
      return ProcesirajGresku(greska, KodoviGresaka::NeispravanParametar);
    smjer = Smjerovi(gdje_je);
  }
  if(komanda == Komande::PomjeriDalje || komanda == Komande::Blokiraj ||
    komanda == Komande::Deblokiraj) {
</font>      PreskociRazmake();
<a name="11"></a><font color="#00FF00"><a href="match723-0.html#11" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

      if(std::cin.peek() == '\n')
        return ProcesirajGresku(greska, KodoviGresaka::NedostajeParametar);
      std::cin &gt;&gt; x;
      if(!std::cin)
        return ProcesirajGresku(greska, KodoviGresaka::NeispravanParametar);
</font>      PreskociRazmake();
<a name="10"></a><font color="#FF0000"><a href="match723-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

      if(std::cin.peek() == '\n')
        return ProcesirajGresku(greska, KodoviGresaka::NedostajeParametar);
      std::cin &gt;&gt; y;
      if(!std::cin || (std::cin.peek() != ' ' &amp;&amp; std::cin.peek() != '\n'))
        return ProcesirajGresku(greska, KodoviGresaka::NeispravanParametar);
</font>  }
  PreskociRazmake();
  if(std::cin.peek() != '\n')
    return ProcesirajGresku(greska, KodoviGresaka::SuvisanParametar);
  return true;
}

void ispisiTablu(std::vector&lt;std::vector&lt;Polje&gt; &gt;);
<a name="5"></a><font color="#FF0000"><a href="match723-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y,
  Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
    Status rezultat(Status::NijeKraj);
    try {
      if(komanda == Komande::PomjeriJednoMjesto) rezultat = Idi(polja, x, y, p_smjer);
      else if(komanda == Komande::PomjeriDalje) {
        rezultat = Idi(polja, x, y, p_x, p_y);
      }
      else if(komanda == Komande::Blokiraj) BlokirajPolje(polja, p_x, p_y);
      else if(komanda == Komande::Deblokiraj) DeblokirajPolje(polja, p_x, p_y);
      else if(komanda == Komande::PrikaziOkolinu) {
        std::vector&lt;std::vector&lt;int&gt;&gt; okolina(PrikaziOkolinu(polja, x, y));
        for(int i = 0; i &lt; 3; i++) {
          for(int j = 0; j &lt; 3; j++) std::cout &lt;&lt; okolina[i][j] &lt;&lt; " ";
</font>          std::cout &lt;&lt; std::endl;
        }
      }
      else if(komanda == Komande::Debug)
        for(int i = 0; i &lt; polja.size(); i++) {
<a name="1"></a><font color="#00FF00"><a href="match723-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

          for(int j = 0; j &lt; polja[i].size(); j++) std::cout &lt;&lt; int(polja[i][j]) &lt;&lt; " ";
          std::cout &lt;&lt; std::endl;
        }
      else if(komanda == Komande::KreirajIgru) {
        int n;
        std::cout &lt;&lt; "Unesite broj polja: ";
        std::cin &gt;&gt; n;
        std::vector&lt;std::vector&lt;int&gt;&gt; mine;
        std::cout &lt;&lt; "Unesite pozicije mina: ";
        for(;;) {
          char znak;
          bool ima_greska(false);
          int x, y;
          std::cin &gt;&gt; znak;
          if(znak == '.') break;
          if(znak != '(') ima_greska = true;
          if(!ima_greska) {
            std::cin &gt;&gt; x &gt;&gt; znak;
            if(!std::cin || znak != ',') ima_greska = true;
          }
          if(!ima_greska) {
            std::cin &gt;&gt; y &gt;&gt; znak;
            if(!std::cin || znak != ')') ima_greska = true;
          }
          if(ima_greska || x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n) {
            std::cin.clear();
            std::cin.ignore(10000, '\n');
            std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
          }
          else mine.push_back({x, y});
        }
        polja = KreirajIgru(n, mine);
      }
      if(komanda == Komande::PomjeriJednoMjesto || komanda == Komande::PomjeriDalje)
        std::cout &lt;&lt; "Tekuca pozicija igraca je (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
    }
    catch(std::domain_error e) {
      std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(std::out_of_range e) {
</font><a name="6"></a><font color="#00FF00"><a href="match723-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

      std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(std::logic_error e) {
      std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    if(komanda == Komande::PomjeriJednoMjesto || komanda == Komande::PomjeriDalje) {
      if(rezultat == Status::KrajPobjeda)
        std::cout &lt;&lt; "Bravo, obisli ste sva sigurna polja" &lt;&lt; std::endl;
      if(rezultat == Status::KrajPoraz)
        std::cout &lt;&lt; "Nagazili ste na minu" &lt;&lt; std::endl;
      if(rezultat != Status::NijeKraj) komanda = Komande::ZavrsiIgru;
    }
    if(komanda == Komande::ZavrsiIgru) {
      for(int i = 0; i &lt; polja.size(); i++)
        for(int j = 0; j &lt; polja[i].size(); j++) polja[i][j] = Polje::Prazno;
</font>      throw std::runtime_error("Igra zavrsena");
    }
};

void ispisiTablu(std::vector&lt;std::vector&lt;Polje&gt;&gt; polja){
   for(int i = 0; i &lt; polja.size(); i++) {
          for(int j = 0; j &lt; polja[i].size(); j++) std::cout &lt;&lt; int(polja[i][j]) &lt;&lt; " ";
          std::cout &lt;&lt; std::endl;
        }
}

//staviti test gdje se vidi da mora biti blokirano početno polje!
//kreirajIgru (4,2)- testirana: 2 za errore, 1 samo za nju, možda još neki tricky duplo zdavanje mjina ili nešto ili kad se ne zadaju kordinate redom 
//prikazi okolinu (4,2) - granicni, normalni, izuzecim izuzeci negativni
//blokiraj i deblokiraj (5,2) - izuzeci 2x, trivia, blokiranje istog polja, sve varijante
//Idi 4 parametra ( ,1)
int __main(){
 //AT (skriveni) - sve moguce greske u UnosKomande
    while (true) {
      Komande komanda;
      Smjerovi smjer;
      int x = 0, y = 0;
      KodoviGresaka greska = KodoviGresaka::SuvisanParametar;
      UnosKomande(komanda, smjer, x, y, greska);
      if(komanda == Komande::ZavrsiIgru) break;
      std::cout &lt;&lt; int(greska) &lt;&lt; " ";
    }
}


 //0 0
int main() {
//AT (bonus) - da li je zahardkodiran unos koordinata 
  std::vector&lt;std::vector&lt;int&gt;&gt; mine = {{0,1}, {0,2}, {1,0}, {1,1}, {1,2}, {2,0}, {2,1}, {2,2}};
  std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla = KreirajIgru(3, mine);
  try{
    BlokirajPolje(tabla, 13,13);
  }
   catch(std::domain_error e){
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }
  try{
    DeblokirajPolje(tabla, 133,133);
  }
   catch(std::domain_error e){
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }
}
</pre>
</body>
</html>
