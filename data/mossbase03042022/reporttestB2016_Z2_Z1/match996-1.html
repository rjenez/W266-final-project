<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6053.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4430.cpp<p></p><pre>
/*B 16/17, Zadaća 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
using namespace std; 

enum class Polje {Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina}; 
typedef vector&lt;vector&lt;Polje&gt;&gt; Tabla; 
enum class Smjerovi {GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};
enum class KodoviGresaka {PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
enum class Komande {PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};


Tabla KreirajIgru (int n, const vector&lt;vector&lt;int&gt;&gt; &amp;mine){
	Tabla tabla (n); 
	for(int i=0; i&lt;n; i++)									// formira tablu za igru nxn
		tabla[i].resize(n); 
		
	for(int i=0; i&lt;mine.size(); i++){						// provjera da li svi vektori vektora imaju dva elementa
			if(mine[i].size()!=2) throw domain_error ("Ilegalan format zadavanja mina"); 
	}
	for(int i=0; i&lt;mine.size(); i++){						// provjerava da li je neka pozicija, x ili y van formata table
		for(int j=0; j&lt;mine[i].size(); j++){
			if(mine[i][j]&gt;=n || mine[i][j]&lt;0) throw domain_error ("Ilegalne pozicije mina"); 
		}
	}
	for(int i=0; i&lt;n; i++){									//popunjava tablu na prazno
		for(int j=0; j&lt;n; j++){
			tabla[i][j]=Polje::Prazno; 
		}
	}
	for(int i=0; i&lt;n; i++){									// popunjava tablu sa minama, na pozicijama koje su date u vektoru 
		for(int j=0; j&lt;n; j++){
<a name="5"></a><font color="#FF0000"><a href="match996-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

			for(int k=0; k&lt;mine.size(); k++){
					if(i==mine[k][0] &amp;&amp; j==mine[k][1])
						tabla[i][j]=Polje::Mina; 
</font>			}
		}
	}
	return tabla; 
}
int OkolinaBroja(const Tabla polja, int x, int y){
	int brojac=0; 
	int n=polja.size(); 
	for(int i=x-1; i&lt;=x+1; i++){
		for(int j=y-1; j&lt;=y+1; j++){
			if(i&gt;=0 &amp;&amp; i&lt;n &amp;&amp; j&gt;=0 &amp;&amp; j&lt;n &amp;&amp; polja[i][j]==Polje::Mina) brojac++; 
		}
	}
	return brojac; 
}

vector&lt;vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y){
	if(x&gt;= polja.size() || y&gt;= polja.size() || y&lt;0 || x&lt;0){
	string x1=to_string(x); 
	string y1=to_string(y); 
	string greska= "Polje ("+x1+","+y1+") ne postoji";
	throw domain_error (greska); 
	}
	
	vector&lt;vector&lt;int&gt;&gt; matrica (3); 
	int n=polja.size(); 
	vector&lt;int&gt; v; 
	for(int i=0; i&lt;3; i++)									//kreira matricu 3x3 koja se vraća iz funkcije
		matrica[i].resize(3); 

	for(int i=x-1; i&lt;=x+1; i++){
		for(int j=y-1; j&lt;=y+1; j++){
			v.resize(0); 
			if(x-1&gt;=0 &amp;&amp; x+1&lt;polja.size() &amp;&amp; y-1&gt;=0 &amp;&amp; y+1&lt;polja[i].size()){
			int brojac=OkolinaBroja(polja, i, j); 
			v.push_back(brojac); 
			}
		}
<a name="2"></a><font color="#0000FF"><a href="match996-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

		matrica.push_back(v); 
	}
	
	
	return matrica; 
}
void BlokirajPolje(Tabla &amp;polja, int x, int y){
	if(x&gt;= polja.size() || y&gt;= polja.size()){
	string x1=to_string(x); 
	string y1=to_string(y); 
	string greska= "Polje ("+x1+","+y1+") ne postoji";
	throw domain_error (greska); 
	}
	if(polja[x][y]==Polje::Prazno) polja[x][y]=Polje::BlokiranoPrazno; 
</font>	else if(polja[x][y]==Polje::Mina) polja[x][y]=Polje::BlokiranoMina; 
<a name="1"></a><font color="#00FF00"><a href="match996-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

	else if(polja[x][y]==Polje::Posjeceno) polja[x][y]=Polje::BlokiranoPosjeceno; 
}
void DeblokirajPolje(Tabla &amp;polja, int x, int y){
	
	if(x&gt;= polja.size() || y&gt;= polja.size()){
	string x1=to_string(x); 
	string y1=to_string(y); 
	string greska= "Polje ("+x1+","+y1+") ne postoji";
	throw domain_error (greska); 
	}
	if(polja[x][y]==Polje::BlokiranoPrazno) polja[x][y]=Polje::Prazno; 
</font>	else if(polja[x][y]==Polje::BlokiranoMina) polja[x][y]=Polje::Mina; 
<a name="6"></a><font color="#00FF00"><a href="match996-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	else if(polja[x][y]==Polje::BlokiranoPosjeceno) polja[x][y]=Polje::Posjeceno; 
}
Status ProvjeraStatusa(Tabla polja){
	Status status=Status::KrajPobjeda; 
	for(int i=0; i&lt;polja.size(); i++){
</font><a name="4"></a><font color="#FF00FF"><a href="match996-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

		for(int j=0; j&lt;polja[i].size(); j++){
			if(polja[i][j]==Polje::Prazno || polja[i][j]==Polje::BlokiranoPrazno){
				status=Status::NijeKraj; 
				return status; 
			}
		}
	}
	return status; 
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
</font><a name="0"></a><font color="#FF0000"><a href="match996-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_14.gif"/></a>

	
	polja[x][y]=Polje::Posjeceno;
	Status status=ProvjeraStatusa(polja); 
	
	if(smjer==Smjerovi::GoreLijevo){
		x--; 
		y--; 
	}
	else if(smjer==Smjerovi::GoreDesno){
		x--; 
		y++; 
	}
	else if(smjer==Smjerovi::Gore){
		x--; 
	}
	else if(smjer==Smjerovi::Desno){
		y++; 
	}
	else if(smjer==Smjerovi::Lijevo){
		y--; 
	}
	else if(smjer==Smjerovi::DoljeDesno){
		x++;
		y++;
	}
	else if(smjer==Smjerovi::DoljeLijevo){
		x++;
		y--; 
	}
	else if(smjer==Smjerovi::Dolje){
		x++;
	}
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size()) throw out_of_range ("Izlazak van igrace table"); 
	if(polja[x][y]==Polje::BlokiranoPrazno || polja[x][y]==Polje::BlokiranoMina || polja[x][y]==Polje::BlokiranoPosjeceno) throw logic_error ("Blokirano polje"); 
	if(polja[x][y]==Polje::Mina) status=Status::KrajPoraz;
	
	return status; 
}
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	polja[x][y]=Polje::Posjeceno; 
	Status status=ProvjeraStatusa(polja); 
	x=novi_x; 
	y=novi_y; 
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size()) throw out_of_range ("Izlazak van igrace table"); 
	if(polja[x][y]==Polje::BlokiranoPrazno || polja[x][y]==Polje::BlokiranoMina || polja[x][y]==Polje::BlokiranoPosjeceno) throw logic_error ("Blokirano polje"); 
</font>	if(polja[x][y]==Polje::Mina) status=Status::KrajPoraz;
	
<a name="3"></a><font color="#00FFFF"><a href="match996-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

	return status;
}
void PrijaviGresku(KodoviGresaka greska){
	if(greska==KodoviGresaka::PogresnaKomanda) cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; endl; 
	else if(greska==KodoviGresaka::NedostajeParametar) cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; endl; 
	else if(greska==KodoviGresaka::NeispravanParametar) cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; endl; 
	else if(greska==KodoviGresaka::SuvisanParametar) cout &lt;&lt; "Zadan je suvisan parametar nakon komande!" &lt;&lt; endl; 
</font>}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	string s; 
	s.resize(10); 
	getline(cin,s); 
	
	for(int i=0; i&lt;10; i++){
		while(s[i]==' ') i++; 											// razmaci na početku komande
		
		if(s[i]=='K'){													// da li je komanda K 
			i++; 
			while(s[i]==' ') i++; 										
			if(s[i]=='\n'){
				komanda=Komande::KreirajIgru; 							// ako iza K nema ništa osim razmaka i entera, smjesti u komanda i izaći iz funkcije
				return true; 
			}
			else PrijaviGresku(KodoviGresaka::SuvisanParametar); 		// ako iza K ima bilo šta osim razmaka i entera prijavi gresku 
		}
		else if(s[i]=='Z'){												// da li je komanda Z 
			i++; 
			while(s[i]==' ') i++; 							
			if(s[i]=='\n'){
				komanda=Komande::ZavrsiIgru; 							
				return true; 
			}
			else PrijaviGresku(KodoviGresaka::SuvisanParametar); 		
		}
		else if(s[i]=='B'){												// da li je komanda B
			i++; 
			while(s[i]==' ') i++; 
			if(s[i]=='\n'){
				komanda=Komande::Blokiraj; 
				return true; 
			}
			else PrijaviGresku(KodoviGresaka::SuvisanParametar); 
		}
		else if(s[i]=='D'){
			i++; 
			while(s[i]==' ') i++; 
			if(s[i]=='\n'){
				komanda=Komande::Deblokiraj; 
			}
			else PrijaviGresku(KodoviGresaka::SuvisanParametar); 
		}
		else if(s[i]=='P' &amp;&amp; s[i+1]=='O'){	
			i=i+2; 
			 while(s[i]==' ') i++; 
			 if(s[i]=='\n'){
			 	komanda=Komande::PrikaziOkolinu; 
			 	return true; 
			 }
			 else PrijaviGresku(KodoviGresaka::SuvisanParametar);
			}
		else if(s[i]=='P' &amp;&amp; s[i+1]=='1'){
			i=i+2; 
			while(s[i]==' ') i++; 
			if(s[i]=='\n'){
				komanda=Komande::PomjeriJednoMjesto; 
				return true; 
			}
		}
		else if(s[i]=='P' &amp;&amp; s[i+1]=='&gt;'){
			
		}
		else PrijaviGresku(KodoviGresaka::PogresnaKomanda);
		
	}
	
	
	
}
void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x=0, int p_y=0){
	if(komanda==Komande::KreirajIgru){
		
	}
	else if(komanda==Komande::ZavrsiIgru){
		
	}
	else if(komanda==Komande::Blokiraj){
		BlokirajPolje(polja, x, y);
	}
	else if(komanda==Komande::Deblokiraj){
		DeblokirajPolje(polja, x, y); 
	}
	else if(komanda==Komande::PrikaziOkolinu){
		
	}
	else if(komanda==Komande::PomjeriJednoMjesto){
		
	}
	else if(komanda==Komande::PomjeriDalje){
		
	}
}

int main ()
{
	try{
	Tabla tabla=KreirajIgru(5, {{0,1}, {0,4}, {1,3}, {1,4}, {2,0}, {2,1}, {2,3}});
	vector&lt;vector&lt;int&gt;&gt; matrica; 
	matrica=PrikaziOkolinu(tabla, 1,1); 
	for(int i=0; i&lt;3; i++){
		for(int j=0; j&lt;3; j++){
			cout &lt;&lt; matrica[i][j] &lt;&lt; " "; 
		}
		cout &lt;&lt; endl; 
	}
	}
	catch(domain_error poruka){
		cout &lt;&lt; poruka.what(); 
	}
	
	
	
	
	return 0;
}</pre>
</body>
</html>
