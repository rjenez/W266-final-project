<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4863.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4863.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;

enum class Polje {
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};
enum class Smjerovi {
 GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};
enum class Status {
 NijeKraj, KrajPoraz, KrajPobjeda
};
enum class KodoviGresaka {
 PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar
};
enum class Komande {
<a name="1"></a><font color="#00FF00"><a href="match46-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_18.gif"/></a>

 PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu,
 ZavrsiIgru, KreirajIgru
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;

bool PostojiPolje(const Tabla &amp;polja, int x, int y) {
	std::string izuzetak;
	for(int i=0; i&lt;polja.size(); i++)
		if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja[i].size()) {
			return false;
		}
	return true;
}

int Prebroji(const Tabla &amp;polja, int tx, int ty) {
	int brojac(0);
	for(int i=tx-1; i&lt;tx+2; i++)
		for(int j=ty-1; j&lt;ty+2; j++)
			if(i&gt;=0 &amp;&amp; j&gt;=0 &amp;&amp;  i&lt;polja.size() &amp;&amp; j&lt;polja.size() &amp;&amp; (i != tx || j != ty) &amp;&amp;  (polja[i][j] == Polje::Mina || polja[i][j] == Polje::BlokiranoMina))
				brojac++;
	return brojac;
}

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	for(int i=0; i&lt;mine.size(); i++)
		if(mine[i].size() != 2)
			throw std::domain_error("Ilegalan format zadavanja mina");
	for(int i=0; i&lt;mine.size(); i++)
		for(int j=0; j&lt;2; j++)
			if(mine[i][j] &lt;0 || mine[i][j] &gt;= n)
				throw std::domain_error("Ilegalne pozicije mina");
	Tabla blok(n,std::vector&lt;Polje&gt;(n, Polje::Prazno));
	for(int i=0; i&lt;mine.size(); i++) 
		blok[mine[i][0]] [mine[i][1]] = Polje::Mina;
	return blok;
}

Matrica PrikaziOkolinu (const Tabla &amp;polja,int x, int y) {
	if(polja.size() == 0 || !PostojiPolje(polja, x, y)) {
		std::string izuzetak;
		izuzetak = "Polje (";
		izuzetak+=std::to_string(x);
		izuzetak+=",";
		izuzetak+=std::to_string(y);
		izuzetak+=") ne postoji";
		throw std::domain_error(izuzetak);
	}
	Matrica okolina;
	std::vector&lt;int&gt; red1;
	red1.push_back(Prebroji(polja, x-1, y-1));
	red1.push_back(Prebroji(polja, x-1, y));
	red1.push_back(Prebroji(polja, x-1, y+1));
	okolina.push_back(red1);
	
	std::vector&lt;int&gt; red2;
	red2.push_back(Prebroji(polja, x, y-1));
	red2.push_back(Prebroji(polja, x, y));
	red2.push_back(Prebroji(polja, x, y+1));
	okolina.push_back(red2);
	
	std::vector&lt;int&gt; red3;
	red3.push_back(Prebroji(polja, x+1, y-1));
	red3.push_back(Prebroji(polja, x+1, y));
	red3.push_back(Prebroji(polja, x+1, y+1));
	okolina.push_back(red3);
	return okolina;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y) {
	if(polja.size() == 0 || !PostojiPolje(polja, x, y)) {
		std::string izuzetak;
		izuzetak = "Polje (";
		izuzetak+=std::to_string(x);
		izuzetak+=",";
		izuzetak+=std::to_string(y);
		izuzetak+=") ne postoji";
		throw std::domain_error(izuzetak);
	}
	if(polja[x][y] == Polje::Prazno) polja[x][y] = Polje::BlokiranoPrazno;
</font>	if(polja[x][y] == Polje::Posjeceno) polja[x][y] = Polje::BlokiranoPosjeceno;
<a name="4"></a><font color="#FF00FF"><a href="match46-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

	if(polja[x][y] == Polje::Mina) polja[x][y] = Polje::BlokiranoMina;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y) {
	if(polja.size() == 0 || !PostojiPolje(polja, x, y)) {
		std::string izuzetak;
		izuzetak = "Polje (";
		izuzetak+=std::to_string(x);
		izuzetak+=",";
		izuzetak+=std::to_string(y);
		izuzetak+=") ne postoji";
		throw std::domain_error(izuzetak);
	}
	if(polja[x][y] == Polje::BlokiranoPrazno) polja[x][y] = Polje::Prazno;
</font><a name="2"></a><font color="#0000FF"><a href="match46-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

	if(polja[x][y] == Polje::BlokiranoPosjeceno) polja[x][y] = Polje::Posjeceno;
	if(polja[x][y] == Polje::BlokiranoMina) polja[x][y] = Polje::Mina;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer) {
	int tx(x), ty(y);
	if(smjer == Smjerovi::GoreLijevo) {tx--; ty--;}
	if(smjer == Smjerovi::Gore) {tx--;}
	if(smjer == Smjerovi::GoreDesno) {tx--; ty++;}
	if(smjer == Smjerovi::Desno) {ty++;}
	if(smjer == Smjerovi::DoljeDesno) {tx++; ty++;}
	if(smjer == Smjerovi::Dolje) {tx++;}
	if(smjer == Smjerovi::DoljeLijevo) {tx++; ty++;}
	if(smjer == Smjerovi::Lijevo) {ty--;}
	
	if(polja.size() == 0 || !PostojiPolje(polja, tx, ty))
		throw std::out_of_range("Izlazak van igrace table");
	if(polja[tx][ty] == Polje::BlokiranoMina || polja[tx][ty] == Polje::BlokiranoPrazno || polja[tx][ty] == Polje::BlokiranoPosjeceno)
</font>		throw std::logic_error("Blokirano polje");
<a name="5"></a><font color="#FF0000"><a href="match46-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

	polja[x][y] = Polje::Posjeceno;
	x = tx;
	y = ty;
	if(polja[x][y] == Polje::Mina) {
		for(int i=0; i&lt;polja.size(); i++) 
</font><a name="6"></a><font color="#00FF00"><a href="match46-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

			for(int j=0; j&lt;polja[i].size(); j++)
				polja[i][j] = Polje::Prazno;
		return Status::KrajPoraz;
	}
	bool kraj(true);
	for(int i=0; i&lt;polja.size(); i++)
</font><a name="3"></a><font color="#00FFFF"><a href="match46-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

		for(int j=0; j&lt;polja[i].size(); j++)
			if(polja[i][j] == Polje::Prazno || polja[i][j] == Polje::BlokiranoPrazno) {
				kraj = false;
				i=polja.size();
				break;
			}
	if(kraj) return Status::KrajPobjeda;
	return Status::NijeKraj;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y) {
	if(polja.size() == 0 || !PostojiPolje(polja, novi_x, novi_y))
		throw std::out_of_range("Izlazak van igrace table");
	if(polja[novi_x][novi_y] == Polje::BlokiranoMina || polja[novi_x][novi_y] == Polje::BlokiranoPrazno || polja[novi_x][novi_y] == Polje::BlokiranoPosjeceno)
</font><a name="0"></a><font color="#FF0000"><a href="match46-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_62.gif"/></a>

		throw std::logic_error("Blokirano polje");
	if(polja[novi_x][novi_y] == Polje::Mina) {
		for(int i=0; i&lt;polja.size(); i++) 
			for(int j=0; j&lt;polja[i].size(); j++)
				polja[i][j] = Polje::Prazno;
		return Status::KrajPoraz;
	}
	x = novi_x;
	y = novi_y;
	polja[x][y] = Polje::Posjeceno;
	
	bool kraj(true);
	for(int i=0; i&lt;polja.size(); i++)
		for(int j=0; j&lt;polja[i].size(); j++)
			if(polja[i][j] == Polje::Prazno || polja[i][j] == Polje::BlokiranoPrazno) {
				kraj = false;
				i=polja.size();
				break;
			}
	if(kraj) return Status::KrajPobjeda;
	return Status::NijeKraj;
}

void PrijaviGresku(KodoviGresaka greska) {
	if(greska == KodoviGresaka::PogresnaKomanda) std::cout&lt;&lt;"Nerazumljiva komanda!\n";
	if(greska == KodoviGresaka::NedostajeParametar) std::cout&lt;&lt;"Komanda trazi parametar koji nije naveden!\n";
	if(greska == KodoviGresaka::NeispravanParametar) std::cout&lt;&lt;"Parametar komande nije ispravan!\n";
	if(greska == KodoviGresaka::SuvisanParametar) std::cout&lt;&lt;"Zadan je suvisan parametar nakon komande!\n";
}

bool Cifra(char c) {
	return(c&gt;='0' &amp;&amp; c&lt;='9');
}

bool DvaCijelaBroja(int i, std::string unos, int &amp;a, int &amp;b, KodoviGresaka &amp;kod_greske) {
	while(i&lt;unos.length() &amp;&amp; unos[i] == ' ')
				i++;
	if(i&gt;= unos.length()) {
		kod_greske = KodoviGresaka::NedostajeParametar;
		return false;
	}
	if(Cifra(unos[i])) {
		int j(i+1);
		while(j &lt; unos.length() &amp;&amp; Cifra(unos[j]))
			j++;
		int tmp1 = stoi(unos.substr(i, j-i));
		i=j+1;
		if(!(Cifra(unos[i]))) {
			kod_greske = KodoviGresaka::NeispravanParametar;
				return false;
			}
		int k(i+1);
		while(k &lt; unos.length() &amp;&amp; Cifra(unos[k]))
			k++;
		int tmp2 = stoi(unos.substr(i, k-i));
		i=k;
		while(i&lt;unos.length()) {
			if(unos[i] != ' ') {
				kod_greske = KodoviGresaka::SuvisanParametar;
					return false;
			}
			i++;
		}
		a = tmp1;
		b = tmp2;
		return true;
	}
	return false;
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;kod_greske) {
	std::string unos;
	std::getline(std::cin, unos);
	for(int i=0; i&lt;unos.length(); i++) {
		while(i&lt;unos.length() &amp;&amp; unos[i] == ' ')
			i++;
		if(unos.substr(i,2) == "P1") {
			i+=2;
			while(i&lt;unos.length() &amp;&amp; unos[i] == ' ')
				i++;
			if(i&gt;=unos.length()) {
				kod_greske = KodoviGresaka::NedostajeParametar;
				return false;
			}
			if(unos.substr(i,3) == "DoD" || unos.substr(i,3) == "DoL") {
				int j(i+3);
				while(j&lt;unos.length()) {
					if(unos[j] != ' ') {
						kod_greske = KodoviGresaka::SuvisanParametar;
						i=unos.length();
						break;	
					}
					j++;
				}
				if(unos.substr(i,3) == "DoD") smjer = Smjerovi::DoljeDesno;
				if(unos.substr(i,3) == "DoL") smjer = Smjerovi::DoljeLijevo;
				komanda = Komande::PomjeriJednoMjesto;
				return true;
			}
			else if(unos.substr(i,2) == "GL" || unos.substr(i,2) == "GD" || unos.substr(i,2) == "Do") {
				int j(i+2);
				while(j&lt;unos.length()) {
					if(unos[j] != ' ') {
						kod_greske = KodoviGresaka::SuvisanParametar;
						i=unos.length();
						break;	
					}
					j++;
				}
				if(unos.substr(i,2) == "GL") smjer = Smjerovi::GoreLijevo;
			    if(unos.substr(i,2) == "GD") smjer = Smjerovi::GoreDesno;
			    if(unos.substr(i,2) == "Do") smjer = Smjerovi::Dolje;
			    komanda = Komande::PomjeriJednoMjesto;
			    return true;
			}
			else if(unos[i] == 'G' || unos[i] == 'D' || unos[i] == 'L') {
				int j(i+1);
				while(j&lt;unos.length()) {
					if(unos[j] != ' ') {
						kod_greske = KodoviGresaka::SuvisanParametar;
						return false;
					}
					j++;
				}
				if(unos[i] == 'G') smjer = Smjerovi::Gore;
				if(unos[i] == 'D') smjer = Smjerovi::Desno;
				if(unos[i] == 'L') smjer = Smjerovi::Lijevo;
				komanda = Komande::PomjeriJednoMjesto;
				return true;
			}
			else {
				kod_greske = KodoviGresaka::NeispravanParametar;
				return false;
			}
		}
		else if (unos.substr(i,2) == "P&gt;") {
			i+=2;
			while(i&lt;unos.length() &amp;&amp; unos[i] == ' ')
				i++;
			if(i&gt;=unos.length()) {
				kod_greske = KodoviGresaka::NedostajeParametar;
				return false;
			}
			if(Cifra(unos[i])) {
				int j(i+1);
				while(j &lt; unos.length() &amp;&amp; Cifra(unos[j]))
					j++;
				int tmp1 = stoi(unos.substr(i, j-i));
				i=j+1;
				if(!(Cifra(unos[i]))) {
					kod_greske = KodoviGresaka::NeispravanParametar;
					return false;
				}
				int k(i+1);
				while(k &lt; unos.length() &amp;&amp; Cifra(unos[k]))
					k++;
				int tmp2 = stoi(unos.substr(i, k-i));
				i=k;
				while(i&lt;unos.length()) {
					if(unos[i] != ' ') {
						kod_greske = KodoviGresaka::SuvisanParametar;
						return false;
					}
					i++;
				}
				komanda = Komande::PomjeriDalje;
				x = tmp1;
				y = tmp2;
				return true;
			}
			else {
				kod_greske = KodoviGresaka::NeispravanParametar;
				return false;
			}
			break;
		}
		else if(unos[i] == 'B') {
			i++;
			while(i&lt;unos.length() &amp;&amp; unos[i] == ' ')
				i++;
			if(i &gt;= unos.length()) {
				kod_greske = KodoviGresaka::NedostajeParametar;
				return false;
			}
			if(Cifra(unos[i])) {
				int j(i+1);
				while(j &lt; unos.length() &amp;&amp; Cifra(unos[j]))
					j++;
				int tmp1 = stoi(unos.substr(i, j-i));
				i=j+1;
				if(!(Cifra(unos[i]))) {
					kod_greske = KodoviGresaka::NeispravanParametar;
					return false;
				}
				int k(i+1);
				while(k &lt; unos.length() &amp;&amp; Cifra(unos[k]))
					k++;
				int tmp2 = stoi(unos.substr(i, k-i));
				i=k;
				while(i&lt;unos.length()) {
					if(unos[i] != ' ') {
						kod_greske = KodoviGresaka::SuvisanParametar;
						return false;
					}
					i++;
				}
				x = tmp1;
				y = tmp2;
				komanda = Komande::Blokiraj;
				return true;
			}
			break;
		}
		else if(unos[i] == 'D') {
			i++;
			int a, b;
			bool UspjesnoOdradjeno(DvaCijelaBroja(i, unos, a, b, kod_greske));
			if(UspjesnoOdradjeno) {
				x = a;
				y = b;
				komanda = Komande::Deblokiraj;
				return true;
			}
			return false;
			break;
		}
		else if(unos.substr(i,2) == "PO") {
			i+=2;
			while(i&lt;unos.length()) {
				if(unos[i] != ' ') {
					kod_greske = KodoviGresaka::SuvisanParametar;
					return false;
				}
				i++;
			}
			komanda = Komande::PrikaziOkolinu;
			return true;
		}
		else if(unos[i] == 'Z') {
			i++;
			while(i&lt;unos.length()) {
				if(unos[i] != ' ') {
					kod_greske = KodoviGresaka::SuvisanParametar;
					return false;
				}
				i++;
			}
			komanda = Komande::ZavrsiIgru;
			return true;
		}
		else if(unos[i] == 'K') {
			i++;
			while(i&lt;unos.length()) {
				if(unos[i] != ' ') {
					kod_greske = KodoviGresaka::SuvisanParametar;
					return false;
				}
				i++;
			}
			komanda = Komande::KreirajIgru;
			return true;
		}
	}
	kod_greske = KodoviGresaka::PogresnaKomanda;
	return false;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
	try{
		if(komanda == Komande::PomjeriJednoMjesto) {
			Status trenutni_status(Idi(polja, x, y, p_smjer));
			std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
			if(trenutni_status == Status::KrajPobjeda) {
				std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;std::endl;
				IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y);
			}
			if(trenutni_status == Status::KrajPoraz) {
				std::cout&lt;&lt;"Nagazili ste na minu\n";
				IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y);
			}
		}
		if(komanda == Komande::PomjeriDalje) {
			Status trenutni_status(Idi(polja, p_x, p_y, x, y));
			std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")"&lt;&lt;std::endl;
			if(trenutni_status == Status::KrajPobjeda) {
				std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja"&lt;&lt;std::endl;
				IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y);}
			if(trenutni_status == Status::KrajPoraz) {
				std::cout&lt;&lt;"Nagazili ste na minu\n";
				IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y);
			}
		}
		if(komanda == Komande::Blokiraj) BlokirajPolje(polja, x, y);
		if(komanda == Komande::Deblokiraj) DeblokirajPolje(polja, x, y);
		if(komanda == Komande::PrikaziOkolinu) {
			auto tmp(PrikaziOkolinu(polja, x, y));
			for(int i=0; i&lt;tmp.size(); i++) {
				for(int j=0; j&lt;tmp[i].size(); j++)
					std::cout&lt;&lt;tmp[i][j]&lt;&lt;" ";
				std::cout&lt;&lt;std::endl;
			}
		}
		if(komanda == Komande::ZavrsiIgru) {
			for(int i=0; i&lt;polja.size(); i++) 
				for(int j=0; j&lt;polja.size(); j++)
					polja[i][j] = Polje::Prazno;
			throw std::runtime_error("Igra zavrsena");
		}
		if(komanda == Komande::KreirajIgru) {
			std::cout&lt;&lt;"Unesite broj polja: ";
			int n;
			std::cin&gt;&gt;n;
			std::cin.ignore();
			std::cout&lt;&lt;"Unesite pozicije mina: ";
			std::vector&lt;std::vector&lt;int&gt;&gt; mine;
			for(;;){
				bool ZavrsetakUnosa(false);
				int brojac(0);
				std::string unos;
				getline(std::cin, unos);
				if(unos == ".")
					break;
				for(int i=0; i&lt;unos.length(); i++) {
					if(unos[i] != '(' || !Cifra(unos[i+1])) {
						std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
						break;	
					}
					i++;
					int j(i);
					while(Cifra(unos[j]))
						j++;
					if(j&gt;=unos.length() || unos[j] != ',') {
						std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
						break;	
					}
					int tmp1(stoi(unos.substr(i, j-i)));
					j++;
					i=j;
					if(i&gt;=unos.length() || !Cifra(unos[i])) {
						std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
						break;	
					}
					while(Cifra(unos[j]))
						j++;
					if(j&gt;=unos.length() || unos[j] != ')') {
						std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
					break;	
					}
					int tmp2(stoi(unos.substr(i, j-i)));
					j++;
					while(j != unos.length()) {
						if(unos[j] != ' ') {
							std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
							break;	
						}
						j++;
					}
					if(tmp1 &lt;0 || tmp2&lt;0 || tmp1&gt;=n || tmp2&gt;=n || (tmp1 == 0 &amp;&amp; tmp2==0)) {
						std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
						break;
					}
					mine.push_back(std::vector&lt;int&gt;{tmp1, tmp2});
					break;
				}
			
			}
		polja = KreirajIgru(n, mine);
		}
	}
	catch(std::domain_error e) {
		std::cout&lt;&lt;e.what()&lt;&lt;std::endl;
	}
	catch(std::out_of_range e) {
		std::cout&lt;&lt;e.what()&lt;&lt;std::endl;
	}
	catch(std::logic_error e) {
		std::cout&lt;&lt;e.what()&lt;&lt;std::endl;
	}
}


int main ()
{
	try{
		Komande komanda;
	 	Smjerovi smjer;
		KodoviGresaka kod_greske;
		Tabla polja;
		int x=0, y=0;
		for(;;) {
			std::cout&lt;&lt;"Unesite komandu: ";
			bool UspjesanUnos(UnosKomande(komanda, smjer, x, y, kod_greske));
			if(UspjesanUnos)
				IzvrsiKomandu(komanda, polja, x, y, smjer);
			else PrijaviGresku(kod_greske);
		}
	}
	catch(std::runtime_error e) {
		std::cout&lt;&lt;"Dovidjenja!";
</font>	}
	
	return 0;
}</pre>
</body>
</html>
