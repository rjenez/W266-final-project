<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3424.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student3424.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;complex&gt;

enum class Polje {Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina};
enum class Smjerovi {GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo};
enum class Status {NijeKraj, KrajPoraz, KrajPobjeda};
enum class KodoviGresaka {PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar};
enum class Komande {PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru};

<a name="1"></a><font color="#00FF00"><a href="match783-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_15.gif"/></a>

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mint)
{
	for(int i(0); i &lt; mint.size(); i++)
	{
		if(mint[i].size() != 2) throw std::domain_error("Ilegalan format zadavanja mina");
		for(int j(0); j &lt; mint[i].size(); j++)
		{
			if(mint[i][j] &lt; 0 || mint[i][j] &gt;= n)
			  throw std::domain_error("Ilegalne pozicije mine");
		}
	}
	
	Tabla polja(n, std::vector&lt;Polje&gt;(n, Polje::Prazno));
	for(int i(0); i &lt; n; i++)
	{
		for(int j(0); j &lt; n; j++)
		{
			for(int k(0); k &lt; mint.size(); k++)
			{
				if(mint[k][0] == i &amp;&amp; mint[k][1] == j)
				  polja[i][j] = Polje::Mina;
			}
		}
	}
	return polja;
}

void BlokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size())
	  throw std::domain_error("Polje(x,y) ne postoji");
	
	if(polja[x][y] == Polje::Mina)
	  polja[x][y] = Polje::BlokiranoMina;
	else if(polja[x][y] == Polje::Posjeceno)
</font>	  polja[x][y] = Polje::BlokiranoPosjeceno;
	else if(polja[x][y] == Polje::Prazno)
<a name="2"></a><font color="#0000FF"><a href="match783-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

	  polja[x][y] = Polje::BlokiranoPrazno;
}

void DeblokirajPolje(Tabla &amp;polja, int x, int y)
{
	if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size())
	  throw std::domain_error("Polje(x,y) ne postoji");
	
	if(polja[x][y] == Polje::BlokiranoMina)
	  polja[x][y] = Polje::Mina;
	else if(polja[x][y] == Polje::BlokiranoPosjeceno)
</font>	  polja[x][y] = Polje::Posjeceno;
	else if(polja[x][y] == Polje::BlokiranoPrazno)
<a name="0"></a><font color="#FF0000"><a href="match783-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_68.gif"/></a>

	  polja[x][y] = Polje::Prazno;
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer);
Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y);

std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja, int x, int y)
{
	if(x &lt; 0 || x &gt;= polja.size() || y &lt; 0 || y &gt;= polja.size())
	  throw std::domain_error("Polje(x,y) ne postoji");
	
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina(3, std::vector&lt;int&gt;(3, 0));
	for(int i(x - 1); i &lt;= x + 1; i++)
	{
		for(int j(y - 1); j &lt;= y + 1; j++)
		{
			if(i &lt; 0 &amp;&amp; i &gt;= polja.size() &amp;&amp; j &lt; 0 &amp;&amp; j &gt;= polja[0].size())
			  okolina[i - (x - 1)][j - (y - 1)] = static_cast&lt;int&gt;(polja[i][j]);
		}
	}
	return okolina;
}

void PrijaviGresku(KodoviGresaka greska)
{
	if(greska == KodoviGresaka::PogresnaKomanda)
	  std::cout &lt;&lt; "Nerazumljiva komanda!" &lt;&lt; std::endl;
	else if(greska == KodoviGresaka::NedostajeParametar)
	  std::cout &lt;&lt; "Komanda trazi parametar koji nije naveden!" &lt;&lt; std::endl;
	else if(greska == KodoviGresaka::NeispravanParametar)
	  std::cout &lt;&lt; "Parametar komande nije ispravan!" &lt;&lt; std::endl;
	else
	  std::cout &lt;&lt; "Zadan je suvisan parametar!" &lt;&lt; std::endl;
}

void removespace(std::string &amp;s)
{
	int i(0);
	while(i &lt; s.length())
	{
		while(s[i] == ' ')
		  s.erase(i, 1);
		  i++;
	}
}

bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska)
{
	std::string unos;
	std::getline(std::cin, unos);
	removespace(unos);
	
	if(unos[0] == 'P')
	{
		if(unos[1] == '1')
		{
			if(unos[2] == 'G')
			{
				if(unos[3] == 'L' &amp;&amp; unos.length() == 4)
				{
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::GoreLijevo;
					return true;
				}
				else if(unos.length() == 3)
				{
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::Gore;
					return true;
				}
				else if(unos[3] == 'D' &amp;&amp; unos.length() == 4)
				{
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::GoreDesno;
					return true;
				}
				else
				{
					greska = KodoviGresaka::NeispravanParametar;
					return false;
				}
			}
			else if(unos[2] == 'D')
			{
				if(unos.length() == 3)
				{
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::Desno;
					return true;
				}
				else if(unos[3] == 'o' &amp;&amp; unos[4] == 'D' &amp;&amp; unos.length() == 5)
				{
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::DoljeDesno;
					return true;
				}
				else if(unos[3] == 'o' &amp;&amp; unos.length() == 4)
				{
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::Dolje;
					return true;
				}
				else if(unos[3] == 'o' &amp;&amp; unos[4] == 'L' &amp;&amp; unos.length() == 5)
				{
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::DoljeLijevo;
					return true;
				}
				else
				{
					greska = KodoviGresaka::NeispravanParametar;
					return false;
				}
			}
			else if(unos[2] == 'L')
			{
				if(unos.length() == 3)
				{
					komanda = Komande::PomjeriJednoMjesto;
					smjer = Smjerovi::Lijevo;
					return true;
				}
				else
				{
					greska = KodoviGresaka::NeispravanParametar;
					return false;
				}
			}
			else if(unos.length() == 2)
			{
				greska = KodoviGresaka::NedostajeParametar;
				return false;
			}
			else
			{
				greska = KodoviGresaka::NeispravanParametar;
				return false;
			}
		}
		else if(unos[1] == '&gt;')
		{
			
		}
		else if(unos[1] == 'O')
		{
			if(unos.length() == 2)
			{
				komanda = Komande::PrikaziOkolinu;
				return true;
			}
			else
			{
				greska = KodoviGresaka::SuvisanParametar;
				return false;
			}
		}
	}
	else if(unos[0] == 'Z')
	{
		if(unos.length() == 1)
		{
			komanda = Komande::ZavrsiIgru;
			return true;
		}
		else
		{
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
	}
	else if(unos[0] == 'K')
	{
		if(unos.length() == 1)
		{
			komanda = Komande::KreirajIgru;
			return true;
		}
		else
		{
			greska = KodoviGresaka::SuvisanParametar;
			return false;
		}
	}
	greska = KodoviGresaka::PogresnaKomanda;
	return false;
}

void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0)
{
	if(komanda == Komande::KreirajIgru)
	{
		try
		{
			int n;
			std::cout &lt;&lt; "Unesite broj polja: ";
			std::cin &gt;&gt; n;
			std::vector&lt;std::vector&lt;int&gt;&gt; mine;
			std::complex&lt;int&gt; koordinate;
		
			std::cout &lt;&lt; "Unesite pozicije mina: ";
			do
			{
				std::cin &gt;&gt; koordinate;
				if(std::cin.get() == '.') break;
				while(!std::cin || koordinate.real() &lt; 0 || koordinate.real() &gt;= n || koordinate.imag() &lt; 0 || koordinate.imag() &gt;= n)
				{
					std::cout &lt;&lt; "Greska, unesite ponovo!" &lt;&lt; std::endl;
					std::cin.clear();
					std::cin.ignore(10000, '\n');
					std::cin &gt;&gt; koordinate;
				}
				if(std::cin.get() == '.') break;
				std::vector&lt;int&gt; v(2);
				v[0] = koordinate.real();
				v[1] = koordinate.imag();
				mine.push_back(v);
			}while(1 == 1);
		
			polja = KreirajIgru(n, mine);
		}
		catch(std::domain_error izuzetak)
		{
			std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
		}
		return;
	}
	else if()
}


int main ()
{
	bool IgramoSe(true);
	int x(0), y(0);
	Komande komanda;
	Smjerovi smjer;
	Tabla polja;
	KodoviGresaka greska;
	
	
	while(IgramoSe)
	{
		try
		{
			std::cout &lt;&lt; "Unesite komandu: ";
			bool Ispravna = UnosKomande(komanda, smjer, x, y, greska);
			if(!Ispravna)
			{
				
			}
			else
			{
				IzvrsiKomandu(komanda, polja, x, y, )
			}
		}
		catch(...)
</font>		{
			
		}
		
	}*/
	return 0;
}</pre>
</body>
</html>
