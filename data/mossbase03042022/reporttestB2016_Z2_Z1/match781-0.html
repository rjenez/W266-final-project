<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6874.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student6874.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/

#include &lt;iostream&gt;
#include &lt;vector&gt; 
#include &lt;stdexcept&gt;
#include &lt;string&gt;

<a name="0"></a><font color="#FF0000"><a href="match781-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum class Polje{
	Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina
};

enum class KodoviGresaka{
	PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeipravanParametar
};

enum class Komande{
	PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru
};

enum class Smjerovi{
	GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo
};

enum class Status{
	NijeKraj, KrajPoraz, KrajPobjeda
};

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;

Tabla KreirajIgru (int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	for(int i=0; i&lt;mine.size(); i++){
		if(mine[i].size()!=2)
		 throw std::domain_error("Ilegalan format zadavanja mina");
		for(int j=0; j&lt;mine[i].size(); j++){
			if(mine[i][j]&gt;=n || mine[i][j]&lt;=0)
			  throw std::domain_error ("Ilegalne pozicije mina");
		}
	}
	Tabla igra(n, std::vector&lt;Polje&gt;(n, Polje::Prazno));
	for(int i=0; i&lt;n; i++){
	  for(int j=0; j&lt;n; j++){
	  	for(int k=0; k&lt;mine.size();k++){
	  		if(i==mine[k][0] &amp;&amp; j==mine[k][1])
	  		  igra[i][j] = Polje::Mina;
	  	}
	  }
	}
return igra;
}




void BlokirajPolje (Tabla &amp;polja, int x, int y){
	if(x&gt;polja.size() || x&lt;0 || y&gt;polja.size() || y&lt;0){
		std::string s("Polje (");
		s+=std::to_string(x);
		s+=",";
		s+=std::to_string(y);
		s+=") ne postoji";
		throw std::domain_error(s);
	}
	
	int a = int(polja[x][y]);
	if(a&lt;3){
		a+=3;
		polja[x][y] = Polje(a);
	}
}

void DeblokirajPolje (Tabla &amp;polja, int x, int y){
	if(x&gt;polja.size() || x&lt;0 || y&gt;polja.size() || y&lt;0){
		std::string s("Polje (");
		s+=std::to_string(x);
		s+=",";
		s+=std::to_string(y);
		s+=") ne postoji";
		throw std::domain_error(s);
	}
	int a = int(polja[x][y]);
	if(a&gt;=3){
		a-=3;
		polja[x][y] = Polje(a);
	}
}

Status Idi(Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi smjer){
	int matrica[8][2] = { {1,-1}, {1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}, {-1,-1}, {0,-1} };
	for(int i=0; i&lt;8; i++){
		if(int(smjer)==i){
			int a = x + matrica[i][0];
			int b = y + matrica[i][1];
			if(a&gt;=polja.size() || a&lt;0 || b&gt;=polja.size() || b&lt;0)
			  throw std::out_of_range("Izlazak van igrace table");
			else if(int(polja[a][b])&gt;=3)
			  throw std::logic_error("Blokirano polje");
			else{
				polja[x][y] = Polje::Posjeceno;
				x = a;
				y = b;
				if(polja[x][y]==Polje::Mina)
				  return Status::KrajPoraz;
			}
		break;
		}
		
	}
	for(int i=0; i&lt;polja.size(); i++){
		for(int j=0; j&lt;polja.size(); j++){
			if(polja[i][j]==Polje::Prazno)
			  return Status::NijeKraj;
		}
	}
	return Status::KrajPobjeda;
}

Status Idi (Tabla &amp;polja, int &amp;x, int &amp;y, int novi_x, int novi_y){
	if(novi_x&gt;=polja.size() || novi_x&lt;0 || novi_y&gt;=polja.size() || novi_y&lt;0)
	  throw std::out_of_range("Izlazak van igrace table");
	if(int(polja[novi_x][novi_y])&gt;=3)
	  throw std::logic_error("Blokirano polje");
	polja[x][y] = Polje::Posjeceno;
	x = novi_x;
	y = novi_y;
	if(polja[x][y]==Polje::Mina){
		for(int i=0; i&lt;polja.size(); i++)
		  for(int j=0; j&lt;polja.size(); j++)
		    polja[i][j] = Polje::Prazno;
		return Status::KrajPoraz;
	}
	for(int i=0; i&lt;polja.size(); i++)
	  for(int j=0; j&lt;polja.size(); j++){
	  	 if(polja[i][j] == Polje::Prazno)
	  	   return Status::NijeKraj;
	  }
	return Status::KrajPobjeda;
}


bool UnosKomande (Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y, KodoviGresaka &amp;greska){
	std::vector&lt;std::string&gt; komande{"P1", "P&gt;", "B", "D", "PO", "Z", "K"} ;
	std::string s;
	std::getline(std::cin, s);
	for(int i=0; i&lt;s.length(); i++)
	  if(s[i]==' ')
	    s.erase(s.begin() + i);
	int i(0);
	for(i=0; i&lt;komande.size(); i++){
		if(komande[i]==s){
			komanda = Komande(i);
			break;
		}
	}
	if(i==komande.size()){
		greska = KodoviGresaka::PogresnaKomanda;
		return false;
	}
	if(s=="P1"){
		std::vector&lt;std::string&gt; prvi_parametar{"GL", "G", "GD", "D", "DoD", "Do", "DoL", "L"};
		std::string s2;
		std::getline(std::cin, s2);
		for(int i=0; i&lt;s2.length(); i++){
			if(s2[i]==' ')
			  s2.erase(s2.begin() +i);
		}
		int i(0);
		for(int i=0; i&lt;8; i++){
			if(prvi_parametar[i]==s2){
				smjer = Smjerovi(i);
				return true;
			}
		}
		if(i==prvi_parametar.size()){
			if(s2.size()==0)
			  greska = KodoviGresaka::NedostajeParametar;
			else
			  greska = KodoviGresaka::SuvisanParametar;
		}
	}
	for(int i=1; i&lt;=3; i++){
		if(s==komande[i]){
			komanda = Komande(i);
			int a, b;
			std::cin&gt;&gt;a&gt;&gt;b;
			x = a; y = b;
			return true;
		}
	}
	for(int i=4; i&lt;7; i++){
		if(s==komande[i]){
			komanda = Komande(i);
			return true;
		}
	}
	return false;
}

void IzvrsiKomandu (Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y, Smjerovi p_smjer = Smjerovi::Gore, int p_x=0, int p_y=0){
	if(komanda==Komande(0)){
		auto s(Idi(polja, x, y, p_smjer));
		std::cout&lt;&lt;"Tekuca pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
		if(s==Status(1)){
			std::cout&lt;&lt;"Nagazili ste na minu";
			IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y, p_smjer, p_x, p_y);
			return;
		}
		if(s==Status(2)){
			std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja";
			IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y , p_smjer, p_x, p_y);
			return;
		}
		
	}
	if(komanda==Komande(1)){
		auto k(Idi(polja, x, y, p_x, p_y));
		std::cout&lt;&lt;"Trenutna pozicija igraca je ("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
		if(k==Status(1)){
			std::cout&lt;&lt;"Nagazili ste na minu";
			IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y);
			return;
		}
		if(k==Status(2)){
			std::cout&lt;&lt;"Bravo, obisli ste sva sigurna polja";
			IzvrsiKomandu(Komande::ZavrsiIgru, polja, x, y);
			return;
		}
	}
	if(komanda==Komande(2)){
		BlokirajPolje(polja, p_x, p_y);
		return;
	}
	if(komanda==Komande(3)){
		DeblokirajPolje(polja, p_x, p_y);
		return;
	}
	if(komanda==Komande(4)){
		auto v(PrikaziOkolinu(polja, x, y));
		for(int i=0; i&lt;v.size(); i++){
		  for(int j=0; j&lt;v[i].size(); j++)
		    std::cout&lt;&lt;v[i][j]&lt;&lt;" ";
		 std::cout&lt;&lt;std::endl;
		}  
		return;
	}
	if(komanda==Komande(5)){
		for(int i=0; i&lt;polja.size(); i++)
		  for(int j=0; j&lt;polja.size(); j++)
		    polja[i][j] = Polje::Prazno;
		throw std::runtime_error("Igra zavrsena");
	}
/*	if(komanda==Komande(6)){
		KreirajIgru(0, )
	}*/
}




int main ()
{
	try{
		//std::std::vector&lt;T&gt; ;
	}
	catch(...){
</font>		
	}
	return 0;
}</pre>
</body>
</html>
