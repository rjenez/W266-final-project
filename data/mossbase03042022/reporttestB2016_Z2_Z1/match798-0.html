<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4659.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student4659.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 1
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Ivona Ivkovic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: iivkovic2@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
<a name="3"></a><font color="#00FFFF"><a href="match798-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

enum class Smjerovi{ GoreLijevo , Gore , GoreDesno , Desno , DoljeDesno , Dolje , DoljeLijevo , Lijevo };
enum class Status { NijeKraj , KrajPoraz , KrajPobjeda};
enum class Polje { Prazno,Posjeceno,Mina,BlokiranoPrazno,BlokiranoPosjeceno,BlokiranoMina };
typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
</font>
<a name="0"></a><font color="#FF0000"><a href="match798-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_43.gif"/></a>

Tabla KreirajIgru(int n,const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine){
	Tabla Igra(n,std::vector&lt;Polje&gt;(n,Polje::Prazno));
	for(int i=0;i&lt;mine.size();i++)if(mine[i].size()&gt;2)throw std::domain_error("Ilegalan format zadavanja mina");
	
	for(int i=0;i&lt;mine.size();i++)if(mine[i][0]&gt;=n || mine[i][1]&gt;=n)throw std::domain_error("Ilegalne pozicije mina");
	
	for(int i=0;i&lt;mine.size();i++){
		Igra[ mine[i][0] ][ mine[i][1] ]=Polje::Mina;
	}
	return Igra;
}
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu (const Tabla &amp;polja,int x,int y){
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size())throw std::domain_error("Polje (x,y) ne postoji");
	std::vector&lt;std::vector&lt;int&gt;&gt; v(3,std::vector&lt;int&gt;(3));
    int i(0),j(0);
    for(int novi_x=x-1;novi_x&lt;=x+1;novi_x++){ 
    	j=0;
    	for(int novi_y=y-1; novi_y&lt;=y+1; novi_y++){
            if(novi_y&gt;=0 &amp;&amp; novi_x&gt;=0 &amp;&amp; novi_y&lt;polja.size() &amp;&amp; novi_x&lt;polja.size()){
    	        int br(0);
    	        for(int a=novi_x-1;a&lt;=novi_x+1;a++){
    		        for(int b=novi_y-1;b&lt;=novi_y+1;b++){
    			        if(a&gt;=0 &amp;&amp; a&lt;polja.size() &amp;&amp; b&gt;=0 &amp;&amp; b&lt;polja.size()) if(polja[a][b]==Polje::Mina) br++;
    		        }
    	        }
    	        if(polja[novi_x][novi_y]==Polje::Mina)br=br-1;
    	        v[i][j]=br;
            }
            j++;
    	}
    	i++;
    }
	return v;
	
}
void BlokirajPolje(Tabla &amp;polja,int x,int y){
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size())throw std::domain_error("Polje (x,y) ne postoji");
	if(polja[x][y]==Polje::Mina) polja[x][y]=Polje::BlokiranoMina;
	if(polja[x][y]==Polje::Prazno) polja[x][y]=Polje::BlokiranoPrazno;
</font><a name="2"></a><font color="#0000FF"><a href="match798-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

    if(polja[x][y]==Polje::Posjeceno) polja[x][y]=Polje::BlokiranoPosjeceno;
}
void DeblokirajPolje(Tabla &amp;polja, int x,int y){
	if(x&lt;0 || y&lt;0 || x&gt;=polja.size() || y&gt;=polja.size())throw std::domain_error("Polje (x,y) ne postoji");
	if(polja[x][y]==Polje::BlokiranoMina) polja[x][y]=Polje::Mina;
	if(polja[x][y]==Polje::BlokiranoPrazno) polja[x][y]=Polje::Prazno;
</font><a name="1"></a><font color="#00FF00"><a href="match798-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_35.gif"/></a>

    if(polja[x][y]==Polje::BlokiranoPosjeceno) polja[x][y]=Polje::Posjeceno;
}

Status Idi(Tabla &amp;polja,int &amp;x, int &amp;y, Smjerovi smjer){
	if (smjer==Smjerovi::GoreLijevo){ x=x-1; y=y-1;}
	if (smjer==Smjerovi::Gore) x=x-1;
	if (smjer==Smjerovi::GoreDesno){ x=x-1; y=y+1;}
	if (smjer==Smjerovi::Lijevo) y=y-1;
	if (smjer==Smjerovi::Desno) y=y+1;
	if (smjer==Smjerovi::DoljeDesno){ x=x+1; y=y+1;}
	if (smjer==Smjerovi::DoljeLijevo){ x=x+1; y=y-1;}
	if (smjer==Smjerovi::Dolje)x=x+1;
}
Status Idi(Tabla &amp;polja,int &amp;x, int &amp;y,int novi_x,int novi_y){
	if(novi_x&lt;0 || novi_y&lt;0 || novi_x&gt;=polja.size() || novi_y&gt;=polja.size())throw std::out_of_range("Izlazak van igrace table");
	if(1){
		x=novi_x;
		y=novi_y;
	}
}

int main ()
{
	std::vector&lt;std::vector&lt;int&gt;&gt; mine = {{0,1}, {0,4}, {1,3}, {1,4}, {2,0}, {2,1}, {2,3}} ;
	std::vector&lt;std::vector&lt;Polje&gt;&gt; tabla = KreirajIgru(5, mine);
	std::vector&lt;std::vector&lt;int&gt;&gt; okolina = PrikaziOkolinu(tabla, 1, 1);
	for(int i = 0; i &lt; okolina.size(); i++)
	{
	  for(int j = 0; j &lt; okolina[i].size(); j++) std::cout &lt;&lt; okolina[i][j] &lt;&lt; " ";
	  std::cout &lt;&lt; std::endl;
	}
	
	return 0;
</font>}</pre>
</body>
</html>
