<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student8288.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z1/student9340.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

enum class Polje { Prazno, Posjeceno, Mina, BlokiranoPrazno, BlokiranoPosjeceno, BlokiranoMina };
enum class Smjerovi { GoreLijevo, Gore, GoreDesno, Desno, DoljeDesno, Dolje, DoljeLijevo, Lijevo };
enum class Status { NijeKraj, KrajPoraz, KrajPobjeda };
enum class KodoviGresaka { PogresnaKomanda, NedostajeParametar, SuvisanParametar, NeispravanParametar };
enum class Komande { PomjeriJednoMjesto, PomjeriDalje, Blokiraj, Deblokiraj, PrikaziOkolinu, ZavrsiIgru, KreirajIgru };

typedef std::vector&lt;std::vector&lt;Polje&gt;&gt; Tabla;
<a name="0"></a><font color="#FF0000"><a href="match704-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_95.gif"/></a>

Tabla KreirajIgru(int n, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mine) {
	Tabla a;
	 a=std::vector&lt;std::vector&lt;Polje&gt;&gt; (n,std::vector&lt;Polje&gt; (n));
	 for(int j=0;j&lt;n;j++) {
	     for(int k=0;k&lt;n;k++) {
	         a[j][k]=Polje::Prazno;
	     }
	 }
	 try   {
	         for(std::vector&lt;int&gt; b: mine) {
	             if(b.size()&lt;2) {
	                 throw std::domain_error("Ilegalan format zadavanja mina");
	             }
	             else {
	                 std::vector&lt;int&gt; c(b);
	                 for(int d=0;d&lt;c.size();d++){
	                     if(c[d]&gt;=n) {
	                     throw std::domain_error ("Ilegalne pozicije mina");
	                 }
	             }
	          
	             a[b[0]][b[1]]=Polje::Mina;
	     }
	         }
	 }
	catch(std::domain_error e) {
		std::cout&lt;&lt;e.what()&lt;&lt;std::endl; 
	}
	return a;
	}
std::vector&lt;std::vector&lt;int&gt;&gt; PrikaziOkolinu(const Tabla &amp;polja,int x,int y) {
    if(x&gt;=polja.size() || y&gt;=polja.size()) {
    	throw std::domain_error("Polje (a,b) ne postoji" );
    }
    std::vector&lt;std::vector&lt;int&gt;&gt; h(3,std::vector&lt;int&gt;(3,0));
     int z(0),m(0),o(0),r(0);
      int n(0),q(0),p(0),w(0);
    for(int i=x-1;i&lt;x+2;i++) {
       for(int j=y-1;j&lt;y+2;j++) {
      if(x&gt;0 &amp;&amp; y&gt;0) {
         int broj=0;
     
      if(polja[x-1][y-1]==Polje::Mina) broj++;
     if(polja[x-1][y]==Polje::Mina) broj++;
     if(polja[x-1][y+1]==Polje::Mina) broj++;
     
     if(polja[x][y-1]==Polje::Mina) broj++;
     if(polja[x][y]==Polje::Mina) broj++;
     if(polja[x][y+1]==Polje::Mina) broj++;
     
     if(polja[x+1][y-1]==Polje::Mina) broj++;
     if(polja[x+1][y]==Polje::Mina) broj++;
     if(polja[x+1][y+1]==Polje::Mina) broj++;
    
     h[m][n]=broj;
      }
      	if(x==0 &amp;&amp; y&gt;0) {
      	int	mina=0;
      		if(polja[x][y-1]==Polje::Mina) mina++;
      		if(polja[x][y+1]==Polje::Mina) mina++;
      		
      		if(polja[x+1][y-1]==Polje::Mina) mina++;
      		if(polja[x+1][y]==Polje::Mina) mina++;
      		if(polja[x+1][y+1]==Polje::Mina) mina++;
      		h[z][q]=mina;
      	}
        		if(y==0 &amp;&amp; x&gt;0) {
                   int ponavljanje=0;
      			 if(polja[x-1][y]==Polje::Mina) ponavljanje++;
      			 if(polja[x-1][y+1]==Polje::Mina) ponavljanje++;
      			 
      			 if(polja[x][y+1]==Polje::Mina) ponavljanje++;
      			 if(polja[x+1][y]==Polje::Mina) ponavljanje++;
      			 if(polja[x+1][y+1]==Polje::Mina) ponavljanje++;
      			
      			 h[r][w]=ponavljanje;
        		}
           		if(x==0 &amp;&amp; y==0) {
          			int kopije(0);
      			if(polja[x][y+1]==Polje::Mina) kopije++;
      			if(polja[x+1][y]==Polje::Mina) kopije++;
      			if(polja[x+1][y+1]==Polje::Mina) kopije++;
           	
           	h[o][p]=kopije;
           		}
      	n++; q++;
    		w++; p++;
     }
      z++;
    m++;
    o++;
    r++;
     }
return h;
}
void BlokirajPolje(Tabla &amp;polja,int x,int y) {
for(int i=0;i&lt;3;i++) {
	if(Polje(i)==polja[x][y]) {
		polja[x][y]=Polje(i+3);
}
}
}
void DeblokirajPolje(Tabla &amp;polja,int x,int y) {
for(int j=3;j&lt;6;j++) {
	if(Polje(j)==polja[x][y]) { 
		polja[x][y]=Polje(j-3);
}
}
}

Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,Smjerovi smjer) {
switch(smjer) {
	case Smjerovi::GoreLijevo:
	polja[x][y]=Polje::Posjeceno;
	x-=1;
	y-=1;
	break;
	case Smjerovi::Gore:
	polja[x][y]=Polje::Posjeceno;
	x-=1;
	break;
	case Smjerovi::GoreDesno:
	polja[x][y]=Polje::Posjeceno;
	x-=1;
	y+=1;
	break;
	case Smjerovi::Desno:
	polja[x][y]=Polje::Posjeceno;
	y+=1;
	break;
	case Smjerovi::DoljeDesno:
	polja[x][y]=Polje::Posjeceno;
	x+=1;
	y+=1;
	break;
	case Smjerovi::Dolje:
	polja[x][y]=Polje::Posjeceno;
	x+=1;
	break;
	case Smjerovi::DoljeLijevo:
	polja[x][y]=Polje::Posjeceno;
	x+=1;
	y-=1;
	break;
	case Smjerovi::Lijevo:
	polja[x][y]=Polje::Posjeceno;
	y-=1;
	break;
	default:
	break;
}
if(polja[x][y]==Polje::Mina) {
for(int j=0;j&lt;polja.size();j++) {
	for(int k=0;k&lt;polja.size();k++) {
	         polja[j][k]=Polje::Prazno;
	     }
}
return Status::KrajPoraz;
}
else {
	int broj=0;
	for(int i=0;i&lt;polja.size();i++) {
	for(int j=0;j&lt;polja.size();j++) { 
		if(polja[i][j]==Polje::Prazno)
		broj++;
 	}
	}
	if(broj==0) return Status::KrajPobjeda;
	else 
	return Status::NijeKraj;
	}
}
Status Idi(Tabla &amp;polja,int &amp;x,int &amp;y,int novi_x,int novi_y) {
	try {
	if(novi_x&gt;=polja.size() || novi_y&gt;=polja.size()) throw std::out_of_range("Izlazak van igrace table");
	else  {
		if(polja[novi_x][novi_y]==Polje::BlokiranoPrazno)
		throw std::logic_error("Blokirano polje");
	}
	polja[x][y]=Polje::Posjeceno;
	x=novi_x;
	y=novi_y;
	}
catch(std::logic_error e) {
	std::cout&lt;&lt;e.what()&lt;&lt;std::endl;
}
catch(std::out_of_range d) {
	std::cout&lt;&lt;d.what()&lt;&lt;std::endl;
}
if(polja[x][y]==Polje::Mina) {
for(int j=0;j&lt;polja.size();j++) {
	for(int k=0;k&lt;polja.size();k++) {
	         polja[j][k]=Polje::Prazno;
	     }
}
return Status::KrajPoraz;
}
else {
	int broj=0;
	for(int i=0;i&lt;polja.size();i++) {
	for(int j=0;j&lt;polja.size();j++) { 
		if(polja[i][j]==Polje::Prazno)
		broj++;
 	}
	}
	if(broj==0) return Status::KrajPobjeda;
	else 
	return Status::NijeKraj;
	}
}
KodoviGresaka PrijaviGresku(KodoviGresaka greska) {
	for(int i=0;i&lt;4;i++) {
		if(KodoviGresaka(i)==greska) {
			return greska;
		}
	}
}
bool UnosKomande(Komande &amp;komanda, Smjerovi &amp;smjer, int &amp;x, int &amp;y,KodoviGresaka &amp;greska) {
	
	if((komanda&lt;Komande(0) &amp;&amp; komanda&gt;=Komande(6)) || (smjer&lt;Smjerovi(0) &amp;&amp; smjer&gt;=Smjerovi(7)) || (greska&lt;KodoviGresaka(0) &amp;&amp; greska&gt;=KodoviGresaka(3)))
	return false;
	else return true;
}
void IzvrsiKomandu(Komande komanda, Tabla &amp;polja, int &amp;x, int &amp;y,
 Smjerovi p_smjer = Smjerovi::Gore, int p_x = 0, int p_y = 0) {
 	std::vector&lt;std::vector&lt;int&gt;&gt; m;
 	for(int i=0;i&lt;6;i++) {
 		if(Komande(i)==komanda) {
 		Idi(polja,x,y,p_smjer);
 		BlokirajPolje(polja,x,y);
 	m = PrikaziOkolinu(polja,x,y);
 		}
 	}
 }

int main ()
{
	Tabla igra;
	std::vector&lt;std::vector&lt;int&gt;&gt; v;
	int n,x,y;
	 do {
	std::cout&lt;&lt;"Unesite komandu: ";
std::string unos;
std::getline(std::cin,unos);

std::cin&gt;&gt;x;
std::cin&gt;&gt;y;

Komande zadatak{Komande(n)};
Smjerovi uputa{Smjerovi(n)};
KodoviGresaka greska{KodoviGresaka(n)};
	std::cout&lt;&lt;"Unesite broj polja: ";
	int g;
	std::cin&gt;&gt;g;
	v.resize(g);
	std::cout&lt;&lt;"Unesite pozicije mina: ";
	for(int i=0;i&lt;g;i++) {
		for(int j=0;j&lt;2;j++) {
		v[i].resize(2);
		std::cin&gt;&gt;v[i][j];
	while(v[i][j]&gt;=n)  {
		std::cout&lt;&lt;"Greska, unesite ponovo!"&lt;&lt;std::endl;
		v[i][j]=0;
	}
	}
	}
if(UnosKomande(zadatak,uputa,x,y,greska)) {
	igra=KreirajIgru(n,v);
	IzvrsiKomandu(Komande(n),igra,x,y,uputa);
}
else {
	PrijaviGresku(KodoviGresaka(n));
}
}while(Idi(igra,x,y,Smjerovi(n))!=Status::KrajPoraz);
</font>	return 0;
}</pre>
</body>
</html>
