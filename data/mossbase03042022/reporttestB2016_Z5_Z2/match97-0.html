<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z2/student5939.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z2/student5939.cpp<p></p><pre>
<a name="1"></a><font color="#00FF00"><a href="match97-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_21.gif"/></a>

/B16/17 (ZadaÄ‡a 5, Zadatak 2)
//Autotestovi by Eldar Kurtic (mail: ekurtic3@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;new&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;

using std::string;
using std::map;

struct Korisnik{
   string ime;
   string prezime;
   string adresa;
   string telefon;
};

class Knjiga{
    string naslov;
    string ime_pisca;
    string zanr;
    int godina_izdanja;
    Korisnik *kor_knjige;
   
    
    public:
   // Korisnik *kor_knjige;
    Knjiga(string nasl,string ime,string znr,int god): naslov(nasl),ime_pisca(ime),zanr(znr),godina_izdanja(god),kor_knjige(nullptr){}
    string DajNaslov()const {return naslov;}
    string DajAutora()const {return ime_pisca;}
    string DajZanr()const {return zanr;}
    int DajGodinuIzdavanja()const {return godina_izdanja;}
    Korisnik *DajKodKogaJe()const {return kor_knjige;}
    
    void ZaduziKnjigu(Korisnik &amp;k){kor_knjige=&amp;k;}   //da li treba alocirat novi pok pa postavi na njeg ?
    void RazduziKnjigu(){kor_knjige=nullptr;}
    bool DaLiJeZaduzena()const { if(kor_knjige)return true; else return false; }
    
};

class Biblioteka{
    map&lt;int,std::shared_ptr&lt;Korisnik&gt;&gt; korisnici;
    map&lt;int,std::shared_ptr&lt;Knjiga&gt;&gt; knjige;
    /*
    void DealocirajKorisnike(){
        for(auto it=korisnici.begin();it != korisnici.end();it++)delete it-&gt;second;
    }
    
    void DealocirajKnjige(){
        for(auto it=knjige.begin();it != knjige.end();it++)delete it-&gt;second;
    }
    */
    static void IspisiKorisnika(const Korisnik &amp;k,int clanski_broj){
        std::cout&lt;&lt;"Clanski broj: "&lt;&lt;clanski_broj&lt;&lt;std::endl;
        std::cout&lt;&lt;"Ime i prezime: "&lt;&lt;k.ime&lt;&lt;" "&lt;&lt;k.prezime&lt;&lt;std::endl;
        std::cout&lt;&lt;"Adresa: "&lt;&lt;k.adresa&lt;&lt;std::endl;
        std::cout&lt;&lt;"Broj telefona: "&lt;&lt;k.telefon&lt;&lt;std::endl;
        
    }
    
    static void IspisiKnjigu(const Knjiga &amp;k,int evid_broj,bool dodatno=true){
        std::cout&lt;&lt;"Evidencijski broj: "&lt;&lt;evid_broj&lt;&lt;std::endl;
        std::cout&lt;&lt;"Naslov: "&lt;&lt;k.DajNaslov()&lt;&lt;std::endl;
</font>        std::cout&lt;&lt;"Pisac: "&lt;&lt;k.DajAutora()&lt;&lt;std::endl;
<a name="0"></a><font color="#FF0000"><a href="match97-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_75.gif"/></a>

        std::cout&lt;&lt;"Zanr: "&lt;&lt;k.DajZanr()&lt;&lt;std::endl;
        std::cout&lt;&lt;"Godina izdavanja: "&lt;&lt;k.DajGodinuIzdavanja()&lt;&lt;std::endl;
        if(k.DaLiJeZaduzena() &amp;&amp; dodatno){
            Korisnik *p(k.DajKodKogaJe());
            std::cout&lt;&lt;"Zaduzena kod korisnika: "&lt;&lt;p-&gt;ime&lt;&lt;" "&lt;&lt;p-&gt;prezime&lt;&lt;std::endl;   
        }
    }
    
    public:
    Biblioteka()=default;
    ~Biblioteka() =default;
    //kopirajuci i pomjerajuci konstruktor
    Biblioteka (const Biblioteka &amp;b);
    Biblioteka (Biblioteka &amp;&amp;b);
    
    //kopirajuci i pomjerajuci operator dodjele
    Biblioteka &amp;operator= (const Biblioteka &amp;b);
    Biblioteka &amp;operator= (Biblioteka &amp;&amp;b){
        std::swap(korisnici,b.korisnici);
        std::swap(knjige,b.knjige);
        return *this;
    }
    
    void RegistrirajNovogKorisnika(int clanski_broj,string ime,string prezime,string adresa,string telefon);
    void RegistrirajNovuKnjigu(int evid_broj,string naslov,string ime_pisca,string zanr,int godina_izdanja);
    Korisnik &amp;NadjiKorisnika(int clanski_broj)const ;
    Knjiga &amp;NadjiKnjigu(int evid_broj)const ;
    
    void IzlistajKorisnike()const {
        for(auto it=korisnici.begin();it != korisnici.end();it++){
            IspisiKorisnika(*(it-&gt;second),it-&gt;first);
            std::cout&lt;&lt;std::endl;
        }
    }
    
    void IzlistajKnjige()const {
        
        for(auto it=knjige.begin();it != knjige.end();it++){
            IspisiKnjigu(*(it-&gt;second),it-&gt;first);
            std::cout&lt;&lt;std::endl;
        }
    }
    
    //IZMJENE VRSENE OVDJE
    /*
    void ZaduziKnjigu(int evid_broj,int clanski_broj){
        auto it(knjige.find(evid_broj));
        if(it == knjige.end())throw std::logic_error("Knjiga nije nadjena");
        auto it2(korisnici.find(clanski_broj));
        if(it2 == korisnici.end())throw std::logic_error("Korisnik nije nadjen");
    
        
        if(k.DaLiJeZaduzena()){
            throw std::logic_error("Knjiga vec zaduzena");
        }else{
            Korisnik p=NadjiKorisnika(clanski_broj);
            k.ZaduziKnjigu(p);
        }
        
        
    }*/
    
     void ZaduziKnjigu(int broj_knjige,int broj_korisnika){
         if( !knjige.count(broj_knjige)) throw std::logic_error("Knjiga nije nadjena");
         if( !korisnici.count(broj_korisnika)) throw std::logic_error("Korisnik nije nadjen");
         auto it_knjiga(knjige.find(broj_knjige));
         auto it_korisnik(korisnici.find(broj_korisnika));
         if(it_knjiga-&gt;second-&gt;DaLiJeZaduzena())throw std::logic_error("Knjiga vec zaduzena");
         it_knjiga-&gt;second-&gt;ZaduziKnjigu(*(it_korisnik-&gt;second));
     }
    
    
    
    void RazduziKnjigu(int evid_broj) {
        auto it(knjige.find(evid_broj));
        if(it == knjige.end())throw std::logic_error("Knjiga nije nadjena");
        Knjiga k=NadjiKnjigu(evid_broj);                                         //da li brisat ??
        if(k.DaLiJeZaduzena()==false){
            throw std::logic_error("Knjiga nije zaduzena");
        }else{
            k.RazduziKnjigu();
        }
    }
    
    void PrikaziZaduzenja(int clanski_broj)const {
        auto it2(korisnici.find(clanski_broj));
        if(it2 == korisnici.end())throw std::domain_error("Korisnik nije nadjen");
        Korisnik kr=*(it2-&gt;second);//da li brisat ??
        int brojac=0;
        for(auto it=knjige.begin();it != knjige.end();it++){
                if(&amp;(*it-&gt;second-&gt;DajKodKogaJe())== &amp;kr){
                    IspisiKnjigu(*(it-&gt;second),it-&gt;first,false);
                    brojac++;
                }
        }
        if(brojac==0)std::cout&lt;&lt;"Nema zaduzenja za tog korisnika!"&lt;&lt;std::endl;
    }
    
};

//copy konstruktor
Biblioteka::Biblioteka(const Biblioteka &amp;b){
    bool uspjela_alokacija(true);
    
    try{
        for(auto it=b.korisnici.begin();it != b.korisnici.end();it++){
            korisnici.insert(std::make_pair(it-&gt;first, std::make_shared&lt;Korisnik&gt;(Korisnik(*(it-&gt;second) ))));
        }
    }catch(...){
       // DealocirajKorisnike();
        uspjela_alokacija=false;
    }
    
    if(uspjela_alokacija){
        
        try{
            for(auto it=b.knjige.begin();it != b.knjige.end();it++){
                knjige.insert(std::make_pair(it-&gt;first, std::make_shared&lt;Knjiga&gt;(Knjiga(*(it-&gt;second) ))));
            }
        }catch(...){
           // DealocirajKorisnike();
            //DealocirajKnjige();
        }
    }
}

//pomjerajuci konstruktor
Biblioteka::Biblioteka(Biblioteka &amp;&amp;b){
    for(auto it=b.korisnici.begin();it != b.korisnici.end();it++){
            korisnici.insert(std::make_pair(it-&gt;first, it-&gt;second));
            it-&gt;second = nullptr;
    }
    
    for(auto it=b.knjige.begin();it != b.knjige.end();it++){
                knjige.insert(std::make_pair(it-&gt;first, it-&gt;second));
                it-&gt;second = nullptr;
    }
}

//kopirajuci operator dodjele
Biblioteka &amp;Biblioteka::operator= (const Biblioteka &amp;b){
    //broj knjiga i broj korisnika ne mora bit isti zato radimo 2 slucaja
        
        //odlucit cemo se za varijantu da nas nije briga jel vec ima dovoljno alocirane memorije tj vrsit cemo potpuno alokaciju !
        int uspjela_alokacija(true);
        map&lt;int,std::shared_ptr&lt;Korisnik&gt;&gt; nova_mapa;
        try{
            for(auto it=b.korisnici.begin();it != b.korisnici.end();it++){
               // nova_mapa.insert(std::make_pair(it-&gt;first, std::make_shared&lt;Korisnik&gt;(Korisnik(*(it-&gt;second) )) ) );
               //nova_mapa.insert(std::make_pair( it-&gt;first, std::make_shared&lt;Korisnik&gt;(Korisnik(*(it-&gt;second))) )    );
             // nova_mapa.insert(it-&gt;first, std::make_shared&lt;Korisnik&gt; (*(it-&gt;second)));
                nova_mapa.insert(std::make_pair(it-&gt;first, std::make_shared&lt;Korisnik&gt; (*(it-&gt;second)) ));
            }
        }catch(...){
          //  for(auto it=nova_mapa.begin();it != nova_mapa.end();it++)delete it-&gt;second;
            uspjela_alokacija=false;
        }
        
        //ako je prosla prva alokacija
        if(uspjela_alokacija){
            map&lt;int,std::shared_ptr&lt;Knjiga&gt;&gt; nove_knjige;
            try{
                for(auto it=b.knjige.begin();it != b.knjige.end();it++){
                    nove_knjige.insert(std::make_pair(it-&gt;first, std::make_shared&lt;Knjiga&gt; ( Knjiga(*(it-&gt;second) ))) );
                }
            }catch(...){
               // for(auto it=nove_knjige.begin();it != nove_knjige.end();it++)delete it-&gt;second;
                //for(auto it=nova_mapa.begin();it != nova_mapa.end();it++)delete it-&gt;second;
                uspjela_alokacija=false;
            }
            
            //ako je sve proslo kako treba zavrsavamo alokacije
            if(uspjela_alokacija){
               // this-&gt;DealocirajKorisnike();
                //this-&gt;DealocirajKnjige();
                //krademo resurese od novamapa i noveknjige
                std::swap(korisnici,nova_mapa);
                std::swap(knjige,nove_knjige);
               
            }
        }
        
         return *this;
}

void Biblioteka::RegistrirajNovogKorisnika(int clanski_broj,string ime,string prezime,string adresa,string telefon){
    auto it(korisnici.find(clanski_broj));
    if(it != korisnici.end())throw std::logic_error("Korisnik vec postoji");
    korisnici.insert(std::make_pair(clanski_broj,std::make_shared&lt;Korisnik&gt;(Korisnik{ime,prezime,adresa,telefon}))  ); //ne moze Korisnik() jer nema konstuktora u strukturi
}

void Biblioteka::RegistrirajNovuKnjigu(int evid_broj,string naslov,string ime_pisca,string zanr,int godina_izdanja){
    auto it(knjige.find(evid_broj));
    if(it != knjige.end())throw std::logic_error("Knjiga vec postoji");
    knjige.insert(std::make_pair(evid_broj,std::make_shared&lt;Knjiga&gt;(Knjiga(naslov,ime_pisca,zanr,godina_izdanja)))); 
}

Korisnik &amp;Biblioteka::NadjiKorisnika(int clanski_broj)const {
    auto it(korisnici.find(clanski_broj));
    if(it == korisnici.end())throw std::logic_error("Korisnik nije nadjen");
    return *it-&gt;second;
}

Knjiga &amp;Biblioteka::NadjiKnjigu(int evid_broj)const {
    auto it(knjige.find(evid_broj));
    if(it == knjige.end())throw std::logic_error("Knjiga nije nadjena");
    return *it-&gt;second;
}


int main(){
    Biblioteka bib8;
bib8.RegistrirajNovogKorisnika(1, "Niko", "Nikic", "Zmaja od Bosne bb", "123 456");
bib8.RegistrirajNovuKnjigu(1, "Vlak u snijegu2", "Mato Lovrak2", "Roman2", 1941);
bib8.RegistrirajNovuKnjigu(2, "Vlak u snijegu", "Mato Lovrak", "Roman", 1931);
bib8.ZaduziKnjigu(2, 1);
bib8.IzlistajKnjige();
</font>    return 0;
}</pre>
</body>
</html>
