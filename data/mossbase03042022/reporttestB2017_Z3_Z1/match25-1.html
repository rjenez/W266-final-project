<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student1534.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student9048.cpp<p></p><pre>
/B2017/2018: Zadaća 3, Zadatak 1
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

<a name="0"></a><font color="#FF0000"><a href="match25-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_97.gif"/></a>

std::function&lt;double(double)&gt; LinearnaInterpolacija(std::vector&lt;std::pair&lt;double, double&gt;&gt; v)
{
    //Trebamo pronaci vrijednost Xi &lt;= X &lt; Xi+1
    //Sto cemo obaviti uz pomoc funkcija iz algoritma
    //Prvo trebamo sortirati primljeni vektor
    std::sort(v.begin(), v.end());
    //Provjeravamo da li postoje cvorovi sa jednakim x-koordinatama, te u tom slucaju bacamo izuzetak
    for(int i(0); i &lt; v.size()-1; i++) {
        if(v[i].first == v[i+1].first) throw std::domain_error ("Neispravni cvorovi");
    }
    // if(it != v.end()) throw std::domain_error("Neispravni cvorovi");

    //vracamo funkciju koja u biti obavlja sav posao
    return [v] (double arg) {
        //Provjeravamo da li je arg van opsega
        if(v.empty() || v[0].first &gt; arg || arg &gt; v[v.size()-1].first) throw std::range_error("Argument izvan opsega");
        //Ako je argument jednak x-koordinati posljednjeg clana
        if(arg == v[v.size()-1].first) return v[v.size()-1].second;
        std::pair&lt;double, double&gt; temp(arg, 0);
        auto it(std::lower_bound(v.begin(), v.end(), temp));
        std::pair&lt;double, double&gt; par1(0, 0);
        std::pair&lt;double, double&gt; par2(0, 0);
        if(it == v.begin()){
            par1 = *it;
            it += 1;
            par2 = *it;
            return par2.second + ((par1.second - par2.second) / (par1.first - par2.first)) * (arg - par2.first);
        }
        else {
            par2 = *it;
            it -= 1;
            par1 = *it;
            return par2.second + ((par1.second - par2.second) / (par1.first - par2.first)) * (arg - par2.first);
        }
        /*auto par2(*it);
        if(it != v.begin()) it-=1;
        auto par1(*it);
        //Ako je argument manji od x-koordinate prvog clana ili argument veci od x-koordinate zadnjeg clana
        //bacamo izuzetak
        //if(arg &lt; par1.first || arg &gt; v[v.size()-1].first) throw std::range_error("Argument izvan opsega");
        return par2.second + ((par1.second - par2.second) / (par1.first - par2.first)) * (arg - par2.first);
        */
    };

}

double fun(double arg)
{
    return arg * arg + std::sin(arg);
}

std::function&lt;double(double)&gt; LinearnaInterpolacija(double(double), double x_min, double x_max, double delta_x)
{
    if(x_min &gt; x_max || delta_x &lt;= 0) throw std::domain_error ("Nekorektni parametri");
    std::vector&lt;std::pair&lt;double, double&gt;&gt; v {};
    std::pair&lt;double, double&gt; temp {};
    int br(0);
    while(temp.first &lt;= x_max) {
        temp.first = x_min + (br * delta_x);
        temp.second = fun(x_min + (br * delta_x));
        v.push_back(temp);
        br++;
    }

    //Radimo isti posao kao i sa prvom funkcijom
    //Prvo sortiramo i provjeravamo da li ima istih cvorova
    std::sort(v.begin(), v.end());
    auto it(std::unique(v.begin(), v.end()));
    if(it != v.end()) throw std::domain_error("Neispravni cvorovi");

    //Vracamo funkciju koja obavlja interpolaciju
    return [v] (double arg) {
        //Ako je argument jednak x-koordinati prvog clana vracamo y-koordinatu posljednjeg para
        //Provjeravamo da li idemo van opsega
        if(v.empty() || v[0].first &gt; arg || arg &gt; v[v.size()-1].first) throw std::range_error("Argument izvan opsega");
        if(arg == v[v.size()-1].first) return v[v.size()-1].second;
        std::pair&lt;double, double&gt; temp (arg, 0);
        auto it(std::lower_bound(v.begin(), v.end(), temp));
        std::pair&lt;double, double&gt; par1(0, 0);
        std::pair&lt;double, double&gt; par2(0, 0);
        if(it == v.begin()) {
            par1 = *it;
            it += 1;
            par2 = *it;
            return par2.second + ((par1.second - par2.second) / (par1.first - par2.first)) * (arg - par2.first);
        }
        else{
            par2 = *it;
            it -= 1;
            par1 = *it;
            return par2.second + ((par1.second - par2.second) / (par1.first - par2.first)) * (arg - par2.first);
        }
        
        /*auto par2(*it);
        if(it != v.begin()) it-=1;
        auto par1(*it);
        //if(arg &lt; par1.first || arg &gt; v[v.size()-1].first) throw std::range_error("Argument izvan opsega");
        return par2.second + ((par1.second - par2.second) / (par1.first - par2.first)) * (arg - par2.first);
        */
    };

}

int main ()
{
    std::cout &lt;&lt; "Odaberite opciju (1 - unos cvorova, 2 - aproksimacija): ";
    int trigger(0);
    std::cin &gt;&gt; trigger;
    std::vector&lt;std::pair&lt;double, double&gt;&gt; v {};
    //Ako zelimo unijeti cvorove
    if(trigger == 1) {
        std::cout &lt;&lt; "Unesite broj cvorova: ";
        int br_cvorova(0);
        std::cin &gt;&gt; br_cvorova;
        std::cout &lt;&lt; "Unesite cvorove kao parove x y: ";
        //Petlja kojom unosimo elemente cvorova, koje zatim guramo u jedan vektor
        std::function&lt;double(double)&gt; f {};
        for(int i(0); i &lt; br_cvorova; i++) {
            std::pair&lt;double, double&gt; temp;
            std::cin &gt;&gt; temp.first &gt;&gt; temp.second;
            v.push_back(temp);
        }
        try {
            f = LinearnaInterpolacija(v);
        } catch(std::domain_error izuzetak) {
            std::cout &lt;&lt; izuzetak.what();
            return 0;
        }
        //Unosimo argumente i pozivamo prvi tip funkcije "LinearnaInterpolacija"
        //sve dok se ne unese nešto što nije broj
        std::cout &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): ";
        double argument(0);
        while(std::cin &gt;&gt; argument) {
            //Poziv funkcije
            //Inicijalizacija funkcije
            try {
                std::cout &lt;&lt; "f(" &lt;&lt; argument &lt;&lt; ") = " &lt;&lt; f(argument);
            } catch(std::range_error izuzetak) {
                std::cout &lt;&lt; izuzetak.what();
                //return 0;
            }
            std::cout &lt;&lt; std::endl &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): ";
        }
    } else if(trigger == 2) {
        std::cout &lt;&lt; "Unesite krajeve intervala i korak: ";
        double x_min(0), x_max(0), delta_x(0);
        std::cin &gt;&gt; x_min &gt;&gt; x_max &gt;&gt; delta_x;
        std::function&lt;double(double)&gt; f1 {};
        try {
            f1 = LinearnaInterpolacija(fun, x_min, x_max, delta_x);
        } catch(std::domain_error izuzetak) {
            std::cout &lt;&lt; izuzetak.what();
            return 0;
        } catch(...) {
            std::cout &lt;&lt; "Neispravni cvorovi";
            return 0;
        }

        std::cout &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): ";
        double argument(0);
        while(std::cin &gt;&gt; argument) {
            try {
                std::cout &lt;&lt; "f(" &lt;&lt; argument &lt;&lt; ") = " &lt;&lt; fun(argument) &lt;&lt; " fapprox(" &lt;&lt; argument &lt;&lt; ") = " &lt;&lt; f1(argument);
            } catch(std::range_error izuzetak) {
                std::cout &lt;&lt; izuzetak.what();
                //return 0;
            }
            std::cout &lt;&lt; std::endl &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): ";
</font>        }

    }

    return 0;
}
</pre>
</body>
</html>
