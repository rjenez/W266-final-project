<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student5488.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student5488.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

std::function&lt;double (double)&gt; LinearnaInterpolacija (std::vector&lt;std::pair&lt;double, double&gt;&gt; vektor_parova){
    auto pocetak = std::begin(vektor_parova);
    auto kraj = std::end(vektor_parova);
<a name="1"></a><font color="#00FF00"><a href="match914-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    std::sort (pocetak, kraj, [](std::pair&lt;double, double&gt; prvi, std::pair&lt;double, double&gt; drugi) {return drugi.first &gt; prvi.first;});
    bool postoji_identican = false;
</font>   try{
        for(auto i = pocetak; i != kraj; i++){
            for(auto j = i + 1; j != kraj; j++){
                if(j-&gt; first == i -&gt; first){
                    postoji_identican = true;
                    break;
                }
            }
        }
        if(postoji_identican)throw std::domain_error ("Neispravni cvorovi");
   } 
   catch(...){
       throw;
   }
    
    return [vektor_parova]  (double x)-&gt; double{
        auto prvi = std::begin(vektor_parova);
        auto zadnji = std::end(vektor_parova);
        zadnji --;
        if (x &lt; (prvi -&gt; first) || x &gt; (zadnji-&gt;first))throw std::range_error("Argument izvan opsega");
        //zadnji--;
        auto gornja_granica = std::lower_bound(prvi, zadnji, std::make_pair(x, 0) , [](std::pair&lt;double, double&gt; prvi, std::pair&lt;double, double&gt; drugi) {return drugi.first &gt; prvi.first;});
        auto donja_granica = std::upper_bound(prvi, zadnji, std::make_pair(x, 0) , [](std::pair&lt;double, double&gt; prvi, std::pair&lt;double, double&gt; drugi) {return drugi.first &gt; prvi.first;});
        donja_granica--;
        
        double rezultat ;
        if(x == gornja_granica -&gt; first) return rezultat = (gornja_granica -&gt; second);
        rezultat = (donja_granica -&gt; second) + ((gornja_granica -&gt; second) - (donja_granica-&gt;second))/((gornja_granica -&gt; first) - (donja_granica-&gt; first)) * (x - (donja_granica -&gt; first));
       
        return rezultat;
    };
}

<a name="2"></a><font color="#0000FF"><a href="match914-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

std::function&lt;double (double)&gt; LinearnaInterpolacija(double f(double), double min_x, double max_x, double korak){
    if(min_x &gt; max_x || korak &lt;= 0)throw std::domain_error("Nekorektni parametri");
</font>    int broj = (int) max_x / korak;
    std::vector&lt;std::pair&lt;double, double&gt;&gt; vektor_parova;
    for(int i = 0; i &lt; broj; i++){
        double x, y;
        x = min_x + i * korak;
        y = f(x);
        std::pair&lt;double, double&gt; par = std::make_pair(x,y);
        vektor_parova.push_back(par);
    }
    return [vektor_parova, min_x, max_x](double x){
        auto prvi = std::begin(vektor_parova);
        auto zadnji = std::end(vektor_parova);
        zadnji--;
        if (x &lt; (min_x) || x &gt; (max_x))throw std::range_error("Argument izvan opsega");
        //zadnji++;
        auto gornja_granica = std::lower_bound ( prvi,  zadnji , std::make_pair(x, 0), [](std::pair&lt;double, double&gt; prvi, std::pair&lt;double, double&gt; drugi) {return drugi.first &gt; prvi.first;});
        auto donja_granica = std::upper_bound ( prvi ,  zadnji , std::make_pair(x, 0), [](std::pair&lt;double, double&gt; prvi, std::pair&lt;double, double&gt; drugi) {return drugi.first &gt; prvi.first;});
        donja_granica --;
        
        double rezultat ;
        if(x == gornja_granica -&gt; first) return rezultat = (gornja_granica -&gt; second);
        rezultat = (donja_granica -&gt; second) + ((gornja_granica -&gt; second) - (donja_granica-&gt;second))/((gornja_granica -&gt; first) - (donja_granica-&gt; first)) * (x - (donja_granica -&gt; first));
        
        
        return rezultat;
    };
    
}





int main(){
    try{
        std::cout &lt;&lt;"Odaberite opciju (1 - unos cvorova, 2 - aproksimacija): ";
        int naredba;
        std::cin &gt;&gt; naredba;
<a name="0"></a><font color="#FF0000"><a href="match914-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

        if(naredba == 1){
    
                std::cout &lt;&lt; "Unesite broj cvorova: ";
                int broj_cvorova;
                std::cin &gt;&gt; broj_cvorova;
                std::cout &lt;&lt;"Unesite cvorove kao parove x y: ";
                std::vector&lt;std::pair&lt;double, double&gt;&gt; vektor_parova;
                for(int i = 0; i &lt; broj_cvorova; i++){
                    double x, y;
                    std::cin &gt;&gt; x &gt;&gt; y;
                    std::pair&lt;double, double&gt; par;
</font>                    par = std::make_pair(x,y);
                    vektor_parova.push_back(par);
                }
                 try{
                 auto f(LinearnaInterpolacija(vektor_parova));
                }
                catch(std::domain_error ){
                    throw;
                }
                std::cout &lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
                double argument;
                std::cin &gt;&gt; argument;
               
                auto f(LinearnaInterpolacija(vektor_parova));
                while(std::cin ){
                   try{
                    std::cout&lt;&lt; "f("&lt;&lt; argument &lt;&lt;") = "&lt;&lt; f(argument) &lt;&lt; std::endl;
                   }
                    catch(std::domain_error izuzetak){
                       std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
                   }
                   catch(std::range_error izuzetak){
                       std::cout &lt;&lt;izuzetak.what() &lt;&lt; std::endl;
                   }
                    std::cout &lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
                    std::cin &gt;&gt; argument;
                   
                }
                
            }
         
        else if(naredba == 2){
            
                std::cout &lt;&lt; "Unesite krajeve intervala i korak: ";
                double pocetak, kraj, korak;
                std::cin &gt;&gt; pocetak &gt;&gt; kraj &gt;&gt; korak;
                try{
                    auto fapprox(LinearnaInterpolacija([](double x){return x*x +std::sin(x);}, pocetak, kraj, korak));
                }
                catch(...){
                    throw;
                }
                std::cout &lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
                double argument;
                std::cin &gt;&gt; argument;
                while(std::cin ){
                    try{
                    auto fapprox(LinearnaInterpolacija([](double x){return x*x +std::sin(x);}, pocetak, kraj, korak));
                    std::cout&lt;&lt; "f("&lt;&lt; argument &lt;&lt;") = "&lt;&lt; argument * argument + std::sin(argument)&lt;&lt; " fapprox("&lt;&lt; argument&lt;&lt; ") = " &lt;&lt; fapprox(argument) &lt;&lt; std::endl;
                    }
                    catch(std::domain_error izuzetak){
                       std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
                   }
                   catch(std::range_error izuzetak){
                       std::cout &lt;&lt;izuzetak.what() &lt;&lt; std::endl;
                   }
                    std::cout &lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
                    std::cin &gt;&gt; argument;
                }
            }
        }
        catch(std::domain_error izuzetak){
            std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
        }
        catch(std::range_error izuzetak){
            std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
        }

    
    
    return 0;
}</pre>
</body>
</html>
