<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student3867.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student3329.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

<a name="0"></a><font color="#FF0000"><a href="match113-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

void testException_order ( std::vector &lt; std::pair &lt; double, double &gt; &gt; &amp;v )
{
/*** provjera razlicitosti sortiranih cvorova ***/
    std::sort ( v.begin (), v.end (), 
        [] ( std::pair &lt; double, double &gt; p1, std::pair &lt; double, double &gt; p2 ) 
            { return p1.first &lt; p2.first; } 
    );
    for ( int i = 0; i &lt; int ( v.size () - 1 ); i++ )
        if ( v.at ( i ).first == v.at ( i + 1 ).first )
            throw std::domain_error ( "Neispravni cvorovi" );
}

void testException_param ( double x_min, double x_max, double delta_x )
{
/*** provjera pravilnosti intervala i pomaka ***/
    if ( x_min &gt; x_max or delta_x &lt;= 0 )
        throw std::domain_error ( "Nekorektni parametri" );
}

std::function &lt; double ( double ) &gt; LinearnaInterpolacija ( std::vector &lt; std::pair &lt; double, double &gt; &gt; v )
{
/*** linearna interpolacija zadana nizom cvorova ***/
    testException_order ( v );
            
    return [ = ] ( double x ) -&gt; double 
    {
        std::vector &lt; std::pair &lt; double, double &gt; &gt; vec = v; //**************** ovo je jako lose, naci bolje rjesenje
        
        if ( x &lt; vec.at ( 0 ).first or x &gt; vec.at ( vec.size () - 1 ).first )
            throw std::range_error ( "Argument izvan opsega" );
        
        std::vector &lt; std::pair &lt; double, double &gt; &gt;::iterator up // gornji najmanji cvor u odnosu na vrijednost aproximacije
            { std::upper_bound ( vec.begin (), vec.end (), x, [] ( double val, const std::pair &lt; double, double &gt; &amp;p ) { return val &lt;= p.first; } ) };
            
        std::vector &lt; std::pair &lt; double, double &gt; &gt;::iterator down { ( --up )++ }; // donji najveci cvor
        
        return down -&gt; second + ( ( up -&gt; second - down -&gt; second  ) / ( up -&gt; first - down -&gt; first ) ) * ( x - down -&gt; first );
    };
}

std::function &lt; double ( double ) &gt; LinearnaInterpolacija ( std::function &lt; double ( double ) &gt; func, double x_min, double x_max, double delta_x )
{
/*** linearna interpolacija zadana intervalom ***/
    std::vector &lt; std::pair &lt; double, double &gt; &gt; knot ( int ( ( x_max - x_min ) / delta_x ) );
    
    testException_param ( x_min, x_max, delta_x );
    
    int i { 0 };
    // kreiranje niza cvorova zadanih parametrima intervala i pomaka
    for ( std::pair &lt; double, double &gt; &amp;x : knot )
        ( x.first = x_min + ( i++ ) * delta_x ), ( x.second = func ( x.first ) );
        
    return LinearnaInterpolacija ( knot );
}

enum State { OptJedan, OptDva }; // opcija izvrsavanja programa

void loop_input ( std::vector &lt; std::pair &lt; double, double &gt; &gt; knot, State state, 
    std::function &lt; double ( double ) &gt; func, double xmin = 0, double xmax = 0, double dx = 1 )
{
/*** aproximacija unosa na osnovu zadanih parametara ***/
    testException_order ( knot );
    testException_param ( xmin, xmax, dx );
    double x, point;
    while ( std::cout &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): " )
    {
        if ( ! ( std::cin &gt;&gt; x ) )
            break;
            
        try { point = ( state == OptJedan ) ? LinearnaInterpolacija ( knot ) ( x ) : LinearnaInterpolacija ( func, xmin, xmax, dx ) ( x ); }
        catch ( const std::exception &amp;e ) { std::cout &lt;&lt; e.what () &lt;&lt; std::endl; continue; }
        
        ( state == OptJedan ) ?
            ( std::cout &lt;&lt; "f(" &lt;&lt; x &lt;&lt; ") = " &lt;&lt; point &lt;&lt; std::endl ) :
            ( std::cout &lt;&lt; "f(" &lt;&lt; x &lt;&lt; ") = " &lt;&lt; func ( x ) &lt;&lt; " fapprox(" &lt;&lt; x &lt;&lt; ") = " &lt;&lt; point &lt;&lt; std::endl );
    }
    
}

void approx ( void )
{ 
/*** izvrsavanje programa za niz cvorova ***/
    int vel;
    std::cout &lt;&lt; "Unesite broj cvorova: ";
    std::cin &gt;&gt; vel;
    std::vector &lt; std::pair &lt; double, double &gt; &gt; knot ( vel, { 0, 0 } );
    
    std::cout &lt;&lt; "Unesite cvorove kao parove x y: ";
    for ( std::pair &lt; double, double &gt; &amp;p : knot )
        std::cin &gt;&gt; p.first &gt;&gt; p.second;
    
    loop_input ( knot, OptJedan, [] ( double ) -&gt; double { return 0; } );
}

void approx ( std::function &lt; double ( double ) &gt; &amp;&amp;func )
{ 
/*** izvrsavanje programa za interval ***/
    double xmin, xmax, dx;
    std::cout &lt;&lt; "Unesite krajeve intervala i korak: ";
    std::cin &gt;&gt; xmin &gt;&gt; xmax &gt;&gt; dx;

    loop_input ( std::vector &lt; std::pair &lt; double, double &gt; &gt; ( 0 ), OptDva, func, xmin, xmax, dx );
}

int main ( void )
{
    int opt;
    std::cout &lt;&lt; "Odaberite opciju (1 - unos cvorova, 2 - aproksimacija): ";
    std::cin &gt;&gt; opt;

    try { ( opt == 1 ) ? approx () : approx ( [] ( double x ) -&gt; double { return x * x + std::sin ( x ); } ); }
    catch ( const std::exception &amp;exc ) { std::cout &lt;&lt; exc.what (); }
    
    return 0;
</font>}</pre>
</body>
</html>
