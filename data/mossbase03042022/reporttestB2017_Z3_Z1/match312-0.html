<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student6617.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student6617.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match312-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B2017/2018: ZadaÄ‡a 3, Zadatak 1
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

typedef std::vector&lt;std::pair&lt;double, double&gt;&gt; vektor;

void Sortiranje(vektor &amp;v) {
    bool sortiran(true);
    for(int i=0; i&lt;v.size()-1; i++) { // paziti na prekoracenje opsega
        if(v.at(i)&gt;v.at(i+1)) { // .at moze baciti izuzetak
            sortiran=false;
            break;
        }
    }
    if(!sortiran) std::sort(v.begin(), v.end()); // ako je soritran, sort vektoru nece nista uraditi
    // mozda i ne trba provjera je li sortiran
}

bool cmp(const std::pair&lt;double, double&gt; &amp;l, const std::pair&lt;double, double&gt; &amp;r) {
    return l.first&lt;r.first;
}

std::function&lt;double(double)&gt; LinearnaInterpolacija(vektor v)
{
    // bacanje izuzetaka (ima iste x) - mozda neka bibliotecka funkcija algorithm
    const double eps(0.0001);
    for(int i=0; i&lt;v.size()-1; i++) { // paziti na prekoracenje opsega
        for(int j=i+1; j&lt;v.size(); j++) {
            if(fabs(v.at(i).first-v.at(j).first)&lt;eps) { // i ovo .at bi moglo baciti izuzetak, a ... bi mogle uhvatit
                throw std::domain_error("Neispravni cvorovi");
            }
        }
    }
    // sortiranje
    Sortiranje(v);
    // glavni dio funkcije
    return [v] (double x) {
        // bacanje izuzetaka
        if(x&lt;v[0].first || x&gt;((v.end()-1)-&gt;first)) throw std::range_error("Argument izvan opsega");
        // provjera je li x vec u vektoru
        auto it1(std::find_if(v.begin(), v.end(), [x] (std::pair&lt;double, double&gt; y) { const double eps(0.0001); return fabs(y.first-x)&lt;eps; }));
        if(it1!=v.end()) return it1-&gt;second;
        // ako nije prekinuta funkcija, ovdje se nastavlja: trazimo odg interval
        auto it(std::lower_bound(v.begin(), v.end(), std::make_pair(x, 0.0), cmp)); // parove poredimo po prvoj vrijednosti
        // linearna interpolacija
        return (it-&gt;second+((it+1)-&gt;second-it-&gt;second)/((it+1)-&gt;first -it-&gt;first)*(x-it-&gt;first));
    };
}

vektor LinearnaInterpolacija(std::function&lt;double(double)&gt; f, double xmin, double xmax, double delta) {
    
}

int main ()
</font>{
    return 0;
}
</pre>
</body>
</html>
