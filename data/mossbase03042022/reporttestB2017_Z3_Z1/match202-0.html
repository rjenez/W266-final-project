<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student1237.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student1237.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;functional&gt;
#include &lt;exception&gt;
#include &lt;set&gt;

// Some kinda useful macros (the C programmer in me will never die).
#define FIRST_POINT (points.begin())
#define LAST_POINT (points.end() - 1)
#define EPSILON 1e-10

// A single global variable to keep track of when the second function gets called.
<a name="0"></a><font color="#FF0000"><a href="match202-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

bool secondFuncGotCalled(false);

// Used for comparing floating-point numbers.
bool areEqual(const double &amp;x, const double &amp;y) 
{
	if ((x &lt; 0 &amp;&amp; y &gt; 0) || (x &gt; 0 &amp;&amp; y &lt; 0))
		return false;
	
	return (std::fabs(x - y) &lt;= EPSILON);
}

// The comp function that gets used in std::sort and elsewhere.
bool comp(const std::pair&lt;double, double&gt; &amp;p1, const std::pair&lt;double, double&gt; &amp;p2) 
{
	return (p1.first &lt; p2.first &amp;&amp; !areEqual(p1.first, p2.first)); 
}

// Test function, in this case it's y(x) = x^2 + sin(x).
double g(double x) 
{ 
	return x * x + std::sin(x); 
}

std::function&lt;double(double)&gt; LinearnaInterpolacija(std::vector&lt;std::pair&lt;double, double&gt;&gt; &amp;points)
{
	// If the second funtion gets called, then we don't have to check for errors,
	// for we already know that the vector of points is competely valid, ie the 
	// elements are already sorted in ascending order and there are no duplicates.
	if (!secondFuncGotCalled)
	{
		// Check whether two or more points have the same x-coordinate.
		std::set&lt;double&gt; xCoordinates;
		for (int i(0); i &lt; points.size(); i++)
			xCoordinates.insert(points.at(i).first);
		if (xCoordinates.size() != points.size())
			throw std::domain_error("Neispravni cvorovi\n");

		std::sort(points.begin(), points.end(), comp);
	}
	secondFuncGotCalled = false;

	// The function that does the actual interpolation.
	return [&amp;points](double x)
	{
		// Special case.
		if (areEqual(x, LAST_POINT-&gt;first))
			return LAST_POINT-&gt;second;

		// Check whether X is in range.
		if ((x &lt; FIRST_POINT-&gt;first &amp;&amp; !areEqual(x, FIRST_POINT-&gt;first)) || x &gt; LAST_POINT-&gt;first)
			throw std::range_error("Argument izvan opsega\n");

		std::vector&lt;std::pair&lt;double, double&gt;&gt;::iterator low, upp;
		low = std::lower_bound(points.begin(), points.end(), std::make_pair(x, 0.), comp);
		upp = std::upper_bound(points.begin(), points.end(), std::make_pair(x, 0.), comp);

		if (upp - low == 1)
			// This is the case in which X is equal to some X_i in the vector of points.
			return low-&gt;second;
		else if (upp - low == 0)
		{
			// This is the case in which X is inbetween some X_i and X_(i + 1) in the vector of points.
			low--;
			return (low-&gt;second + ((upp-&gt;second - low-&gt;second) / (upp-&gt;first - low-&gt;first)) * (x - low-&gt;first));
		}
	};
}

std::function&lt;double(double)&gt; LinearnaInterpolacija(double f(double), double min, double max, double delta)
{
	// Check whether the parameters are valid or not.
	if ((min &gt; max &amp;&amp; !areEqual(min, max)) || delta &lt;= 0)
		throw std::domain_error("Nekorektni parametri\n");
	
	// Has to be static because it's gonna be passed by reference to the first function.
	static std::vector&lt;std::pair&lt;double, double&gt;&gt; points;
	for (int j(0); (min &lt;= max || areEqual(min, max)); min += delta, j++)
		points.push_back(std::make_pair(min, f(min)));

	secondFuncGotCalled = true;
	return LinearnaInterpolacija(points);
}

int main(void)
{
	int option;
	std::cout &lt;&lt; "Odaberite opciju (1 - unos cvorova, 2 - aproksimacija): ";
	std::cin &gt;&gt; option;

	int n;
	double min, max, delta;
	std::function&lt;double(double)&gt; f;
	std::vector&lt;std::pair&lt;double, double&gt;&gt; points;
	
	try
	{
		if (option == 1)
		{
			std::cout &lt;&lt; "Unesite broj cvorova: ";
			std::cin &gt;&gt; n;
			points.resize(n);
			std::cout &lt;&lt; "Unesite cvorove kao parove x y: ";
			for (int i(0); i &lt; n; i++)
				std::cin &gt;&gt; points.at(i).first &gt;&gt; points.at(i).second;
			f = LinearnaInterpolacija(points);
		}
		else if (option == 2)
		{
			std::cout &lt;&lt; "Unesite krajeve intervala i korak: ";
			std::cin &gt;&gt; min &gt;&gt; max &gt;&gt; delta;
			f = LinearnaInterpolacija(g, min, max, delta);
		}	
	}
	catch (std::domain_error d)
	{
		std::cout &lt;&lt; d.what();
		return 1; 
	}

	for (;;)
	{
		double arg;
		std::cout &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): ";
		std::cin &gt;&gt; arg;
		if (!std::cin)
			break;

		try
		{
			if (option == 1)
				std::cout &lt;&lt; "f(" &lt;&lt; arg &lt;&lt; ") = " &lt;&lt; f(arg) &lt;&lt; std::endl;
			else if (option == 2)
				std::cout &lt;&lt; "f(" &lt;&lt; arg &lt;&lt; ") = " &lt;&lt; g(arg) &lt;&lt; " fapprox(" 
				          &lt;&lt; arg &lt;&lt; ") = " &lt;&lt; f(arg) &lt;&lt; std::endl;
		}
		catch(std::range_error r)
		{
			std::cout &lt;&lt; r.what();
		}
	}		

	return 0;
</font>}</pre>
</body>
</html>
