<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student3442.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student3442.cpp<p></p><pre>

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

<a name="0"></a><font color="#FF0000"><a href="match280-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

typedef std::pair&lt;double, double&gt; ParDoublovaT;

double CalculateLinearInterpolation(const std::vector&lt;ParDoublovaT&gt;&amp;  vpd, double x)
{
    if(x &lt; vpd.front().first || x &gt; vpd.back().first){
        throw std::range_error("Argument izvan opsega");
    }
    
    const auto par_i1 = std::upper_bound(vpd.begin(), vpd.end(), std::make_pair(x, 0.));
    const auto par_i = par_i1 - 1;
    
    return par_i-&gt;second + ((par_i1-&gt;second - par_i-&gt;second) / (par_i1-&gt;first - par_i-&gt;first)) * (x - par_i-&gt;first);
}

std::function&lt;double(double)&gt; LinearnaInterpolacija(std::vector&lt;ParDoublovaT&gt; vpd)
{
    std::sort(vpd.begin(), vpd.end());
    constexpr auto Eps = 1e-10;
    
    for(std::size_t i = 0; i &lt; vpd.size() - 1; ++i) {
        if(std::fabs (vpd[i].first - vpd[i + 1].first) &lt; Eps ) {
            throw std::domain_error("Neispravni cvorovi");
        }
    }
    
    return [vpd](double x){
        return CalculateLinearInterpolation(vpd, x);
    };
}

template&lt;typename DoubleLike&gt;
std::function&lt;double(double)&gt; LinearnaInterpolacija(DoubleLike f(DoubleLike), double x_min, double x_max, double dx)
{
    if(x_min &gt; x_max || dx &lt; 0) {
        throw std::domain_error("Nekorektni parametri");
    }
    
    std::vector&lt;ParDoublovaT&gt; vpd;
    
    for(; x_min &lt; x_max; x_min += dx){
        vpd.emplace_back(x_min, f(x_min));
    }
    
   return [vpd](double x){
        return CalculateLinearInterpolation(vpd, x);
    };
    
}

double test_funkcija(double x)
{
    return x*x + std::sin(x);
}

int main ()
{
    std::cout &lt;&lt; "Odaberite opciju (1 - unos cvorova, 2 - aproksimacija): ";
    int opcija;
    std::cin &gt;&gt; opcija; 
    
    
    if(opcija == 1){
        std::cout &lt;&lt; "Unesite broj cvorova: ";
        int br_cvorova;
        std::cin &gt;&gt; br_cvorova;
        std::cout &lt;&lt; "Unesite cvorove kao parove x y: ";
        std::vector&lt;ParDoublovaT&gt; pd;
        for(int i = 0; i &lt; br_cvorova; ++i){
            double x, y;
            std::cin &gt;&gt; x &gt;&gt; y;
            pd.emplace_back(x, y);
        }
        try {
            auto lin_inter = LinearnaInterpolacija(pd);
            for(;;){
                std::cout &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): ";
                double arg;
                std::cin &gt;&gt; arg;
                if(!std::cin)
                    return 0;
                try {
                    auto x = lin_inter(arg);
                    std::cout &lt;&lt; "f(" &lt;&lt; arg &lt;&lt; ") = " &lt;&lt; x &lt;&lt; '\n';
                }
                catch (std::range_error e) {
                    std::cout &lt;&lt; e.what() &lt;&lt; '\n';
                }
            }
        }
        catch (std::domain_error e) {
            std::cout &lt;&lt; e.what() &lt;&lt; '\n';
        }
    
        
    }
    
    if(opcija == 2){
        std::cout &lt;&lt; "Unesite krajeve intervala i korak: ";
        double x_min, x_max, dx;
        std::cin &gt;&gt; x_min &gt;&gt; x_max &gt;&gt; dx;
        
        try {
            auto lin_inter = LinearnaInterpolacija(test_funkcija, x_min, x_max, dx);
            for(;;){
                std::cout &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): ";
                double arg;
                std::cin &gt;&gt; arg;
                if(!std::cin)
                    return 0;
               try {
                    auto x = lin_inter(arg);
                    std::cout &lt;&lt; "f(" &lt;&lt; arg &lt;&lt; ") = " &lt;&lt; test_funkcija(arg);
                    std::cout &lt;&lt; " fapprox(" &lt;&lt; arg &lt;&lt; ") = " &lt;&lt; x &lt;&lt; '\n';
               }
               catch (std::range_error e) {
                    std::cout &lt;&lt; e.what() &lt;&lt; '\n';
               }
            }
            
        }
        catch (std::domain_error e) {
            std::cout &lt;&lt; e.what() &lt;&lt; '\n';
</font>        }
        
    }
    
    
    
	return 0;
}</pre>
</body>
</html>
