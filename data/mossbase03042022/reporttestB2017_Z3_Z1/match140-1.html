<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student7546.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student5611.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match140-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B2017/2018: ZadaÄ‡a 3, Zadatak 1
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;limits&gt;
#include &lt;iterator&gt;
#include &lt;cmath&gt;
#include &lt;functional&gt;

typedef std::vector&lt;std::pair&lt;double,double&gt;&gt; Vektor;
typedef std::pair&lt;double, double&gt; Par;
typedef std::function&lt;double(double)&gt; Omotac;

bool FunkcijaKriterija(const Par &amp;p1, const Par &amp;p2)
{
    if(p1.first == p2.first) throw std::domain_error ("Neispravni cvorovi");
    return p1.first &lt; p2.first;
}

void SortirajVektor(Vektor &amp;parovi)
{
    return std::sort(parovi.begin(), parovi.end(), FunkcijaKriterija);
}

bool FunkcijaKriterija_2(Par prvi, Par drugi)
{
    return prvi.first &lt; drugi.first;
}

double Formula(const Par &amp;prvi, const Par &amp;drugi, double x)
{
    return prvi.second + ((drugi.second - prvi.second)/(drugi.first-prvi.first))*(x-prvi.first);
}

Omotac LinearnaInterpolacija(Vektor &amp;parovi)
{

    SortirajVektor(parovi); //sortira vektor i provjerava da li postoje iste x koordinate parova u vektoru

    try {
        return[parovi](double x) {
            if(x&lt;parovi[0].first || x&gt;parovi[parovi.size()-1].first) throw std::range_error ("Argument izvan opsega");
            Par pomocni_par;
            pomocni_par.first = x;
            pomocni_par.second = std::numeric_limits&lt;double&gt;::min();
            auto iter(lower_bound(parovi.begin(), parovi.end(), pomocni_par, FunkcijaKriterija_2));
            if(iter != parovi.end()) {
                return Formula(*(iter-1), *iter, x);
            }
            return parovi[parovi.size()-1].second;
        };
    } catch(...) {
        throw;
    }
}

Omotac LinearnaInterpolacija(Omotac funkcija, double xmin, double xmax, double deltax)
{
    if(deltax &lt;= 0 || xmin&gt;xmax) throw std::domain_error ("Nekorektni parametri");
    return[funkcija, xmin, xmax, deltax](double x) {
        if(x&lt;xmin || x&gt;xmax) throw std::range_error ("Argument izvan opsega");
        int brojac(0);
        Par prvi_par, drugi_par;
        while((xmin + brojac*deltax)&lt;xmax) {
            prvi_par.first = xmin + brojac*deltax;
            prvi_par.second = funkcija(xmin + brojac*deltax);
            //brojac++;
            drugi_par.first = xmin + (brojac+1)*deltax;
            drugi_par.second = funkcija(xmin + (brojac+1)*deltax);
            if(prvi_par.first&lt;=x &amp;&amp; x&lt;drugi_par.first) break;
            brojac++;
        }
        return Formula(prvi_par, drugi_par, x);
    };
}

int main ()
{
    int opcija(0);
    std::cout &lt;&lt; "Odaberite opciju (1 - unos cvorova, 2 - aproksimacija): ";
    std::cin &gt;&gt; opcija;   
    try {
        if(opcija == 1) {
            Vektor parovi;
            std::cout &lt;&lt; "Unesite broj cvorova: ";
            int br_cvorova;
            std::cin &gt;&gt; br_cvorova;
            std::cout &lt;&lt; "Unesite cvorove kao parove x y: ";
            for(int i=0; i&lt;br_cvorova; i++) {
                double prva_koordinata, druga_koordinata;
                std::cin &gt;&gt; prva_koordinata;
                std::cin &gt;&gt; druga_koordinata;
                Par pomocni;
                pomocni=std::make_pair(prva_koordinata, druga_koordinata);
                parovi.push_back(pomocni);
            }

            double argument(0);

            do {
                auto funkcija(LinearnaInterpolacija(parovi));

                std::cout &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): ";
                std::cin &gt;&gt; argument;
                if(!std::cin) break;
                double rezultat(funkcija(argument));

                std::cout &lt;&lt; "f(" &lt;&lt; argument &lt;&lt; ") = " &lt;&lt; rezultat;
                std::cout &lt;&lt; std::endl;

            } while(std::cin);
        }
    } catch (std::domain_error IZUZETAK) {
        std::cout &lt;&lt; IZUZETAK.what() &lt;&lt; std::endl;
    } catch (std::range_error IZUZETAK) {
        std::cout &lt;&lt; IZUZETAK.what() &lt;&lt; std::endl;
    }

    if(opcija == 2) {
        std::cout &lt;&lt; "Unesite krajeve intervala i korak: ";
        double xmin, xmax, deltax;
        std::cin &gt;&gt; xmin &gt;&gt; xmax &gt;&gt; deltax;

        double argument(0);

        do {

            try {
                auto funkcija(LinearnaInterpolacija([](double x) {
                    return x*x + sin(x);
                }, xmin, xmax, deltax));

                std::cout &lt;&lt; "Unesite argument (ili \"kraj\" za kraj): ";
                std::cin &gt;&gt; argument;
                if(!std::cin) break;

                double rezultat(argument*argument + sin(argument));
                std::cout &lt;&lt; "f(" &lt;&lt; argument &lt;&lt; ") = " &lt;&lt; rezultat &lt;&lt; " fapprox(" &lt;&lt; argument &lt;&lt; ") = " &lt;&lt; funkcija(argument) &lt;&lt; std::endl;
            } catch (std::domain_error IZUZETAK) {
                std::cout &lt;&lt; IZUZETAK.what() &lt;&lt; std::endl;
            } catch (std::range_error IZUZETAK) {
                std::cout &lt;&lt; IZUZETAK.what() &lt;&lt; std::endl;
            }

        } while(std::cin);
    }
    return 0;
</font>}
</pre>
</body>
</html>
