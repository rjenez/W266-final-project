<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student5355.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student5413.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

<a name="0"></a><font color="#FF0000"><a href="match2-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum opcija {cvor=1, aprox=2};
bool ViseMinusa (const std::string &amp;arg)
{
    int brojac(0);
    for (int i(0); i&lt;arg.size(); i++) {
        if ( arg[i]=='-') {
            brojac++;
            if (brojac&gt;=2) return true;
        }
    }
    return false;
}

bool ViseTacaka (const std::string &amp;arg)
{
    int brojac(0);
    for (int i(0); i&lt;arg.size(); i++) {
        if ( arg[i]=='.') {
            brojac++;
            if (brojac&gt;=2) return true;
        }
    }
    return false;
}

bool NaN ( std::string arg)
{
    if (arg=="." || arg=="-") return false;
    if (ViseTacaka(arg) || ViseMinusa(arg)) return false;
    for (int i(0); i&lt;arg.size(); i++) {
        if (arg[i]==',') return false;
        if ( (arg[i]&lt;'0'|| arg[i]&gt;'9') &amp;&amp; arg[i]!='\n' &amp;&amp;  arg[i]!='.' &amp;&amp; arg[i]!='-') {
            return false;
        }
    }
    arg.erase (arg.begin()+ arg.size()-1);
    return true;
}

bool PrviElement (std::vector&lt;std::pair&lt;double,double&gt;&gt; &amp;V)
{

    int sizeV(V.size());
    if (V.size()==0) return true;
    std::set&lt;double&gt; L;
    for (int i(0); i&lt;V.size(); i++) {
        auto k(V[i].first);
        L.insert(k);
    }
    int sizeL(L.size());
    if (sizeL==sizeV) {
        std::sort (V.begin(), V.end());
        return true;
    }
    return false;

}

std::function&lt;double(double)&gt;  LinearnaInterpolacija (   std::vector&lt;std::pair&lt;double,double&gt;&gt; &amp; VUP)
{
      
    if (!PrviElement(VUP)) throw std::domain_error ("Neispravni cvorovi");


    return [=] (double x) {
        int last=VUP.size()-1;
        if (VUP.size()==0) throw std::range_error (" Argument izvan opsega");
        if (x&lt;VUP[0].first || x&gt;VUP[last].first) throw std::range_error (" Argument izvan opsega");
        if (VUP[0].first==0 &amp;&amp; x==0) return VUP[0].first;
        const std::pair&lt;double, double&gt; trazi (x,0);


        auto x1= std::lower_bound (VUP.begin(), VUP.end(), trazi);
        auto x0=x1;
        x0--;

        return  (x0-&gt;second +  ((x1-&gt;second - x0-&gt;second)/(x1-&gt;first - x0-&gt;first))* (x- x0-&gt;first));
    };


}

std::function &lt;double(double)&gt;  LinearnaInterpolacija ( double fun(double), double xp, double xk , double korak)
{

    if (xp&gt;xk || korak&lt;=0) throw std::domain_error ("Nekorektni parametri");
    std::vector&lt;std::pair &lt;double,double&gt;&gt; VUP2;
    double pom(xp),pomf(0);
    int i(0);
    while (pom&lt;xk) {
        pom= xp+ (korak*i);
        pomf= fun(pom);
        std::pair&lt;double, double&gt; trazi=std::make_pair (pom,pomf);
        VUP2.push_back (trazi);
        i++;
    }
    
 return [=] (double x) {
        int last=VUP2.size()-1;
        if (VUP2.size()==0) throw std::range_error ("Argument izvan opsega");
        if (VUP2[0].first==0 &amp;&amp; x==0) return VUP2[0].first;
        if (x&lt;VUP2[0].first || x&gt;VUP2[last].first) throw std::range_error ("Argument izvan opsega");
        const std::pair&lt;double, double&gt; trazi (x,0);
        auto x1= std::lower_bound (VUP2.begin(), VUP2.end(), trazi);
        auto x0=x1;
        x0--;
        return  (x0-&gt;second +  ((x1-&gt;second - x0-&gt;second)/(x1-&gt;first - x0-&gt;first))* (x- x0-&gt;first));
    };
}


int main ()
{

    int un(0);
    std::cout&lt;&lt;"Odaberite opciju (1 - unos cvorova, 2 - aproksimacija): ";
    std::cin&gt;&gt;un;
    if (cvor==un) {
        std::cout&lt;&lt;"Unesite broj cvorova: ";
        int cbr(0);
        std::cin&gt;&gt;cbr;
        if (cbr==0) return 0;
        std::cout&lt;&lt;"Unesite cvorove kao parove x y: ";
        std::vector&lt;std::pair&lt;double,double&gt;&gt; parovi;
        for (int i(0); i&lt;cbr; i++) {
            double x(0),y(0);
            std::cin&gt;&gt;x&gt;&gt;y;
            parovi.push_back (std::pair &lt;double,double&gt; (x,y));
        }
        try {
         LinearnaInterpolacija (parovi);
        } catch (std::domain_error e) {
            std::cout&lt;&lt;e.what();
            return 0;
        }
        std::cin.ignore (10000, '\n');
        while (1) {
            std::cout&lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
            std::string arg;
            std::getline(std::cin, arg);

            if ( NaN(arg))  {
                double argd= std::stod(arg);

                try {
                    auto f=LinearnaInterpolacija (parovi);
                    auto arr=f(argd);
                    std::cout&lt;&lt;"f("&lt;&lt;argd&lt;&lt;") = "&lt;&lt;arr&lt;&lt;std::endl;
                } catch (std::range_error td) {
                    std::cout&lt;&lt;td.what();
                    std::cout&lt;&lt;std::endl;
                }
                continue;
            } else {
                break;
            }

        }
    } else if (aprox==un) {
        std::cout&lt;&lt;"Unesite krajeve intervala i korak: ";
        double min(0), max(0) , korak(0);
        std::cin&gt;&gt;min&gt;&gt;max&gt;&gt;korak;
        std::cin.ignore (10000, '\n');
        try {
            auto f= LinearnaInterpolacija ([](double x)-&gt; double { return x*x+ std::sin (x);} ,min,max,korak);
        } catch (std::domain_error td) {
            std::cout&lt;&lt;td.what();
            return 0;
        }
        while (1) {
            std::cout&lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
            std::string arg;
            std::getline(std::cin, arg);

            if ( NaN(arg))  {
                double argd= std::stod(arg);
                try {
                    auto f= LinearnaInterpolacija ([](double x)-&gt; double { return x*x+ std::sin (x);} ,min,max,korak);
                    auto adds=f(argd);
                    std::cout&lt;&lt;"f("&lt;&lt;argd&lt;&lt;") = "&lt;&lt;(argd*argd+std::sin(argd))&lt;&lt;" fapprox("&lt;&lt;argd&lt;&lt;") = "&lt;&lt;adds&lt;&lt;std::endl;
                } catch (std::range_error e) {
                    std::cout&lt;&lt;e.what();
                    std::cout&lt;&lt;std::endl;

                }

                continue;
            } else {
</font>                break;
            }
        }
    }
 return 0;
}

</pre>
</body>
</html>
