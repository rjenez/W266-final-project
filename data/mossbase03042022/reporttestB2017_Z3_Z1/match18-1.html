<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student1202.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z1/student1410.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;
#include&lt;stdexcept&gt;
#include &lt;iomanip&gt;
<a name="0"></a><font color="#FF0000"><a href="match18-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using std::function;
using std::vector;
using std::cout;
using std::cin;
bool Provjeri(vector&lt;std::pair&lt;double,double&gt;&gt;&amp;vektor)
{
    auto it(std::unique(vektor.begin(),vektor.end(),
    []( std::pair&lt;double,double&gt; prvi, std::pair&lt;double,double&gt;drugi) {
        return (prvi.first==drugi.first);
    }));
    if(it==vektor.end())//kraj,dakle nema istih-&gt;true svi su razliciti
        return true;
    return false; //false postoji isti element
}
void Poredaj (vector&lt;std::pair&lt;double,double&gt;&gt; &amp;vektor)
{
    std::sort(vektor.begin(),vektor.end(),[] ( std::pair&lt;double,double&gt; prvi, std::pair&lt;double,double&gt; drugi) {
        return prvi.first&lt;drugi.first;
    });
}

function&lt;double(double)&gt;LinearnaInterpolacija(std::vector&lt;std::pair&lt;double,double&gt;&gt; vektorparova)
{
    
    Poredaj(vektorparova);
    
    if(!Provjeri(vektorparova)) throw std::domain_error ("Neispravni cvorovi");
    //NAPOMENA :u funkciji koja se vraca treba se baciti izuzetak za argument!!!
    return [vektorparova](double arg) {
         if(vektorparova.size()==0) throw std::range_error("Argument izvan opsega");
        if(arg &lt; vektorparova[0].first || arg&gt;vektorparova[(int(vektorparova.size())-1)].first)
            throw std::range_error("Argument izvan opsega");
        if(arg==vektorparova[(int(vektorparova.size())-1)].first) {
            return vektorparova[(int(vektorparova.size())-1)].second;
        } else {
            auto iter( std::lower_bound(vektorparova.begin(),vektorparova.end(),arg,
            []( std::pair&lt;double,double&gt; x,double arg) {

                return  x.first&lt;arg ;
            }));
            //ako je arg jednak prvom clanu vektora,iteer ce pokazivati na prvi cl
            if((iter-vektorparova.begin())==0) {
                auto iterSlj(iter+1);
                return (iter-&gt;second+(((iterSlj-&gt;second-iter-&gt;second)/(iterSlj-&gt;first-iter-&gt;first))*(arg-iter-&gt;first)));
            } else if(iter-&gt;first==arg) {
                auto iterSlj(iter+1);
                return (iter-&gt;second+(((iterSlj-&gt;second-iter-&gt;second)/(iterSlj-&gt;first-iter-&gt;first))*(arg-iter-&gt;first)));
            } else {
                auto iterPrethodni(iter-1);
                return (iterPrethodni-&gt;second+(((iter-&gt;second-iterPrethodni-&gt;second)/(iter-&gt;first-iterPrethodni-&gt;first))*(arg-iterPrethodni-&gt;first)));
            }

        }

    };

}

function&lt;double(double)&gt;LinearnaInterpolacija(std::function&lt;double(double)&gt; funkcija,double min,double max,double delta)
{
    if(min&gt;max) throw std::domain_error("Nekorektni parametri");
    if(delta&lt;=0) throw std::domain_error("Nekorektni parametri");
    vector&lt;std::pair&lt;double,double&gt;&gt; vektor;
    for(auto i=min; i&lt;=max; i+=delta) {
       
        vektor.push_back(std::make_pair(i,funkcija(i)));
        if(i == max) break;
    }

    return [vektor](double arg) {
       if(vektor.size()==0)  throw std::range_error("Argument izvan opsega");
 if(arg &lt; vektor[0].first || arg&gt;vektor[(int(vektor.size())-1)].first+1e-10)
  throw std::range_error("Argument izvan opsega");
          
        if(arg==vektor[(int(vektor.size())-1)].first) {
            return vektor[(int(vektor.size())-1)].second;
        } else {
            

            auto iter( std::lower_bound(vektor.begin(),vektor.end(),arg,
            []( std::pair&lt;double,double&gt; x,double arg) {
                return  x.first&lt;arg ;
            }));
            //ako je arg jednak prvom clanu vektora,iteer ce pokazivati na prvi cl
            if((iter-vektor.begin())==0) {
                auto iterSlj(iter+1);
                return (iter-&gt;second+(((iterSlj-&gt;second-iter-&gt;second)/(iterSlj-&gt;first-iter-&gt;first))*(arg-iter-&gt;first)));
            } else if(iter-&gt;first==arg) {
                auto iterSlj(iter+1);
                return (iter-&gt;second+(((iterSlj-&gt;second-iter-&gt;second)/(iterSlj-&gt;first-iter-&gt;first))*(arg-iter-&gt;first)));
            } else {
                auto iterPrethodni(iter-1);
                return (iterPrethodni-&gt;second+(((iter-&gt;second-iterPrethodni-&gt;second)/(iter-&gt;first-iterPrethodni-&gt;first))*(arg-iterPrethodni-&gt;first)));
            }

        }

    };


}

int main ()
{
    
    cout&lt;&lt;"Odaberite opciju (1 - unos cvorova, 2 - aproksimacija): ";
    int n;
    cin&gt;&gt;n;
    if(n==1) {
        cout&lt;&lt;"Unesite broj cvorova: ";
        int br;
        cin&gt;&gt;br;
        vector&lt;std::pair&lt;double,double&gt;&gt; vektor;
        cout&lt;&lt;"Unesite cvorove kao parove x y: ";
        for(int i=0; i&lt;br; i++) {
            double x,y;
            cin&gt;&gt;x&gt;&gt;y;
            vektor.push_back(std::make_pair(x,y));
        }

        double arg;
        
           try{
               auto f(LinearnaInterpolacija(vektor));
            do {
                cout&lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
                cin&gt;&gt;arg;
                if(!cin) break;
             try{
                cout&lt;&lt;"f("&lt;&lt;arg&lt;&lt;") = "&lt;&lt;f(arg)&lt;&lt;std::endl;
                }catch(std::range_error izuzetak) {
            cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
        }
                
   } while(cin);
    } catch(std::domain_error izuzetak) {
            cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
        }
    } else {
        
        double arg;
        cout&lt;&lt;"Unesite krajeve intervala i korak: ";
        double min,max,korak;
        cin&gt;&gt;min&gt;&gt;max&gt;&gt;korak;
        try{
 auto f(LinearnaInterpolacija([](double x) {
                    return x*x+sin(x);
                },min,max,korak));
            
        do {
            cout&lt;&lt;"Unesite argument (ili \"kraj\" za kraj): ";
            cin&gt;&gt;arg;
            if(!cin) break;
                try{
                cout&lt;&lt;"f("&lt;&lt;arg&lt;&lt;") = "&lt;&lt;arg*arg+sin(arg)&lt;&lt;" fapprox("&lt;&lt;arg&lt;&lt;") = "&lt;&lt;f(arg)&lt;&lt;std::endl;
                }catch(std::range_error izuzetak) {
                cout&lt;&lt;izuzetak.what() &lt;&lt; std::endl; } 
         
   }while(cin);
        }  catch(std::domain_error e) {
                cout&lt;&lt;e.what() &lt;&lt; std::endl;
</font>            }
    }
    return 0;
}
</pre>
</body>
</html>
