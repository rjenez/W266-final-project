<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z6/student5961.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z6/student7795.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match82-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B2017/2018: ZadaÄ‡a 5, Zadatak 6
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;utility&gt;
#include &lt;iterator&gt;
#include &lt;iomanip&gt;
#include &lt;set&gt;

using namespace std::placeholders;
using NumType = int;

class Berza {
public:
    Berza(NumType min_cijena, NumType max_cijena);
    Berza(NumType max_cijena);
  
    void RegistrirajCijenu(NumType cijena);
    int DajBrojRegistriranihCijena() const { return info.size(); }
    void BrisiSve() { return info.clear(); }
    NumType DajMinimalnuCijenu() const;
    NumType DajMaksimalnuCijenu() const;
    NumType DajBrojCijenaVecihOd(NumType value) const;
    void Ispisi() const;
    
    bool operator !() const { return info.empty(); };
    NumType operator [](int i) const;
    Berza&amp; operator++();
    Berza&amp; operator--();
    Berza operator++(int);
    Berza operator--(int);
    Berza operator-() const;
    
    Berza&amp; operator+=(NumType);
    Berza&amp; operator-=(NumType);
    Berza&amp; operator-=(const Berza&amp;);
    
    friend Berza operator +(const Berza &amp;b, NumType y);
    friend Berza operator -(const Berza &amp;b, NumType y);
    friend Berza operator +(NumType y, const Berza &amp;b);
    friend Berza operator -(NumType y, const Berza &amp;b);
    friend Berza operator -(const Berza &amp;a, const Berza &amp;b);
    
    friend bool operator==(const Berza&amp;, const Berza&amp;);
    friend bool operator!=(const Berza&amp;, const Berza&amp;);
private:
    enum IncreaseType { Uvecaj, Umanji };
    enum ThrowType { RangeError, DomainError };
    
    std::vector&lt;NumType&gt; info;
    NumType min_cijena, max_cijena;
    
    void checkIfEmpty() const {
        if(!*this) throw std::range_error("Nema registriranih cijena");
    }
    
    void SetNewValues(IncreaseType type, NumType value, ThrowType exept = RangeError) {
        bool check (false);
        if(type == Uvecaj) {
            check = std::any_of(info.begin(), info.end(), std::bind(std::greater&lt;NumType&gt;(), std::bind(std::plus&lt;NumType&gt;(), _1, std::abs(value)), max_cijena));
                    
            if(value != 0 &amp;&amp; !check)
                std::transform(info.begin(), info.end(), info.begin(), std::bind(std::plus&lt;NumType&gt;(), _1, value));
        }
        else if(type == Umanji) {
            check = std::any_of(info.begin(), info.end(), std::bind(std::less&lt;NumType&gt;(), std::bind(std::minus&lt;NumType&gt;(), _1, std::abs(value)), min_cijena));
                    
            if(value != 0 &amp;&amp; !check)
                std::transform(info.begin(), info.end(), info.begin(), std::bind(std::minus&lt;NumType&gt;(), _1, value));
        }
        
        if(check) {
            if(exept == RangeError) throw std::range_error("Prekoracen dozvoljeni opseg cijena");
            else if(exept == DomainError) throw std::domain_error("Prekoracen dozvoljeni opseg cijena");
        }
    }
};

////////////////////////
Berza::Berza(NumType min_cijena, NumType max_cijena) : min_cijena(min_cijena), max_cijena(max_cijena) {
    if(min_cijena &lt; 0 || max_cijena &lt; 0)
        throw std::range_error("Ilegalne granicne cijene");
}
Berza::Berza(NumType max_cijena) : min_cijena(0), max_cijena(max_cijena) {
    if(max_cijena &lt; 0)
        throw std::range_error("Ilegalne granicne cijene");
}

void Berza::RegistrirajCijenu(NumType cijena) {
    if(cijena &lt; min_cijena || cijena &gt; max_cijena)
        throw std::range_error("Ilegalna cijena");
    info.push_back(cijena);
} 
NumType Berza::DajMinimalnuCijenu() const {
    checkIfEmpty();
    return *std::min_element(info.begin(), info.end());
}
NumType Berza::DajMaksimalnuCijenu() const {
    checkIfEmpty();
    return *std::max_element(info.begin(), info.end());
}
NumType Berza::DajBrojCijenaVecihOd(NumType value) const {
    checkIfEmpty();
    return std::count_if(info.begin(), info.end(), std::bind(std::greater&lt;NumType&gt;(), _1, value));
}

void Berza::Ispisi() const {
    std::vector&lt;double&gt; values;
    std::transform(info.begin(), info.end(), std::back_inserter(values), std::bind(std::divides&lt;double&gt;(), _1, 100.0));
    std::sort(values.begin(), values.end(), std::greater&lt;double&gt;());
    std::copy(values.begin(), values.end(), std::ostream_iterator&lt;double&gt;(std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2), "\n"));
}

Berza&amp; Berza::operator++() {
    SetNewValues(IncreaseType::Uvecaj, 100);
    return *this;
}
Berza&amp; Berza::operator--() {
    SetNewValues(IncreaseType::Umanji, 100);
    return *this;
}
Berza Berza::operator++(int) {
    Berza value(min_cijena, max_cijena);
    value.info = info;
    SetNewValues(IncreaseType::Uvecaj, 100);
    return value;
}
Berza Berza::operator--(int) {
    Berza value(min_cijena, max_cijena);
    value.info = info;
    SetNewValues(IncreaseType::Umanji, 100);
    return value;
}
Berza Berza::operator-() const {
    Berza val(this-&gt;min_cijena, this-&gt;max_cijena);
    val.info = info;
    std::transform(info.begin(), info.end(), val.info.begin(), std::bind(std::minus&lt;NumType&gt;(), std::bind(std::minus&lt;NumType&gt;(), max_cijena, min_cijena), _1));
    return val;
}

Berza operator +(const Berza &amp;b, NumType y) {
    Berza result(b.min_cijena, b.max_cijena);
    result.info = b.info;
    if(y &lt;= 0) result.SetNewValues(Berza::IncreaseType::Umanji, y, Berza::ThrowType::DomainError);
    else result.SetNewValues(Berza::IncreaseType::Uvecaj, y, Berza::ThrowType::DomainError);
    return result;
}
Berza operator -(const Berza &amp;b, NumType y) {
    Berza result(b.min_cijena, b.max_cijena);
    result.info = b.info;
    if(y &lt;= 0) result.SetNewValues(Berza::IncreaseType::Uvecaj, y, Berza::ThrowType::DomainError);
    else result.SetNewValues(Berza::IncreaseType::Umanji, y, Berza::ThrowType::DomainError);
    return result;
}
inline Berza operator +(NumType y, const Berza &amp;b) {
    return b + y;
}
Berza operator -(NumType y, const Berza &amp;b) {
    Berza result(b.min_cijena, b.max_cijena);
    std::transform(b.info.begin(), b.info.end(), std::back_inserter(result.info), std::bind(std::minus&lt;NumType&gt;(), y, _1));
    result.SetNewValues(Berza::IncreaseType::Uvecaj, 0, Berza::ThrowType::DomainError); /// will only perform check 
    result.SetNewValues(Berza::IncreaseType::Umanji, 0, Berza::ThrowType::DomainError); /// will only perform check
    return result;
}

Berza operator -(const Berza &amp;a, const Berza &amp;b) {
    if(a.info.size() != b.info.size() || a.min_cijena != b.min_cijena || a.max_cijena != b.max_cijena)
        throw std::domain_error("Nesaglasni operandi");
    Berza value(a.min_cijena, a.max_cijena);
    
    std::transform(a.info.begin(), a.info.end(), b.info.begin(), std::back_inserter(value.info), std::minus&lt;NumType&gt;());
    value.SetNewValues(Berza::IncreaseType::Uvecaj, 0, Berza::ThrowType::DomainError); /// will only perform check 
    value.SetNewValues(Berza::IncreaseType::Umanji, 0, Berza::ThrowType::DomainError); /// will only perform check
    
    return value;
}

Berza&amp; Berza::operator+=(NumType value) {
    return *this = *this + value;
}
Berza&amp; Berza::operator-=(NumType value) {
    return *this = *this - value;
}
Berza&amp; Berza::operator-=(const Berza&amp; b) {
    return *this = *this - b;
}

NumType Berza::operator [](int i) const {
    if(i &lt; 0 || i &gt;= info.size()) 
        throw std::range_error("Neispravan indeks");
    return info.at(i);
}

bool operator==(const Berza&amp; b1, const Berza&amp; b2) {
    std::set&lt;bool&gt; s;
    std::transform(b1.info.begin(), b1.info.end(), b2.info.begin(), std::inserter(s, s.begin()), std::equal_to&lt;NumType&gt;());
    return b1.info.size() == b2.info.size() &amp;&amp; !std::any_of(s.begin(), s.end(), std::bind(std::equal_to&lt;bool&gt;(), _1, false) );
}
bool operator!=(const Berza&amp; b1, const Berza&amp; b2) {
    return b1.info.size() != b2.info.size() || !(b1 == b2);
}


int main () {
 
	return 0;
</font>}
</pre>
</body>
</html>
