<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z1/student5185.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z5/Z1/student5185.cpp<p></p><pre>
/*  {/B16/17 (ZadaÄ‡a 5, Zadatak 1)
//Autotestovi by Eldar Kurtic (mail: ekurtic3@etf.unsa.ba)
//Za autotestove se obracati *iskljucivo* osobi koja ih pise
} */
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;stdexcept&gt;

struct Korisnik{
    std::string ime, prezime, adresa, telefon;
};

class Knjiga{
        std::string naslovKnjige, imePisca, zanr;
        int godinaIzdavanja;
        Korisnik* zaduzeno;
    public: //Konstruktor
    Knjiga(std::string naslovKnjige, std::string imePisca, std::string zanr, int godinaIzdavanja) : naslovKnjige(naslovKnjige), imePisca(imePisca), zanr(zanr), godinaIzdavanja(godinaIzdavanja), zaduzeno(nullptr) {}
    
    //Pristupne metode
    std::string DajNaslov()const{
        return naslovKnjige;
    }
    std::string DajAutora()const{
        return imePisca;
    }
    std::string DajZanr()const{
        return zanr;
    }
    int DajGodinuIzdavanja() const{
        return godinaIzdavanja;
    }
<a name="0"></a><font color="#FF0000"><a href="match65-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_86.gif"/></a>

    Korisnik* DajKodKogaJe() const{
        return zaduzeno;
    }
    
    //Dodatne metode
    void ZaduziKnjigu(Korisnik &amp;k){
       
        zaduzeno = &amp;k;
    }
    void RazduziKnjigu(){
        zaduzeno = nullptr;
    }
    bool DaLiJeZaduzena(){
        if (zaduzeno == nullptr) return false;
        return true;
    }
    
};

class Biblioteka{
        std::map&lt;int, Korisnik*&gt; korisnici;
        std::map&lt;int, Knjiga*&gt; knjige;
        void Pomocna(int evBr, Knjiga* knjiga) const{
            std::cout &lt;&lt; "Evidencijski broj: " &lt;&lt; evBr &lt;&lt; std::endl
                &lt;&lt; "Naslov: " &lt;&lt; knjiga-&gt;DajNaslov() &lt;&lt; std::endl
                &lt;&lt; "Pisac: "&lt;&lt; knjiga-&gt;DajAutora() &lt;&lt; std::endl
                &lt;&lt; "Zanr: " &lt;&lt; knjiga-&gt;DajZanr() &lt;&lt; std::endl
                &lt;&lt; "Godina izdavanja: " &lt;&lt; knjiga-&gt;DajGodinuIzdavanja() &lt;&lt; std::endl;
        }
    public:   
        Biblioteka(){}
        Biblioteka(const Biblioteka &amp;b){ 
            try{ //U slucaju nekog izuzetka
                for (auto i : b.korisnici){
                    Korisnik* k (new Korisnik(*i.second));
                    korisnici.insert(std::make_pair(i.first, k));
                } 
            }
            catch (...){
                for (auto i : korisnici){
                    delete i.second; i.second = nullptr;
                } 
                throw;
            }
            try{
                for (auto i : b.knjige) {
                    Knjiga* k(new Knjiga (*i.second));
                    knjige.insert(std::make_pair(i.first, k));
                }
            }catch (...){
                for (auto i : knjige){
                    delete i.second; i.second = nullptr;
                } 
                throw;
            }
            
            
        }//Trebalo bi da radi, sigurno pravi duboke kopije
        Biblioteka(Biblioteka &amp;&amp;b){
            //Prvo obrisati sve pokazivace
            for (auto i : knjige) {delete i.second; i.second = nullptr;}
            for (auto i : korisnici) {delete i.second; i.second = nullptr;}
            
            //Ocistiti mape
            korisnici.clear();
            knjige.clear();
            
            //Kopirati i obrisati pokazivace
            for (auto i : b.korisnici) {
                korisnici.insert(std::make_pair(i.first, i.second));
                
            }
            for (auto i : b.knjige) {
                knjige.insert(std::make_pair(i.first, i.second));
                
            }
            b.korisnici.clear();
            b.knjige.clear();
            
        }
        Biblioteka &amp;operator =(const Biblioteka &amp;b){
            try{ //U slucaju nekog izuzetka
                for (auto i : b.korisnici){
                    Korisnik* k (new Korisnik(*i.second));
                    korisnici.insert(std::make_pair(i.first, k));
                } 
            }
            catch (...){
                for (auto i : korisnici){
                    delete i.second; i.second = nullptr;
                } 
                throw;
            }
            try{
                for (auto i : b.knjige) {
                    Knjiga* k(new Knjiga (*i.second));
                    knjige.insert(std::make_pair(i.first, k));
                }
            }catch (...){
                for (auto i : knjige){
                    delete i.second; i.second = nullptr;
                } 
                throw;
            }
            
            return *this;
        } //Trebalo bi da radi, sigurno pravi duboke kopije
        Biblioteka &amp;operator =(Biblioteka &amp;&amp;b){ 
            //Prvo obrisati sve pokazivace
            for (auto i : knjige) {delete i.second; i.second = nullptr;}
            for (auto i : korisnici) {delete i.second; i.second = nullptr;}
            
            //Ocistiti mape
            korisnici.clear();
            knjige.clear();
            
            //Kopirati i obrisati pokazivace
            for (auto i : b.korisnici) {
                korisnici.insert(std::make_pair(i.first, i.second));
                
            }
            for (auto i : b.knjige) {
                knjige.insert(std::make_pair(i.first, i.second));
                
            }
            b.korisnici.clear();
            b.knjige.clear();
            
            return *this;
        }
        ~Biblioteka(){
            for (auto i : knjige) {delete i.second; i.second = nullptr;}
            for (auto i : korisnici) {delete i.second; i.second = nullptr;}
            
        }
        
        void RegistrirajNovogKorisnika (int clanskiBroj, std::string ime, std::string prezime, std::string adresa, std::string telefon){
            for (auto i : korisnici) if (clanskiBroj == i.first) throw std::logic_error ("Korisnik vec postoji");
            //Ako nije bacio izuzetak znaci da nema tog cl broja
            Korisnik* k1(new Korisnik); //stvori pok
            k1-&gt;ime = ime; k1-&gt;prezime = prezime; k1-&gt;adresa = adresa; k1-&gt;telefon=telefon; //popuni info
            korisnici.insert(std::make_pair(clanskiBroj, k1)); // ubaci u mapu
        }
        
        void RegistrirajNovuKnjigu(int evidencijskiBroj, std::string naslovKnjige, std::string imePisca, std::string zanr, int godinaIzdavanja){
            for (auto i : knjige) if (evidencijskiBroj == i.first) throw std::logic_error ("Knjiga vec postoji");
            
            knjige.insert(std::make_pair(evidencijskiBroj, new Knjiga (naslovKnjige, imePisca, zanr, godinaIzdavanja)));
        } //
        
        Korisnik &amp;NadjiKorisnika (int clanskiBroj) const{
            for (auto i : korisnici) if (clanskiBroj == i.first) return *(i.second);
            throw std::logic_error ("Korisnik nije nadjen");
        } //
        
        Knjiga &amp;NadjiKnjigu (int evidencijskiBroj) const{
            for (auto i : knjige) if (evidencijskiBroj == i.first) return *(i.second);
            throw std::logic_error ("Knjiga nije nadjena");
        } //
        
        void IzlistajKorisnike() const{
            for (auto i : korisnici) {
                std::cout &lt;&lt; "Clanski broj: " &lt;&lt; i.first &lt;&lt; std::endl
                &lt;&lt; "Ime i prezime: " &lt;&lt; i.second-&gt;ime &lt;&lt; " " &lt;&lt; i.second-&gt;prezime &lt;&lt; std::endl
                &lt;&lt; "Adresa: " &lt;&lt; i.second-&gt;adresa &lt;&lt; std::endl
                &lt;&lt; "Broj telefona: " &lt;&lt; i.second-&gt;telefon &lt;&lt; std::endl &lt;&lt; std::endl;
            }
        }
        
        void IzlistajKnjige() const{
            for (auto i : knjige) {
                Pomocna(i.first, i.second);
           
                if (i.second-&gt;DaLiJeZaduzena()){
                    
                std::cout &lt;&lt; "Zaduzena kod korisnika: " &lt;&lt; i.second-&gt;DajKodKogaJe()-&gt;ime &lt;&lt; " " &lt;&lt; i.second-&gt;DajKodKogaJe()-&gt;prezime &lt;&lt; std::endl;}
                std::cout &lt;&lt; std::endl;
            }
        } //
        
        void ZaduziKnjigu(int evidencijskiBroj, int clanskiBroj){
            
            
            if (NadjiKnjigu(evidencijskiBroj).DaLiJeZaduzena()) throw std::logic_error ("Knjiga vec zaduzena");
                
            NadjiKnjigu(evidencijskiBroj).Knjiga::ZaduziKnjigu(NadjiKorisnika(clanskiBroj));
        } //
        
        void RazduziKnjigu(int evidencijskiBroj){

            if (!(NadjiKnjigu(evidencijskiBroj).DaLiJeZaduzena())) throw std::logic_error ("Knjiga nije zaduzena");
            
            NadjiKnjigu(evidencijskiBroj).Knjiga::RazduziKnjigu();
        } //
        
        void PrikaziZaduzenja (int clanskiBroj) const{
            int brojac(0); 
            Korisnik k1 (NadjiKorisnika(clanskiBroj)); // To je taj clan
            for (auto i : knjige) {
                Korisnik *pokNaKorisnika(i.second-&gt;DajKodKogaJe());
                if (pokNaKorisnika == nullptr) continue;
                Korisnik k2 (*pokNaKorisnika); // Trazimo knige koje ima
                
                if (k1.ime == k2.ime &amp;&amp; k1.prezime == k2.prezime &amp;&amp; k1.adresa == k2.adresa &amp;&amp; k1.telefon == k2.telefon) {
                    Pomocna(i.first, i.second);
                    brojac++;
                }
            }
            if (brojac==0) throw std::logic_error("Nema zaduzenja za tog korisnika!");
            
        } 
};


int main (){
    
    Biblioteka b; 
    for (;;){
        std::cout &lt;&lt; "Dobrodosli. Vasa biblioteka je trenutno prazna. Da li zelite raditi sa knjigama(1), clanovima(2) ili izaci (0)? ";
        int n=0; std::cin &gt;&gt; n;
        if (n == 0) break;
        else if (n == 1)
            for(;;){
                std::cout &lt;&lt; "Da li zelite dodati registrovati nove knjige (1), izlistati knjige(2), zaduziti(3) ili razduziti knjigu(4) [0 za kraj] ? ";
                int m; std::cin &gt;&gt; m;
                if (m == 0) break;
                else if (m == 1){
                    int evidencijskiBroj,  godinaIzdavanja; std::string naslovKnjige, imePisca, zanr; 
                    std::cout &lt;&lt; "Unesite evidencijski broj: "; std::cin &gt;&gt; evidencijskiBroj; std::cin.ignore(10000, '\n');
                    std::cout &lt;&lt; "Unesite naslov knjige: "; std::getline(std::cin, naslovKnjige);
                    std::cout &lt;&lt; "Unesite ime autora knjige: "; std::getline(std::cin, imePisca);
                    std::cout &lt;&lt; "Unesite zanr knjige: "; std::getline(std::cin, zanr);
                    std::cout &lt;&lt; "Unesite godinu izdavanja: "; std::cin &gt;&gt; godinaIzdavanja; std::cin.ignore(10000, '\n');
                    b.RegistrirajNovuKnjigu(evidencijskiBroj, naslovKnjige, imePisca, zanr, godinaIzdavanja);
                }
                else if (m==2){
                    b.IzlistajKnjige();
                }
                else if (m==3){
                    int evidencijskiBroj, clanskiBroj;
                    std::cout &lt;&lt; "Unesite evidencijski broj: "; std::cin &gt;&gt; evidencijskiBroj; std::cin.ignore(10000, '\n');
                    std::cout &lt;&lt; "Unesite clanski broj: "; std::cin &gt;&gt; clanskiBroj; std::cin.ignore(10000, '\n');
                    b.ZaduziKnjigu(evidencijskiBroj, clanskiBroj);
                }
                else if (m==4){
                    int evidencijskiBroj;
                    std::cout &lt;&lt; "Unesite evidencijski broj: "; std::cin &gt;&gt; evidencijskiBroj; std::cin.ignore(10000, '\n');
                    
                    b.RazduziKnjigu(evidencijskiBroj);
                }
            }
        
        else if (n == 2)
            for(;;){
                std::cout &lt;&lt; "Da li zelite dodati registrovati nove clanove (1), izlistati clanove(2), prikazati zaduzenja (3) [0 za kraj] ? ";
                int m; std::cin &gt;&gt; m;
                if (m == 0) break;
                else if (m == 1){
                    int clanskiBroj; std::string ime, prezime, adresa, telefon; 
                    std::cout &lt;&lt; "Unesite clanski broj: "; std::cin &gt;&gt; clanskiBroj; std::cin.ignore(10000, '\n');
                    std::cout &lt;&lt; "Unesite ime clana: "; std::getline(std::cin, ime);
                    std::cout &lt;&lt; "Unesite prezime clana: "; std::getline(std::cin, prezime);
</font><a name="1"></a><font color="#00FF00"><a href="match65-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

                    std::cout &lt;&lt; "Unesite adresu clana: "; std::getline(std::cin, adresa);
                    std::cout &lt;&lt; "Unesite telefon clana:  "; std::getline(std::cin, telefon);
                    b.RegistrirajNovogKorisnika(clanskiBroj, ime, prezime, adresa, telefon);
                }
                else if (m==2){
                    b.IzlistajKorisnike();
                }
                else if (m==3){
                    int clanskiBroj;
                    std::cout &lt;&lt; "Unesite clanski broj: "; std::cin &gt;&gt; clanskiBroj; std::cin.ignore(10000, '\n');
                    b.PrikaziZaduzenja(clanskiBroj);
                }
                
            }
        
        else{
            std::cout &lt;&lt; "greska, ponovite unos" &lt;&lt; std::endl;
            std::cin.clear(); std::cin.ignore(10000, '\n');
        }
    }
    
    
	return 0;
</font>}</pre>
</body>
</html>
