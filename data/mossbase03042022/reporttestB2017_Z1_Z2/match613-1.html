<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student4011.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student6781.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.
*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

<a name="0"></a><font color="#FF0000"><a href="match613-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

std::vector&lt;std::vector&lt;double&gt;&gt; NajvecaPlaninaMatrice(std::vector&lt;std::vector&lt;double&gt;&gt; m)
{
	std::vector&lt;std::vector&lt;double&gt;&gt; planina;

	if(m.size()==0 || m.at(0).size()==0) return planina;

	int velicina=m.at(0).size();
	for(int i=1; i&lt;m.size(); i++) {
		if(m.at(i).size()!=velicina) throw std::domain_error("Matrica nije korektna");
</font>	}

// za matrice kolone(vrste) i one cija je jedna dimenzija manja od 3 planina je zapravo najveci njen element
// te je dovoljno njega vratiti tj. vratiti matricu formata 1x1 (nece postojati planina veceg neparnog reda)
	double naj=m.at(0).at(0);
	if(m.size()&lt;3 || m.at(0).size()&lt;3) {
		for(int i=0; i&lt;m.size(); i++) {
			for(int j=0; j&lt;m.at(0).size(); j++) if(m.at(i).at(j)&gt;naj) naj=m.at(i).at(j);
		}
		planina.resize(1);
		planina.at(0).push_back(naj);
		return planina;
	}

// kada je matrica formata vecih od 3 trazimo planine prema poznatom pravilu

	int prvadimenzija(m.size()), drugadimenzija(m.at(0).size());
	int najvecadimenzijaplanine;
	if(prvadimenzija&lt;drugadimenzija) najvecadimenzijaplanine=prvadimenzija;
	else najvecadimenzijaplanine=drugadimenzija;
	if(najvecadimenzijaplanine%2==0) najvecadimenzijaplanine-=1;            // odredjujemo najveci moguci red planine matrice

	int prvakoord(0), drugakoord(0), temp_prva(0), temp_druga(0);
	double temp_suma(0);
	double clan, vrh(m.at(0).at(0));

	for(int i=0; i&lt;m.size(); i++) {
		for(int j=0; j&lt;m.at(0).size(); j++) {

			std::vector&lt;std::vector&lt;double&gt;&gt; privremena; // deklarisana matrica ce sluziti za smjestanje potencijalnih najvecih planina zadane matrice

			clan=m.at(i).at(j);
			temp_prva=i;
			temp_druga=j;
			int pocetak1(i), pocetak2(j);

			privremena.resize(1);
			privremena.at(0).push_back(clan);

			double unutra(m.at(i).at(j));
			for(int k=1; k&lt;=najvecadimenzijaplanine; k++) {
				if (pocetak1-k&lt;0 || pocetak2-k&lt;0 || k+pocetak1&gt;=m.size() || k+pocetak2&gt;=m.at(0).size()) break;
				for(int p=pocetak1-k; p&lt;=pocetak1+k; p++) {
					for(int q=pocetak2-k; q&lt;=pocetak2+k; q++) {
						if(p==pocetak1-k || p==pocetak1+k || q==pocetak2-k || q==pocetak2+k) temp_suma+=m.at(p).at(q);
					}
				}

				if(temp_suma&lt;unutra) {
					privremena.resize(0);
					int kontrolna(0);
					for(int p=pocetak1-k; p&lt;=pocetak1+k; p++) {
						privremena.resize(privremena.size()+1);
						for(int q=pocetak2-k; q&lt;=pocetak2+k; q++) {
							privremena.at(kontrolna).push_back(m.at(p).at(q));
						}
						kontrolna++;
					}
				}
				unutra=temp_suma;
				temp_suma=0;
			}
			if(privremena.size()&gt;planina.size()) {                              // odabir trazene najvece planine prema uvjetima zadatka
				planina=std::move(privremena);
				vrh=clan;
				prvakoord=temp_prva;
				drugakoord=temp_druga;
			}
			if(privremena.size()==planina.size()) {
				if(clan&gt;vrh || (std::fabs(clan-vrh)&gt;0 &amp;&amp; temp_prva&gt;prvakoord) || (std::fabs(clan-vrh)&gt;0 &amp;&amp; temp_prva==prvakoord &amp;&amp; temp_druga&gt;drugakoord)) {
					planina=std::move(privremena);
					vrh=clan;
					prvakoord=temp_prva;
					drugakoord=temp_druga;
				}
			}
		}
	}
	
	return planina;
}

int main ()
{
	int m,n;
	std::cout &lt;&lt; "Unesite dimenzije matrice (m i n): ";
	std::cin &gt;&gt; m &gt;&gt; n;
	if(m&lt;0 || n&lt;0) {
		std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!" &lt;&lt; std::endl;
		return 1;
	}

	std::vector&lt;std::vector&lt;double&gt;&gt; matrica (m, std::vector&lt;double&gt;(n));

	std::cout &lt;&lt; "Unesite elemente matrice: ";
	for(int i=0; i&lt;m; i++) {
		for(int j=0; j&lt;n; j++) {
			std::cin &gt;&gt; matrica.at(i).at(j);
		}
	}
	std::cout &lt;&lt; std::endl;

	try {
<a name="2"></a><font color="#0000FF"><a href="match613-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

		std::vector&lt;std::vector&lt;double&gt;&gt; naj_planina(NajvecaPlaninaMatrice(matrica));

		std::cout &lt;&lt; "Najveca planina unesene matrice je: " &lt;&lt; std::endl;
		for(int i=0; i&lt;naj_planina.size(); i++) {
			for(int j=0; j&lt;naj_planina.at(0).size(); j++) {
</font><a name="1"></a><font color="#00FF00"><a href="match613-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

				std::cout &lt;&lt; std::setw(6) &lt;&lt; naj_planina.at(i).at(j);
			}
			std::cout &lt;&lt; std::endl;
		}

	} catch (std::domain_error izuzetak) {
		std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
</font>	}

	return 0;
}</pre>
</body>
</html>
