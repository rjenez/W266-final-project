<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student5829.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student8753.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
<a name="0"></a><font color="#FF0000"><a href="match12-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using std::vector;
using std::cout;
using std::cin;
typedef vector&lt;vector&lt;double&gt;&gt; MAT;
const double EP=0.001;

bool DaLiJeGrbava(MAT &amp;mat){
	for(int i(1);i&lt;mat.size();i++){
		if(mat.at(i).size()!=mat.at(0).size()) throw std::domain_error("Matrica nije korektna");
	}
	if(mat.at(0).size()==0) return true;
	return false;
}

vector&lt;double&gt; MaxEl(MAT &amp;mat){
	vector&lt;double&gt; v;
	for(auto &amp;red : mat)
		for(auto &amp;x:red) v.push_back(x);
	for(int i(0);i&lt;v.size();i++){
		for(int j(i+1);j&lt;v.size();j++){
			if((v.at(i)-v.at(j)&lt;EP) &amp;&amp; (v.at(i)-v.at(j)&gt;-EP)){
				v.erase(v.begin()+j);
				j--;
			}
		}
	}
	for(int i(0);i&lt;v.size();i++){
		for(int j(0);j&lt;v.size();j++){
			if(v.at(i)&gt;v.at(j)){
				double pom(v.at(i));
				v.at(i)=v.at(j);
				v.at(j)=pom;
			}
		}
	}
	return v;
}

int DimMaxPodMat(int i,int j,int p,int d){
	int d1(0),d2(0);
	if(p-1&lt;=i-p) d1=p-1;
	else d1=i-p;
	if(d-1&lt;=j-d) d2=d-1;
	else d2=j-d;
	if(d1&lt;=d2) return d1;
	return d2;
}

double SumaKv(MAT &amp;mat,int br,int centar){
	double suma(0);
	for(int i(0);i&lt;mat.size();i++){
		for(int j(0);j&lt;mat.at(i).size();j++){
			if((i==centar-br || i==centar+br) &amp;&amp; (j&gt;=centar-br &amp;&amp; j&lt;=centar+br)) suma+=mat.at(i).at(j);
			if((j==centar-br || j==centar+br) &amp;&amp; (i&gt;centar-br &amp;&amp; i&lt;centar+br)) suma+=mat.at(i).at(j);
		}
	}
	return suma;
}

MAT Oblikovnje(MAT mat){
	if(mat.size()==1) return mat;
	int dim=(mat.size()-1)/2;
	vector&lt;double&gt; v;
	v.push_back(mat.at(dim).at(dim));
	for(int i(0);i&lt;dim;i++){
		double k(0);
		k=SumaKv(mat,i+1,dim);
		v.push_back(k);
	}
	for(int i(1);i&lt;v.size();i++){
		if(v.at(i)&gt;=v.at(i-1)){
			for(int j(0);j&lt;v.size()-i;j++){
				mat.erase(mat.end()-1);
				mat.erase(mat.begin());
			}
			for(int k(0);k&lt;mat.size();k++){
				for(int j(0);j&lt;v.size()-i;j++){
				mat.at(k).erase(mat.at(k).end()-1);
				mat.at(k).erase(mat.at(k).begin());	
				}
			}
			return mat;
		}
	}
	return mat;
}

MAT PronadjiVrhMat(MAT &amp;mat,double br){
	vector&lt;MAT&gt; v;
	for(int i(0);i&lt;mat.size();i++){
		for(int j(0);j&lt;mat.at(i).size();j++){
			if((mat.at(i).at(j)-br&lt;=EP) &amp;&amp; (mat.at(i).at(j)-br&gt;=-EP)){
				int dim=DimMaxPodMat(mat.size(),mat.at(i).size(),i+1,j+1);
				MAT podmat;
				int d(0);
				for(int k(i-dim);k&lt;i+dim+1;k++){
					podmat.resize(podmat.size()+1);
					for(int l(j-dim);l&lt;j+dim+1;l++){
						podmat.at(d).push_back(mat.at(k).at(l));
					}
					d++;
				}
				podmat=Oblikovnje(podmat);
				v.push_back(podmat);
			}
		}
	}
	if(v.size()==1) return v.at(0);
	int max(0);
	for(int i(0);i&lt;v.size();i++){
		if(v.at(i).size()%2==0){
			v.erase(v.begin()+i);
			i--;
			}
		else if(v.at(i).size()&gt;max) max=v.at(i).size();
	}
	for(int i(0);i&lt;v.size();i++){
			if(v.at(i).size()&lt;max){
				v.erase(v.begin()+i);
				i--;
			}
		}
	return v.at(0);
}

vector&lt;vector&lt;double&gt;&gt; NajvecaPlaninaMatrice(MAT mat){
	if(mat.size()==0 || (mat.size()==1 &amp;&amp; mat.at(0).size()==0)) return MAT();
	if(mat.size()==1 &amp;&amp; mat.at(0).size()==1) return mat;
	if(mat.size()==1 &amp;&amp; mat.at(0).size()&gt;1){
		vector&lt;double&gt; d(MaxEl(mat));
		return MAT{{d.at(0)}};
	}
	if(DaLiJeGrbava(mat)){
		return MAT();
	}
	if(mat.size()&gt;1 &amp;&amp; mat.at(0).size()==1){
		vector&lt;double&gt; d(MaxEl(mat));
		return MAT{{d.at(0)}};
	}
	vector&lt;MAT&gt; vrhmat;
	vector&lt;double&gt; max(MaxEl(mat));
	for(int i(0);i&lt;max.size();i++){
		vrhmat.push_back(PronadjiVrhMat(mat,max.at(i)));
	}
	if(vrhmat.size()==1) return vrhmat.at(0);
	int maxi(0);
	for(int i(0);i&lt;vrhmat.size();i++){
		if(vrhmat.at(i).size()&gt;maxi) maxi=vrhmat.at(i).size();
	}
	for(int i(0);i&lt;vrhmat.size();i++){
		if(vrhmat.at(i).size()&lt;maxi){
			vrhmat.erase(vrhmat.begin()+i);
			i--;
		}
	}
	return vrhmat.at(0);
}

int main ()
{
	int m(0),n(0);
	cout&lt;&lt;"Unesite dimenzije matrice (m i n): ";
	cin&gt;&gt;m&gt;&gt;n;
	if(m&lt;0 || n&lt;0){
		cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";
		return 0;
	}
	cout&lt;&lt;"Unesite elemente matrice:";
	MAT mat;
	for(int i(0);i&lt;m;i++){
		mat.resize(mat.size()+1);
		for(int j(0);j&lt;n;j++){
			double k(0);
			cin&gt;&gt;k;
			mat.at(i).push_back(k);
		}
	}
	try{
		MAT Planina=NajvecaPlaninaMatrice(mat);
		cout&lt;&lt;std::endl&lt;&lt;"Najveca planina unesene matrice je:"&lt;&lt;std::endl;
		for(vector&lt;double&gt; &amp;v : Planina){
					for(double &amp;i : v) cout&lt;&lt;std::right&lt;&lt;std::setw(6)&lt;&lt;i;
					cout&lt;&lt;std::endl;
				}
	}
	catch(std::domain_error izuzetak){
		cout&lt;&lt;izuzetak.what();
</font>	}
	return 0;
}</pre>
</body>
</html>
