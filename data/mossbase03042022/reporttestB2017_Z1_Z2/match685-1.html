<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student8560.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student4665.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

std::vector&lt;std::vector&lt;double&gt;&gt;  KreirajMatricu(int m, int n) {
        return std::vector&lt;std::vector&lt;double&gt;&gt;(m, std::vector&lt;double&gt; (n));
}
std::vector&lt;std::vector&lt;double&gt;&gt;  UnesiMatricu(int m, int n) {
        auto M(KreirajMatricu(m, n));
        for (int i = 0; i &lt; m; i++)
            for (int j = 0; j &lt; n; j++) {
                std::cin &gt;&gt; M.at(i).at(j);
            }
        return M;
}
std::vector&lt;std::vector&lt;double&gt;&gt; NajvecaPlaninaMatrice(std::vector&lt;std::vector&lt;double&gt;&gt; M) {
	std::vector&lt;std::vector&lt;double&gt;&gt; planina;
	if(M.size() == 0) return M;
	if(M.at(0). size() == 0) return M;
<a name="1"></a><font color="#00FF00"><a href="match685-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	for (int i = 1; i &lt; M.size(); i++) 
		if(M.at(0).size() != M.at(i).size()) throw std::domain_error("Matrica nije korektna");
</font>	if(M.size() &lt; 3 || M.at(0).size() &lt; 3) {
		int max = M.at(0).at(0);
		for (int i = 0; i &lt; M.size(); i++) {
			for (int j = 0; j &lt; M.at(i).size(); j++) {
				if(max &lt; M.at(i).at(j)) max = M.at(i).at(j);
			}
		}
	   std::vector&lt;std::vector&lt;double&gt;&gt; vektor(1);
	   vektor.at(0).push_back(max);
	   return vektor;
	}
	if(M.size() == 3 &amp;&amp; M.at(0).size() == 3) return M;
	int m = M.size() - 1, n = M.at(0).size() - 1;
	if(M.size() == 3) {
		m++;
		planina.resize(3); planina.at(0).resize(3);  planina.at(1).resize(3);  planina.at(2).resize(3);
	}
	if(M.at(0).size()) n++;
	for (int i = 1; i &lt; m; i++) {
		if(i == M.size() - 1) break;
		for (int j = 1; j &lt; n; j++) {
			if(j == M.at(0).size() - 1) break;
			int zbir0 = 0, zbir1 = 0, k = 1;
<a name="0"></a><font color="#FF0000"><a href="match685-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

			zbir0 = M.at(i-1).at(j - 1) + M.at(i-1).at(j) + M.at(i-1).at(j+1) + M.at(i).at(j-1) + M.at(i).at(j+1) + M.at(i+1).at(j-1) + M.at(i+1).at(j) + M.at(i+1).at(j+1);
			
			if(zbir0 &lt; M.at(i).at(j)) {
</font>				if(M.size() == 3 || M.at(0).size() == 3) {
					if(M.at(i).at(j) &gt; planina.at(1).at(1)) {
						planina.at(0).at(0) =  M.at(i-1).at(j - 1); planina.at(0).at(1) =  M.at(i-1).at(j); planina.at(0).at(2) =  M.at(i-1).at(j + 1);
						planina.at(1).at(0) =  M.at(i).at(j - 1); planina.at(1).at(1) =  M.at(i).at(j); planina.at(1).at(2) =  M.at(i).at(j + 1);
						planina.at(2).at(0) =  M.at(i+1).at(j - 1); planina.at(2).at(1) =  M.at(i+1).at(j); planina.at(2).at(2) =  M.at(i+1).at(j + 1);	
					}
				}
				if((i - 2 &gt; 0 &amp;&amp; i + 2 &lt; M.size() &amp;&amp; j + 2 &lt; M.at(0).size() &amp;&amp; j - 2 &gt; 0)) {
					zbir1 = M.at(i-1-k).at(j - 1-k) + M.at(i-1-k).at(j) + M.at(i-1-k).at(j+1+k) + M.at(i).at(j-1-k) + M.at(i).at(j+1+k) + M.at(i+1+k).at(j-1-k) + M.at(i+1+k).at(j) + M.at(i+1+k).at(j+1+k);
					k++;
					while(zbir1 &lt; zbir0 &amp;&amp; i - 1 - k &gt; 0 &amp;&amp; i + 1 + k &lt; M.size() &amp;&amp; j + 1 + k &lt; M.at(0).size() &amp;&amp; j - 1 - k &gt; 0) {
						zbir0 = zbir1;
						zbir1 = M.at(i-1-k).at(j - 1-k) + M.at(i-1-k).at(j) + M.at(i-1-k).at(j+1+k) + M.at(i).at(j-1-k) + M.at(i).at(j+1+k) + M.at(i+1+k).at(j-1-k) + M.at(i+1+k).at(j) + M.at(i+1+k).at(j+1+k);
						k++;
					}
					if(zbir1 &gt;= zbir0) {
						if(k*2 + 1 &gt; planina.size()) {
							planina.resize(k*2 + 1);
							for(int h = i  - k; h &lt; i + 1 + k; h++) {
								planina.at(h - i  + k).resize(k*2 + 1);
								for(int f = i  - k; f &lt; i + 1 + k; f++)
									planina.at(h - i + k).at(f - i  + k) = M.at(h).at(f);
							}
						} else if (k*2 + 1 == planina.size()) {
							if(M.at(i).at(j) &gt; planina.at(planina.size() - (planina.size() - 1)/2 - 1).at(planina.size() - (planina.size() - 1)/2 - 1)) {
								planina.resize(k*2 + 1);
								for(int h = i  - k; h &lt; i + 1 + k; h++) {
									planina.at(h - i  + k).resize(k*2 + 1);
									for(int f = i  - k; f &lt; i + 1 + k; f++)
										planina.at(h - i  + k).at(f - i  + k) = M.at(h).at(f);
								}
							}
						}
					} else {
						if(k*2 + 1 &gt; planina.size()) {
							planina.resize(k*2 + 1);
							for(int h = i - k; h &lt; i + 1 + k; h++) {
								planina.at(h - i  + k).resize(k*2 + 1);
								for(int f = i - k; f &lt; i + 1 + k; f++)
									planina.at(h - i  + k).at(f - i  + k) = M.at(h).at(f);
							}
						} else if (k*2 + 1 == planina.size()) {
							if(M.at(i).at(j) &gt; planina.at(planina.size() - (planina.size() - 1)/2 - 1).at(planina.size() - (planina.size() - 1)/2 - 1)) {
								planina.resize(k*2 + 1);
								for(int h = i - 1 - k; h &lt; i + 2 + k; h++) {
									planina.at(h).resize(k*2 + 1);
									for(int f = i - 1 - k; f &lt; i + 2 + k; f++)
										planina.at(h).at(f) = M.at(h).at(f);
								}
							}
						}
					}
				}
			}
		}
	}
	return planina;
}

int main ()
{
	try {
		int m,n;
		std::cout &lt;&lt; "Unesite dimenzije matrice (m i n): ";
		std::cin &gt;&gt; m &gt;&gt; n;
		if(m &gt;= 0 &amp;&amp; n &gt;= 0) {
			auto M(UnesiMatricu(m,n));
			std::cout &lt;&lt; "Unesite elemente matrice:" &lt;&lt; std::endl;
			auto planina(NajvecaPlaninaMatrice(M));
			std::cout &lt;&lt; "Najveca planina unesene matrice je:" &lt;&lt; std::endl;
			for (int i = 0; i &lt; planina.size(); i++) {
				for (int j = 0; j &lt; planina.at(i).size(); j++) {
					std::cout &lt;&lt;  std::setw(6) &lt;&lt; planina.at(i).at(j);
				}
				std::cout &lt;&lt; std::endl;
			}
		} else {
			std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!";
		}
	}
	catch (const char error[]) {
		std::cout &lt;&lt; error &lt;&lt; std::endl;
	}
	
	return 0;
}</pre>
</body>
</html>
