<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student4770.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student4770.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica;
double suma_koncentricnih(Matrica v, int i , int j, int brojac)
{
	double suma(0);
	if(i+brojac&gt;=v.size() || j+brojac&gt;=v.at(i).size() || i-brojac&lt;0 || j-brojac&lt;0) return -100;
	for(int k=i-brojac; k&lt;=i+brojac; k++) {
		for(int l=j-brojac; l&lt;=j+brojac; l++) {
			if(k==i-brojac &amp;&amp; (l==j-brojac || l==j+brojac)) suma+=v.at(k).at(l);
			else if(k==i-brojac &amp;&amp; (l!=j-brojac || l!=j+brojac)) suma+=v.at(k).at(l);
			else if(k==i+brojac &amp;&amp; (l==j-brojac || l==j+brojac)) suma+=v.at(k).at(l);
			else if(k==i+brojac &amp;&amp; (l!=j-brojac || l!=j+brojac)) suma+=v.at(k).at(l);
			else if(l==j+brojac || l==j-brojac) suma+=v.at(k).at(l);
		}
	}

	return suma;

}
Matrica napravi_pod_matricu(Matrica v, int i, int j,int brojac)
{
	std::vector&lt;double&gt; pomocni;
	Matrica nova;
	for(int k=0; k&lt;v.size(); k++) {
		for(int l=0; l&lt;v.at(i).size(); l++) {
			if(k&gt;=i-brojac &amp;&amp; k&lt;=i+brojac &amp;&amp; l&gt;=j-brojac &amp;&amp; l&lt;=j+brojac)
				pomocni.push_back(v.at(k).at(l));

		}
		nova.push_back(pomocni);
		pomocni.resize(0);
	}

	return nova;
}
Matrica nadjimax(Matrica v)
{
<a name="0"></a><font color="#FF0000"><a href="match722-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

	double max=v.at(0).at(0);
	for(int i=0; i&lt;v.size(); i++) {
		for(int j=0; j&lt;v.at(i).size(); j++) {
			if(v.at(i).at(j)&gt;max) max=v.at(i).at(j);
		}
	}

	Matrica pomocna(1);
	pomocna.at(0).push_back(max);

	return pomocna;
</font>}
Matrica NajvecaPlaninaMatrice(Matrica v)
{
	if(v.size()==0) return {};
	bool prazan_vektor(true);
	for(int i=0;i&lt;v.size();i++){
		if(v.at(i).size()!=0) prazan_vektor=false;
	}
	if(prazan_vektor) return {};
<a name="1"></a><font color="#00FF00"><a href="match722-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	for(int i=0; i&lt;v.size(); i++) {
		if(v.at(i).size()!=v.at(0).size()) throw std::domain_error("Matrica nije korektna");
	}
	if(v.size()==0) return {};
</font>	if(v.size()==3) {

	}
	int brojac(0),max_brojac(0),max_i(0),max_j(0);
	for(int i=0; i&lt;v.size(); i++) {
		for(int j=0; j&lt;v.at(i).size(); j++) {
<a name="2"></a><font color="#0000FF"><a href="match722-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

			brojac=0;
			if(i-brojac&gt;=0 &amp;&amp; i+brojac&lt;v.size() &amp;&amp; j-brojac&gt;=0 &amp;&amp; j+brojac&lt;v.at(i).size()) {
</font>				if(v.at(i).at(j)&gt;suma_koncentricnih(v,i,j,1)) {
					while(suma_koncentricnih(v,i,j,brojac)&gt;suma_koncentricnih(v,i,j,brojac+1)) {
						brojac++;
						if(brojac+1==v.size()-1 || brojac+1==v.at(i).size()-1) break;
					}
					if(suma_koncentricnih(v,i,j,brojac)==-100) brojac--;
					if(brojac&gt;max_brojac) {
						max_brojac=brojac;
						max_i=i;
						max_j=j;
					}
					if(brojac==max_brojac) {
						if(v.at(i).at(j)&gt;v.at(max_i).at(max_j)) {
							max_i=i;
							max_j=j;
						} else if(v.at(i).at(j)==v.at(max_i).at(max_j)) {
							if(i&lt;max_i) {
								max_i=i;
								max_j=j;
							} else if(i==max_i) {
								if(j&lt;max_j) {
									max_j=j;
								}
							}
						}
					}
				}
			}
		}
	}
	Matrica planina(napravi_pod_matricu(v,max_i,max_j,max_brojac));
	int br(0);
	for(int i=0; i&lt;planina.size(); i++) {
		if(planina.at(i).size()!=0) br++;
	}
	if(br==1) planina=nadjimax(v);

	return planina;

}


int main ()
{
	try {
		std::cout&lt;&lt;"Unesite dimenzije matrice (m i n): ";
		int m,n;
		std::cin&gt;&gt;m&gt;&gt;n;
		if(m&lt;0 || n&lt;0) {
			std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";
			return 0;
		}
		std::cout&lt;&lt;"Unesite elemente matrice:";
		Matrica mat;
		for(int i=0; i&lt;m; i++) {
			std::vector&lt;double&gt; pomocni;
			for(int j=0; j&lt;n; j++) {
				int k;
				std::cin&gt;&gt;k;
				pomocni.push_back(k);
			}
			mat.push_back(pomocni);
		}
		
		Matrica f(NajvecaPlaninaMatrice(mat));
		std::cout&lt;&lt;std::endl&lt;&lt;"Najveca planina unesene matrice je:"&lt;&lt;std::endl;
		

		for(auto red : f) {
			for(auto k : red)
				std::cout&lt;&lt;std::setw(6)&lt;&lt;k;
			std::cout&lt;&lt;std::endl;
		}
	} catch(std::domain_error a) {
		std::cout&lt;&lt;a.what();
	}

	return 0;
}</pre>
</body>
</html>
