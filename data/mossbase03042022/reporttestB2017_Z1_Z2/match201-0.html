<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student2153.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student2153.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
<a name="0"></a><font color="#FF0000"><a href="match201-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std; //papak sam
typedef vector&lt;vector&lt;double&gt;&gt; Matrica;

bool JeLiPlanina(Matrica m, int pocx, int pocy, int krajx, int krajy){
	int srednjix((pocx+krajx)/2);
	int srednjiy((pocy+krajy)/2);
	double S(0);//pomocni element za sumiranje
	int n(1); 
	double a(m.at(srednjix).at(srednjiy));//a je vrijednost sred. elementa
	
	
	while(n&lt;=srednjix-pocx) {
		S=0;
		for(int i=srednjix-n; i&lt;=srednjix+n; i++){
			for(int j=srednjiy-n; j&lt;=srednjiy+n; j++){
				if(i==srednjix-n || i==srednjix+n || j==srednjix-n || j==srednjiy+n) 
				S=S+m.at(i).at(j);//sabira sve elemente u krugu oko srednjeg ukljucujuci i njega
			}
		}
		if(S&gt;a) return false;
		a=S;//sad a=S da bi mogla poredit opet
		n++;
	}
	return true;
}

Matrica NajvecaPlaninaMatrice(Matrica m){
	Matrica planina;
	int pocx(0), pocy(0), krajx(0), krajy(0), duzina(3), pom(0);//pom cuva vr najv do tada nadjene planine
	bool da(false);//u pocetku nema planine
	
	Matrica prazna;
	if(m.size()==0 || m[0].size()==0) {
		return prazna;
	}
	for(int i(0); i&lt;m.size(); i++){
		if(m.at(i).size()!=m.at(0).size()) throw domain_error("Matrica nije korektna");
	}
	while(duzina&lt;=m.size() &amp;&amp; duzina&lt;=m.at(0).size()){
	for(int i(0); i&lt;m.size()-duzina+1; i++){//ide po i sve do treceg odzada, povecavat ce se duzina 3,5,7...
		for(int j(0); j&lt;m.at(0).size()-duzina+1; j++){//krece se po j
			da=JeLiPlanina(m, i, j, i+duzina-1, j+duzina-1);
			if(duzina&gt;pom){//sacuva sve koordinate samo za najvecu do tad planinu 
			if(da){
				pocx=i;
				pocy=j;
				krajx=i+duzina-1;
				krajy=j+duzina-1;//kad nadjemo planinu cuvamo kordinate krajeva matrice planine
				pom=duzina;
			}
			}
			da=false;
			
		}
	}
		duzina+=2;
	}
	vector&lt;double&gt; pom1; 
	for(int i=pocx; i&lt;=krajx; i++){
		for(int j=pocy; j&lt;=krajy; j++){
			pom1.push_back(m.at(i).at(j));
		}
		planina.push_back(pom1);
		pom1.resize(0);
	} 
  if(planina.size()==1) {
  	double pom2(planina.at(0).at(0));
  	for(int i(0); i&lt;m.size(); i++){
  		for(int j(0); j&lt;m.at(0).size(); j++){
  			if(m.at(i).at(j)&gt;pom2) {
  				
  				planina.at(0).at(0)=m.at(i).at(j);
  			}
  		}
  	}
  }
	return planina;
}

int main ()
{
	int m, n;
	
	cout&lt;&lt;"Unesite dimenzije matrice (m i n): ";
	cin&gt;&gt;m&gt;&gt;n;
	if(m&lt;0 || n&lt;0) {
		cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";	
		return 0;
	}
	
	Matrica mat(m);
	for(int i(0); i&lt;m; i++) {
		mat.at(i).resize(n);
	}
	if(n&gt;0 &amp;&amp; m&gt;0){
	cout&lt;&lt;"Unesite elemente matrice:";
	for(int i(0); i&lt;m; i++){
		for(int j(0); j&lt;n; j++){
			cin&gt;&gt;mat.at(i).at(j);
		}
	}
	
	
	Matrica test2(NajvecaPlaninaMatrice(mat));
	cout&lt;&lt;endl&lt;&lt;"Najveca planina unesene matrice je:"&lt;&lt;endl;
	for(int i(0); i&lt;test2.size(); i++){
		for(int j(0); j&lt;test2.at(0).size(); j++){
			cout&lt;&lt;setw(6)&lt;&lt;test2.at(i).at(j);
		}
		cout&lt;&lt;endl;
</font>	}
}
	return 0;
}</pre>
</body>
</html>
