<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student2477.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student6259.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match189-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::domain_error;
using std::setw;

typedef vector&lt;vector&lt;double&gt;&gt; Matrica;

double Vrati_zbir_koncentricnog_kvadrata(Matrica M, int m, int n) {
	
	double zbir(0);
	
	for(int i(m); i &lt; n + 1; i++) 
		for(int j(m); j &lt; n + 1; j++)
			if(i == m || i == n  || ((j == m || j == n)  &amp;&amp; (i &gt; m &amp;&amp; i &lt; n))) zbir += M.at(i).at(j);
	
	return zbir;
}


Matrica NajvecaPlaninaMatrice(Matrica M) {
	Matrica N;
	
	if(M.size() == 0 || M.at(0).size() == 0) return N;
		
	for(int i(0); i &lt; M.size() - 1; i++) {
		if(M.at(i + 1).size() != M.at(i).size() ) throw domain_error ("Matrica nije korektna");
	}
	
	if(M.size() &lt; 3 &amp;&amp; M.at(0).size() &lt; 3) {
		int max(M.at(0).at(0));
		for(int i(0); i &lt; M.size(); i++) 
			for(int j(0); j &lt; M.at(0).size(); j++)
				if(max &lt; M.at(i).at(j)) max = M.at(i).at(j);
		
		N.resize(1);
		N.at(0).push_back(max);
		return N;
	}
	
	double pom(0), pom2(1000);
	
	for(int i(1); i &lt; M.size() - 1; i++) 
		for(int j(1); j &lt; M.at(0).size() - 1; j++) {
			double vrh(M.at(i).at(j));
			int jj(-1), ii(-1);

			pom = Vrati_zbir_koncentricnog_kvadrata(M, i - 1, j + 1);
			
			if(vrh &gt; pom) {
				ii = i - 1;
				jj = j + 1;
			do{
				pom = Vrati_zbir_koncentricnog_kvadrata(M, i - 1, j + 1);
				if( i &gt; 1  &amp;&amp; j &lt; M.at(0).size() - 1) {
					i--;
				    j++;
					pom2 = Vrati_zbir_koncentricnog_kvadrata(M, i - 1, j + 1);
				
					ii = i + 1; 
					jj = j - 1;
				}
			}
			
			while(pom2 &lt; pom &amp;&amp; i &lt; M.size()  &amp;&amp; j &lt; M.at(0).size());
			}
			
			if(jj != -1 &amp;&amp; ii != -1) {
				N.resize(jj - ii + 1);
				for(int i(0); i &lt; N.size(); i++)
					N.at(i).resize(jj - ii + 1);
			
			
				for(int i(0); i &lt; jj - ii + 1; i++) {
					int jjj(ii);
					for(int j(0); j &lt; jj - ii + 1; j++){
						N.at(i).at(j) = M.at(ii + i).at(jjj);
						jjj++;
					}
				}
			}
		}
	
	
	return N;
	
}


int main ()
{
	int m, n;
	cout &lt;&lt; "Unesite dimenzije matrice (m i n): ";
	cin &gt;&gt; m &gt;&gt; n;
	
	if(m &lt; 0 || n &lt; 0) {
		cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!";
		return 0;
	}
	
	Matrica M(m, vector&lt;double&gt; (n));
	cout &lt;&lt; "Unesite elemente matrice: ";
	for(int i(0); i &lt; m; i++) {
		for(int j(0); j &lt; n; j++) {
			cin &gt;&gt; M.at(i).at(j);
		}
	}

	try {
		Matrica N(NajvecaPlaninaMatrice(M));
		cout &lt;&lt; "\nNajveca planina unesene matrice je: " &lt;&lt; endl;
	
		for(auto red : N) {
			for(auto x : red) cout &lt;&lt; setw(6) &lt;&lt; x ;
			cout &lt;&lt; endl;
		}
	}
	
	catch(domain_error izuzetak) {
		cout &lt;&lt; izuzetak.what();
</font>	}
	
	return 0;
}</pre>
</body>
</html>
