<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student2267.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student2267.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include&lt;iomanip&gt;
#define eps 0.00001

bool Poredi (double a, double b) {
	return fabs(a - b) &lt; eps;
}

std::vector&lt;std::vector&lt;double&gt;&gt; NajvecaPlaninaMatrice (std::vector&lt;std::vector&lt;double&gt;&gt; matrica) {
	std::vector&lt;std::vector&lt;double&gt;&gt; Planina, pomocnaPlanina;
	
	if (matrica.size() == 0) {
		return Planina;
	}
	
	for (int i = 0; i &lt; matrica.size(); i++) {
		if (matrica.at(i).size() != matrica.at(0).size()) {
			throw std::domain_error ("Matrica nije korektna");
		}
	}
	
	
	int i,j,k,l=0, korak(3);
	double suma=0, novaSuma(0);
	for(i=0; i&lt;matrica.size(); i++) {
		for(j=0; j&lt;matrica.size(); j++) {
			
			if (i == 0 || i == matrica.size()-1 || j == 0 || j == matrica.at(0).size()-1) {
				continue;
			}
			k=i-1;
			l=j-1;
			
			for(int m=k; m&lt;k+3; m++) { //prva 3*3
				for(int n=l; n&lt;l+3; n++) {
					if(m == i &amp;&amp; n == j) {
						continue;
					}
					else {
						suma+=matrica.at(m).at(n);
					}
				}
			}
			if (suma &lt; matrica.at(i).at(j)) {
			
				if (k == 0 || l == 0) {
					int g(0);
					pomocnaPlanina.resize(korak);
					for (int m = k; m &lt; k+korak; m++) {
						pomocnaPlanina.at(g++).resize(0);
						for(int n=k; n&lt;l+korak; n++) {
							pomocnaPlanina.at(m).push_back(matrica.at(m).at(n));
						}
					}
				} else {
					ponovo:
					k--;
					l--;
					novaSuma = suma;
					korak += 2;
					if (k &lt; 0 || korak &gt; matrica.size() || korak &gt; matrica.at(0).size()) {
						break;
					}
					
					for (int m = k; m &lt; k+korak; k++) {
						for(int n=k; n&lt;l+korak; n++) {
							if (k == m || l == n || m == k+korak-1 || n == l+korak-1) {
								suma+=matrica.at(m).at(n);
							}
						}
					}
					if (suma &lt; novaSuma) {
						pomocnaPlanina.resize(korak);
						int g=0;
						for (int m = k; m &lt; k+korak; m++) {
							pomocnaPlanina.at(g++).resize(korak);
							for (int n = l; n &lt; l+korak; n++) {
								pomocnaPlanina.at(m).push_back(matrica.at(m).at(n));
							}
						}
						if (k != 0 || l != 0) {
							goto ponovo;
						}
					} else {
						break;
					}
					
				}
				
			}
			if (pomocnaPlanina.size() &gt; Planina.size()) {
				
				Planina.resize(pomocnaPlanina.size());
				for (int m = 0; m &lt; pomocnaPlanina.size(); m++) {
					Planina.at(m).resize(pomocnaPlanina.at(0).size());
					for (int n = 0; n &lt; pomocnaPlanina.at(0).size(); n++) {
						Planina.at(m).at(n) = pomocnaPlanina.at(m).at(n);
					}
				}
			} else if (pomocnaPlanina.size() == Planina.size()) {
				int a((Planina.size()/2)+1), b((pomocnaPlanina.size()/2)+1);
				if (Poredi(Planina.at(a).at(a), pomocnaPlanina.at(b).at(b))) {
					Planina.resize(pomocnaPlanina.size());
					for (int m = 0; m &lt; pomocnaPlanina.size(); m++) {
						Planina.at(m).resize(pomocnaPlanina.at(0).size());
						for (int n = 0; n &lt; pomocnaPlanina.at(0).size(); n++) {
							Planina.at(m).at(n) = pomocnaPlanina.at(m).at(n);
						}
					}
				}
			}
		}
	}
	return Planina;
}
int main ()
{
	try {

		std::vector&lt;std::vector&lt;double&gt;&gt; mat;
		int m, n;
		double element;
		std::cout &lt;&lt; "Unesite dimenzije matrice (m i n): ";
<a name="0"></a><font color="#FF0000"><a href="match794-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

		std::cin&gt;&gt;m&gt;&gt;n;
		 if (m&lt;0 ||  n&lt;0)
		{ std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!"; return 0; }
		
	
		
		std::cout &lt;&lt; "Unesite elemente matrice: " &lt;&lt; std::endl;
		mat.resize(m);
		for (int i = 0; i &lt; m; i++) {
			for (int j = 0; j &lt; n; j++) {
				std::cin &gt;&gt; element;
				mat.at(m).push_back(element);
</font>			}
		}	
<a name="2"></a><font color="#0000FF"><a href="match794-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		std::vector&lt;std::vector&lt;double&gt;&gt; planina(NajvecaPlaninaMatrice(mat));
		std::cout&lt;&lt;"Najveca planina unesene matrice je"&lt;&lt;std::endl;
		for (int i = 0; i &lt; planina.size(); i++) {
			for (int j = 0; j &lt; planina.size(); j++) {
</font><a name="1"></a><font color="#00FF00"><a href="match794-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

				std::cout &lt;&lt;std::setw(6)&lt;&lt; planina.at(i).at(j);
			}
			std::cout &lt;&lt; std::endl;
		}
		
	}
	catch (std::domain_error error) {
		std::cout &lt;&lt; error.what() &lt;&lt; std::endl;
</font>	}
	
	
	
	return 0;
}</pre>
</body>
</html>
