<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student3568.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student5861.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;

<a name="2"></a><font color="#0000FF"><a href="match561-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica;

double SumaClanovaKvadrata(Matrica matrica, int i, int j, int a)
{
	double suma1 = 0;
</font>	double suma2 = 0;
	double suma3 = 0;
	double suma4 = 0;
	for(int k=0; k&lt;2*a+1; k++) {
		suma1 = suma1 + matrica.at(i-a).at(j-a+k);
		suma2 = suma2 + matrica.at(i+a).at(j-a+k);
		suma3 = suma3 + matrica.at(i-a+k).at(j-a);
		suma4 = suma4 + matrica.at(i-a+k).at(j+a);
	}
	double suma = suma1 + suma2 + suma3 + suma4 - (matrica.at(i-a).at(j-a) + matrica.at(i-a).at(j+a) + matrica.at(i+a).at(j-a) + matrica.at(i+a).at(j+a));
<a name="0"></a><font color="#FF0000"><a href="match561-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

	return suma;
}

/*bool ProvjeraDaLiJeOpadajuciNiz(std::vector&lt;double&gt; niz)
{
	for(int i=0; i&lt;niz.size()-1; i++) {
		if(niz.at(i)&lt;niz.at(i+1)) {
			return false;
		}
	}
	return true;
}*/

Matrica PiramidalnaMatrica(Matrica matrica, int i, int j, int n)
{
	Matrica piramidalnaMatrica(2*n+1, std::vector&lt;double&gt;(2*n+1));
	for(int k=0; k&lt;2*n+1; k++) {
		for(int m=0; m&lt;2*n+1; m++) {
			piramidalnaMatrica.at(k).at(m)=matrica.at(i-n+k).at(j-n+m);
</font>		}
	}
	return piramidalnaMatrica;
}

void printajMatricu(Matrica matrica)
{
	for(auto red : matrica) {
		for(auto clan : red)
			std::cout&lt;&lt;std::setw(6)&lt;&lt;clan;
		std::cout&lt;&lt;std::endl;
	}
}
/*void dodajOsobine(std::vector&lt;double&gt; osobineNM, std::vector&lt;double&gt; osobinePM)
{
	osobinePM.clear();
	osobinePM.push_back(osobineNM.at(0));
	osobinePM.push_back(osobineNM.at(1));
	osobinePM.push_back(osobineNM.at(2));
	osobinePM.push_back(osobineNM.at(3));
}*/

bool DaLiJeNadjenaNovaMatrica(std::vector&lt;double&gt; osobineNM, std::vector&lt;double&gt; osobinePM)
{
	if(osobineNM.at(0) &gt; osobinePM.at(0)) {
		return true;
	} else if((osobineNM.at(0)==osobinePM.at(0)) &amp;&amp; (osobineNM.at(1))&gt;osobinePM.at(1)) {
		return true;
	} else if((osobineNM.at(0)==osobinePM.at(0))&amp;&amp;(osobineNM.at(1)==osobinePM.at(1)) &amp;&amp; osobineNM.at(2)&lt;osobinePM.at(2)) {
		return true;
	} else if((osobineNM.at(0)==osobinePM.at(0))&amp;&amp;(osobineNM.at(1)==osobinePM.at(1)) &amp;&amp; (osobineNM.at(2)==osobinePM.at(2)) &amp;&amp; osobineNM.at(3)&lt;osobinePM.at(3)) {
		return true;
	} else {
		return false;
	}
}
int UdaljenostPozicijeOdRubaMatrice(Matrica matrica, int i, int j)
{
	int r = matrica.size();
	int c = matrica.at(0).size();
	int n = std::min(i,j);
	n = std::min(n, r-i-1);
	n = std::min(n, c-j-1);
	return n;
}

bool DaliSeNaDatojPozicijiNalaziPiramidalnaMatrica(Matrica matrica, int i, int j)
{
	int n = UdaljenostPozicijeOdRubaMatrice(matrica, i, j);
	if(n==0) return true;
	double prethodniKvadrat = matrica.at(i).at(j);

	for(int k=n; k&gt;0; k--) {
		double trenutniKvadrat = SumaClanovaKvadrata(matrica, i, j, n-k+1);
		if(prethodniKvadrat&gt;trenutniKvadrat) {
			prethodniKvadrat = trenutniKvadrat;
		} else
			return false;
		if(k==1) {
			return true;
		}
	}
}

Matrica NajvecaPlaninaMatrice(Matrica matrica)
{
	Matrica piramidalnaMatrica;
	bool novaMatricaPronadjena = false;
	bool matricaPronadjena = false;
	std::vector&lt;double&gt; osobinePrethodneMatrice = {0, 0, 0, 0};
	std::vector&lt;double&gt; osobineNoveMatrice;


	int r = matrica.size();
	int c = matrica.at(0).size();
	//int prethodniKvadrat;
	//int trenutniKvadrat;

	for(int i=0; i&lt;r; i++) {
		for(int j=0; j&lt;c; j++) {
			if(matrica.at(i).size()!=c)
				throw std::domain_error("Matrica nije korektna");
		}
	}
	for(int i=0; i&lt;r; i++) {
		for(int j=0; j&lt;c; j++) {
			novaMatricaPronadjena = false;

			int n = UdaljenostPozicijeOdRubaMatrice(matrica, i, j);


			int prethodniKvadrat = matrica.at(i).at(j);

			novaMatricaPronadjena = DaliSeNaDatojPozicijiNalaziPiramidalnaMatrica(matrica, i, j);

			if(novaMatricaPronadjena) {
				osobineNoveMatrice = {double(n), matrica.at(i).at(j), double(i), double(j)};
				matricaPronadjena = true;
			}

			if(novaMatricaPronadjena &amp;&amp; DaLiJeNadjenaNovaMatrica(osobineNoveMatrice, osobinePrethodneMatrice)) {
				piramidalnaMatrica = PiramidalnaMatrica(matrica, i, j, n);
				//dodajOsobine(osobineNoveMatrice, osobinePrethodneMatrice);
				osobinePrethodneMatrice.clear();
				osobinePrethodneMatrice.push_back(osobineNoveMatrice.at(0));
				osobinePrethodneMatrice.push_back(osobineNoveMatrice.at(1));
				osobinePrethodneMatrice.push_back(osobineNoveMatrice.at(2));
				osobinePrethodneMatrice.push_back(osobineNoveMatrice.at(3));
			}
		}
	}
	if(matricaPronadjena == false) {
		Matrica praznaMatrica(0, std::vector&lt;double&gt;(0));
		return praznaMatrica;
	}
	return piramidalnaMatrica;
}

Matrica NapraviMatricu()
{
	int m;
	int n;
	double clan;
	std::cout&lt;&lt;"Unesite dimenzije matrice (m i n): ";
	std::cin&gt;&gt;m&gt;&gt;n;
	if(m&lt;0 || n&lt;0) {
		std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";
		Matrica matrica;
		return matrica;
	} else {
<a name="1"></a><font color="#00FF00"><a href="match561-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

		Matrica matrica(m, std::vector&lt;double&gt;(n));
		std::cout&lt;&lt;"Unesite elemente matrice: ";
		for(int i = 0; i &lt; m; i++) {
			for(int j=0; j&lt;n; j++) {
</font>				std::cin&gt;&gt;clan;
				matrica.at(i).at(j)=clan;
			}
		}
		return matrica;
	}

}
int main()
{
	Matrica matrica = NapraviMatricu();
	if(matrica.empty()) return 0;

	Matrica a;
	try {
		std::cout&lt;&lt;"\nNajveca planina unesene matrice je: \n";
		a = NajvecaPlaninaMatrice(matrica);
	} catch (std::domain_error e) {
		std::cout &lt;&lt; e.what();
	}

	printajMatricu(a);

	return 0;
}</pre>
</body>
</html>
