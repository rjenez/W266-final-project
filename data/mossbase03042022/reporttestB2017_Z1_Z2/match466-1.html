<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student2176.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student3572.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;
#include &lt;stdexcept&gt;

typedef std::vector&lt;std::vector&lt;double&gt;&gt; matrica;
const double epsilon = 0.000001;

std::vector&lt;double&gt; Vecaplanina (std::vector&lt;double&gt; a, std::vector&lt;double&gt; b)
{
	if(a.at(1)&gt;b.at(1)) return a;
	if(a.at(1)&lt;b.at(1)) return b;
	if(a.at(1)-b.at(1)&lt;epsilon) {
		if(a.at(2)&lt;b.at(2)) return a;
		if(a.at(2)&gt;b.at(2)) return b;
		if(a.at(2)-b.at(2)&lt;epsilon) return b;
		{
			if(a.at(3)&lt;b.at(3)) return a;
			if(a.at(3)&gt;b.at(3)) return b;
		}
	}
}
std::vector&lt;double&gt; Najveci(matrica a)
{
	for(int i=0; i&lt;a.size()-1; i++) {
		if(a.at(0).at(0)&gt;a.at(1).at(0)) return a.at(0);
		if(abs(a.at(0).at(0)-a.at(1).at(0))&lt;epsilon) {
			a.at(1)=Vecaplanina(a.at(0),a.at(1));
			a.erase(a.begin()+0);
		}
	}
	return a.at(0);
}

matrica KreirajMatricu(int a,int b)
{
	matrica m;
	if(a==0 || b==0) return m;
	if(a&lt;0 || b&lt;0) throw std::domain_error("Dimenzije matrice moraju biti nenegativne!");
	return matrica(a,std::vector&lt;double&gt; (b));
}

bool Planina(std::vector&lt;std::vector&lt;double&gt;&gt; a)
{
	int x=a.size()/2;
	int koncentricni {0};
	std::vector&lt;double&gt; planina;
	planina.push_back(a.at(x).at(x));
	for(int k=0; k&lt;x; k++) {
		for(int i=0; i&lt;a.size(); i++) {
			for(int j=0; j&lt;a.size(); j++) {
				if((i&gt;=x-k-1 &amp;&amp; i&lt;=x+k+1 &amp;&amp; (j==x-k-1||j==x+k+1)) || (j&gt;=x-k-1 &amp;&amp; j&lt;=x+k+1 &amp;&amp; (i==x-k-1 || i==x+k+1))) koncentricni+=a.at(i).at(j);
			}
		}
		planina.push_back(koncentricni);
		koncentricni=0;
	}
	for(int i=0; i&lt;planina.size()-1; i++) {
		if(planina.at(i)&lt;planina.at(i+1))return false;
	}
	return true;
}

std::vector&lt;std::vector&lt;double&gt;&gt;MaxElement(matrica a){
	double max(a.at(0).at(0));
<a name="0"></a><font color="#FF0000"><a href="match466-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	for(int i=0;i&lt;a.size();i++){
		for(int j=0;j&lt;a.at(0).size();j++){
			if(a.at(i).at(j)&gt;max)max=a.at(i).at(j);
		}
	}
	return (matrica(1,std::vector&lt;double&gt; (1,max)));
</font>}

std::vector&lt;std::vector&lt;double&gt;&gt; NajvecaPlaninaMatrice(matrica a)
{
	if(a.size()==0 || a.at(0).size()==0) return KreirajMatricu(0,0);
	
	int redovi=a.size();
	int kolone=a[0].size();
	if(redovi==1 &amp;&amp; kolone==1) return a;
	if(redovi&lt;3 &amp;&amp; kolone&lt;3) return MaxElement(a);
	for(int i=0; i&lt;a.size(); i++) {
		if(a.at(i).size()!=a.at(0).size()) throw std::domain_error("Matrica nije korektna");
	}
	int n {0};
	std::vector&lt;double&gt; sacuvaj;
	if(redovi==kolone) {
		n=redovi;

	} else if(redovi&lt;kolone) n=redovi;
	else n=kolone;
	if(n%2==0) n-=1;
	matrica sveplanine;
	matrica planina;
	std::vector&lt;double&gt; x;
	for(int dim=n; dim&gt;=3; dim-=2) {
		for(int k=0; k&lt;=redovi-dim; k++) {
			for(int z=0; z&lt;=kolone-dim; z++) {
				for(int i=0+k; i&lt;dim+k; i++) {
<a name="2"></a><font color="#0000FF"><a href="match466-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

					for(int j=0+z; j&lt;dim+z; j++) {
						x.push_back(a.at(i).at(j));
					}
					planina.push_back(x);
					x.resize(0);
</font>				}
				if(Planina(planina)) {
					sacuvaj.push_back(dim);
				    sacuvaj.push_back(planina.at((dim+k)/2).at((dim+z)/2));
				    //else sacuvaj.push_back(planina.at(0).at(0));
					sacuvaj.push_back(k);
					sacuvaj.push_back(z);
					sveplanine.push_back(sacuvaj);
					sacuvaj.resize(0);
					planina.resize(0);
				} else planina.resize(0);
			}
		}
	}
	if(sveplanine.size()==0) return matrica(KreirajMatricu(0,0));
	sacuvaj=Najveci(sveplanine);
//	planina=KreirajMatricu(sacuvaj.at(0),sacuvaj.at(0));
	for(int i=sacuvaj.at(2); i&lt;sacuvaj.at(0)+sacuvaj.at(2); i++) {
		for(int j=sacuvaj.at(3); j&lt;sacuvaj.at(0)+sacuvaj.at(3); j++) {
			x.push_back(a.at(i).at(j));
		}
		planina.push_back(x);
		x.resize(0);
	}
	return planina;
}


int main ()
{
	try {
		std::cout&lt;&lt;"Unesite dimenzije matrice (m i n): ";
		int m,n;
		std::cin&gt;&gt;m&gt;&gt;n;
		matrica a(KreirajMatricu(m,n));
<a name="1"></a><font color="#00FF00"><a href="match466-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

		std::cout&lt;&lt;"Unesite elemente matrice: "&lt;&lt;std::endl;
		for(int i=0; i&lt;m; i++) {
			for(int j=0; j&lt;n; j++) {
				std::cin&gt;&gt;a.at(i).at(j);
</font>
			}
		}

<a name="3"></a><font color="#00FFFF"><a href="match466-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

		a=NajvecaPlaninaMatrice(a);
		std::cout&lt;&lt;"Najveca planina unesene matrice je:"&lt;&lt;std::endl;
		for(int i=0; i&lt;a.size(); i++) {
			for(int j=0; j&lt;a.at(0).size(); j++) {
</font><a name="4"></a><font color="#FF00FF"><a href="match466-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

				std::cout&lt;&lt;std::right&lt;&lt;std::setw(6)&lt;&lt;a.at(i).at(j);
			}
			std::cout&lt;&lt;std::endl;
		}
	} catch(std::domain_error e) {
		std::cout&lt;&lt;e.what();
	}
	return 0;
</font>}</pre>
</body>
</html>
