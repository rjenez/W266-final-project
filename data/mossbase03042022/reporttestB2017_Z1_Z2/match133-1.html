<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student5961.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student7795.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;limits&gt;

/* typedefs of arrays and matrices */
<a name="0"></a><font color="#FF0000"><a href="match133-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using DubArr = std::vector&lt;double&gt;;
using Mat = std::vector&lt;DubArr&gt;;

/* define structure of metaSubMatrix */
struct plMatrix {
     int midX, midY;
     int dimension;   
};

/* return greatest possible size of matrix */
int MaxDefaultSize(int a, int b) {
     int max{(a &lt; b) ? a : b};
     
     if(max == 0) return 0;
     if(max % 2 == 0) return max-1;
     return max;
}

/* elements sum of submatrix */
double SubMatrixSum(const Mat &amp;matrix, const plMatrix &amp;submatrix) {
     double _sum {0.};
     
     for(int i {submatrix.midX - submatrix.dimension}; i &lt;= submatrix.midX + submatrix.dimension; ++i)
          for(int j {submatrix.midY - submatrix.dimension}; j &lt;= submatrix.midY + submatrix.dimension; ++j)
               _sum = _sum + matrix.at(i).at(j);
     
     return _sum;
}

/* check the validity of matrix | ReturnValues = (-1 if 0xM or Mx0, 0 if non-matrix, 1 if valid matrix) */
int ValidMatrix(const Mat &amp;matrix) {
     if(matrix.empty()) return -1; 
     
     /* check validty of nonzero matrix */
     int _rowSize = static_cast&lt;int&gt;(matrix.at(0).size());
     if(_rowSize == 0) return -1;
     
     for(int i = 1; i &lt; matrix.size(); ++i)
          if(_rowSize != static_cast&lt;int&gt;(matrix.at(i).size())) return 0;
          
     return 1;
}

/* function to check if submatrix is mountain */
bool isMatrixMountain(const Mat &amp;matrix, const plMatrix &amp;submatrix) {
     double _previousSquare = SubMatrixSum(matrix, plMatrix {submatrix.midX, submatrix.midY, 0});
     double _nextSquare;
     double _shift{.0};
  
     /* check if submatrix is mountain */
     for(int i {1}; i &lt;= submatrix.dimension; ++i) {
          _nextSquare = SubMatrixSum(matrix, plMatrix {submatrix.midX, submatrix.midY, i});
          /* iff condition for mountain matrix */
          if((_nextSquare-_previousSquare) &gt;= (_previousSquare-_shift)) 
               return false;
               
          _shift = _previousSquare;
          _previousSquare = _nextSquare;
     }
     /* return default value */
     return true;
}

/* function to create matrix using passed struct object */
Mat CreateMatrixUsingStructure(const Mat &amp;matrix, const plMatrix &amp;submatrix) {
     /* instance for 0 dimension */
     if(submatrix.dimension == 0) return {{matrix.at(submatrix.midX).at(submatrix.midY)}};
     
     Mat output;
     DubArr temp;
     
     /* generate a matrix by the given structure */
     for(int i {submatrix.midX - submatrix.dimension}; i &lt;= submatrix.midX + submatrix.dimension; ++i) {
          for(int j {submatrix.midY - submatrix.dimension}; j &lt;= submatrix.midY + submatrix.dimension; ++j)
               temp.push_back(matrix.at(i).at(j));
          output.push_back(temp);
          temp.clear();
     }
     
     return output;
}

/* find the biggest mountain within a matrix */
Mat NajvecaPlaninaMatrice(const Mat &amp;matrix) {
     int _check {ValidMatrix(matrix)};
     plMatrix outputSubMatrix;
          
     /* check validity of matrix first */
     if(_check == -1) return (Mat {});
     else if(_check == 0) throw std::domain_error("Matrica nije korektna");
     else {
          /* create subMatrix to save info about */
          plMatrix tempSub;
          bool _subSet {false}; // paramater for the return value
     
          /* initiate the size parameters for submatrix search */
          int sizeX {static_cast&lt;int&gt;(matrix.size())};
          int sizeY {static_cast&lt;int&gt;(matrix.at(0).size())};
          
          /* start searching for the submatrices */
          for(int dimension {MaxDefaultSize(sizeX, sizeY)}; dimension &gt;= 0; --dimension) 
          {
               for(int i {dimension}; i &lt; (sizeX-dimension); ++i) {
                    for(int j {dimension}; j &lt; (sizeY-dimension); ++j) {
                         /* start searching for submatrices */
                         tempSub = {i, j, dimension};
                         if(isMatrixMountain(matrix, tempSub)) {
                              /* insert default value */
                              if(!_subSet) {
                                   outputSubMatrix = tempSub;
                                   _subSet = true;
                              }
                              else {
                                   if(tempSub.dimension &gt; outputSubMatrix.dimension)      outputSubMatrix = tempSub;
                                   else if(tempSub.dimension == outputSubMatrix.dimension) 
                                   {
                                        if(matrix.at(outputSubMatrix.midX).at(outputSubMatrix.midY) &lt; matrix.at(i).at(j))
                                             outputSubMatrix = tempSub;
                                        else if(outputSubMatrix.midX &gt; i)
                                             outputSubMatrix = tempSub;
                                        else if(outputSubMatrix.midX == i &amp;&amp; outputSubMatrix.midY &gt; j)
                                             outputSubMatrix = tempSub;
                                   }
                              }
                         }
                    }
               }
          }
     }
     /* output value */
     return (CreateMatrixUsingStructure(matrix, outputSubMatrix));
}

/* function to print matrix */
void PrintMatrix(const Mat &amp;matrix) {
     for(auto row: matrix) {
          for(auto element: row) 
               std::cout &lt;&lt; std::right &lt;&lt; std::setw(6) &lt;&lt; element;
          std::cout &lt;&lt; '\n';
     }
}

/* implementing main function here */
int main () {
     /* input */
     int m, n;
     std::cout &lt;&lt; "Unesite dimenzije matrice (m i n): ";
     std::cin &gt;&gt; m &gt;&gt; n;
     if(m &lt; 0 || n &lt; 0) {
          std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!";
          return 0;
     }
     
     std::cout &lt;&lt; "Unesite elemente matrice:";
     Mat matrica;
     DubArr red;
     double num;
     for(int i{0}; i &lt; m; i++) {
          
          for(int j{0}; j &lt; n; j++) {
               std::cin &gt;&gt; num;
               red.push_back(num);
          }
          matrica.push_back(red);
          red.clear();
     }
     try {
          std::cout &lt;&lt; std::endl &lt;&lt; "Najveca planina unesene matrice je:" &lt;&lt; std::endl;
          Mat output {NajvecaPlaninaMatrice(matrica)};
          PrintMatrix(output);
     }
     catch(std::domain_error &amp;e) {
          std::cout &lt;&lt; e.what();
</font>     }
	return 0;
}</pre>
</body>
</html>
