<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student3542.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student3542.cpp<p></p><pre>
/*B 2017/2018, ===TITLE===
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: student3542@etf.unsa.ba.	
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

int min(int a, int b, int c, int d)
{
    int e(a &lt; b ? a : b), f(c &lt; d ? c : d);
    return e &lt; f ? e : f;
}

std::vector&lt;std::vector&lt;double&gt;&gt; NajvecaPlaninaMatrice(std::vector&lt;std::vector&lt;double&gt;&gt; matrica)
{
    if (matrica.empty()) 
    	return std::vector&lt;std::vector&lt;double&gt;&gt;();

    for (std::vector&lt;double&gt; vektor : matrica)
		if (vektor.size() != matrica.at(0).size())
			throw std::domain_error("Matrica nije korektna");
			
    if (!matrica.at(0).size()) 
    	return std::vector&lt;std::vector&lt;double&gt;&gt;();
    	
    //Glavni dio
    int maxdim(0), maxvrh(0), x, y;
    for (int i(0); i &lt; matrica.size(); i++)
        for (int j(0); j &lt; matrica.at(0).size(); j++)
        {
            int prethodni(matrica.at(i).at(j)), max(min(i, j, matrica.size() - 1 - i, matrica.at(0).size() - 1 - j)), d(0), dim(0);
<a name="0"></a><font color="#FF0000"><a href="match631-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

            while (++d &lt;= max)
            {
                //Racunanje zbira elemenata d-tog koncentricnog kvadrata
                double s(0);
                for (int k(i-d); k &lt;= i+d; k++)
                    for (int l(j-d); l &lt;= j+d; l++)
                        if (k == i-d || k == i+d || l == j-d || l == j+d)
                            s += matrica.at(k).at(l);
                if (s &lt; prethodni) 
                	prethodni = s;
</font>                else break;
            }
            dim = 2*d - 1;
            //Postavljanje novog kandidata
            if (dim &gt; maxdim || (dim == maxdim &amp;&amp; matrica.at(i).at(j) &gt; maxvrh))
                maxvrh = matrica.at(i).at(j), maxdim = dim, x = i - d + 1, y = j - d + 1;
        }
    std::vector&lt;std::vector&lt;double&gt;&gt; tmp(maxdim);
<a name="1"></a><font color="#00FF00"><a href="match631-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    for (int i(x); i &lt; x + maxdim; i++)
        for (int j(y); j &lt; y + maxdim; j++)
            tmp.at(i-x).push_back(matrica.at(i).at(j));
</font>    return tmp;
}

int _main ()
{
    int m, n;
    std::cout &lt;&lt; "Unesite dimenzije matrice (m i n): ";
    if (!(std::cin &gt;&gt; m &gt;&gt; n), m &lt; 0 || n &lt; 0)
    {
        std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!";
        return 0;
    }
    
    std::cout &lt;&lt; "Unesite elemente matrice:\n";
    std::vector&lt;std::vector&lt;double&gt;&gt; matrica(m, std::vector&lt;double&gt;(n));
    for (std::vector&lt;double&gt; &amp;red : matrica)
        for (double &amp;el : red)
            std::cin &gt;&gt; el;
            
    std::cout &lt;&lt; "Najveca planina unesene matrice je:" &lt;&lt; std::endl;
    matrica = NajvecaPlaninaMatrice(matrica);
    
<a name="2"></a><font color="#0000FF"><a href="match631-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

    for (std::vector&lt;double&gt; red : matrica)
    {
        for (double element : red)
            std::cout &lt;&lt; std::setw(6) &lt;&lt; element;
        std::cout &lt;&lt; std::endl;
</font>    }
	return 0;
}


std::vector&lt;std::vector&lt;double&gt;&gt; PomocnaFunkcija (std::vector&lt;std::vector&lt;double&gt;&gt; m)
    {
        size_t br = m.size();
        size_t bk = br ? m.at(0).size() : 0;
        std::vector&lt;std::vector&lt;double&gt;&gt; r (3 * br, std::vector&lt;double&gt; (3 * bk));
        for (size_t i = 0; i &lt; br; ++i)
            for (size_t j = 0; j &lt; bk; ++j)
            {
                auto el = m.at(i).at(j);
                r.at(br - i - 1)    .at(bk - j - 1)     = el; //gornja-lijeva
                r.at(br - i - 1)    .at(j + bk)         = el; //gornja-srednja
                r.at(br - i - 1)    .at(3 * bk - j - 1) = el; //gornja-desna
                r.at(i + br)        .at(bk - j - 1)     = el; //centralna-lijeva
                r.at(i + br)        .at(j + bk)         = el; //centralna-srednja
                r.at(i + br)        .at(3 * bk - j - 1) = el; //centralna-desna
                r.at(3 * br - i - 1).at(bk - j - 1)     = el; //donja-lijeva
                r.at(3 * br - i - 1).at(j + bk)         = el; //donja-srednja
                r.at(3 * br - i - 1).at(3 * bk - j - 1) = el; //donja-desna
            }
        return r;
    }

int main()
{
    _main();
    _main();
    _main();
    
}</pre>
</body>
</html>
