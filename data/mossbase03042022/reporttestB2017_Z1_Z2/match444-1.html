<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student5381.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student2035.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

bool JesuLiJednaki(double x, double y) {
	double epsilon(pow(10,-15));
	return std::fabs(x-y)&lt;=epsilon*(std::fabs(x)+std::fabs(y));
	
}


double SumaKteOkoline(std::vector&lt;std::vector&lt;double&gt;&gt; matrica, int iti_red, int jta_kolona, int k) //ovdje primas regularnu matricu, napravi funkciju koja provjerava regularnost matrice i to u glavnom funkciji radi
{
	
	
	double suma(0); 
	
<a name="0"></a><font color="#FF0000"><a href="match444-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

	for(int i=iti_red-k; i&lt;=iti_red+k; i++)
	for(int j=jta_kolona-k; j&lt;=jta_kolona+k; j++) 
	{
	if(i==iti_red-k || i==iti_red+k || j==jta_kolona-k || j==jta_kolona+k) {
		suma=suma+matrica.at(i).at(j); 
</font>
	}}
	
	return suma; 
	
}


bool RegularnaMatrica(std::vector&lt;std::vector&lt;double&gt;&gt; matrica) { //provjeri da li ok ova funkcija opet 
	if(matrica.size()==0) return true; //regularna je prazna matrica
<a name="3"></a><font color="#00FFFF"><a href="match444-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	int kolone(matrica.at(0).size()); 
	for(int i=1; i&lt;matrica.size(); i++) {
		if(matrica.at(i).size()!=kolone) return false; 
</font>	}
	
	return true; 
}


std::vector&lt;std::vector&lt;double&gt;&gt; IzdvojiPodmatricu(std::vector&lt;std::vector&lt;double&gt;&gt; matrica, int centralni_element_red, int centralni_element_kolona, int dimenzija) {
	std::vector&lt;std::vector&lt;double&gt;&gt; nova(dimenzija*2+1, std::vector&lt;double&gt; (dimenzija*2+1));
	int a=0; 
	int b=0; 
	for(int i=centralni_element_red-dimenzija; i&lt;=centralni_element_red+dimenzija; i++) {{
	for(int j=centralni_element_kolona-dimenzija; j&lt;=centralni_element_kolona+dimenzija; j++) {
	nova.at(a).at(b)=matrica.at(i).at(j); 

	b++; } 
	b=0;
		a++; 
	}
	

	
	}
	return nova; 
	
}

bool FunkcijaProvjere(int br_redova_matrice, int broj_konolna_matrice, int iti_red, int jta_kolona, int k) {
	if(iti_red-k&lt;0 || jta_kolona-k&lt;0 || iti_red+k&gt;=br_redova_matrice || jta_kolona+k&gt;=broj_konolna_matrice) return false; //ili stroga nejednakost kod svih
	return true;
}

std::vector&lt;std::vector&lt;double&gt;&gt; MaxClanMatrice(std::vector&lt;std::vector&lt;double&gt;&gt; matrica) {
	std::vector&lt;std::vector&lt;double&gt;&gt; rezultat(1, std::vector&lt;double&gt; (1)); 
	double max_element(matrica.at(0).at(0)); 
<a name="4"></a><font color="#FF00FF"><a href="match444-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

	for(int i=0; i&lt;matrica.size(); i++)
	for(int j=0; j&lt;matrica.at(0).size(); j++)
	if(matrica.at(i).at(j)&gt;max_element &amp;&amp; !JesuLiJednaki(matrica.at(i).at(j), max_element)) max_element=matrica.at(i).at(j); //ovdje si ubacila za poredjenje jer je bilo unsaefe
</font>	
	rezultat.at(0).at(0)=max_element; 
	return rezultat; 
	
}


std::vector&lt;std::vector&lt;double&gt;&gt; NajvecaPlaninaMatrice(std::vector&lt;std::vector&lt;double&gt;&gt; matrica) {
	if(!RegularnaMatrica(matrica)) throw std::domain_error("Matrica nije korektna"); 
	std::vector&lt;std::vector&lt;double&gt;&gt; rezultat;
	if(matrica.size()==0) return rezultat; 
	if(matrica.at(0).size()==0) return rezultat; 
	if(matrica.size()&lt;3 || matrica.at(0).size()&lt;3) { //svodi se na trazenje max elementa
		rezultat=MaxClanMatrice(matrica); 
		return rezultat; 
	}
	bool prvi_ulaz(true); 
	bool kontrolna_za_pomocnu_funkciju(true);
	double suma(0); 
	double previous_suma(0);
	int kontrolna_dimenzija(0); //skontaaj da li da krenes od 1 ili 0 
	int dimenzija(0);
	int koordinata_i(0);
	int koordinata_j(0); 
	int maxdimenzija(0); 
	int finalna_koordinata_i(0); 
	int finalna_koordinata_j(0); 
	for(int i=1; i&lt;matrica.size()-1; i++) {
		for(int j=1; j&lt;matrica.at(0).size()-1; j++) {
			prvi_ulaz=true; 
			kontrolna_za_pomocnu_funkciju=true;
			kontrolna_dimenzija=0;
			previous_suma=0;
			dimenzija=0;
			while(kontrolna_za_pomocnu_funkciju) {
				//napraviti funkciju ovu provjere umjesto slanja po referenci; 
				if(!FunkcijaProvjere(matrica.size(), matrica.at(0).size(), i, j, kontrolna_dimenzija)) break;
				
				suma=SumaKteOkoline(matrica, i, j, kontrolna_dimenzija); 
			//	std::cout &lt;&lt; "Izasao sam iz funkcije. Ja sam element " &lt;&lt; matrica.at(i).at(j) &lt;&lt; "Mogu ici do dimenzije " &lt;&lt; kontrolna_dimenzija &lt;&lt;" i tu mi je suma " &lt;&lt; suma &lt;&lt;" a prosla suma mi je bila " &lt;&lt; previous_suma &lt;&lt;std::endl;
				if(prvi_ulaz) {
					previous_suma=suma;
					prvi_ulaz=false;
					kontrolna_dimenzija++;
					continue;
				}
				
				else {
					if(previous_suma&gt;suma)
					{
						dimenzija=kontrolna_dimenzija; 
						kontrolna_dimenzija++; 
						previous_suma=suma;
						koordinata_i=i; 
						koordinata_j=j; 
						continue;
					}
					
					else {
					//	std::cout &lt;&lt; "SORRY IPAK MOGU SAMO DO DIMENZIJE " &lt;&lt; dimenzija; 
						break;
					}
				}
				previous_suma=suma;
				
						}
						
				if(dimenzija&gt;maxdimenzija) {maxdimenzija=dimenzija; 
					finalna_koordinata_i=koordinata_i; 
					finalna_koordinata_j=koordinata_j;
					//ovdje dodaj jos onih more uslova kada su iste bla bla
				}
				
				//ovdje si pocela dodavati da znas kad se sve raspadne i testiraj ovo btw
				//OVDJE SI DODAVALA ONO POREDJENJE
				else if(dimenzija==maxdimenzija) {
					if(matrica.at(koordinata_i).at(koordinata_j)&gt;matrica.at(finalna_koordinata_i).at(finalna_koordinata_j) &amp;&amp; !JesuLiJednaki(matrica.at(koordinata_i).at(koordinata_j), matrica.at(finalna_koordinata_i).at(finalna_koordinata_j))) {
						finalna_koordinata_i=koordinata_i; 
						finalna_koordinata_j=koordinata_j; 
					}
					else if(JesuLiJednaki(matrica.at(koordinata_i).at(koordinata_j),matrica.at(finalna_koordinata_i).at(finalna_koordinata_j)) &amp;&amp; koordinata_i&lt;finalna_koordinata_i) {
						finalna_koordinata_i=koordinata_i; 
						finalna_koordinata_j=koordinata_j; 
					}
					else if(JesuLiJednaki(matrica.at(koordinata_i).at(koordinata_j),matrica.at(finalna_koordinata_i).at(finalna_koordinata_j)) &amp;&amp; koordinata_i==finalna_koordinata_i &amp;&amp; koordinata_j&lt;finalna_koordinata_j) {
						finalna_koordinata_i=koordinata_i;
						finalna_koordinata_j=koordinata_j; 
					}
				}
		}
	}

		if(maxdimenzija) {
		try {
		std::vector&lt;std::vector&lt;double&gt;&gt; rez(IzdvojiPodmatricu(matrica, finalna_koordinata_i, finalna_koordinata_j, maxdimenzija )); 
			return rez;
		}
		catch(std::out_of_range) {std::cout &lt;&lt; "bio je problem izdvojiti podmatricu"; } }
		
		rezultat=MaxClanMatrice(matrica); 
	
	return rezultat; 
}

int main ()
{
	std::cout &lt;&lt; "Unesite dimenzije matrice (m i n): ";
	int m, n; 
	std::cin &gt;&gt; m &gt;&gt; n; //ovdje ona provjera i zajebancije
	if(m&lt;0 || n&lt;0) {
		std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!";
		return 0; 
	}
	std::cout &lt;&lt; "Unesite elemente matrice: "; 
	std::vector&lt;std::vector&lt;double&gt;&gt; matrica(m, std::vector&lt;double&gt; (n)); 
<a name="1"></a><font color="#00FF00"><a href="match444-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	for(int i=0; i&lt;m; i++) 
	for(int j=0; j&lt;n; j++)
	std::cin &gt;&gt; matrica.at(i).at(j); 

	std::vector&lt;std::vector&lt;double&gt;&gt; planina(NajvecaPlaninaMatrice(matrica));
</font>	std::cout &lt;&lt; std::endl &lt;&lt; "Najveca planina unesene matrice je: " &lt;&lt;std::endl;
	if(planina.size()!=0) {
	for(int i=0; i&lt;planina.size(); i++) {
<a name="2"></a><font color="#0000FF"><a href="match444-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	for(int j=0; j&lt;planina.at(0).size(); j++) {
	std::cout &lt;&lt; std::setw(6) &lt;&lt; planina.at(i).at(j); }
</font>	std::cout &lt;&lt; std::endl; } }
	
	
	
	
	return 0;
}</pre>
</body>
</html>
