<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student6172.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student4998.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
<a name="0"></a><font color="#FF0000"><a href="match72-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

typedef std::vector&lt;std::vector&lt;double&gt;&gt; Dblmatrica;
int manjiod(int x,int y)
{
	if(x&lt;y) return x;
	return y;
}
Dblmatrica KreirajMatricu(int broj_redova,int broj_kolona)
{
	return Dblmatrica(broj_redova,std::vector&lt;double&gt;(broj_kolona));
}
Dblmatrica NajvecaPlaninaMatrice(Dblmatrica matrica)
{
	int m(matrica.size());//broj redova

	Dblmatrica najvplanina(0);
	if(m==0) return najvplanina;//matrica prazna
	//matrica ima jedan element tj formata 1x1
	int n(matrica.at(0).size());//broj kolona
	if(n==0) return najvplanina;
	if(m==1 &amp;&amp; n==1) {
		najvplanina=KreirajMatricu(n,n);
		najvplanina.at(0).at(0)=matrica.at(0).at(0);
		return najvplanina;
	}
	//matrica formata 2x2
	if(m==2 &amp;&amp; n==2) {
		int max(matrica.at(0).at(0));
		for(int i=0; i&lt;n; i++) {
			for(int j=0; j&lt;n; j++) {
				if(matrica.at(i).at(j)&gt;max) max=matrica.at(i).at(j);
			}
		}
		najvplanina=KreirajMatricu(1,1);//tada najveca planina ima jedan element i to je najveci element matrice
		najvplanina.at(0).at(0)=max;
		return najvplanina;
	}
	//grbava matrica
	for(int i=1; i&lt;m; i++) {
		if(matrica.at(i).size()!=matrica.at(i-1).size())
			throw std::domain_error("Matrica nije korektna");
	}
	//u ovom dijelu najvplanina ima velicinu 0

	const double epsilon(0.0000000001);//dva realna broja jednaka ako je std::fabs(x-y)&lt;epsilon
	int sirina(0),ivrha,jvrha,vrh;//vrh,sirina planine i koordinate vrha
	int ipom,jpom,pomvrh,pomsirina(1),pomdim,pompomsirina;//dimenzije neke pomocne planine koje cemo porediti sa najvecom planinom
	//rubne slucajeve u ovom dijelu ne posmatramo kao moguce vrhove nego se baziramo na trazenje planine formata veceg od 1x1
	//uzimamo slucaj kada su dimenzije matrice matrice vece ili jednake 3x3
	if(m&gt;2 &amp;&amp; n&gt;2) {
		for(int i=1; i&lt;m-1; i++) {
			for(int j=1; j&lt;n-1; j++) {
				auto a(matrica.at(i).at(j));
				double suma(0),sumaprije(0),prvasuma(0);
				pompomsirina=1;
				while(i-pompomsirina&gt;=0 &amp;&amp; i+pompomsirina&lt;=m-1 &amp;&amp; j-pompomsirina&gt;=0 &amp;&amp; j+pompomsirina&lt;=n-1) {
					//prvo racunamo sumu prvog kvadrata oko centralnog elementa pa ako mozemo prosirimo se
			//	if(i-pomsirina)
					for(int k=i-pompomsirina; k&lt;=i+pompomsirina; k++) {
						for(int t=j-pompomsirina; t&lt;=j+pompomsirina; t++)
							if(k==i-pompomsirina || k==i+pompomsirina || t==j-pompomsirina || t==j+pompomsirina)
								suma+=matrica.at(k).at(t);
					}


					if(pompomsirina==1) {
						prvasuma=suma;
						sumaprije=suma;
					//	suma=0;

					}
					//treba nam prva suma oko ovog centralnog
					if(a&lt;prvasuma) break;
					if(suma&gt;sumaprije) break;


					if(pomsirina!=1)
						sumaprije=suma;
					suma=0;
					pomsirina=pompomsirina;
					pompomsirina++;
				}
				//kad se izvrti while petlja nasli smo najvecu mogucu sirinu za taj element a,imamo njegove koordirante i sirinu te planine
				if((prvasuma-0)&gt;epsilon) {
					if(a&gt;prvasuma) {
						ipom=i;
						jpom=j;
						pomvrh=a;
						pomdim=pomsirina;
					}
					if(pomdim&gt;sirina) {
						sirina=pomdim;
						vrh=pomvrh;
						ivrha=ipom;
						jvrha=jpom;

					} else if (pomdim==sirina) {
						//ako prva pomocna planina ima veci vrh a iste su im dimenzije
						if(std::fabs(pomvrh-vrh)&gt;epsilon) {
							vrh=pomvrh;
							ivrha=ipom;
							jvrha=jpom;


						} else if(ivrha&gt;ipom) {

							ivrha=ipom;
							jvrha=jpom;
							sirina=pomdim;
							vrh=pomvrh;
						} else if (jpom&lt;jvrha)
							jvrha=jpom;

					}
				}



			}
		}

	}
	if(sirina&gt;0) { //znaci da smo pronasli planinu
		najvplanina=KreirajMatricu(2*sirina+1,2*sirina+1);
		int br=0;
		int brk=0;
		for(int i=ivrha-sirina; i&lt;=ivrha+sirina; i++) {
			for(int j=jvrha-sirina; j&lt;=jvrha+sirina; j++){
				najvplanina.at(br).at(brk)=matrica.at(i).at(j);
			
			//najvplanina.at(std::abs(sirina-i).push_back(matrica.at(i).at(j));
			//najvplanina.at(br).push_back(matrica.at(i).at(j));
		
				brk++;
			}
		br++;
		brk=0;
	}
	}

//ako je dimenzija matrice ostala nula,znaci da nismo pronasli nijednu matricu formata veceg od 1x1 i sve se svede na trazenje
//najveceg elementa matrice koji ce biti ta planina
	double max(matrica.at(0).at(0));
	if(sirina==0) {
		for(int i=0; i&lt;m; i++) {
			for(int j=0; j&lt;n; j++) {
				auto a(matrica.at(i).at(j));
				if(a&gt;max) max=a;
			}
		}
		najvplanina.resize(1);
		najvplanina.at(0).resize(1);
		najvplanina.at(0).at(0)=max;
	}

	return najvplanina;

}

int main ()
{
	try {
		int m,n;
		std::cout&lt;&lt;"Unesite dimenzije matrice (m i n): ";
		std::cin&gt;&gt;m&gt;&gt;n;
		if(m&lt;0 || n&lt;0) std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne! ";
		else {
			Dblmatrica matrica(m);
			for(int i=0; i&lt;m; i++) matrica.at(i).resize(n);
			std::cout&lt;&lt;"Unesite elemente matrice:";
			for(int i=0; i&lt;m; i++) {
				for(int j=0; j&lt;n; j++) {
					std::cin&gt;&gt;matrica.at(i).at(j);
				}
			}
			Dblmatrica planina;
			planina=NajvecaPlaninaMatrice(matrica);
			std::cout&lt;&lt;std::endl&lt;&lt;"Najveca planina unesene matrice je:"&lt;&lt;std::endl;
			for(int i=0; i&lt;planina.size(); i++) {
				for(int j=0; j&lt;planina.size(); j++) {
					std::cout&lt;&lt;std::setw(6)&lt;&lt;planina.at(i).at(j);
				}
				std::cout&lt;&lt;std::endl;
			}
		}
	} catch( std::domain_error poruka) {
		std::cout&lt;&lt;poruka.what()&lt;&lt;std::endl;
</font>	}
	return 0;
}
</pre>
</body>
</html>
