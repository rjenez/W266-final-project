<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student4850.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student4850.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/

#include &lt;iostream&gt;
#include&lt;vector&gt; 
#include&lt;iomanip&gt; 
#include&lt;stdexcept&gt;
#include&lt;cmath&gt;

bool JesuLiJednaki(double a, double b, double Eps=1e-10){
	             if(std::fabs(a-b)&lt;Eps)
	             return true; 
	             return false;
}

<a name="1"></a><font color="#00FF00"><a href="match987-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

 typedef  std::vector&lt;std::vector&lt;double&gt;&gt; Matrica; 
 
Matrica  KreirajMatricu(int broj_redova, int broj_kolona) {
	    
	         return Matrica(broj_redova, std::vector&lt;double&gt; (broj_kolona)); 
}


Matrica UnesiMatricu(int broj_redova, int broj_kolona) {
</font>	
	             Matrica  a(broj_redova, std::vector&lt;double&gt; (broj_kolona)); 
	             std::cout &lt;&lt; "Unesite elemente matrice: " &lt;&lt; std::endl; 
	             for(int i=0; i&lt;broj_redova; i++) {
	             	for(int j=0; j&lt;broj_kolona; j++) {
	             		std::cin &gt;&gt; a.at(i).at(j); 
	             	}
	             }
	             
	           return a; 
}

 bool GrbavaMatrica (Matrica m ) {
 	   
 	    int broj_kolona=m[0].size(); 
 	    for(int i=1; i&lt;m.size(); i++ ) {
 	    	
 	    	if(broj_kolona!=m.at(i).size()) return false; 
 	    }
 	 return true; 
 }
 
 
void IspisiMatricu(Matrica m) {
	  
	    for(int i=0; i&lt;m.size(); i++) {
	    	for(int j=0; j&lt;m.at(0).size(); j++) {
<a name="2"></a><font color="#0000FF"><a href="match987-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	    	 std::cout &lt;&lt; std::setw(6) &lt;&lt; m.at(i).at(j);
	    	}
	    	std::cout &lt;&lt; std::endl; 
	    }
} 
 
 
 
Matrica  NajvecaPlaninaMatrice(Matrica m) {
</font>	      
	       if( m.size()==0 || m.at(0).size()==0) return m; 
	 if(GrbavaMatrica(m)==false) throw std::domain_error ("Matrica nije korektna"); 


          if(m.size()&lt;3 || m.at(0).size()&lt;3) {
          	Matrica y;
          	y=KreirajMatricu(1,1);
          	double naj=m.at(0).at(0);
          	for(int i=0; i&lt;m.size(); i++) {
          		
          		for(int j=0; j&lt;m[0].size(); j++){
          			if(naj&lt;m.at(i).at(j)) {
          				naj=m.at(i).at(j);
          			}
          			
          		}
          	}
          	   y.at(0).at(0)=naj;
          	   return y; 
          }
          	
          

	 
	 /* e sada ovdje izracunala prvu  najvecu planinu */ 
	 
  	int  maksimalni_broj_obilazaka=0, koordinata_i=0, koordinata_j=0, maksimalni_vrh=0; 
	 bool a= false, nesto=false; 

	 
	
	 for(int i =1; i&lt;m.size()-1; i++ ){
	 	   for(int j =1; j&lt;m.at(0).size()-1; j++) {
	 	   	    
	 	   	    
	 	   	  /* moram ovdje napraviti  for petlju za krug obilaska */ 
	 	   	  int krug_kolona=0;  
	 	   	  
	 	   	  if(j&lt;((m.at(0).size()-1)-j)) krug_kolona=j; 
	 	   	  else if(j&gt;((m.at(0).size()-1)-j)) krug_kolona=m.at(0).size()-1-j; 
	 	   	   else if(j==(m.at(0).size()-1-j)) krug_kolona=j; 
	 	   	     
	 	   	  int krug_redova=0; 
	 	   	  
	 	   	  if(i&lt;m.size()-i-1) krug_redova=i; 
	 	   	    else if(i&gt;m.size()-1-i) krug_redova=m.size()-1-i; 
	 	   	    else if(i==m.size()-1-i) krug_redova=i; 
	 	   	    
	 	   	    
	 	   	   int krug=0; 
	 	   	     
	 	   	     if(krug_kolona&lt;=krug_redova) krug=krug_kolona; 
	 	   	     else krug=krug_redova; 
	 	   	       
	 	   	       /*nakon sto sam se odlucila kolko puta se moze maksimalno obici  a to nam govori
	 	   	        promjenjiva krug sada obilazim i gledam kolko puta ce se najvise obici
	 	   	        i racunam sume krugova*/
	 	   	        
	 	   	        
	 	   	        
	 	   	      
	 	   	        
	 	   	        
	 	   	        int k;
	 	   	       int  suma2=0; 
	 	   	       for( k=1; k&lt;=krug; k++) {
	 	   	       	/* ovdje ce izrcunati sumu pojdinacnog reda */
	 	   	       	  int suma =0; 
	 	   	       	  for( int l=i-k; l&lt;=i+k; l++) {
	 	   	       	  	   
	 	   	       	  	  suma+=m.at(l).at(j-k); 
	 	   	       	  	 
	 	   	       	  }
	 	   	       	
	 	   	       	   
	 	   	       	  for( int l=i-k; l&lt;=i+k; l++){
	 	   	       	  	suma+=m.at(l).at(j+k);
	 	   	       	  	
	 	   	       	  }
	 	   	       
	 	   	       	  for(int l=j-k+1; l&lt;=j+k-1; l++){
	 	   	       	  	suma+=m.at(i-k).at(l);
	 	   	       	  
	 	   	       	  }
	 	   	       	  
	 	   	       	  for(int  l=j-k+1; l&lt;=j+k-1; l++){
	 	   	       	  	suma+=m.at(i+k).at(l);
	 	   	       	  
	 	   	       	  }
	 	   	       	 
	 	   	           if(JesuLiJednaki(suma, m.at(i).at(j))) {
	 	   	           	k--; 
	 	   	           	break; 
	 	   	           }
	 	   	    
	 	   	             if( k==1  &amp;&amp; suma&gt;m.at(i).at(j) )   { 
	 	   	       	    k--; 
	 	   	       	   break; 
	 	   	       	   }
	 	   	       	   nesto =false; 
	 	   	       	   if(k==1  &amp;&amp; suma &lt; m.at(i).at(j)) {
	 	   	       	   	suma2=suma; 
	 	   	       	   	nesto=true; 
	 	   	       	   
	 	   	       	   }
	 	   	       	  
	 	   	       	   if( k&gt;1 &amp;&amp;  suma&gt;suma2) {
	 	   	       	    
	 	   	       	   k--; 
	 	   	       	   break;
	 	   	       	   }
	 	   	       	   if(k&gt;1 &amp;&amp; suma&lt;suma2) {
	 	   	       	   	 suma2=suma; 
	 	   	       	   	
	 	   	       	   }
	 	   	       }
	 	   	      
	 	   	      if(k&gt;krug &amp;&amp; nesto==false) k--; 
	 	   	       if (nesto==true) k--;
	 	   	      maksimalni_broj_obilazaka=k; 	   
	 	   	     if(k&gt;=1) {
	 	   	     	
	 	   	      	a=true; 
	 	   	     	maksimalni_vrh=m.at(i).at(j);
	 	   	     	koordinata_i=i; 
	 	   	     	koordinata_j=j; 
	 	   	     	break;
	 	   	     }
	 	   	       	   
	 	   	           	  
	 	   }	  
	 	 
	 	  if(a==true) break; 
	 }
	 
	 
  /* 	 std::cout &lt;&lt;" maksimalni_broj_obilazaka "  &lt;&lt;  maksimalni_broj_obilazaka  &lt;&lt;
	   " maksimalni_vrh " &lt;&lt; maksimalni_vrh &lt;&lt;std::endl &lt;&lt;
	 "a taj element se nalazi na kordinatama " &lt;&lt; koordinata_i &lt;&lt; koordinata_j; */
	 
	 
	 
	   // ovdje cu sve prepisati  
	   
  	     bool nesto1=false;
	     int broj_obilazaka=0; 
	  
	      for(int i=1; i&lt;m.size()-1; i++) {
	   	  for(int j=1; j&lt;m.at(0).size()-1; j++){
	   	  	
	   	  	int krug_kolona=0;
	   	  	if(j&lt;((m.at(0).size()-1-j))) krug_kolona=j;
	   	  	else if(j&gt;((m.at(0).size()-1-j))) krug_kolona=m.at(0).size()-1-j;
	   	  	else if(j==(m.at(0).size()-1-j)) krug_kolona =j;
	   	  	
	   	    int krug_redova=0; 
	   	    if(i&lt;((m.size()-1-i))) krug_redova=i; 
	   	    else if(i&gt;(m.size()-i-1)) krug_redova=m.size()-1-i; 
	   	    else if(i==(m.size()-i-1)) krug_redova=i; 
	   	  
	   	  	
	   	  	int krug=0; 
	   	  	if(krug_redova &lt;=krug_kolona) krug=krug_redova; 
	   	  	else krug=krug_kolona; 
	   	  	
	   	  	
	   	  	
	   	  	int k; 
	   	  	int suma2=0; 
	   	  	
	   	  	broj_obilazaka=0; 
	   	  	
	   	  	for(k=1; k&lt;=krug; k++ ) {
	   	  		int suma=0; 
	   	  
	   	    for(int l=i-k; l&lt;=i+k; l++ ) {
	   	    	 suma+=m.at(l).at(j-k); 
	   	    }
	   	    for(int l=i-k; l&lt;=i+k; l++ ){
	   	    	 suma+=m.at(l).at(j+k);
	   	    }
	   	    for(int l=j-k+1; l&lt;=j+k-1; l++){
	   	    	  suma+=m.at(i-k).at(l);
	   	    }
	   	    
	   	    for(int l=j-k+1; l&lt;=j+k-1; l++) {
	   	    	suma+=m.at(i+k).at(l); 
	   	    }
	   	    if(JesuLiJednaki(suma,m.at(i).at(j))){
	   	    	k--;
	   	    	break; 
	   	    }
	   	    
	   	    if(k==1 &amp;&amp; suma&gt;m.at(i).at(j)) {
	   	    	k--;
	   	    	break;
	   	    }
	   	    nesto1=false;
	   	    if(k==1 &amp;&amp; suma&lt;m.at(i).at(j)) {
	   	    	suma2=suma; 
	   	    	nesto1=true;
	   	    }
	   	    if(k&gt;1 &amp;&amp; suma&gt;suma2) {
	   	    	k--; 
	   	    	break; 
	   	    }
	   	    if(k&gt;1 &amp;&amp; suma&lt;suma2) {
	   	    	suma2=suma; 
	   	    }
	   	  	}
	   	  	
	   	  	
	   	  	
	   	  	 if(k&gt;krug &amp;&amp; nesto1 == false) k--;
	   	  	
	   	  if(nesto1==true){
	   	  	k--;
	   	  }	
	   	  
	   	  if(k&gt;=1) {
	   	  broj_obilazaka=k;
	   	  
	   	  
	   	  if(broj_obilazaka&gt;maksimalni_broj_obilazaka) {
	   	  	maksimalni_broj_obilazaka=k; 
	   	  	koordinata_i=i;
	   	  	koordinata_j=j;
	   	   maksimalni_vrh=m.at(i).at(j);
	   	  	
	   	  }
	   	  
	   	  
	   	  
	   	  if(broj_obilazaka==maksimalni_broj_obilazaka) {
	   	  	  if(maksimalni_vrh &lt;m.at(i).at(j))  {
	   	  	  	    maksimalni_vrh=m.at(i).at(j);
	   	  	  	    koordinata_j=j;
	   	  	  	    koordinata_i=i;
	   	  	  	    maksimalni_broj_obilazaka=broj_obilazaka;    
	   	  	  }
	   	  	  
	   	  	  
	   	  	 if(JesuLiJednaki(maksimalni_vrh,m.at(i).at(j))) {
	   	  	 	    if(koordinata_i&gt;i) {
	   	  	 	    	 koordinata_i=i; 
	   	  	 	    	 koordinata_j=j; 
	   	  	 	    	 maksimalni_vrh=m.at(i).at(j);
	   	  	 	    }
	   	  	 	    if(koordinata_i==i) {
	   	  	 	    	if(koordinata_j&gt;j) {
	   	  	 	    		
	   	  	 	    		koordinata_j=j; 
	   	  	 	    		koordinata_i=i;
	   	  	 	    	
	   	  	 	    	}
	   	  	 	    	
	   	  	 	    }
	   	  	 	
	   	  	 }
	   	  	
	   	  }
	   	  	 	    	}
	   	  
	   	  
	   	  
	   	  
	   	  
	   	  
	   	 
	   	  
	   	  }
	   }
	  
	 
	
	 
	 
   /*std::cout &lt;&lt;  "maksimalni_broj_obilazaka " &lt;&lt; maksimalni_broj_obilazaka
	     &lt;&lt; "koordinata_i "&lt;&lt; koordinata_i &lt;&lt;"koordinata_j" &lt;&lt;  koordinata_j &lt;&lt; "maksimalni_vrh" &lt;&lt; maksimalni_vrh;
	    
	     std::cout &lt;&lt; std::endl;    */
	     
	     
	     
	    int  b=0, c=0;
  	   Matrica x; 
  	   x=KreirajMatricu(maksimalni_broj_obilazaka*2+1, maksimalni_broj_obilazaka*2+1);   
  	   for(int i=koordinata_i-maksimalni_broj_obilazaka; i &lt;=koordinata_i+maksimalni_broj_obilazaka ; i++ ) {
  	   	    c=0; 
<a name="3"></a><font color="#00FFFF"><a href="match987-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

  	   	  for(int j=koordinata_j-maksimalni_broj_obilazaka; j&lt;=koordinata_j+maksimalni_broj_obilazaka; j++){
  	   	    x.at(b).at(c)=m.at(i).at(j); 
  	   	   
  	   	    c++;
</font>  	   	  }
  	   b++;
  	   
  	   } 
  	   
  	
  	  
  	  
  	   	       
  	   	  
  	  return x;  
  	  
  	 
 
 }
	  
	 
	 

int main ()  {
	
	 try {
	 
	 std::cout &lt;&lt; "Unesite dimenzije matrice (m i n): "; 
	 int m,n; 
	 std::cin &gt;&gt; m &gt;&gt; n; 
	 if(m&lt;0 || n&lt;0) {
	 	std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!" ; 
	 	return 0; 
	 }
	 Matrica mat; 
	  mat=KreirajMatricu(m,n); 
	  
	 mat=UnesiMatricu(m,n); 
	// IspisiMatricu(mat);
	 Matrica NajvecaPlanina=(NajvecaPlaninaMatrice(mat)); 
<a name="0"></a><font color="#FF0000"><a href="match987-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

     std::cout &lt;&lt; "Najveca planina unesene matrice je: " &lt;&lt; std::endl;
	 IspisiMatricu(NajvecaPlanina);
	  
	 
	 
	 }
	 catch (std::domain_error izuzetak) {
	 	  std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl; 
	 }
	return 0;
</font>}</pre>
</body>
</html>
