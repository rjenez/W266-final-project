<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student6517.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student2196.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica;
const double epsilon = 0.000000001;



Matrica KreirajMatricu(int broj_redova, int broj_kolona){
	return Matrica(broj_redova, std::vector&lt;double&gt; (broj_kolona));
}



Matrica NajvecaPlaninaMatrice(Matrica x){
	for(int i=0; i&lt;int(x.size()); i++){
		if(x.at(i).size()!=
		x.at(0).size()) throw std::domain_error("Matrica nije korektna");    //Provjera oblika matrice, da li je grbava ili ne.
	}
	Matrica max=KreirajMatricu(0,0);			//Kreiranje prazne matrice, ukoliko je jedna od dimenzija matrice 0.
	if(x.size()&gt;0 &amp;&amp; x.at(0).size()&gt;0){
		max=KreirajMatricu(1,1);		
		max.at(0).at(0)=x.at(0).at(0);
		for(int i=0; i&lt;int(x.size()); i++){								//Trazenje najvece planine dimenzija 1x1.
			for(int j=0; j&lt;int(x.at(i).size()); j++){
				if(max.at(0).at(0)&lt;x.at(i).at(j)) max.at(0).at(0)=x.at(i).at(j);
			}
		}
	}
	std::vector&lt;Matrica&gt; PlaninaMatrice;					//Vektor koji ce sadrzavati sve Planine matrice dimenzija 2x2 i vece.
	std::vector&lt;std::complex&lt;int&gt;&gt; koordinate;				//Vektor koji ce sadrzavati koordinate svakog vrha planine.
	if(x.size()&gt;2 &amp;&amp; x.at(0).size()&gt;2){
		for(int i=1; i&lt;int(x.size())-1; i++){
			for(int j=1; j&lt;int(x.at(i).size())-1; j++){
				std::vector&lt;double&gt; sume;							//Vektor svih suma koncentricnih kvadrata jedne planine.
				int brojac=1;								//"Poluprecnik" koncentricnih kvadrata jedne planine.
					while(i-brojac&gt;=0 &amp;&amp; j-brojac&gt;=0 &amp;&amp; i+brojac&lt;x.size() &amp;&amp; j+brojac&lt;x.at(i).size()){		//Provjera da li su koordinate unutar matrice.
						double suma=0;
<a name="0"></a><font color="#FF0000"><a href="match536-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

						for(int k=i-brojac; k&lt;=i+brojac; k++){
							for(int l=j-brojac; l&lt;=j+brojac; l++){
								if(l==j-brojac || l==j+brojac || k==i-brojac || k==i+brojac) suma+=x.at(k).at(l);
							}
						}
						if(sume.size()==0 &amp;&amp; suma&lt;x.at(i).at(j)){
</font>							sume.push_back(suma);
							brojac++;
						} 
						else if (sume.size()&gt;0 &amp;&amp; suma&lt;sume.at(sume.size()-1)){
							sume.push_back(suma);	
							brojac++;
						} 
						else break;
					}
					brojac--;					
				if(sume.size()&gt;0){
					PlaninaMatrice.push_back(KreirajMatricu(2*brojac+1, 2*brojac+1));	//Kreiranje matrice odgovarajucih dimenzija u vektoru.
					koordinate.push_back(std::complex&lt;int&gt;(i,j));	//Ubacivanje koordinata vrha na prvo mjesto vektora (koordinate i matrica su na istim mjestima u svojim vektorima).
					for(int k=i-brojac; k&lt;=i+brojac; k++){
						for(int l=j-brojac; l&lt;=j+brojac; l++){
							PlaninaMatrice.at(int(PlaninaMatrice.size())-1).at(k-(i-brojac)).at(l-(j-brojac))=x.at(k).at(l); //Ubacivanje odgovarajucih elemenata u malocas kreiranu matricu.
						}
					}
				} 
			}
		}
	}
	if(PlaninaMatrice.size()&gt;0){
		max=PlaninaMatrice.at(0);									
		std::complex&lt;int&gt; max_koordinate=koordinate.at(0);
			for(int i=1; i&lt;int(PlaninaMatrice.size()); i++){													
				if(max.size()&lt;PlaninaMatrice.at(i).size()){
					max=PlaninaMatrice.at(i);	
					max_koordinate=koordinate.at(i);
				}  				  										//Trazenje najvece podmatrice.
				else if(max.size()==PlaninaMatrice.at(i).size()){																			
					if(max.at(max.size()/2).at(max.size()/2)&lt;PlaninaMatrice.at(i).at(PlaninaMatrice.size()/2).at(PlaninaMatrice.size()/2)){			//Trazenje najveceg centralnog elementa. 
						max=PlaninaMatrice.at(i);
						max_koordinate=koordinate.at(i);
					}	
					else if(fabs(max.at(max.size()/2).at(max.size()/2)-PlaninaMatrice.at(i).at(PlaninaMatrice.size()/2).at(PlaninaMatrice.size()/2))&lt;epsilon){
						if(koordinate.at(i).real()&lt;max_koordinate.real()){
							max=PlaninaMatrice.at(i);
							max_koordinate=koordinate.at(i);							//Trazenje minimalne prve koordinate vrha.
						} 														
						else if(koordinate.at(i).real()==max_koordinate.real()){
							if(koordinate.at(i).imag()&lt;max_koordinate.imag()){ 			//Trazenje minimalne druge koordinate vrha.
								max=PlaninaMatrice.at(i);
<a name="2"></a><font color="#0000FF"><a href="match536-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

								max_koordinate=koordinate.at(i);
							}															
						}
					}
				}
			}			
	}
	return max;
}

int main ()
{
	std::cout &lt;&lt; "Unesite dimenzije matrice (m i n): ";
	int redovi, kolone;
	std::cin &gt;&gt; redovi &gt;&gt; kolone;
	if(redovi&lt;0 || kolone&lt;0){
</font>		std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!\n";
		return 0;
	} 
	Matrica m(KreirajMatricu(redovi, kolone));
	std::cout &lt;&lt; "Unesite elemente matrice: ";
	for(int i=0; i&lt;redovi; i++){
<a name="3"></a><font color="#00FFFF"><a href="match536-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

		for(int j=0; j&lt;kolone; j++){
			std::cin &gt;&gt; m.at(i).at(j);
		}
	}
	Matrica planina=NajvecaPlaninaMatrice(m);
</font>	std::cout &lt;&lt; "\nNajveca planina unesene matrice je:\n";
	for(int i=0; i&lt;planina.size(); i++){
<a name="1"></a><font color="#00FF00"><a href="match536-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

		for(int j=0; j&lt;planina.at(0).size(); j++){
			std::cout &lt;&lt; std::setw(6) &lt;&lt; planina.at(i).at(j);
</font>		}
		std::cout &lt;&lt; std::endl;
	}
	return 0;
}</pre>
</body>
</html>
