<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student3320.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student6517.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

#define Epsilon 4*atan(1)

typedef std::vector&lt;std::vector&lt;double&gt;&gt; matrica_double;

matrica_double NapraviMatricu(matrica_double M, int i, int j, int nivo)
{
	matrica_double trenutna_planina( (2*nivo+1), std::vector&lt;double&gt;(2*nivo+1));
	int a(0), b(0);
	
	for(int k=(i-nivo); k&lt;=(i+nivo); k++)
	{
<a name="1"></a><font color="#00FF00"><a href="match951-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

		for(int l=(j-nivo); l&lt;=(j+nivo); l++)
			{
				trenutna_planina.at(a).at(b)=M.at(k).at(l);
				b++;
</font>			}
		b=0;
		a++;
	}
	
	return trenutna_planina;
}

bool DaLiJePlanina(matrica_double M, int i, int j, int nivo, int suma)
{
	int trenutna_suma(0);
<a name="0"></a><font color="#FF0000"><a href="match951-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

	for(int k=(i-nivo); k&lt;=(i+nivo); k++)
	{
		for(int l=(j-nivo); l&lt;=(j+nivo); l++)
			{
				if(k==(i-nivo) || k==(i+nivo) || l==(j-nivo) || l==(j+nivo))
				trenutna_suma+=M.at(k).at(l);		
</font>			}	
	}
	
			
	if(trenutna_suma&lt;suma)
	return true;
	else
	return false;
}

matrica_double NajvecaPlaninaMatrice (matrica_double M )
{
	matrica_double planina, planina2;
	
	for(int i=0; i&lt;M.size(); i++)
	{
		if(M.at(0).size()!=M.at(i).size())
		throw std::domain_error ("Matrica nije korektna");
	}
	
	if(M.size()==0 || M.at(0).size()==0)
	return planina;  //u ovom trenutku prazna
	
	
	if(M.size()&lt;=2 || M.at(0).size()&lt;=2)
	{
		int maksimalan_element(M.at(0).at(0) );
		for(int i=0; i&lt;M.size(); i++)
		{
			for(int j=0; j&lt;M.at(0).size(); j++)
			{
				if(M.at(i).at(j) - maksimalan_element &gt; Epsilon) ///////////dodao za epsilon
				maksimalan_element=M.at(i).at(j);
			}
		}
		planina.resize(1);
		planina.at(0).resize(1);
		planina.at(0).at(0)=maksimalan_element;
		return planina;
	}
	
	int nivo(1), maks_nivo(0);
	for(int i=0; i&lt;M.size(); i++)
	{
		for(int j=0; j&lt;M.at(i).size(); j++)
		{
			if(i==0 || i==M.size()-1 || j==0 || j==M.at(i).size()-1 )
			continue;
			
			nivo=1;
			
			int suma( M.at(i).at(j) );
			while( (i-nivo)&gt;=0 &amp;&amp; (i+nivo)&lt;M.size() &amp;&amp; (j+nivo)&lt;M.at(i).size() &amp;&amp; (j-nivo)&gt;=0 &amp;&amp; DaLiJePlanina(M, i, j, nivo, suma))
			{
				suma=0;	
				for(int k=(i-nivo); k&lt;=(i+nivo); k++)
				{
					for(int l=(j-nivo); l&lt;=(j+nivo); l++)
						{
							if(k==(i-nivo) || k==(i+nivo) || l==(j-nivo) || l==(j+nivo))
								suma+=M.at(k).at(l);		
						}	
				}
				
				nivo++;
			}
			
			if(maks_nivo&lt;(nivo-1))
			{
				maks_nivo=(nivo-1);
				planina=NapraviMatricu(M, i, j, (nivo-1) );
			}
			else if(maks_nivo==(nivo-1) &amp;&amp; (nivo-1)!=0)
			{
				planina2=NapraviMatricu(M, i, j, (nivo-1) );
				
				if( planina2.at(nivo).at(nivo) - planina.at(nivo).at(nivo) &gt; Epsilon ) ///////////////////dodao za epsilon
				{
					planina=planina2;
				}
			//ukoliko su planine istog nivoa i imaju isti vrh, promjenjiva "planina" ne treba da poprimi vrijednost "planina2", jer njen vrh ima manje indekse (uslov zadatka)
			}
		}
	}
	
	if(planina.size()==0)
	{
		int maksimalan_element(M.at(0).at(0) );
		for(int i=0; i&lt;M.size(); i++)
		{
			for(int j=0; j&lt;M.at(0).size(); j++)
			{
				if( (i==0 || j==0 || j==M.at(0).size()-1 || i==M.size()-1 ) &amp;&amp; M.at(i).at(j)-maksimalan_element&gt;Epsilon)    ////////////////dodao za epsilon
				maksimalan_element=M.at(i).at(j);
			}
		}
		planina.resize(1);
		planina.at(0).resize(1);
		planina.at(0).at(0)=maksimalan_element;
		return planina;
	}
	
	return planina;
}

int main ()
{
	std::cout&lt;&lt;"Unesite dimenzije matrice (m i n): ";
	int a, b;
	std::cin&gt;&gt;a&gt;&gt;b;
	
	if(a&lt;0 || b&lt;0)
	{
		std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";
		return 0;
	}
	
	matrica_double M(a, std::vector&lt;double&gt;(b)); ///
	
	std::cout&lt;&lt;"Unesite elemente matrice: "&lt;&lt;std::endl;
	for (int i=0; i&lt;a; i++) 
	{
		for (int j=0; j&lt;b; j++) 
		{
			std::cin&gt;&gt;M.at(i).at(j);
		}
	}
	
	
	try
	{
		M=NajvecaPlaninaMatrice(M);
		
	}
	catch(std::domain_error poruka)
	{
		std::cout&lt;&lt;poruka.what();
		return 0; //ne znam treba li (vidi iz autotesta)
	}
	
	std::cout&lt;&lt;"Najveca planina unesene matrice je: "&lt;&lt;std::endl;
	for(int i=0; i&lt;M.size(); i++)
	{
<a name="2"></a><font color="#0000FF"><a href="match951-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

		for(int j=0; j&lt;M.at(0).size(); j++)
		{
			std::cout&lt;&lt;std::setw(6)&lt;&lt;M.at(i).at(j);
</font>		}
		std::cout&lt;&lt;std::endl;
	}
	
	return 0;
}</pre>
</body>
</html>
