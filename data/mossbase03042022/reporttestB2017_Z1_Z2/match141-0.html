<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student1237.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student1237.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;

#define EMPTY_MATRIX {}

// Less typing.
<a name="0"></a><font color="#FF0000"><a href="match141-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_97.gif"/></a>

typedef std::vector&lt;std::vector&lt;double&gt;&gt; matrix;

bool isEmpty(matrix m)
{
    if (m.size() == 0)
        return true;
        
    for (int y(0); y &lt; m.size(); y++)
        if (m.at(y).size() != 0)
            return false;
    
    return true;
}

bool isRagged(matrix m)
{
    int n_columns(m.at(0).size());
    for (int y(1); y &lt; m.size(); y++)
        if (m.at(y).size() != n_columns)
            return true;
    
    return false;
}

bool canCreateSquareWithRadiusR(matrix source, int x, int y, int r)
{
    return (((x + r &lt; source.at(0).size()) &amp;&amp; (x - r &gt;= 0)) &amp;&amp; ((y + r &lt; source.size()) &amp;&amp; (y - r &gt;= 0)));
}

bool firstPeakIsHigherThanSecondOne(matrix m1, matrix m2)
{
    return (m1.at(m1.size() / 2).at(m1.size() / 2) &gt; m2.at(m2.size() / 2).at(m2.size() / 2));
}

bool equalPeaks(matrix m1, matrix m2)
{
    return (m1.at(m1.size() / 2).at(m1.size() / 2) == m2.at(m2.size() / 2).at(m2.size() / 2));
}

matrix getMountain(matrix source, int x, int y)
{
    int radius(1);
    long double peak(source.at(y).at(x));
    
    while (canCreateSquareWithRadiusR(source, x, y, radius))
    {
        long double sum(0);
        
        for (int i(x - radius); i &lt;= x + radius; i++)
        {
            sum += source.at(y - radius).at(i);
            sum += source.at(y + radius).at(i);
        }
        
        for (int i(y - radius + 1); i &lt;= y + radius - 1; i++)
        {
            sum += source.at(i).at(x - radius);
            sum += source.at(i).at(x + radius);
        }
        
        if (sum &lt; peak)
        {
            peak = sum;
            radius++;
        }
        else
            break;
    }
    radius--;
    
    if (radius == 0)
        return matrix {{source.at(y).at(x)}};
    
    matrix mountain;
    for (int i(y - radius); i &lt;= y + radius; i++)
    {
        std::vector&lt;double&gt; row;
        for (int j(x - radius); j &lt;= x + radius; j++)
            row.push_back(source.at(i).at(j));
            
        mountain.push_back(row);
    }
    
    return mountain;
}

matrix NajvecaPlaninaMatrice(matrix source)
{
    if (isEmpty(source))
        return matrix EMPTY_MATRIX;
    
    if (isRagged(source))
        throw std::domain_error("Matrica nije korektna\n");
    
    int n_rows(source.size()), n_columns(source.at(0).size());
    int peak_x, peak_y;
    
    matrix current_largest_mountain;
    for (int y(0); y &lt; n_rows; y++)
    {
        for (int x(0); x &lt; n_columns; x++)
        {
            matrix new_mountain(getMountain(source, x, y));
            if (new_mountain.size() &gt; current_largest_mountain.size())
            {
                current_largest_mountain = std::move(new_mountain);
                peak_x = x;
                peak_y = y;
            }
            else if (new_mountain.size() == current_largest_mountain.size())
                if (firstPeakIsHigherThanSecondOne(new_mountain, current_largest_mountain))
                {
                    current_largest_mountain = std::move(new_mountain);
                    peak_x = x;
                    peak_y = y;
                }
                else if (equalPeaks(new_mountain, current_largest_mountain))
                    if (x &lt; peak_x)
                    {
                        current_largest_mountain = std::move(new_mountain);
                        peak_x = x;
                        peak_y = y;
                    }
                    else if (x == peak_x)
                        if (y &lt; peak_y)
                        {
                            current_largest_mountain = std::move(new_mountain);
                            peak_x = x;
                            peak_y = y;
                        }
        }
    }
    
    return current_largest_mountain;
}

int main (void)
{
    int columns, rows;
    std::cout &lt;&lt; "Unesite dimenzije matrice (m i n): ";
    
    std::cin &gt;&gt; rows &gt;&gt; columns;
    if (rows &lt; 0 || columns &lt; 0)
    {
        std::cout &lt;&lt; "Dimenzije matrice moraju biti nenegativne!\n";
        return -1;
    }
    
    double input;
    matrix input_matrix(rows, std::vector&lt;double&gt;());
    std::cout &lt;&lt; "Unesite elemente matrice: \n"; 
    for (int y(0); y &lt; rows; y++)
        for (int x(0); x &lt; columns; x++)
        {
            std::cin &gt;&gt; input;
            input_matrix.at(y).push_back(input);
        }
    
    matrix largestMountain(NajvecaPlaninaMatrice(input_matrix));
    std::cout &lt;&lt; "\nNajveca planina unesene matrice je:" &lt;&lt; std::endl;
    for (int y(0); y &lt; largestMountain.size(); y++)
    {
        for (int x(0); x &lt; largestMountain.at(0).size(); x++)
                std::cout &lt;&lt; std::setw(6) &lt;&lt; largestMountain.at(y).at(x);
</font>        
        std::cout &lt;&lt; std::endl;     
    }
    
	return 0;
}</pre>
</body>
</html>
