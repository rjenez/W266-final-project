<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student1688.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student1688.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

// ispitujem da li je to ta podmatrica
<a name="0"></a><font color="#FF0000"><a href="match76-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

int saberi(std::vector&lt;std::vector&lt;double&gt;&gt; matrica,int a,int pom_i,int b,int pom_j,int duzina){
	int s(0);
	int najveci_clan(matrica.at(pom_i).at(pom_j));
	for(int i(a);i&lt;a+duzina;i++){
		for(int j(b);j&lt;b+duzina;j++){
			if(i!=pom_i &amp;&amp; j!=pom_j) { s+=matrica.at(i).at(j);
		}
	}
	std::cout&lt;&lt;std::endl;
	}
	if(s&lt;najveci_clan) return najveci_clan;
	return 0;
}

std::vector&lt;std::vector&lt;double&gt;&gt;NajvecaPlaninaMatrice(std::vector&lt;std::vector&lt;double&gt;&gt;m){
	for(int i=0;i&lt;m.size();i++){
		for(int j=0;j&lt;m[i].size();j++){
			if(m.size()!=m[i].size()) throw std::domain_error ("Matrica nije korektna");
		}
	}

	for(int i=0;i&lt;m.size();i++){
		for(int j=0;j&lt;m[i].size();j++)
		if(m.size()==0 || m[i].size()==0)
		return std::vector&lt;std::vector&lt;double&gt;&gt;(0,std::vector&lt;double&gt;(0));
	}
	int suma(0),i,j,k,pom_j,pom_i,index_i,index_j,duzina(0);
	//Ove varijable cuvaju mi vrijednost ako je to planina koju sam trebala naci
	//pom_j -&gt; cuva mi index "j" tj. kolonu odakle mi pocinje podmatrica u kojoj je suma clanova manja od srednjeg clana
	//pom_i -&gt; cuva mi index "i" tj red odakle mi pocinje podmatrica u kojoj je suma clanova manja od srednjeg clana 
	//index_i -&gt; cuva mi u kojem redu se nalazi srednji clan podmatrice 
	//index_j -&gt; cuva mi u kojoj koloni se nalazi srednji clan podmatrice
	for(i=0;i&lt;=m.size();i++){
		int index_i1,index_j1,pom_i1,pom_j1,suma_1(0);
		// a mi je pomocna varijabla da provjerim da li cu promijeniti duzinu podmatrice
		int a=(i%m.size());
		if(a%2==0){
			duzina=a;
			for(k=0;k&lt;=m.size();k++){
				for(j=0;j&lt;=m[0].size();j++){
					index_i1=(duzina/2)+k;
					index_j1=(duzina/2)+j;
					pom_i1=k;
					pom_j1=j;
				//	std::cout &lt;&lt; index_i1 &lt;&lt; " " &lt;&lt; index_j1 &lt;&lt; std::endl;
					// ove varijable su mi pomocne samo dok provjerim je li to ta podmatrica (da mogu sacuvati koja je to podmatrica)
					//m-&gt; saljem citavu matricu
					//pom_i1-&gt; saljem red odakle hocu da mi pocne provjeravanje podmatrice
					//index_i1-&gt; saljem red u kojem ce se nalaziti sredisnji clan te podmatrice
					//pom_j1 -&gt; saljem kolonu odakle hocu da mi pocne provjeravanje podmatrice
					//index_j1 -&gt; saljem kolonu u kojoj se nalazi sredisnji clan te podmatrice
					//duzina-&gt; saljem kolika mi je trenutna duzina i visina podmatrice
					if(duzina+pom_i1&lt;m.size() &amp;&amp; duzina+pom_j1&lt;m.size()) suma_1=saberi(m,pom_i1,index_i1,pom_j1,index_j1,duzina);{
					if(suma_1&gt;suma){
						suma=suma_1;
						index_i=index_i1;
						index_j=index_j1;
						pom_i=pom_i1;
						pom_j=pom_j1;
					}
					if(suma_1==suma){
						if(pom_i1&lt;pom_i1) {
							suma=suma_1;
							index_i=index_i1;
							index_j=index_j1;
							pom_i=pom_i1;
							pom_j=pom_j1;
						}
						if(pom_i1==pom_i){
							if(pom_j1&lt;pom_j){
								suma=suma_1;
								index_i=index_i1;
								index_j=index_j1;
								pom_i=pom_i1;
								pom_j=pom_j1;
							}
						}
					}
				
				}
			}
		}
		}
		else{
			for(j=0;j&lt;m.size();j++){
				index_i1=(duzina/2)+i;
				index_j1=(duzina/2)+j;
				pom_i1=i;
				pom_j1=j;
			if(duzina+pom_i1&lt;m.size() &amp;&amp; duzina+pom_j1&lt;m.size()) suma_1=saberi(m,pom_i1,index_i1,pom_j1,index_j1,duzina);{
				if(suma_1&gt;suma){
					suma=suma_1;
					index_i=index_i1;
					index_j=index_j1;
					pom_i=pom_i1;
					pom_j=pom_j1;
				}
				if(suma_1==suma){
					if(pom_i1&lt;pom_i){
						suma=suma_1;
						index_i=index_i1;
						index_j=index_j1;
						pom_i=pom_i1;
						pom_j=pom_j1;
					}
					if(pom_i1==pom_i){
						if(pom_j1&lt;pom_j){
							suma=suma_1;
							index_i=index_i1;
							index_j=index_j1;
							pom_i=pom_i1;
							pom_j=pom_j1;
						}
					}
				}
			}
		}
			
	}
	}
//	std::cout&lt;&lt;duzina;
	// sacuvam od koje mi kolone pocinje, jer cu dok popunjavala kolone morat pomjerat j i onda bi bio problem kad predem u drugi red
	int pom_j1(pom_j);
	// formiram matricu koju cu vratiti kao rezultat
	std::vector&lt;std::vector&lt;double&gt;&gt;vrh_planine(duzina,std::vector&lt;double&gt;(duzina));
	for(int p(0);p&lt;vrh_planine.size();p++){
		pom_j=pom_j1;
		for(int q(0);q&lt;vrh_planine[p].size();q++){
			vrh_planine.at(p).at(q)=m.at(pom_i).at(pom_j);
			pom_j++;	
		}
		pom_i++;
	}
	return vrh_planine;
}

int main ()
{ 
	try{
	std::cout&lt;&lt;"Unesite dimenzije matrice (m i n): ";
	int m,n;
	std::cin&gt;&gt;m&gt;&gt;n;
	if(m&lt;0 || n&lt;0){
		std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";
	return 0;
	}
	std::vector&lt;std::vector&lt;double&gt;&gt;mat(m,std::vector&lt;double&gt;(n));
	std::cout&lt;&lt;"Unesite elemente matrice:"&lt;&lt;std::endl;
	for(int i=0;i&lt;mat.size();i++){
		for(int j=0;j&lt;mat[i].size();j++) std::cin&gt;&gt;mat[i][j];
	}
	
	auto planina(NajvecaPlaninaMatrice(mat));
	std::cout&lt;&lt;"Najveca planina unesene matrice je: "&lt;&lt;std::endl;
	for(int i(0);i&lt;planina.size();i++){
		for(int j(0);j&lt;planina[i].size();j++){
			std::cout&lt;&lt;std::setw(6)&lt;&lt;planina[i][j];
		}
		std::cout&lt;&lt;std::endl;
	}
	
	}
	catch(std::domain_error izuzetak){
		std::cout&lt;&lt;izuzetak.what() &lt;&lt;std::endl;
	}
	return 0;
</font>}  


</pre>
</body>
</html>
