<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student3178.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z2/student6195.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 2

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.

*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

typedef std::vector&lt;std::vector&lt;double&gt;&gt; Matrica;

Matrica KreirajMatricu (int broj_redova, int broj_kolona) {
	return Matrica(broj_redova, std::vector&lt;double&gt;(broj_kolona));
}

Matrica UnesiMatricu (int broj_redova, int broj_kolona) {
	auto a(KreirajMatricu(broj_redova, broj_kolona));
	for(int i(0); i &lt; broj_redova; i++) {
		for(int j(0); j &lt; broj_kolona; j++)
		std::cin&gt;&gt;a.at(i).at(j);
	}
	return a;
}
std::vector&lt;int&gt; dajPlaninu(Matrica m,int r,int k){
	double suma=0,sumalast=0; int sirina=1;
	bool planina=false;bool prva=false;
	int brojac=0;
	while(1){
		if(r-sirina&gt;=0&amp;&amp;r+sirina&lt;m.size()&amp;&amp;k-sirina&gt;=0&amp;&amp;k+sirina&lt;m.at(0).size()){
		for(int i=k-sirina;i&lt;=k+sirina;i++){
			suma+=m.at(r-sirina).at(i);
		}
		for(int i=k-sirina;i&lt;=k+sirina;i++){
			suma+=m.at(r+sirina).at(i);
		}
		for(int i=r-sirina+1;i&lt;r+sirina;i++) suma+=m.at(i).at(k-sirina);
		for(int i=r-sirina+1;i&lt;r+sirina;i++) suma+=m.at(i).at(k+sirina);
		}
		else{
			planina=false;
			prva=true;

		}
		if(m.at(r).at(k)&gt;suma&amp;&amp;!prva){
			planina=true;
			sumalast=suma;
			prva=true;
			sirina++;
		}
		else if(suma&gt;sumalast){
			sirina++;
			sumalast=suma;
			suma=0;
		}
		else{
			sirina--;
			planina=false;
		}
		if(!planina){
            if(sirina&lt;0) sirina=0;
            if(r-sirina&lt;0||k-sirina&lt;0||r+sirina&gt;=m.size()|| k+sirina&gt;m.at(0).size()) sirina--;
            if(sirina&lt;0) sirina=0;
			std::vector&lt;int&gt; v{r,k,sirina,0};
			if(brojac==0) v.at(3)=-1;
		
			return v;
		}
		brojac++;
	}
}
Matrica NajvecaPlaninaMatrice (Matrica m) {
	// provjera
<a name="1"></a><font color="#00FF00"><a href="match678-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

	for(int i=0;i&lt;m.size();i++) for(int j=0;j&lt;m.at(i).size();j++) if(m.at(i).size()!=m.at(0).size()) throw std::domain_error("Matrica nije korektna");
	if(m.size()==0||m.at(0).size()==0) return Matrica();
</font><a name="0"></a><font color="#FF0000"><a href="match678-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

	if(m.at(0).size()==1||m.size()==1||m.size()==2&amp;&amp;m.at(0).size()==2){
		double max=m.at(0).at(0);
		for(int i=0;i&lt;m.size();i++) for(int j=0;j&lt;m.at(0).size();j++) if(m.at(i).at(j)&gt;max) max=m.at(i).at(j);
</font>		Matrica tmp(1);
		tmp.at(0).push_back(max);
		return tmp;
	}
	//
	std::vector&lt;std::vector&lt;int&gt;&gt; planine,planinet;
	for(int i=1;i&lt;m.size()-1;i++){
		for(int j=1;j&lt;m.at(i).size()-1;j++){
			planinet.push_back(dajPlaninu(m,i,j));
		}
	}
	for(int i=0;i&lt;planinet.size();i++){
		if(planinet.at(i).at(3)!=-1) planine.push_back(planinet.at(i));
	}
	if(planine.size()==0) {
		double max=m.at(0).at(0);
		for(int i=0;i&lt;m.size();i++) for(int j=0;j&lt;m.at(0).size();j++) if(m.at(i).at(j)&gt;max) max=m.at(i).at(j);
		Matrica tmp(1);
		tmp.at(0).push_back(max);
		return tmp;
	}
	std::vector&lt;int&gt; max(planine.at(0));

	for(int i=0;i&lt;planine.size();i++){
 
		if(planine.at(i).at(2)&gt;max.at(2)) max=planine.at(i);
		else if(max.at(2)==planine.at(i).at(2)&amp;&amp;m.at(planine.at(i).at(0)).at(planine.at(i).at(1))&gt;m.at(max.at(0)).at(max.at(1))) max=planine.at(i);
		else if(max.at(2)==planine.at(i).at(2)&amp;&amp;m.at(planine.at(i).at(0)).at(planine.at(i).at(1))==m.at(max.at(0)).at(max.at(1))&amp;&amp;planine.at(i).at(0)&gt;max.at(0)){
			max=planine.at(i);
		}
		else if(max.at(2)==planine.at(i).at(2)&amp;&amp;m.at(planine.at(i).at(0)).at(planine.at(i).at(1))==m.at(max.at(0)).at(max.at(1))&amp;&amp;planine.at(i).at(0)==max.at(0)&amp;&amp;planine.at(i).at(1)&gt;max.at(1)){
			max=planine.at(i);
		}
	}
	if(max.at(2)&lt;1) return Matrica();
	Matrica tmpmat(2*max.at(2)+1);

	int brojac=0;
	for(int i=max.at(0)-max.at(2);i&lt;=max.at(0)+max.at(2);i++){
<a name="2"></a><font color="#0000FF"><a href="match678-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		for(int j=max.at(1)-max.at(2);j&lt;=max.at(1)+max.at(2);j++ ) tmpmat.at(brojac).push_back(m.at(i).at(j));
		brojac++;
	}
	return tmpmat;
}

int main ()
{
	int m, n;
	std::cout&lt;&lt;"Unesite dimenzije matrice (m i n): ";
	std::cin&gt;&gt;m&gt;&gt;n;
	if(m&lt;0||n&lt;0){
</font>		std::cout&lt;&lt;"Dimenzije matrice moraju biti nenegativne!";
		return 0;
	}

	std::cout&lt;&lt;"Unesite elemente matrice:\n";
	auto a=UnesiMatricu(m,n);
	try{
	Matrica mat=NajvecaPlaninaMatrice(a);
	std::cout&lt;&lt;"Najveca planina unesene matrice je:\n";
	for(int i=0;i&lt;mat.size();i++){
		for(int j=0;j&lt;mat.at(i).size();j++) std::cout&lt;&lt;std::setw(6)&lt;&lt;mat.at(i).at(j);
		std::cout&lt;&lt;std::endl;
	}
	}
	catch(std::domain_error e){
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what()&lt;&lt;std::endl;
	}

	return 0;
}
</pre>
</body>
</html>
