<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student6877.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student3701.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;

typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;

long long int Obicni_presjek (long long int a) {
	return a;
}

int SumaDjelilaca (long long int broj) {
	int suma=0; 
	for (long long int max=fabs(broj); max&gt;0; max--)
		if (broj%max==0) suma+=max;
	return suma;
}

bool Da_li_je_prost (long long int broj) {
	if (broj&lt;=1) return false;
	for (int i=2; i&lt;=sqrt(broj); i++)
		if (broj%i==0) return false;
	return true;
}

int BrojProstihFaktora (long long int broj) {
	std::vector&lt;int&gt; pom;
	if (Da_li_je_prost(broj)) { int brojac=1; return brojac; }
	for (int i=2; i&lt;broj/2+1; i++)
		if (broj%i==0 &amp;&amp; Da_li_je_prost(i)==true) {
			pom.push_back(i);
			broj=broj/i;
			if (Da_li_je_prost(broj)) {pom.push_back(broj); break;}
			i--;
			if (broj==1) break;
		}
	return pom.size();
}

bool Savrsen_broj (int broj) {
	if (broj&lt;=0) return false;
	int suma_cifara=0;
	for (int i=1; i&lt;broj; i++)
		if (int(broj)%i==0) suma_cifara+=i;
	if (suma_cifara==int(broj)) return true;
	return false;
}

int BrojSavrsenihDjelilaca (long long int broj) {
	int savrseni=0;
	for (long long int max=fabs(broj); max&gt;0; max--)
		if (broj%max==0 &amp;&amp; Savrsen_broj(max)==true) savrseni++;
	return savrseni;
}

int SumaCifara (long long int broj) {
	int suma=0;
	while (broj!=0){
		int cifra=broj%10;
		suma+=cifra;
		broj/=10;
	}
	return suma;
}

template &lt;typename Tip1, typename Tip2&gt;
//std::vector&lt;std::vector&lt;int&gt;&gt; UvrnutiPresjek (Tip1 poc1, Tip1 iza_k1, Tip2 poc2, Tip2 iza_k2) {
<a name="0"></a><font color="#FF0000"><a href="match933-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

auto UvrnutiPresjek (Tip1 poc1, Tip1 iza_k1, Tip2 poc2, Tip2 iza_k2)-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt;&gt; {
	std::vector&lt;std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt;&gt; mat;
	std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt; p;
</font>	int i=0;
	bool da=true;
	for (auto temp1=poc1; temp1 != iza_k1; temp1++){
		da=true;
		for (auto temp2=poc2; temp2 != iza_k2; temp2++) {
			if (Obicni_presjek(*temp1)==Obicni_presjek(*temp2)) {
				p.push_back(*temp1);
				p.push_back(0);
				p.push_back(0);
				mat.resize(i);
				mat.push_back(p);
				p.resize(0);
				i++;
			}
		}
	}
	std::sort(mat.begin(), mat.end());
	return mat;
}

template &lt;typename Tip1, typename Tip2, typename Tip, typename P_Tip&gt;
//std::vector&lt;std::vector&lt;int&gt;&gt; UvrnutiPresjek (Tip1 poc1, Tip1 iza_k1, Tip2 poc2, Tip2 iza_k2, P_Tip f(Tip)) {
<a name="1"></a><font color="#00FF00"><a href="match933-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

auto UvrnutiPresjek (Tip1 poc1, Tip1 iza_k1, Tip2 poc2, Tip2 iza_k2, P_Tip f(Tip))-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt;&gt; {
	std::vector&lt;std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt;&gt; mat;
	std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt; p;
</font>	int i=0;
	for (auto temp1=poc1; temp1!=iza_k1; temp1++) {
		for (auto temp2=poc2; temp2!=iza_k2; temp2++) {
<a name="4"></a><font color="#FF00FF"><a href="match933-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

			if (f(*temp1)==f(*temp2)) {
				p.push_back(*temp1);
           		p.push_back(*temp2);
        	 	p.push_back(f(*temp1));
           		mat.resize(i);
            	mat.push_back(p);
</font>            	p.resize(0);
            	i++;
			}
		}
	}
//std::cout&lt;&lt;"mat "&lt;&lt;mat.size();
	std::sort(mat.begin(),mat.end(), [](const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;a,const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;b) {
									//	for (int i=a.size()-1; i&gt;0; i--) 
										int i=a.size()-1;
										if (a[i]!=b[i]) return a[i]&lt;b[i]; 
										else if (a[i]==b[i] &amp;&amp; a[0]==b[0]) return a[i-1]&lt;b[i-1];
										return a[0]&lt;b[0]; });
	return mat;
}

template &lt;typename Tip1, typename Tip2&gt;
<a name="2"></a><font color="#0000FF"><a href="match933-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

auto UvrnutaRazlika (Tip1 poc1, Tip1 iza_k1, Tip2 poc2, Tip2 iza_k2)-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt;&gt; {
	std::vector&lt;std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt;&gt; mat;
	std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt; p;
</font>	int i=0;
	bool pom=true, r=true;
	for (auto temp1=poc1; temp1 != iza_k1; temp1++) {
		pom=true;
		for (auto temp2=poc2; temp2 != iza_k2; temp2++) 
			if (Obicni_presjek(*temp1)==Obicni_presjek(*temp2)) pom=false;
		if (pom==true) {
			p.push_back(*temp1);
			p.push_back(0);
			mat.resize(i);
			mat.push_back(p);
			p.resize(0);
			i++;
		}
	}
	for (auto temp2=poc2; temp2!=iza_k2; temp2++) {
		r=true;
		for (auto temp1=poc1; temp1!=iza_k1; temp1++)
			if (Obicni_presjek(*temp2)==Obicni_presjek(*temp1)) r=false;
		if (r==true) {
			p.push_back(*temp2);
			p.push_back(0);
			mat.resize(i);
			mat.push_back(p);
			p.resize(0);
			i++;
		}
	}
	std::sort (mat.begin(),mat.end(),[](const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;a,const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;b) { return a&gt;b;});
	return mat;
}


template &lt;typename Tip1, typename Tip2, typename Tip, typename P_Tip&gt;
//std::vector&lt;std::vector&lt;int&gt;&gt; UvrnutaRazlika (Tip1 poc1, Tip1 iza_k1, Tip2 poc2, Tip2 iza_k2, P_Tip f(Tip)) {
<a name="3"></a><font color="#00FFFF"><a href="match933-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

auto UvrnutaRazlika (Tip1 poc1, Tip1 iza_k1, Tip2 poc2, Tip2 iza_k2, P_Tip f(Tip))-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt;&gt; { 
	std::vector&lt;std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt;&gt; mat;
	std::vector&lt;typename std::remove_reference &lt;decltype(*poc1)&gt;::type&gt; p;
</font>	int i=0;
	bool pom=true, r=true;
	for (auto temp1=poc1; temp1 != iza_k1; temp1++) {
		pom=true;
		for (auto temp2=poc2; temp2 != iza_k2; temp2++) 
			if (f(*temp1)==f(*temp2)) pom=false;
		if (pom==true) {
			p.push_back(*temp1);
			p.push_back(f(*temp1));
			mat.resize(i);
			mat.push_back(p);
			p.resize(0);
			i++;
		}
	}
	for (auto temp2=poc2; temp2!=iza_k2; temp2++) {
		r=true;
		for (auto temp1=poc1; temp1!=iza_k1; temp1++)
			if (f(*temp2)==f(*temp1)) r=false;
		if (r==true) {
			p.push_back(*temp2);
			p.push_back(f(*temp2));
			mat.resize(i);
			mat.push_back(p);
			p.resize(0);
			i++;
		}
	}
	std::sort (mat.begin(),mat.end(),[](const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;a,const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;b) { return a&gt;b;});
	return mat;
}

template &lt;typename Tip&gt;
void Ispisi(std::vector&lt;std::vector&lt;Tip&gt;&gt; m){
	for (int i=0; i&lt;m.size(); i++) {
		for (int j=0; j&lt;m[i].size(); j++)
			std::cout&lt;&lt;std::right&lt;&lt;std::setw(6)&lt;&lt;m[i][j]&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}
}

int main ()
{
	int vel1,vel2,pom=0;
	int broj;
   	std::deque&lt;int&gt; dek1, dek2;
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	std::cin&gt;&gt;vel1;
    std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	for (int i=0; i&lt;vel1; i++) {
		std::cin&gt;&gt;broj;
		pom=0;
		for (auto j=dek1.begin(); j!=dek1.end(); j++)
			if (broj==*j) pom=1;
		if (pom==0) dek1.push_back(broj);
		else {i--;}
	}
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;vel2;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	for (int i=0; i&lt;vel2; i++){
      std::cin&gt;&gt;broj;
      pom=0;
      for (auto j=dek2.begin(); j!=dek2.end(); j++)
         if (broj==*j) pom=1;
      if (pom==0) dek2.push_back(broj);
      else { i--; }
   }
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera:\n";
	auto presjek=UvrnutiPresjek(dek1.begin(),dek1.end(),dek2.begin(),dek2.end(),SumaCifara);
	Ispisi(presjek);
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera:\n";
	auto razlika=UvrnutaRazlika(dek1.begin(),dek1.end(),dek2.begin(),dek2.end(),BrojProstihFaktora);
	Ispisi(razlika);
	std::cout&lt;&lt;"Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
