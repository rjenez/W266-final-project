<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student6255.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student3411.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

template &lt;typename Tip1, typename Tip2, typename TipFunkcije, typename TipParametra&gt;
auto UvrnutiPresjek(Tip1 p1, Tip1 p2, Tip2 p3, Tip2 p4, TipFunkcije fun(TipParametra)/*=[] (typename std::remove_reference&lt;decltype(*p1)&gt;::type x) {return x;}*/) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt; typename std::remove_reference&lt;decltype(*p1)&gt;::type &gt;&gt; matrica;
	Tip1 pomocna1(p1);
	Tip2 pomocna2(p3);
	int br(0);
<a name="0"></a><font color="#FF0000"><a href="match482-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	while(pomocna1!=p2){
		pomocna2=p3;
		while(pomocna2!=p4){
			//if-uslov koji provjerava da li za date elemente iz blokova podataka funkcija daje istu vrijednost
			//ukoliko je uslov zadovoljen u matricu se smjestaju dobijeni podaci na nacin koji je specifirano u zadatku
			if(fun(*pomocna1)==fun(*pomocna2)){
				br++;
				matrica.resize(br);
				matrica[br-1].resize(3);
				matrica[br-1][0]=*pomocna1;
				matrica[br-1][1]=*pomocna2;
				matrica[br-1][2]=fun(*pomocna1);
			}
			pomocna2++;
		}
		pomocna1++;
	}
	//sortiranje matrice po zadanom poretku
	std::sort(matrica.begin(), matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; q1, std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; q2){
</font>	if(q1[2]&lt;q2[2]) return true; else if(q1[2]&gt;q2[2]) return false; else if(q1[2]==q2[2]){
		if(q1[0]&lt;q2[0]) return true; else if(q1[0]&gt;q2[0]) return false; else if(q1[0]==q2[0]){
			if(q1[1]&lt;q2[1]) return true; else if(q1[1]&gt;q2[1]) return false; else if(q1[1]==q2[1]) return true;
		}
	}});
	return matrica;
}
//Preklapanje funckije UvrnutiPresjek da bi se obezbijedilo njeno funkcionisanje ukoliko se pozove i sa 4 i sa 5 parametara
//Princip rada ove funckije je identican prethodno opisanom 
template &lt;typename Tip1, typename Tip2&gt;
auto UvrnutiPresjek(Tip1 p1, Tip1 p2, Tip2 p3, Tip2 p4)-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt; typename std::remove_reference&lt;decltype(*p1)&gt;::type &gt;&gt; matrica;
	Tip1 pomocna1(p1);
	Tip2 pomocna2(p3);
	int br(0);
<a name="1"></a><font color="#00FF00"><a href="match482-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

	while(pomocna1!=p2){
		pomocna2=p3;
		while(pomocna2!=p4){
			if(*pomocna1==*pomocna2){
				br++;
				matrica.resize(br);
				matrica[br-1].resize(3);
				matrica[br-1][0]=*pomocna1;
				matrica[br-1][1]=0;
				matrica[br-1][2]=0;
			}
			pomocna2++;
</font>		}
		pomocna1++;
	}
	std::sort(matrica.begin(), matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; q1,std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; q2){
	if(q1[0]&lt;=q2[0]) return true; else return false;});
	return matrica;
}
template &lt;typename Tip1, typename Tip2&gt;
auto UvrnutaRazlika(Tip1 p1, Tip1 p2, Tip2 p3, Tip2 p4)-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt; typename std::remove_reference&lt;decltype(*p1)&gt;::type &gt;&gt; matrica;
	Tip1 pomocna1(p1);
	Tip2 pomocna2(p3);
	int br(0);
	while(pomocna1!=p2){
		pomocna2=p3;
		bool jednaki(false);
		while(pomocna2!=p4){
			if(*pomocna1==*pomocna2){
				jednaki=true;
				break;
			}
			pomocna2++;
		}
		if(!jednaki){
			br++;
			matrica.resize(br);
			matrica[br-1].resize(2);
			matrica[br-1][0]=*pomocna1;
			matrica[br-1][1]=0;
		}
		pomocna1++;
	}
	pomocna1=p1;
	pomocna2=p3;
	while(pomocna2!=p4){
		pomocna1=p1;
		bool jednaki(false);
		while(pomocna1!=p2){
			if(*pomocna1==*pomocna2){
				jednaki=true;
				break;
			}
<a name="3"></a><font color="#00FFFF"><a href="match482-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			pomocna1++;
		}
		if(!jednaki){
			br++;
			matrica.resize(br);
			matrica[br-1].resize(2);
			matrica[br-1][0]=*pomocna2;
			matrica[br-1][1]=0;
</font>		}
		pomocna2++;
	}
	std::sort(matrica.begin(), matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; q1,std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; q2){
	if(q1[0]&lt;=q2[0]) return false; else return true;});
	return matrica;
}
template &lt;typename Tip1, typename Tip2, typename TipFunkcije, typename TipParametra&gt;
auto UvrnutaRazlika(Tip1 p1, Tip1 p2, Tip2 p3, Tip2 p4, TipFunkcije fun(TipParametra))-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt; typename std::remove_reference&lt;decltype(*p1)&gt;::type &gt;&gt; matrica;
	Tip1 pomocna1(p1);
	Tip2 pomocna2(p3);
	int br(0);
	//2 ugnijezdene while-petlje koje traze elemente prvog bloka elemenata koji nemaju svog para u drugom bloku elemenata
	while(pomocna1!=p2){
		pomocna2=p3;
		bool jednaki(false);
		while(pomocna2!=p4){
			if(fun(*pomocna1)==fun(*pomocna2)){
				jednaki=true;
				break;
			}
			pomocna2++;
		}
		if(!jednaki){
			br++;
			matrica.resize(br);
<a name="2"></a><font color="#0000FF"><a href="match482-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

			matrica[br-1].resize(2);
			matrica[br-1][0]=*pomocna1;
			matrica[br-1][1]=fun(*pomocna1);
		}
		pomocna1++;
	}
	pomocna1=p1;
	pomocna2=p3;
	//2 ugnijezdene while-petlje koje izvdajaju elemente iz drugog bloka elemenata koji nemaju svog para u prvom bloku
	while(pomocna2!=p4){
		pomocna1=p1;
		bool jednaki(false);
</font>		while(pomocna1!=p2){
			if(fun(*pomocna1)==fun(*pomocna2)){
				jednaki=true;
				break;
			}
			pomocna1++;
		}
		if(!jednaki){
			br++;
			matrica.resize(br);
			matrica[br-1].resize(2);
			matrica[br-1][0]=*pomocna2;
			matrica[br-1][1]=fun(*pomocna2);
		}
		pomocna2++;
	}
	//sortiranje matrice u zadani poredak
	std::sort(matrica.begin(), matrica.end(), [] (std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; q1, std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; q2){
		if(q1[0]&gt;q2[0]) return true; else if(q1[0]&lt;q2[0]) return false; else if(q1[0]==q2[0]){
			if(q1[1]&gt;=q2[1]) return true; else if(q1[1]&lt;q2[1]) return false;
		}
	});
	return matrica;
}

bool Prost(long long int x){
	//PAZI NA OPSEG: KORISTIS ABS
	int kor(sqrt(abs(x)));
	bool prost(true);
	if(x==2) return true;
	if(x==0 || x==1 || x%2==0) return false;
	for(int i=3; i&lt;=kor; i+=2){
		if(x%i==0) {
			prost=false;
			break;
		}
	}
	return prost;
}

int SumaDjelilaca(long long int x){
	int suma(x);
	if(x&gt;=0){
		for(long long int i=1; i&lt;=x/2; i++)
		if(x%i==0) suma+=i;
	}
	if(x&lt;0){
		suma*=-1;
		for(long long int i=1; i&lt;=(-1*(x/2)); i++)
		if(x%i==0) suma+=i;
	}
	return suma;
}

int BrojProstihFaktora(long long int x){
	int br(0);
	if(x&lt;0) x*=-1;
		for(long long int i=2; i&lt;=(x/2); i++){
			long long int broj(x);
			if(broj%i==0 &amp;&amp; Prost(i)){
				while(broj%i==0){
					br++;
					broj/=i;
				}
			}
		}
		if(Prost(x)) br++;
	return br;
}
int BrojSavrsenihDjelilaca(long long int x){
	int br(0);
	 if(x&gt;0){
	for(long long int i=2; i&lt;=x; i++){
		if(x%i==0){
			int djelilac(SumaDjelilaca(i)-i);
			if(i==djelilac) br++;
		}
	}
	}
	else if(x&lt;0){
		for(long long int i=x; i&lt;=-2; i++){
			if(x%i==0){
				int djelilac(1*(SumaDjelilaca(i)-i));
				if(i==djelilac) br++;
			}
		}
	}
	return br;
}

int ZbirCifara(long long int x){
	int suma(0);
	if(x&gt;0){
		while(x&gt;0){
			suma+=x%10;
			x/=10;
		}
	}
	if(x&lt;0){
		while(x&lt;0){
			suma+=x%10;
			x/=10;
		}
	//	suma*=-1;
	}
	return suma;
}
int main ()
{	int n1,n2,br1(0),br2(0);
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	std::cin&gt;&gt;n1;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	std::deque&lt;int&gt; v1(n1);
	for(int i=0; i&lt;n1; i++){
		int x;
		std::cin&gt;&gt;x;
		if(!(std::count(v1.begin(), v1.begin()+br1,x))) {
			v1[i]=x;
			br1++;
		}
		else i--;
	}
	v1.resize(br1);
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;n2;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	std::deque&lt;int&gt; v2(n2);
	for(int i=0; i&lt;n2; i++){
		int x;
		std::cin&gt;&gt;x;
		if(!(std::count(v2.begin(), v2.begin()+br2,x))){
			v2[i]=x;
			br2++;
		}
		else i--;
	}
	v2.resize(br2);
	/*std::vector&lt;std::vector&lt;int&gt;&gt;*/ auto a(UvrnutiPresjek(v1.begin(),v1.end(),v2.begin(),v2.end(),ZbirCifara));
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera:"&lt;&lt;std::endl;
<a name="4"></a><font color="#FF00FF"><a href="match482-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	for(int i=0; i&lt;a.size(); i++){
		for(int j=0; j&lt;a[i].size(); j++){
</font>			std::cout&lt;&lt;std::right&lt;&lt;std::setw(6)&lt;&lt;a[i][j]&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	auto a1(UvrnutaRazlika(v1.begin(),v1.end(),v2.begin(),v2.end(),BrojProstihFaktora));
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera:"&lt;&lt;std::endl;
	for(int i=0; i&lt;a1.size(); i++){
		for(int j=0; j&lt;a1[i].size(); j++){
			std::cout&lt;&lt;std::right&lt;&lt;std::setw(6)&lt;&lt;a1[i][j]&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
