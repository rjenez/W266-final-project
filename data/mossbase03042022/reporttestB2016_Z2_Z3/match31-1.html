<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4273.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student1364.cpp<p></p><pre>
/*B 16/17, Zadaća 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

<a name="0"></a><font color="#FF0000"><a href="match31-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_61.gif"/></a>

using std::cin; using std::cout; using std::endl;

int SumaCifara (long long int broj) {
	int suma(0);
	do {
		int cifra(fabs(broj%10));
		suma+=cifra;
		broj/=10;
	}
	while (broj!=0);
	return suma;
}

int SumaDjelilaca(long long int broj) {
	int suma(0); 
	long long int br(fabs(broj));
	for (int i=1; i&lt;=br; i++) { //Ubaci za prekoracenje
		if (br%i==0)
		suma+=i;
	}
	return suma;
}

int BrojProstihFaktora (long long int broj) {
	//Nadjimo prvo faktore broja, a zatim izbacimo proste
	std::vector&lt;int&gt; vek; //Vektor prostih faktora
	long long int n(broj);
	for (int i=2; i&lt;=n; i++) { //Long long?
		while(n%i==0) {
			vek.push_back(i);
			n/=i;
		}
	}
	return vek.size();
}

int BrojSavrsenihDjelilaca (long long int broj) {
	long long int n(fabs(broj));
	int brojac(0);
	for (int i=2; i&lt;=n; i++) {
		if (n%i==0) {
			if (i==(SumaDjelilaca(i)-i)) brojac++; 
		}
	}
	return brojac;
}

template &lt;typename Kontejner1, typename Kontejner2, typename NekiTip1, typename NekiTip2&gt;
auto UvrnutiPresjek(Kontejner1 poc1, Kontejner1 iza_k1, Kontejner2 poc2, Kontejner2 iza_k2, NekiTip2 funkcija(NekiTip1)) -&gt; typename std::vector&lt;std::vector&lt;decltype(*poc1+*poc1)&gt;&gt; {
	typedef decltype(*poc1+*poc1) Tip;
	int brojac(0);
	std::vector&lt;Tip&gt; vek;
	for (int i=0; i&lt;(iza_k1-poc1); i++) {
		for (int j=0; j&lt;(iza_k2-poc2); j++) {
			if (funkcija(poc1[i])==funkcija(poc2[j])) {
				vek.push_back(poc1[i]); vek.push_back(poc2[j]); vek.push_back(funkcija(poc1[i]));
				brojac++; //Broj elemenata u presjeku
			}
		}
	}
	std::vector&lt;std::vector&lt;Tip&gt;&gt; matrica(brojac, std::vector&lt;Tip&gt;(3)); //Matrica formata br.elx3
	int k(0);
	for (int i=0; i&lt;brojac; i++) {
		for (int j=0; j&lt;3; j++) {
			matrica[i][j]=vek[k];
			k++;
		}
	}
	//Prije vracanja sortirajmo 
	sort(matrica.begin(), matrica.end());
		/*Sortirajmo potrebno je njene redove sortirati u rastući poredak po vrijednosti treće koordinate, tj. po vrijednosti
funkcije . Ukoliko dva reda imaju istu vrijednost f, tada ih treba sortirati po vrijednosti x, a
ukoliko se i vrijednoti x poklapaju, onda po vrijednosti y. Za sortiranje obavezno koristite
funkciju “sort” iz biblioteke “algorithm” uz prikladnu funkciju kriterija implementiranu kao
lambda funkcija.*/
	sort (matrica.begin(), matrica.end(), [] (std::vector&lt;Tip&gt; v1, std::vector&lt;Tip&gt; v2) {
		if (v1[2]==v2[2]) { //Ako su iste vrijednosti funkcije, tj. trece koordinate
			if (v1[0]==v2[0]) { //Ako je isto x
				return v1[1]&lt;v2[1]; //Opadajuci
			}
			return v1[0]&lt;v2[0];
		}
		return v1[2]&lt;v2[2]; //Rastuci kriterij
	});
	return matrica;
}

template &lt;typename Kontejner, typename Kontejner2&gt;
auto UvrnutiPresjek (Kontejner poc1, Kontejner iza_k1, Kontejner2 poc2, Kontejner2 iza_k2) -&gt; typename std::vector&lt;std::vector&lt;decltype(*poc1+*poc1)&gt;&gt; {
	typedef decltype(*poc1+*poc1) Tip;
	std::vector&lt;Tip&gt; vek; 
	int brojac(0);
	for (int i=0; i&lt;(iza_k1-poc1); i++) {
		for (int j=0; j&lt;(iza_k2-poc2); j++) {
			if (poc1[i]==poc2[j]) {
				//Provjerimo da li se element vec javlja u vektoru
				int k(0);
				for (k=0; k&lt;vek.size(); k++) {
					if (poc1[i]==vek[k]) break;
				}
				if (k==vek.size()) {
					vek.push_back(poc1[i]);	//Pronasli smo element presjeka
					brojac++;
				}
			}
		}
	}
	std::vector&lt;std::vector&lt;Tip&gt;&gt; matrica (brojac, std::vector&lt;Tip&gt;(3));
	for (int i=0; i&lt;brojac; i++) {
		for (int j=0; j&lt;3; j++) {
			matrica[i][0]=vek[i];
			if (j!=0) {
				matrica[i][j]=0;    
			}
		}
	}
	//Prije vracanja sortirajmo
	sort(matrica.begin(), matrica.end());
	return matrica;
}

template &lt;typename Kontejner1, typename Kontejner2, typename NekiTip1, typename NekiTip2&gt;
auto UvrnutaRazlika(Kontejner1 poc1, Kontejner1 iza_k1, Kontejner2 poc2, Kontejner2 iza_k2, NekiTip2 funkcija(NekiTip1)) -&gt; typename std::vector&lt;std::vector&lt;decltype(*poc1+*poc1)&gt;&gt; {
	int brojac(0);
	typedef decltype(*poc1+*poc1) Tip;
	std::vector&lt;Tip&gt; vek;
	//Razlika kont1 i kont2
	for (int i=0; i&lt;(iza_k1-poc1); i++) {
		int j(0);
		for (j=0; j&lt;(iza_k2-poc2); j++) {
			if (funkcija(poc1[i])==funkcija(poc2[j])) break; 
		}
		//Ako nismo pronasli ni jednu vrijednost, pronasli smo razliku
		if (j==iza_k2-poc2) { //Provjerimo da li se nalazi vec u vektoru
			int k(0);
			for (k=0; k&lt;vek.size(); k++) {
				if (poc1[i]==vek[k]) break;
			}
			if (k==vek.size()) { //Nije doslo de prekida
				vek.push_back(poc1[i]); vek.push_back(funkcija(poc1[i]));
				brojac++; //Broj elemenata u presjeku
				}
		}
	}
	//Razlika kont2 i kont1
	for (int j=0; j&lt;(iza_k2-poc2); j++) {
		int i(0);
		for (i=0; i&lt;(iza_k1-poc1); i++) {
			if (funkcija(poc1[i])==funkcija(poc2[j])) break; 
		}
		//Ako nismo pronasli ni jednu vrijednost jednaku, pronasli smo razliku
		if (i==iza_k1-poc1) { //Provjerimo da li se nalazi vec u vektoru
			int k(0);
			for (k=0; k&lt;vek.size(); k++) {
				if (poc2[j]==vek[k]) break;
			}
			if (k==vek.size()) { //Nije doslo de prekida
				vek.push_back(poc2[j]); vek.push_back(funkcija(poc2[j]));
				brojac++; //Broj elemenata u presjeku
				}
		}
	}
	
	std::vector&lt;std::vector&lt;Tip&gt;&gt; matrica(brojac, std::vector&lt;Tip&gt;(2)); //Matrica formata br.elx2
	int k(0);
	for (int i=0; i&lt;brojac; i++) {
		for (int j=0; j&lt;2; j++) {
			matrica[i][j]=vek[k];
			k++;
		}
	}
	//Konacno, sortirajmo matricu
	sort (matrica.begin(), matrica.end(), [] (std::vector&lt;Tip&gt; v1, std::vector&lt;Tip&gt; v2) {
		if (v1[0]==v2[0]) return v1[1]&gt;v2[1];
		return v1[0]&gt;v2[0];
</font>	});
	
	return matrica;
}

//Uvrnuta razlika sa cetiri parametra
template &lt;typename Kontejner, typename Kontejner2&gt;
<a name="1"></a><font color="#00FF00"><a href="match31-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_36.gif"/></a>

auto UvrnutaRazlika (Kontejner poc1, Kontejner iza_k1, Kontejner2 poc2, Kontejner2 iza_k2) -&gt; typename std::vector&lt;std::vector&lt;decltype(*poc1+*poc1)&gt;&gt; {
	typedef decltype(*poc1+*poc1) Tip;
	int brojac(0);
	std::vector&lt;Tip&gt; vek;
	//Razlika kont1 i kont2
	for (int i=0; i&lt;(iza_k1-poc1); i++) {
		int j(0);
		for (j=0; j&lt;(iza_k2-poc2); j++) {
			if (poc1[i]==poc2[j]) break; 
		}
		//Ako nismo pronasli ni jednu vrijednost, pronasli smo razliku
		if (j==iza_k2-poc2) { //Provjerimo da li se nalazi vec u vektoru
			int k(0);
			for (k=0; k&lt;vek.size(); k++) {
				if (poc1[i]==vek[k]) break;
			}
			if (k==vek.size()) { //Nije doslo de prekida
				vek.push_back(poc1[i]); vek.push_back(0);
				brojac++; //Broj elemenata u presjeku
				}
		}
	}
	//Razlika kont2 i kont1
	for (int j=0; j&lt;(iza_k2-poc2); j++) {
		int i(0);
		for (i=0; i&lt;(iza_k1-poc1); i++) {
			if (poc1[i]==poc2[j]) break; 
		}
		//Ako nismo pronasli ni jednu vrijednost jednaku, pronasli smo razliku
		if (i==iza_k1-poc1) { //Provjerimo da li se nalazi vec u vektoru
			int k(0);
			for (k=0; k&lt;vek.size(); k++) {
				if (poc2[j]==vek[k]) break;
			}
			if (k==vek.size()) { //Nije doslo de prekida
				vek.push_back(poc2[j]); vek.push_back(0);
				brojac++; //Broj elemenata u presjeku
				}
		}
	}
	std::vector&lt;std::vector&lt;Tip&gt;&gt; matrica (brojac, std::vector&lt;Tip&gt;(2));
	int k(0);
	for (int i=0; i&lt;brojac; i++) {
		for (int j=0; j&lt;2; j++) {
			matrica[i][j]=vek[k];
			k++;
		}
	}
	//Prije vracanja sortirajmo
	sort(matrica.begin(), matrica.end(), [] (std::vector&lt;int&gt; v1, std::vector&lt;Tip&gt; v2) {
		return v1[0]&gt;v2[0];
	});
	return matrica;
}

int main ()
{
	std::deque&lt;int&gt; dek1, dek2;
	//cout &lt;&lt; BrojProstihFaktora(5) &lt;&lt; endl;
	//cout &lt;&lt; BrojSavrsenihDjelilaca(168);
	cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	int br1, br2;
	cin &gt;&gt; br1;
	//Pri unosu treba obezbijediti da se ponavljanje već unesenog elementa ignorira, tako da oba deka sigurno imaju sve različite elemente prije poziva funkcija
	cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	for (int i=0; i&lt;br1; i++) {
		int broj; 
		cin &gt;&gt; broj;
		for (int i=0; i&lt;dek1.size(); i++) {
			while (dek1[i]==broj)  {
				cin&gt;&gt; broj; i=0; 
			}
		}
		dek1.push_back(broj);
	}
	cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	cin &gt;&gt; br2; //Ispravi unos!!!!
	cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	for (int i=0; i&lt;br2; i++) {
		int broj;
		cin &gt;&gt; broj; //Provjerimo je li vec unesen
		for (int i=0; i&lt;dek2.size(); i++) {
			while (dek2[i]==broj) {
				cin&gt;&gt; broj; i=0; 
			}
		}
		dek2.push_back(broj);
	}
	auto matrica=UvrnutiPresjek(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), SumaCifara);
	cout &lt;&lt; "Uvrnuti presjek kontejnera: " &lt;&lt; endl;
	for (int i=0; i&lt;matrica.size(); i++) {
		for (int j=0; j&lt;3; j++) {
			cout &lt;&lt; std::setw(6) &lt;&lt;matrica[i][j] &lt;&lt; " " ;
		}
		cout &lt;&lt; endl;
	}
	auto matrica1=UvrnutaRazlika(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), BrojProstihFaktora);
	
	cout &lt;&lt; "Uvrnuta razlika kontejnera: " &lt;&lt; endl;
	for (int i=0; i&lt;matrica1.size(); i++) {
		for (int j=0; j&lt;2; j++) {
			cout &lt;&lt; std::setw(6) &lt;&lt;matrica1[i][j] &lt;&lt; " " ;
		}
		cout &lt;&lt; endl;
	}
	cout &lt;&lt; "Dovidjenja!";
	return 0;
</font>}</pre>
</body>
</html>
