<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4415.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4415.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: i javni ATo-vi su dio postavke

	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba

*/

#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;iomanip&gt;



int BrojProstihFaktora (int n)
{
	int brojac(0);
	int djelilac(2);
	if (n == 0) return 0;
	while (n != 1) {
		if (n % djelilac != 0) djelilac++;
		else {
			n /= djelilac;
			brojac++;
		}
	}
	return brojac;
}

bool Savrsen (int n) 
{
	int suma1(0);
	for (int i = 1; i &lt; n; i++) {
		if (n % i == 0) suma1 += i;
	}
	
	return suma1 == n;
}


int BrojSavrsenihDjelilaca (int n) 
{
	int brojac(0);
	for (int i = 2; i &lt;= n; i++) {
		if (n % i == 0 and Savrsen(i)) brojac++;
	}
	return brojac;
}

int SumaDjelilaca(int n)
{
	int suma = 1;
	for (int i = 2; i*i &lt;= n; i++) {
		int p = 1;
		while (n%i == 0) {
			p = p*i+1;
			n /= i;
		}
		suma *= p;
	}
	if (n &gt; 1)
		suma *= 1 + n;
	return suma;
}

int SumaCifara (int n) 
{
	int suma(0);
	while (n !=0) {
		suma += abs(n%10);
		n /= 10;
	}
	return suma;
}

template &lt;typename TipPok1,typename TipPok2,typename TipF_par,typename TipF_ret&gt;
auto UvrnutiPresjek(TipPok1 p1,TipPok1 p2,TipPok2 p3, TipPok2 p4,TipF_ret fun(TipF_par)) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; 
{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	auto poc(p3);
	while (p1 != p2) {
		p3 = poc;
		while (p3 != p4) {
			if (fun(*p1) == fun(*p3)) {
				Matrica.push_back({*p1,*p3,fun(*p1)});
			}
			p3++;
		}
		p1++;
	}
	
<a name="0"></a><font color="#FF0000"><a href="match628-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

	std::sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;decltype(*p1+*p1)&gt; v1,std::vector&lt;decltype(*p1+*p1)&gt; v2) {
		if (v1[2] &lt; v2[2]) return true;
		if(v1[2] == v2[2]) {
			if(v1[0] &lt; v2[0]) return true;
			if (v1[0] == v2[0]) {
				if (v1[1] &lt; v2[1]) return true;
			}
			return false;
</font>		}
		return false;
	});
	
	return Matrica;
}

template &lt;typename TipPok1,typename TipPok2&gt;
auto UvrnutiPresjek(TipPok1 p1,TipPok1 p2,TipPok2 p3, TipPok2 p4) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; 
{	
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	auto poc(p3);
	while (p1 != p2) {
		p3 = poc;
		while (p3 != p4) {
			if ((*p1) == (*p3)) {
				Matrica.push_back({*p1,decltype(*p3+*p3)(),decltype(*p1+*p1)()});
			}
			p3++;
		}
		p1++;
	}
	
<a name="1"></a><font color="#00FF00"><a href="match628-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

	std::sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;decltype(*p1+*p1)&gt; v1,std::vector&lt;decltype(*p1+*p1)&gt; v2) {
		if (v1[2] &lt; v2[2]) return true;
		if(v1[2] == v2[2]) {
			if(v1[0] &lt; v2[0]) return true;
			if (v1[0] == v2[0]) {
				if (v1[1] &lt; v2[1]) return true;
			}
			return false;
</font>		}
		return false;
	});
	
	return Matrica;
}
template &lt;typename TipPok1,typename TipPok2,typename TipF_par,typename TipF_ret&gt;
auto UvrnutaRazlika(TipPok1 p1,TipPok1 p2,TipPok2 p3, TipPok2 p4,TipF_ret fun(TipF_par)) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; 
{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	auto poc(p3);
	auto poc2(p1);
	bool test(false);
	while (p1 != p2) {
		test = false;
		p3 = poc;
		while (p3 != p4) {
			if (fun(*p1) == fun(*p3)) {
				test = true;
				break;
			}
			p3++;
		}
		if (test == false) Matrica.push_back({*p1,fun(*p1)});
		p1++;
	}
	p3 = poc;
	while (p3 != p4) {
		test = false;
		p1 = poc2;
		while (p1 != p2) {
			if (fun(*p3) == fun(*p1)) {
				test = true;
				break;
			}
			p1++;
		}
		if (test == false) Matrica.push_back({*p3,fun(*p3)});
		p3++;
	}
	
<a name="2"></a><font color="#0000FF"><a href="match628-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	std::sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;decltype(*p1+*p1)&gt; v1,std::vector&lt;decltype(*p1+*p1)&gt; v2) {
		if (v1[0] &gt; v2[0]) return true;
		if(v1[0] == v2[0]) {
			if(v1[1] &lt; v2[1]) return true;
			return false;
</font>		}
		return false;
	});
	
	return Matrica;
}



template &lt;typename TipPok1,typename TipPok2&gt;
auto UvrnutaRazlika(TipPok1 p1,TipPok1 p2,TipPok2 p3, TipPok2 p4) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; 
{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	auto poc(p3);
	auto poc2(p1);
	bool test(false);
	while (p1 != p2) {
		test = false;
		p3 = poc;
		while (p3 != p4) {
			if ((*p1) == (*p3)) {
				test = true;
				break;
			}
			p3++;
		}
		if (test == false) Matrica.push_back({*p1,decltype(*p3)()});
		p1++;
	}
	p3 = poc;
	while (p3 != p4) {
		test = false;
		p1 = poc2;
		while (p1 != p2) {
			if ((*p3) == (*p1)) {
				test = true;
				break;
			}
			p1++;
		}
		if (test == false) Matrica.push_back({*p3,decltype(*p3)()});
		p3++;
	}
	
<a name="3"></a><font color="#00FFFF"><a href="match628-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	std::sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;decltype(*p1+*p1)&gt; v1,std::vector&lt;decltype(*p1+*p1)&gt; v2) {
		if (v1[0] &gt; v2[0]) return true;
		if(v1[0] == v2[0]) {
			if(v1[1] &lt; v2[1]) return true;
			return false;
</font>		}
		return false;
	});
	
	return Matrica;
}

int main ()
{
	

	
	

	
	
	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	int n(0);
	std::cin &gt;&gt; n;
	std::deque&lt;int&gt; v1(0);
	std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	int n2(0);
	for (int i = 0; i &lt; n; i++) {
		do {
			std::cin &gt;&gt; n2;
			if (std::find(v1.begin(),v1.end(),n2) == v1.end()) break;
		}while(1);
		v1.push_back(n2);
	}
	
	std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	std::cin &gt;&gt; n;
	std::deque&lt;int&gt; v2(0);
	std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	for (int i = 0; i &lt; n; i++) {
		do {
			std::cin &gt;&gt; n2;
			if (std::find(v2.begin(),v2.end(),n2) == v2.end()) break;
		}while(1);
		v2.push_back(n2);
	}
	
	std::cout &lt;&lt; "Uvrnuti presjek kontejnera:" &lt;&lt; std::endl;
	
	auto Matrica = UvrnutiPresjek(v1.begin(),v1.end(),v2.begin(),v2.end(),SumaCifara);
	
	for (auto i : Matrica) {
		for (auto i2 : i) {
			std::cout &lt;&lt;std::setw(6)&lt;&lt; i2 &lt;&lt; " ";
		}
		std::cout  &lt;&lt; std::endl;
	}
<a name="4"></a><font color="#FF00FF"><a href="match628-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	std::cout &lt;&lt; "Uvrnuta razlika kontejnera:" &lt;&lt; std::endl;
	Matrica = UvrnutaRazlika(v1.begin(),v1.end(),v2.begin(),v2.end(),BrojProstihFaktora);
</font>	
	for (auto i : Matrica) {
		for (auto i2 : i) {
			std::cout &lt;&lt;std::setw(6)&lt;&lt; i2 &lt;&lt; " ";
		}
		std::cout  &lt;&lt; std::endl;
	}
	std::cout &lt;&lt; "Dovidjenja!" &lt;&lt; std::endl;
	return 0;
}
</pre>
</body>
</html>
