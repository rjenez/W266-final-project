<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2464.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2068.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	.
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;

int SumaCifara(long long int x) {
	int suma(0);
	while(x) {
		suma+=abs(x%10);
		x/=10;
	}
	return suma;
}

int SumaDjelilaca(long long int x) {
	int suma(0);
	for(int i=1; i&lt;=abs(x); i++) if(!(x%i)) suma+=i;
	return suma;
}

bool DaLiJeProst(long long int x) {
	if(x&lt;2) return 0; if(x==2) return 1; if(x%2==0) return 0;
	for(int i=3; i&lt;=sqrt(x); i+=2) if(x%i==0) return 0;
	return 1;
}

int BrojProstihFaktora(long long int x) {
	int broj(0);/*
	for(int i=2; i&lt;=abs(x); i++) if(x%i==0 &amp;&amp; DaLiJeProst(i)) broj++;
	return broj;*/
	while(x&gt;1) {
		for(int i=2; i&lt;=abs(x); i++) {
			if(x%i==0) {
				x/=i;
				broj++;
				break;
			}
		}
	}
	return broj;
}

int BrojSavrsenihDjelilaca(long long int x) {
	int broj(0);
	for(int i=1; i&lt;=abs(x); i++) if(!(x%i) &amp;&amp; SumaDjelilaca(i)==i+i) broj++;
	return broj;
}

<a name="2"></a><font color="#0000FF"><a href="match729-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

template &lt;typename Tip1, typename Tip2, typename Tip3, typename Tip4&gt;
auto UvrnutiPresjek(Tip1 pok1a, Tip1 pok1b, Tip2 pok2a, Tip2 pok2b, Tip3 F(Tip4)) -&gt; typename std::vector&lt;std::vector&lt;Tip3&gt;&gt; {
</font>	std::vector&lt;std::vector&lt;Tip3&gt;&gt;matrica;
	
	for(Tip1 temp1=pok1a; temp1!=pok1b; temp1++) {
		for(Tip2 temp2=pok2a; temp2!=pok2b; temp2++) {
			if(F(*temp1)==F(*temp2)) {
				std::vector&lt;Tip3&gt;vek={*temp1, *temp2, F(*temp1)};
				matrica.push_back(vek);
			}
		}
	}
<a name="1"></a><font color="#00FF00"><a href="match729-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;Tip3&gt; a, std::vector&lt;Tip3&gt; b) { 
		if(a[2]!=b[2]) return a[2]&lt;b[2]; if(a[0]!=b[0]) return a[0]&lt;b[0]; return a[1]&lt;b[1]; 
</font>		
	});
	return matrica;
}


template &lt;typename Tip1, typename Tip2&gt;
<a name="3"></a><font color="#00FFFF"><a href="match729-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

auto UvrnutiPresjek(Tip1 pok1a, Tip1 pok1b, Tip2 pok2a, Tip2 pok2b) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;&gt; {      
</font>	typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;&gt;matrica;
	
	for(Tip1 temp1=pok1a; temp1!=pok1b; temp1++) {
		for(Tip2 temp2=pok2a; temp2!=pok2b; temp2++) {
			if(*temp1==*temp2) {
				std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;vek={*temp1, 0, 0};
				matrica.push_back(vek);
			}
		}
	}
	
<a name="0"></a><font color="#FF0000"><a href="match729-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;a, std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;b) {
		return a[0]&lt;b[0];
	});
	
	return matrica;
}


template &lt;typename Tip1, typename Tip2, typename Tip3, typename Tip4&gt;
auto UvrnutaRazlika(Tip1 pok1a, Tip1 pok1b, Tip2 pok2a, Tip2 pok2b, Tip3 F(Tip4)) -&gt; typename std::vector&lt;std::vector&lt;Tip3&gt;&gt; {
</font>	std::vector&lt;std::vector&lt;Tip3&gt;&gt;matrica;
	
	for(Tip1 temp1=pok1a; temp1!=pok1b; temp1++) {
		bool nadjen(false);
		for(Tip2 temp2=pok2a; temp2!=pok2b; temp2++) {
			if(F(*temp1)==F(*temp2)) {
				nadjen=true;
				break;
			}
		}
		if(!nadjen) {
			std::vector&lt;Tip3&gt;vek={*temp1, F(*temp1)};
			matrica.push_back(vek);
		}
	}
	
	for(Tip2 temp2=pok2a; temp2!=pok2b; temp2++) {
		bool nadjen(false);
		for(Tip1 temp1=pok1a; temp1!=pok1b; temp1++) {
			if(F(*temp1)==F(*temp2)) {
				nadjen=true;
				break;
			}
		}
		if(!nadjen) {
			std::vector&lt;Tip3&gt;vek={*temp2, F(*temp2)};
			matrica.push_back(vek);
		}
	}
	
<a name="5"></a><font color="#FF0000"><a href="match729-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;Tip3&gt;a, std::vector&lt;Tip3&gt; b) {
		if(a[0]!=b[0]) return b[0]&lt;a[0]; return b[1]&gt;a[1];
</font>	});
	return matrica;
}

template &lt;typename Tip1, typename Tip2&gt;
<a name="4"></a><font color="#FF00FF"><a href="match729-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

auto UvrnutaRazlika(Tip1 pok1a, Tip1 pok1b, Tip2 pok2a, Tip2 pok2b) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;&gt; {
</font><a name="4"></a><font color="#FF00FF"><a href="match729-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;&gt;matrica;
</font>	
	for(Tip1 temp1=pok1a; temp1!=pok1b; temp1++) {
		bool nadjen(false);
		for(Tip2 temp2=pok2a; temp2!=pok2b; temp2++) {
			if(*temp1==*temp2) {
				nadjen=true;
				break;
			}
		}
		if(!nadjen) {
			std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;vek={*temp1, 0};
			matrica.push_back(vek);
		}
	}
	
	for(Tip2 temp2=pok2a; temp2!=pok2b; temp2++) {
		bool nadjen(false);
		for(Tip1 temp1=pok1a; temp1!=pok1b; temp1++) {
			if(*temp1==*temp2) {
				nadjen=true;
				break;
			}
		}
		if(!nadjen) {
			std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;vek={*temp2, 0};
			matrica.push_back(vek);
		}
	}
	
	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;a, std::vector&lt;typename std::remove_reference&lt;decltype(*pok1a)&gt;::type&gt;b) {
		return a[0]&gt;b[0];
	});
	
	return matrica;
}

int main () {
	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	int n1; std::cin &gt;&gt; n1;
	std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	std::deque&lt;int&gt;d1(n1);
	for(int i=0; i&lt;n1; i++) {
		std::cin &gt;&gt; d1[i];
		for(int j=0; j&lt;i; j++) if(d1[j]==d1[i]) {
			i--; 
			break;
		}
	}
	d1.resize(n1);
	std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	int n2; std::cin &gt;&gt; n2;
	std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	std::deque&lt;int&gt;d2(n2);
	for(int i=0; i&lt;n2; i++) {
		std::cin &gt;&gt; d2[i];
		for(int j=0; j&lt;i; j++) if(d2[j]==d2[i]) {
			i--;
			break;
		}
	}
	d2.resize(n2);
	auto matrica=UvrnutiPresjek(d1.begin(), d1.end(), d2.begin(), d2.end(), SumaCifara);
	std::cout &lt;&lt; "Uvrnuti presjek kontejnera: \n";
	for(auto i : matrica) {
		for(auto j : i) {
			std::cout &lt;&lt; std::setw(6) &lt;&lt; j &lt;&lt; " ";
		}
		std::cout &lt;&lt; "\n";
	}
	
	matrica=UvrnutaRazlika(d1.begin(), d1.end(), d2.begin(), d2.end(), BrojProstihFaktora);
	std::cout &lt;&lt; "Uvrnuta razlika kontejnera: \n";
	for(auto i : matrica) {
		for(auto j : i) {
			std::cout &lt;&lt; std::setw(6) &lt;&lt; j &lt;&lt; " ";
		}
		std::cout &lt;&lt; "\n";
	}
	
	std::cout &lt;&lt; "Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
