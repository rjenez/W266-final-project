<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student1317.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student1317.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;deque&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;iomanip&gt;

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::deque;

bool DaLiJeProst(long long int n)
{
    if(n&lt;2) return false;
    else
    {
		double n1(sqrt(n));
		for(long long int i=2; i&lt;=n1; i++)
		{
			if(n%i==0) return false;
			if(i==int(n1)) break;
		}
    }
	return true;
}

int BrojProstihFaktora(long long int broj)
{
	int brojac(0);
	
	for(long long int i=1; i&lt;=broj; i++)
	{	
		if(broj%i==0) 
		{
			if(DaLiJeProst(i)) 
			{
				brojac++;
				long long int rez(broj/i);
				do
				{
					if(rez%i==0) 
					{
						brojac++;
						rez/=i;
					}
					else break;
				}while(rez!=0);
			}
		}
		if(i==broj) break;
	}
	
	return brojac;
}

int BrojSavrsenihDjelilaca(long long int broj)
{
	int brojac(0);
	
	for(int i=6; i&lt;=broj; i++)
	{
		if(broj%i==0)
		{
			int suma(0);
			for(int j=1; j&lt;i; j++)
				if(i%j==0) suma+=j;
			
			if(suma==i) brojac++;
		}
	}
	
	return brojac;
}

int SumaDjelilaca(long long int broj)
{
	int suma(0);
	broj=abs(broj);
	for(int i=1; i&lt;=broj; i++)
		if(broj%i==0) suma+=i;
	
	return suma;
}

int SumaCifara(long long int broj)
{
	int sum_cif(0);
	
	do
	{
		int cifra(broj%10);
		if(cifra&lt;0) cifra*=(-1);
		broj/=10;
		
		sum_cif+=cifra;
	} while(broj!=0);
	
	return sum_cif;
}

// Funkcija UvrnutaRazlika odredjuje obicnu razliku dva bloka
<a name="5"></a><font color="#FF0000"><a href="match310-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

template &lt;typename NekiKon1, typename NekiKon2&gt;
auto UvrnutaRazlika(NekiKon1 pocetak1, NekiKon1 iza_kraja1, NekiKon2 pocetak2, NekiKon2 iza_kraja2) -&gt; vector&lt;vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt;
{
	vector&lt;vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; mat;
</font>	for(int i=0; i&lt;(iza_kraja1-pocetak1); i++)
	{
		int j;
		for(j=0; j&lt;(iza_kraja2-pocetak2); j++)
		{
			if(pocetak1[i]==pocetak2[j]) break;
		}
		if(j==(iza_kraja2-pocetak2))
		{
			vector&lt;decltype(*pocetak1+*pocetak1)&gt; pom_vek;
			pom_vek.push_back(pocetak1[i]);
			pom_vek.push_back(0);
			mat.push_back(pom_vek);
		}
	}
	for(int i=0; i&lt;(iza_kraja2-pocetak2); i++)
	{
		int j;
		for(j=0; j&lt;(iza_kraja1-pocetak1); j++)
		{
			if(pocetak2[i]==pocetak1[j]) break;
		}
		if(j==(iza_kraja1-pocetak1))
		{
			vector&lt;decltype(*pocetak1+*pocetak1)&gt; pom_vek;
			pom_vek.push_back(pocetak2[i]);
			pom_vek.push_back(0);
			mat.push_back(pom_vek);
		}
	}
	
<a name="0"></a><font color="#FF0000"><a href="match310-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	std::sort(mat.begin(), mat.end(), [](vector&lt;decltype(*pocetak1+*pocetak1)&gt; a, vector&lt;decltype(*pocetak1+*pocetak1)&gt; b)-&gt;bool
	{ 
		if(a[0]&gt;b[0]) return true;
</font>		
		return false;
	});
	
	return mat;
}

// Funkcija UvrnutaRazlika odredjuje one elemente iz jednog 
// ili drugog bloka koji nemaju svog para u odnosu na funkciju f
<a name="1"></a><font color="#00FF00"><a href="match310-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

template &lt;typename NekiKon1, typename NekiKon2, typename NekiTip1, typename NekiTip2&gt;
auto UvrnutaRazlika(NekiKon1 pocetak1, NekiKon1 iza_kraja1, NekiKon2 pocetak2, NekiKon2 iza_kraja2, NekiTip1 f(NekiTip2)) -&gt; vector&lt;vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt;
{
	vector&lt;vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; mat;
</font>	for(int i=0; i&lt;(iza_kraja1-pocetak1); i++)
	{
		int j;
		for(j=0; j&lt;(iza_kraja2-pocetak2); j++)
		{
			if(f(pocetak1[i])==f(pocetak2[j])) break;
		}
		if(j==(iza_kraja2-pocetak2))
		{
			vector&lt;decltype(*pocetak1+*pocetak1)&gt; pom_vek;
			pom_vek.push_back(pocetak1[i]);
			pom_vek.push_back(f(pocetak1[i]));
			mat.push_back(pom_vek);
		}
	}
	for(int i=0; i&lt;(iza_kraja2-pocetak2); i++)
	{
		int j;
		for(j=0; j&lt;(iza_kraja1-pocetak1); j++)
		{
			if(f(pocetak2[i])==f(pocetak1[j])) break;
		}
		if(j==(iza_kraja1-pocetak1))
		{
			vector&lt;decltype(*pocetak1+*pocetak1)&gt; pom_vek;
			pom_vek.push_back(pocetak2[i]);
			pom_vek.push_back(f(pocetak2[i]));
			mat.push_back(pom_vek);
		}
	}
	
<a name="2"></a><font color="#0000FF"><a href="match310-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

	std::sort(mat.begin(), mat.end(), [](vector&lt;decltype(*pocetak1+*pocetak1)&gt; a, vector&lt;decltype(*pocetak1+*pocetak1)&gt; b)-&gt;bool
	{ 
		if(a[0]&gt;b[0]) return true;
</font>		else if(a[0]==b[0] &amp;&amp; a[1]&gt;b[1]) return true;
		
		return false;
	});
	
	return mat;
}

// Funkcija UvrnutiPresjek odredjuje obicni presjek dva bloka
<a name="6"></a><font color="#00FF00"><a href="match310-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

template &lt;typename NekiKon1, typename NekiKon2&gt;
auto UvrnutiPresjek(NekiKon1 pocetak1, NekiKon1 iza_kraja1, NekiKon2 pocetak2, NekiKon2 iza_kraja2) -&gt; vector&lt;vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt;
{
	vector&lt;vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; mat;
</font>	for(int i=0; i&lt;(iza_kraja1-pocetak1); i++)
	{
		for(int j=0; j&lt;(iza_kraja2-pocetak2); j++)
		{
			if(pocetak1[i]==pocetak2[j])
			{
				vector&lt;decltype(*pocetak1+*pocetak1)&gt; pom_vek;
				pom_vek.push_back(pocetak1[i]);
				pom_vek.push_back(0);
				pom_vek.push_back(0);
				mat.push_back(pom_vek);
			}
		}
	}

	return mat;
}

// Funkcija UvrnutiPresjek odredjuje one elemente iz jednog 
// ili drugog bloka koji imaju svog para u odnosu na funkciju f
<a name="3"></a><font color="#00FFFF"><a href="match310-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

template &lt;typename NekiKon1, typename NekiKon2, typename NekiTip1, typename NekiTip2&gt;
auto UvrnutiPresjek(NekiKon1 pocetak1, NekiKon1 iza_kraja1, NekiKon2 pocetak2, NekiKon2 iza_kraja2, NekiTip1 f(NekiTip2)) -&gt; vector&lt;vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt;
{
	vector&lt;vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; mat;
</font>	for(int i=0; i&lt;(iza_kraja1-pocetak1); i++)
	{
		for(int j=0; j&lt;(iza_kraja2-pocetak2); j++)
		{
			if(f(pocetak1[i])==f(pocetak2[j]))
			{
				vector&lt;decltype(*pocetak1+*pocetak1)&gt; pom_vek;
				pom_vek.push_back(pocetak1[i]);
				pom_vek.push_back(pocetak2[j]);
				pom_vek.push_back(f(pocetak1[i]));
				mat.push_back(pom_vek);
			}
		}
	}

<a name="4"></a><font color="#FF00FF"><a href="match310-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

	std::sort(mat.begin(), mat.end(), [](vector&lt;decltype(*pocetak1+*pocetak1)&gt; a, vector&lt;decltype(*pocetak1+*pocetak1)&gt; b)-&gt;bool
	{ 
		if(a[2]&lt;b[2]) return true;
</font>		else if(a[2]==b[2] &amp;&amp; a[0]&lt;b[0]) return true;
		else if(a[2]==b[2] &amp;&amp; a[0]==b[0] &amp;&amp; a[1]&lt;b[1]) return true;
		
		return false;
	});
	
	return mat;
}

int main ()
{
	int n;
	cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	cin &gt;&gt; n;
	
	deque&lt;int&gt; prvi_kon;
	cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	while(prvi_kon.size()!=n)
	{
		int broj;
		cin &gt;&gt; broj;
		int i;
		for(i=0; i&lt;prvi_kon.size(); i++) if(prvi_kon[i]==broj) break;
		if(prvi_kon.size()==i) prvi_kon.push_back(broj);
	}
	
	int m;
	cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	cin &gt;&gt; m;
	
	deque&lt;int&gt; drugi_kon;
	cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	while(drugi_kon.size()!=m)
	{
		int broj;
		cin &gt;&gt; broj;
		int i;
		for(i=0; i&lt;drugi_kon.size(); i++) if(drugi_kon[i]==broj) break;
		if(drugi_kon.size()==i) drugi_kon.push_back(broj);
	}
	
	vector&lt;vector&lt;int&gt;&gt; mat1(UvrnutiPresjek(prvi_kon.begin(), prvi_kon.end(), drugi_kon.begin(), drugi_kon.end(), SumaCifara));
	cout &lt;&lt; "Uvrnuti presjek kontejnera:" &lt;&lt; endl;
	for(int i=0; i&lt;mat1.size(); i++)
	{
		for(int j=0; j&lt;mat1[i].size(); j++)
		{
			cout &lt;&lt; std::setw(6) &lt;&lt; mat1[i][j] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
	
	vector&lt;vector&lt;int&gt;&gt; mat3(UvrnutaRazlika(prvi_kon.begin(), prvi_kon.end(), drugi_kon.begin(), drugi_kon.end(), BrojProstihFaktora));
	cout &lt;&lt; "Uvrnuta razlika kontejnera:" &lt;&lt; endl;
	for(int i=0; i&lt;mat3.size(); i++)
	{
		for(int j=0; j&lt;mat3[i].size(); j++)
		{
			cout &lt;&lt; std::setw(6) &lt;&lt; mat3[i][j] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
	cout &lt;&lt; "Dovidjenja!" &lt;&lt; endl;
	
	return 0;
}


</pre>
</body>
</html>
