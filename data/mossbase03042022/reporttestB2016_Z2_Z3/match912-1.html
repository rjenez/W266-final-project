<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4736.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student5298.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/

#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

using namespace std;

int SumaDjelilaca(long long int n) {
	int br = n;
	
	for (long long int i = 1; i &lt; n / 2 + 1; i++)
		if (n % i == 0)
			br += i;
	
	return br;
}

bool Prost(const long long int &amp;n) {
	if (n &gt; 2 &amp;&amp; n % 2 == 0)
		return false;
	
	for (int i = 2; i &lt; n/2 + 1; i++)
		if (n % i == 0)
			return false;
		
	return true;
}

int BrojProstihFaktora(long long int n) {
	int br = 0;
	const int poc = n;
	
	for (long long int i = 2; i &lt;= poc; i++) {
		if (!Prost(i))
			continue;
		if (n % i == 0) {
			n /= i;
			br++;
			i--;
		}
	}
	
	return br;
}

int BrojSavrsenihDjelilaca(long long int n) {
	int br = 0;
	
	for (long long int i = 2; i &lt; n; i++) {
		if(n % i == 0 &amp;&amp; i == SumaDjelilaca(i) - i){
			br++;
		}
		
	}
	
	return br;
}

template &lt;typename ItS1, typename ItS2, typename TipFun, typename TipF&gt;
void UvrnutiPresjekPomocna(const ItS1 &amp;s1_poc, const ItS1 &amp;s1_kraj, const ItS2 &amp;s2_poc, const ItS2 &amp;s2_kraj, TipF fun, std::vector&lt;std::vector&lt;TipFun&gt;&gt; &amp;izlaz) {
	TipFun tmp;
	vector&lt;TipFun&gt; tmp_trojka;
	
	for(ItS1 iS1 = s1_poc; iS1 != s1_kraj; iS1++) {
		tmp = fun(*iS1);
		for(ItS2 iS2 = s2_poc; iS2 != s2_kraj; iS2++) {
			if (tmp == fun(*iS2)) {
				tmp_trojka.clear();
				tmp_trojka.push_back(*iS1);
				tmp_trojka.push_back(*iS2);
				tmp_trojka.push_back(tmp);
				izlaz.push_back(tmp_trojka);
			}
		}
	}
	
	sort(izlaz.begin(), izlaz.end(), [](vector&lt;TipFun&gt; t1, vector&lt;TipFun&gt; t2) {
		if (t1[2] &lt; t2[2])
			return true;
		else if (t1[2] &gt; t2[2])
			return false;
		if (t1[0] &lt; t2[0])
			return true;
		else if (t1[0] &gt; t2[0])
			return false;
		if (t1[1] &lt; t2[1])
			return true;
		else
			return false;
	});
}

<a name="3"></a><font color="#00FFFF"><a href="match912-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

template &lt;typename ItS1, typename ItS2&gt;
auto UvrnutiPresjek(ItS1 s1_poc, ItS1 s1_kraj, ItS2 s2_poc, ItS2 s2_kraj) -&gt; vector&lt;vector&lt;decltype(*s1_poc + 1)&gt;&gt; {
</font>	typedef decltype(*s1_poc + 1) TipFun;
	
	function&lt;TipFun(TipFun)&gt; fun = [](TipFun n) { return n; };
	vector&lt;vector&lt;TipFun&gt;&gt; izlaz;
	
<a name="1"></a><font color="#00FF00"><a href="match912-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

	UvrnutiPresjekPomocna(s1_poc, s1_kraj, s2_poc, s2_kraj, fun, izlaz);
	
	return izlaz;
}

template &lt;typename ItS1, typename ItS2, typename TipF&gt;
auto UvrnutiPresjek(ItS1 s1_poc, ItS1 s1_kraj, ItS2 s2_poc, ItS2 s2_kraj, TipF fun) -&gt; vector&lt;vector&lt;decltype(*s1_poc + 1)&gt;&gt; {
</font>    typedef decltype(*s1_poc + 1) TipFun;

    vector&lt;vector&lt;TipFun&gt;&gt; izlaz;

    UvrnutiPresjekPomocna(s1_poc, s1_kraj, s2_poc, s2_kraj, fun, izlaz);

    return izlaz;
}

template &lt;typename ItS1, typename ItS2, typename TipFun, typename Tipf&gt;
void UvrnutaRazlikaPomocna(const ItS1 &amp;s1_poc, const ItS1 &amp;s1_kraj, const ItS2 &amp;s2_poc, const ItS2 &amp;s2_kraj, Tipf fun, std::vector&lt;std::vector&lt;TipFun&gt;&gt; &amp;izlaz){
    TipFun tmp;
    std::vector&lt;TipFun&gt; tmp_par;
    
    bool has_equal;
    
    for (ItS1 iS1 = s1_poc; iS1 != s1_kraj; iS1++) {
    	has_equal = false;
    	tmp = fun(*iS1);
    	
    	for (ItS2 iS2 = s2_poc; iS2 != s2_kraj; iS2++) {
    		if (tmp == fun(*iS2)) {
    			has_equal = true;
    			break;
    		}
    	}
    	
    	if (!has_equal) {
    		tmp_par.clear();
    		tmp_par.push_back(*iS1);
    		tmp_par.push_back(tmp);
    		izlaz.push_back(tmp_par);
    	}
    }
    
    for (ItS2 iS2 = s2_poc; iS2 != s2_kraj; iS2 ++) {
    	has_equal = false;
    	tmp = fun(*iS2);
    	
    	for (ItS1 iS1 = s1_poc; iS1 != s1_kraj; iS1++) {
    		if (tmp == fun(*iS1)) {
    			has_equal = true;
    			break;
    		}
    	}
    	
    	if (!has_equal) {
    		tmp_par.clear();
    		tmp_par.push_back(*iS2);
    		tmp_par.push_back(tmp);
    		izlaz.push_back(tmp_par);
    	}
    }
    
    sort(izlaz.begin(), izlaz.end(), [](vector&lt;TipFun&gt; t1, vector&lt;TipFun&gt; t2){
    	if (t1[0] &lt; t2[0])
    		return false;
    	else if (t1[0] &gt; t2[0])
    		return true;
    	if (t1[1] &lt; t2[1])
    		return false;
    	else
    		return true;
    });
}

<a name="4"></a><font color="#FF00FF"><a href="match912-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

template &lt;typename ItS1, typename ItS2&gt;
auto UvrnutaRazlika(ItS1 s1_poc, ItS1 s1_kraj, ItS2 s2_poc, ItS2 s2_kraj) -&gt; vector&lt;vector&lt;decltype(*s1_poc + 1)&gt;&gt; {
</font>    typedef decltype(*s1_poc + 1) TipFun;
    function&lt;TipFun(TipFun)&gt; fun = [](TipFun n){ return n; };

    vector&lt;vector&lt;TipFun&gt;&gt; izlaz;

<a name="2"></a><font color="#0000FF"><a href="match912-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

    UvrnutaRazlikaPomocna(s1_poc, s1_kraj, s2_poc, s2_kraj, fun, izlaz);

    return izlaz;

}

template &lt;typename ItS1, typename ItS2, typename TipF&gt;
auto UvrnutaRazlika(ItS1 s1_poc, ItS1 s1_kraj, ItS2 s2_poc, ItS2 s2_kraj, TipF fun) -&gt; vector&lt;vector&lt;decltype(*s1_poc + 1)&gt;&gt; {
</font>    typedef decltype(*s1_poc + 1) TipFun;

    std::vector&lt;std::vector&lt;TipFun&gt;&gt; izlaz;

    UvrnutaRazlikaPomocna(s1_poc, s1_kraj, s2_poc, s2_kraj, fun, izlaz);

    return izlaz;

}

int main(){
    deque&lt;int&gt; s1;
    deque&lt;int&gt; s2;

    int n, v;
    cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; v;
        while (find(s1.begin(), s1.end(), v) != s1.end())
        	cin &gt;&gt; v;
        s1.push_back(v);
    }

    cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; v;
        while (find(s2.begin(), s2.end(), v) != s2.end())
        	cin &gt;&gt; v;
        s2.push_back(v);
    }

    cout &lt;&lt; "Uvrnuti presjek kontejnera:\n";
<a name="0"></a><font color="#FF0000"><a href="match912-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    std::vector&lt;std::vector&lt;int&gt;&gt; izlaz = UvrnutiPresjek(s1.begin(), s1.end(), s2.begin(), s2.end(), [](int x) {
    	int suma = 0;
    	while(x != 0){
    		suma += x%10;
    		x/=10;
    	}
    	return suma;
    });
    for(int i = 0; i &lt; izlaz.size(); i++){
</font>        for(int j = 0; j &lt; 3; j++)
            cout &lt;&lt; setw(6) &lt;&lt; izlaz[i][j] &lt;&lt; " ";
        cout &lt;&lt; "\n";
    }

    cout &lt;&lt; "Uvrnuta razlika kontejnera:\n";
    izlaz = UvrnutaRazlika(s1.begin(), s1.end(), s2.begin(), s2.end(), BrojProstihFaktora);
    for(int i = 0; i &lt; izlaz.size(); i++){
        for(int j = 0; j &lt; 2; j++)
            cout &lt;&lt; setw(6) &lt;&lt; izlaz[i][j] &lt;&lt; " ";
        cout &lt;&lt; "\n";
    }

    cout &lt;&lt; "Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
