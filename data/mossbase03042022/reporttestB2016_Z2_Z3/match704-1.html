<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student7085.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student8599.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;
int SumaDjelilaca(long long n)
{
	int suma(0);
<a name="2"></a><font color="#0000FF"><a href="match704-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	for(int i=1; i&lt;=fabs(n); i++) {
		if(n%i==0)
			suma+=i;
	}
	return suma;
}
int BrojProstihFaktora(long long int n)
{
	int broj(0);
	for(int i=2; i&lt;=fabs(n); i++) {
</font>		if(n%i==0) {
			broj++;
			n/=i;
			i--;
		}
	}
	return broj;
}
int BrojSavrsenihDjelilaca(long long int n)
{
	int broj(0);
	for(int i=2; i&lt;=n; i++) {
		if(n%i==0) {
			int suma(SumaDjelilaca(i)-i);
			if(i==suma)
				broj++;
		}
	}
	return broj;
}

int SumaCifara(long long int x)
{
	int suma(0);
	while(x!=0) {
		int c(x%10);
		suma+=c;
		x/=10;
	}
	return suma;
}


template &lt;typename Tip1, typename Tip2, typename TipF&gt;

auto UvrnutiPresjek(Tip1 p1, Tip1 p2, Tip2 x1, Tip2 x2, TipF f) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; {
	typedef typename std::remove_reference&lt;decltype(*p1)&gt;::type Tip;
	int n(0);
	Tip1 q1(p1);
	Tip1 q2(p2);
	Tip2 y1(x1);
	Tip2 y2(x2);
	for(int i=0; i&lt;p2-p1; i++) {
		Tip2 y1(x1);
		for(int j=0; j&lt;x2-x1; j++) {
			if(f(*q1)==f(*y1))

				n++;
			y1++;
		}
		q1++;
	}
	std::vector&lt;std::vector&lt;Tip&gt;&gt; matrica(n);
	int duzina(0);
	q1=p1;
	for(int i=0; i&lt;p2-p1; i++) {
		y1=x1;
		for(int j=0; j&lt;x2-x1; j++) {
			if(f(*q1)==f(*y1)) {
				matrica[duzina].push_back(*q1);
				matrica[duzina].push_back(*y1);
				matrica[duzina].push_back(f(*q1));
				duzina++;
			}
			y1++;
		}
		q1++;
	}
<a name="0"></a><font color="#FF0000"><a href="match704-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	std::sort(matrica.begin(), matrica.end(), [] (const std::vector&lt;Tip&gt; &amp;v1, const std::vector&lt;Tip&gt; &amp;v2) {
		if(v1[2]==v2[2] &amp;&amp; v1[0]==v2[0])
			return v1[1]&lt;v2[1];
		if(v1[2]==v2[2]) {
			return v1[0]&lt;v2[0];
		}
		return v1[2]&lt;v2[2];
	});



	return  matrica;
}
template &lt;typename Tip1, typename Tip2, typename TipF, typename TipA&gt;
</font>auto UvrnutaRazlika(Tip1 p1, Tip1 p2, Tip2 x1, Tip2 x2, TipF f(TipA x)) -&gt;  typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; {
	typedef typename std::remove_reference&lt;decltype(*p1)&gt;::type Tip;
	int n(0);
	Tip1 q1(p1);
	Tip1 q2(p2);
	Tip2 y1(x1);
	Tip2 y2(x2);
	for(int i=0; i&lt;p2-p1; i++) {
		y1=x1;
		while(y1!=y2) {
			if(f(*q1)==f(*y1))
				break;
			y1++;
		}
		if(y1==y2)
			n++;
		q1++;
	}
	int n2(0);
	y1=x1;
	for(int i=0; i&lt;x2-x1; i++) {
		q1=p1;
		while(q1!=p2) {
			if(f(*q1)==f(*y1))
				break;
			q1++;
		}
		if(q1==p2)
			n2++;
		y1++;
	}
	std::vector&lt;std::vector&lt;Tip&gt;&gt; matrica(n+n2);
	int duzina(0);
	q1=p1;
	for(int i=0; i&lt;p2-p1; i++) {
		y1=x1;
		while(y1!=x2) {
			if(f(*q1)==f(*y1))
				break;
			y1++;
		}
		if(y1==x2) {
			matrica[duzina].push_back(*q1);
			matrica[duzina].push_back(f(*q1));
			duzina++;
		}
		q1++;
	}
	y1=x1;
	for(int i=0; i&lt;x2-x1; i++) {
		q1=p1;
		while(q1!=p2) {
			if(f(*q1)==f(*y1))
				break;
			q1++;
		}
		if(q1==p2) {
			matrica[duzina].push_back(*y1);
			matrica[duzina].push_back(f(*y1));
			duzina++;
		}
		y1++;
	}
	std::sort(matrica.begin(), matrica.end(), [] (const std::vector&lt;Tip&gt; &amp;v1, const std::vector&lt;Tip&gt; &amp;v2) {
		if(v1[0]==v2[0])
			return v1[1]&gt;v1[2];
		return v1[0]&gt;v2[0];
	});
	return matrica;
}

template &lt;typename Tip1, typename Tip2&gt;
<a name="4"></a><font color="#FF00FF"><a href="match704-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

auto UvrnutiPresjek(Tip1 p1, Tip1 p2, Tip2 x1, Tip2 x2) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; {
</font>	typedef typename std::remove_reference&lt;decltype(*p1)&gt;::type Tip;
	int n(0);
	Tip1 q1(p1);
	Tip1 q2(p2);
	Tip2 y1(x1);
	Tip2 y2(x2);
	for(int i=0; i&lt;p2-p1; i++) {
		y1=x1;
		for(int j=0; j&lt;x2-x1; j++) {
			while(y1!=x2) {
				if(*q1==*y1)
					n++;
				y1++;
			}
		}
		q1++;
	}

	std::vector&lt;std::vector&lt;Tip&gt;&gt; matrica(n, std::vector&lt;Tip&gt;(3));
	int duzina(0);
	q1=p1;
	for(int i=0; i&lt;p2-p1; i++) {
		y1=x1;
		for(int j=0; j&lt;x2-x1; j++) {
			if(*q1==*y1) {
				matrica[duzina][0]=*q1;
				duzina++;
			}
			y1++;
		}
		q1++;
	}
<a name="1"></a><font color="#00FF00"><a href="match704-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	std::sort(matrica.begin(), matrica.end(), [] (const std::vector&lt;Tip&gt; &amp;v1, const std::vector&lt;Tip&gt; &amp;v2) {
		if(v1[2]==v2[2] &amp;&amp; v1[0]==v2[0])
			return v1[1]&lt;v2[1];
		if(v1[2]==v2[2]) {
			return v1[0]&lt;v2[0];
		}
		return v1[2]&lt;v2[2];
</font>	});



	return  matrica;
}
template &lt;typename Tip1, typename Tip2&gt;
auto UvrnutaRazlika(Tip1 p1, Tip1 p2, Tip2 x1, Tip2 x2) -&gt;  typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; {
	typedef typename std::remove_reference&lt;decltype(*p1)&gt;::type Tip;
	int n(0);
	Tip1 q1(p1);
	Tip1 q2(p2);
	Tip2 y1(x1);
	Tip2 y2(x2);
	for(int i=0; i&lt;p2-p1; i++) {
		y1=x1;
		while(y1!=y2) {
			if(*q1==*y1)
				break;
			y1++;
		}
		if(y1==y2)
			n++;
		q1++;
	}
	int n2(0);
	y1=x1;
	for(int i=0; i&lt;x2-x1; i++) {
		q1=p1;
		while(q1!=p2) {
			if(*q1==*y1)
				break;
			q1++;
		}
		if(q1==p2)
			n2++;
		y1++;
	}
	std::vector&lt;std::vector&lt;Tip&gt;&gt; matrica(n+n2, std::vector&lt;Tip&gt;(2));
	int duzina(0);
	q1=p1;
	for(int i=0; i&lt;p2-p1; i++) {
		y1=x1;
		while(y1!=x2) {
			if(*q1==*y1)
				break;
			y1++;
		}
		if(y1==x2) {
			matrica[duzina][0]=*q1;
			duzina++;
		}
		q1++;
	}
	y1=x1;
	for(int i=0; i&lt;x2-x1; i++) {
		q1=p1;
		while(q1!=p2) {
			if(*q1==*y1)
				break;
			q1++;
		}
		if(q1==p2) {
			matrica[duzina][0]=*y1;
			duzina++;
		}
		y1++;
	}
	std::sort(matrica.begin(), matrica.end(), [] (const std::vector&lt;Tip&gt; &amp;v1, const std::vector&lt;Tip&gt; &amp;v2) {
<a name="3"></a><font color="#00FFFF"><a href="match704-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		if(v1[0]==v2[0])
			return v1[1]&gt;v1[2];
		return v1[0]&gt;v2[0];
	});
	return matrica;
}

int main ()
{
	int n;
</font>	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	std::cin &gt;&gt; n;
	std::deque&lt;int&gt; k1;
	std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	int a;
	int j;
	for(int i=0; i&lt;n; i++) {
		std::cin &gt;&gt; a;
		if(i==0) k1.push_back(a);

		else {
			for(j=0; j&lt;i; j++) {
				if(k1[j]==a)
					break;
			}
			if(j==i)
				k1.push_back(a);
			else i--;
		}
	}
	std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	std::cin &gt;&gt; n;
	std::deque&lt;int&gt; k2;
	std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	for(int i=0; i&lt;n; i++) {
		std::cin &gt;&gt; a;
		if(i==0) k2.push_back(a);
		else {
			for(j=0; j&lt;i; j++) {
				if(k2[j]==a)
					break;
			}
			if(j==i)
				k2.push_back(a);
			else i--;
		}
	}
	std::cout &lt;&lt; "Uvrnuti presjek kontejnera:" ;
	auto m=UvrnutiPresjek(std::begin(k1), std::end(k1), std::begin(k2), std::end(k2), SumaCifara);
	for(int i=0; i&lt;m.size(); i++) {
		std::cout &lt;&lt; std::endl;
		for(int j=0; j&lt;m[1].size(); j++)
			std::cout &lt;&lt; std::setw(6) &lt;&lt; m[i][j] &lt;&lt; " ";
	}

	auto x2=UvrnutaRazlika(std::begin(k1), std::end(k1), std::begin(k2), std::end(k2), BrojProstihFaktora);
	std::cout &lt;&lt;std:: endl &lt;&lt;  "Uvrnuta razlika kontejnera:";
	for(int i=0; i&lt;x2.size(); i++) {
		std::cout &lt;&lt; std::endl;
		for(int j=0; j&lt;x2[0].size(); j++)
			std::cout &lt;&lt; std::setw(6) &lt;&lt; x2[i][j] &lt;&lt;" ";
	}
	std::cout &lt;&lt; std::endl;
	std::cout &lt;&lt; "Dovidjenja!";
	
	
	
 
return 0;
}</pre>
</body>
</html>
