<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student7802.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2447.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;stdexcept&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;


bool Fun(std::deque&lt;int&gt; dek, int broj){
	for(int i=0;i&lt;dek.size();i++){
		if(dek[i]==broj){
			return false;
		}
	}
	return true;
}



int SumaCifara(long long int n){
	int a(0);
	while(n!=0){
		int cifra(n%10);
		a+=cifra;
		n/=10;
	}
	return a;
}

int SumaDjelilaca(long long int n){
	int suma(0);
	for(int i=1;i&lt;=std::abs(n);i++){
		if(std::abs(n)%i==0)
		suma+=i;
	}
	return suma;
}


int BrojProstihFaktora(long long int n){
	int brojac(0);
	for(int i=2;i&lt;=n;i++){
		while(n%i==0){
			brojac++;
			n/=i;
		}
	}
	return brojac;
}

int BrojSavrsenihDjelilaca(long long int n){
	int brojac(0);
	for(int i=1;i&lt;=std::abs(n);i++){
		if(n%i==0){
			if(SumaDjelilaca(i)-i==i) brojac++;
		}
	}
	return brojac;
}





template&lt;typename tip1,typename tip2,typename tip3,typename tip4&gt;
auto UvrnutiPresjek(tip1 it1,tip1 it2,tip2 it3,tip2 it4,tip3 fun(tip4))-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt;&gt;{
	
	
	tip1 p1(it1);
	tip1 p2(it2);
	tip2 p3(it3);
	tip2 p4(it4);
	
	typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	Matrica mat;
	
	int i=1;
	while(p1!=p2){
	
		while(p3!=p4){
		
			auto a(fun(*p1));
			auto b(fun(*p3));
		
			a=fun(*p1);
			b=fun(*p3);
			
<a name="3"></a><font color="#00FFFF"><a href="match493-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			if(a==b){
			mat.resize(i);
			mat[i-1].push_back(*p1);
			mat[i-1].push_back(*p3);
			mat[i-1].push_back(a);
</font><a name="5"></a><font color="#FF0000"><a href="match493-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

			i++	;
			} 
			p3++;
		}
		p1++;
		p3=it3;
	}
	
	
	
	std::sort(mat.begin(),mat.end(), [] (std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt; v1,std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt; v2){
</font>		
		/*if(v1[0]!=v2[0]) return v1[0]&lt;v2[0];
		else if(v1[0]==v2[0]) return v1[1]&lt;v2[1];
		else if(v1[1]!=v2[1]) return v1[1]&lt;v2[1];*/
		
		if(v1[int (v1.size()-1)]!= v2[int (v2.size()-1)]) return v1[int (v1.size()-1)]&lt; v2[int (v2.size()-1)];
		else if( v1[int (v1.size()-1)]==v2[int (v2.size()-1)] &amp;&amp; v1[0]!=v2[0]) return v1[0]&lt;v2[0];
		if(v1[0]==v2[0]) return v1[1]&lt;v2[1];
		
		
	
	});
	
return mat;

}


template&lt;typename tip1,typename tip2,typename tip3,typename tip4&gt;
auto UvrnutaRazlika(tip1 it1,tip1 it2,tip2 it3,tip2 it4,tip3 fun(tip4))-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt;&gt;{
	
	
	tip1 p1(it1);
	tip1 p2(it2);
	tip2 p3(it3);
	tip2 p4(it4);
	
	typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	Matrica mat;
	int i=1;
	while(p1!=p2){
		bool cad(false);
		while(p3!=p4){
		
			auto a(fun(*p1));
			auto b(fun(*p3));
			a=fun(*p1);
			b=fun(*p3);
			if(a==b){
			cad=true;
			break;
			} 
			p3++;
		}
			if(cad==false){
			mat.resize(i);
			mat[i-1].push_back(*p1);
			mat[i-1].push_back(fun(*p1));
			i++	;
			}
		p1++;
		p3=it3;
		
	}
	
	tip1 p11(it1);
	tip1 p22(it2);
	tip2 p33(it3);
	tip2 p44(it4);
	
	
	while(p33!=p44){
		bool cad(false);
		while(p11!=p22){
		
			auto a(fun(*p33));
			auto b(fun(*p11));
			a=fun(*p33);
			b=fun(*p11);
			if(a==b){
			cad=true;
			break;
			} 
			p11++;
			}
			if(cad==false){
			mat.resize(i);
<a name="2"></a><font color="#0000FF"><a href="match493-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

			mat[i-1].push_back(*p33);
			mat[i-1].push_back(fun(*p33));
			i++	;
			}
		p33++;
		p11=it1;
		
	}
	
std::sort(mat.begin(),mat.end(), [] (std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt; v1,std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt; v2){
</font>		
		if(v1[0]!=v2[0]) return v1[0]&gt;v2[0];
		else if(v1[0]==v2[0]) return v1[int(v1.size()-1)]&gt;v2[int(v2.size()-1)];
	
	});
	
return mat;

}









template&lt;typename tip1,typename tip2&gt;
auto UvrnutaRazlika(tip1 it1,tip1 it2,tip2 it3,tip2 it4)-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt;&gt;{
	
	
	tip1 p1(it1);
	tip1 p2(it2);
	tip2 p3(it3);
	tip2 p4(it4);
	
	typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	Matrica mat;
	int i=1;
	while(p1!=p2){
		bool cad(false);
		while(p3!=p4){
		
			auto a=*p1;
			auto b=*p3;
			
			if(a==b){
			cad=true;
			break;
			} 
			p3++;
		}
<a name="4"></a><font color="#FF00FF"><a href="match493-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

			if(cad==false){
			mat.resize(i);
			mat[i-1].push_back(*p1);
			mat[i-1].push_back(0);
			i++	;
			}
		p1++;
		p3=it3;
		
	}
	
	tip1 p11(it1);
</font>	tip1 p22(it2);
	tip2 p33(it3);
	tip2 p44(it4);
	
	
	while(p33!=p44){
		bool cad(false);
		while(p11!=p22){
		
			auto a=*p33;
			auto b=*p11;
		
			if(a==b){
			cad=true;
			break;
			} 
			p11++;
			}
<a name="1"></a><font color="#00FF00"><a href="match493-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

			if(cad==false){
			mat.resize(i);
			mat[i-1].push_back(*p33);
			mat[i-1].push_back(0);
			i++	;
			}
		p33++;
		p11=it1;
		
		
	}
	

	
	
	
std::sort(mat.begin(),mat.end(), [] (std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt; v1,std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt; v2){
</font>		
		if(v1[0]!=v2[0]) return v1[0]&gt;v2[0];
		else if(v1[0]==v2[0]) return v1[int(v1.size()-1)]&gt;v2[int(v2.size()-1)];
	
	});
	
return mat;

}








template&lt;typename tip1,typename tip2&gt;
auto UvrnutiPresjek(tip1 it1,tip1 it2,tip2 it3,tip2 it4)-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt;&gt;{
	
	
	tip1 p1(it1);
	tip1 p2(it2);
	tip2 p3(it3);
	tip2 p4(it4);
	
	typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	Matrica mat;
	
	int i=1;
	while(p1!=p2){
	
		while(p3!=p4){
		
			auto a= *p1;
			auto b= *p3;
		
<a name="0"></a><font color="#FF0000"><a href="match493-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

			if(a==b){
			mat.resize(i);
			mat[i-1].push_back(*p1);
			mat[i-1].push_back(0);
			mat[i-1].push_back(0);
			i++	;
			} 
			p3++;
		}
		p1++;
		p3=it3;
	}
	
	
	
	std::sort(mat.begin(),mat.end(), [] (std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt; v1,std::vector&lt;typename std::remove_reference&lt;decltype(*it1)&gt;::type&gt; v2){
</font>		
		/*if(v1[0]!=v2[0]) return v1[0]&lt;v2[0];
		else if(v1[0]==v2[0]) return v1[1]&lt;v2[1];
		else if(v1[1]!=v2[1]) return v1[1]&lt;v2[1];*/
		
		if(v1[int (v1.size()-1)]!= v2[int (v2.size()-1)]) return v1[int (v1.size()-1)]&lt; v2[int (v2.size()-1)];
		else if( v1[int (v1.size()-1)]==v2[int (v2.size()-1)] &amp;&amp; v1[0]!=v2[0]) return v1[0]&lt;v2[0];
		if(v1[0]==v2[0]) return v1[1]&lt;v2[1];
		
		
	
	});
	
return mat;

}















int main ()
{
	int n1,n2,x1,x2;
	std::deque&lt;int&gt;d1;
	std::deque&lt;int&gt;d2;
	
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	std::cin&gt;&gt;n1;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	for(int i=0;i&lt;n1;i++){
		std::cin&gt;&gt;x1;
		if(Fun(d1,x1)==true){
		d1.push_back(x1);
		}else i--;
	
	}
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;n2;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	for(int i=0;i&lt;n2;i++){
		std::cin&gt;&gt;x2;
		if(Fun(d2,x2)==true){
		d2.push_back(x2);
		}
		else i--;
	}
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera: "&lt;&lt;std::endl;
	std::deque&lt;int&gt;::iterator it1(d1.begin());
	std::deque&lt;int&gt;::iterator it2(d1.end());
	std::deque&lt;int&gt;::iterator it3(d2.begin());
	std::deque&lt;int&gt;::iterator it4(d2.end());
	
	typedef std::vector&lt;std::vector&lt;int&gt;&gt; Matrica;
	Matrica mat,mat1;
	
	mat=UvrnutiPresjek(it1,it2,it3,it4,SumaCifara);
	for(int i=0;i&lt;mat.size();i++){
		for(int j=0;j&lt;mat[0].size();j++){
			std::cout&lt;&lt;std::setw(6)&lt;&lt;mat[i][j]&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera:"&lt;&lt;std::endl;
	std::deque&lt;int&gt;::iterator itt1(d1.begin());
	std::deque&lt;int&gt;::iterator itt2(d1.end());
	std::deque&lt;int&gt;::iterator itt3(d2.begin());
	std::deque&lt;int&gt;::iterator itt4(d2.end());
	
	
	
	mat1=UvrnutaRazlika(itt1,itt2,itt3,itt4,BrojProstihFaktora);
	
	for(int i=0;i&lt;mat1.size();i++){
		for(int j=0;j&lt;mat1[0].size();j++){
			std::cout&lt;&lt;std::setw(6)&lt;&lt;mat1[i][j]&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Dovidjenja!";
	
	return 0;
}</pre>
</body>
</html>
