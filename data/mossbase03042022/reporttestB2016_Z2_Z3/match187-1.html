<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student5297.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student1758.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

<a name="0"></a><font color="#FF0000"><a href="match187-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template &lt;typename Tip, typename TipF, typename Tip1, typename Tip2&gt;
std::vector&lt;std::vector&lt;TipF&gt;&gt; UvrnutiPresjek (Tip1 pocetak1, Tip1 kraj1, Tip2 pocetak2, Tip2 kraj2, TipF f (Tip)) {
	std::vector&lt;std::vector&lt;TipF&gt;&gt; matrica;
	while(pocetak1!=kraj1) {
		auto clan1=*pocetak1;
		auto poc2=pocetak2;
		while(poc2!=kraj2) {
			auto clan2=*poc2;
			if(f(clan1)==f(clan2)) {
				std::vector&lt;TipF&gt; vektor;
				vektor.push_back(clan1);
				vektor.push_back(clan2);
				vektor.push_back(f(clan1));
				bool nema(false);
				for(int i(0); i&lt;matrica.size(); i++) {
					if(matrica[i][0]==vektor[0]) {
						for(int j(1); j&lt;vektor.size(); j++) {
							if(matrica[i][j]==vektor[j] &amp;&amp; nema==false) {
								nema=true;
							}
						}
					}
				}
				if(nema==false) matrica.push_back(vektor);
			}
			poc2++;
		}
		auto kra2=kraj2;
		kra2--;
		auto clan=*kra2;
		if(f(clan1)==f(clan)) {
			std::vector&lt;TipF&gt; vektorcic;
			vektorcic.push_back(clan1);
			vektorcic.push_back(clan);
			vektorcic.push_back(f(clan));
			bool nema(false);
			for(int i(0); i&lt;matrica.size(); i++) {
				if(matrica[i][0]==vektorcic[0]) {
					for(int j(1); j&lt;vektorcic.size(); j++) {
						if(matrica[i][j]==vektorcic[j] &amp;&amp; nema==false) {
							nema=true;
						}
					}
				}
			}
			if(nema==false) matrica.push_back(vektorcic);
		}
		pocetak1++;
	}
	auto clan1=*pocetak1;
	kraj2--;
	auto clan2=*kraj2;
	if(f(clan1)==f(clan2)) {
		std::vector&lt;TipF&gt; vektor;
		vektor.push_back(clan1);
		vektor.push_back(clan2);
		vektor.push_back(f(clan1));
		bool nema(false);
		for(int i(0); i&lt;matrica.size(); i++) {
			if(matrica[i][0]==vektor[0]) {
				for(int j(1); j&lt;vektor.size(); j++) {
					if(matrica[i][j]==vektor[j] &amp;&amp; nema==false) {
						nema=true;
					}
				}
			}
		}
		if(nema==false) matrica.push_back(vektor);
	}
	return matrica;
}



int SumaDjelilaca (int x) {
	int suma(0);
	do {
		suma+=abs(x%10);
		x/=10;
	} while(x!=0);
	return suma;
}

int main () {
	std::vector&lt;int&gt; v1;
	std::vector&lt;int&gt; v2;
	int br1, br2;
	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	std::cin &gt;&gt; br1;
	for(int i(0); i&lt;br1; i++) {
		int broj;
		std::cin &gt;&gt; broj;
		v1.push_back(broj);
	}
	std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	std::cin &gt;&gt; br2;
	for(int i(0); i&lt;br2; i++) {
		int broj;
		std::cin &gt;&gt; broj;
		v2.push_back(broj);
	}
	
	auto matrica(UvrnutiPresjek&lt;int, int&gt;(v1.begin(), v1.end(), v2.begin(), v2.end(), SumaDjelilaca)); /*[] (int x) -&gt; int {
		int suma(0);
		do {
			suma+=abs(x%10);
			x/=10;
		} while(x!=0);
		return suma;
	}));*/
	std::sort(matrica.begin(), matrica.end()); /*, [] (auto vektor1, auto vektor2) -&gt; bool {
		if(vektor1[2]==vektor2[2]) {
			if(vektor1[1]==vektor2[1]) {
				return vektor1[0]&lt;vektor2[0];
			}
			return vektor1[1]&lt;vektor2[1];
		}
		return vektor1[2]&lt;vektor2[2];
	});*/
	for(int i(0); i&lt;matrica.size(); i++) {
		for(int j(0); j&lt;matrica[i].size(); j++) {
			std::cout &lt;&lt; matrica[i][j] &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
	return 0;
</font>}</pre>
</body>
</html>
