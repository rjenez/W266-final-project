<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student1110.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4226.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

int SumaDjelilaca(long long int x){
	int suma(0);
	for(long long int i(1); i&lt;=abs(x); i++)
		if(abs(x%i)==0) suma+=i; 
	return suma;
}

bool jelprost(long long int x){
	if(x&lt;=3) return true;
	else if(x%2==0 || x%3==0) return false;
	int i=5;
	while(i*i&lt;=x){
		if(x%i == 0 || x%(i+2) == 0) return false;
		i+=6;
	}
	return true;
}

int BrojProstihFaktora(long long int x){
	int brojac(0);
	auto temp = abs(x);
	for(long long int i(2); i&lt;=abs(x); i++){
		if(temp%i==0)
			while(temp%i==0){
				brojac++;
				temp/=i;
			}
	}
	return brojac;
}

int BrojSavrsenihDjelilaca(long long int x){
	int brojac(0);
	for(long long int i(2); i&lt;=x; i++){
		if(abs(x%i)==0){
			long long int suma(0);
			for(int j(1); j&lt;i; j++)
				if(abs(i%j)==0) suma+=j;
			if(suma==i) brojac++;
		}
	}
	return brojac;
}

template &lt;typename tip1, typename tip2&gt;
auto UvrnutiPresjek(tip1 pocetak1, tip1 kraj1, tip2 pocetak2, tip2 kraj2) -&gt; std::vector&lt;std::vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; {
	int brojac(0);
	for(auto i(pocetak1); i!=kraj1; i++){
		for(auto j(pocetak2); j!=kraj2; j++){
			if(*i==*j) brojac++;
		}
	}
	std::vector&lt;std::vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; matrica;
	matrica.resize(brojac);
	int brojac2(0);
	for(auto i(pocetak1); i!=kraj1; i++){
		for(auto j(pocetak2); j!=kraj2; j++){
			if(*i==*j){
<a name="4"></a><font color="#FF00FF"><a href="match835-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

				matrica[brojac2].push_back(*i);
				matrica[brojac2].push_back(0);
				matrica[brojac2].push_back(0);
				brojac2++;
			}
		}
	}
	std::sort(matrica.begin(), matrica.end(), [](const std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; &amp;a, const std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; &amp;b){
</font>		if(a[2]==b[2]){
			if(a[0]==b[0]) return a[1]&lt;b[1];
			return a[0]&lt;b[0];
		}
		return  (a[2]&lt;b[2]);});
	return matrica;
}

template &lt;typename tip1, typename tip2, typename tip3&gt;
auto UvrnutiPresjek(tip1 pocetak1, tip1 kraj1, tip2 pocetak2, tip2 kraj2, tip3 f) -&gt; std::vector&lt;std::vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; {
	int brojac(0);
	for(auto i(pocetak1); i!=kraj1; i++){
		for(auto j(pocetak2); j!=kraj2; j++){
			if(f(*i)==f(*j)) brojac++;
		}
	}
	std::vector&lt;std::vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; matrica;
	matrica.resize(brojac);
	int brojac2(0);
	for(auto i(pocetak1); i!=kraj1; i++){
		for(auto j(pocetak2); j!=kraj2; j++){
			if(f(*i)==f(*j)){
<a name="0"></a><font color="#FF0000"><a href="match835-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

				matrica[brojac2].push_back(*i);
				matrica[brojac2].push_back(*j);
				matrica[brojac2].push_back(f(*i));
				brojac2++;
			}
		}
	}
	std::sort(matrica.begin(), matrica.end(), [](const std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; &amp;a, const std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; &amp;b){
</font>		if(a[2]==b[2]){
			if(a[0]==b[0]) return a[1]&lt;b[1];
			return a[0]&lt;b[0];
		}
		return  (a[2]&lt;b[2]);});
	return matrica;
}

template &lt;typename tip1, typename tip2&gt;
auto UvrnutaRazlika(tip1 pocetak1, tip1 kraj1, tip2 pocetak2, tip2 kraj2) -&gt; std::vector&lt;std::vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt;{
	int brojac(0);
	std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; pom;
	tip1 pocetak1_pomocni1(pocetak1);
	tip2 pocetak2_pomocni1(pocetak2);
	bool valja(true);
	for(auto i(pocetak1); i != kraj1; i++){
		for(auto j(pocetak2); j != kraj2; j++)
			if(*i == *j) valja = false;
		if(valja) pom.push_back(*i);
		valja = true;
	}
	for(auto i(pocetak2); i != kraj2; i++){
		for(auto j(pocetak1); j != kraj1; j++)
			if(*i == *j) valja = false;
		if(valja) pom.push_back(*i);
		valja = true;
	}
	std::vector&lt;std::vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; matrica;
	pocetak1=pocetak1_pomocni1;
	pocetak2=pocetak2_pomocni1;
	matrica.resize(int(pom.size()));
	std::sort(pom.begin(), pom.end());
	for(auto i(pom.begin()); i!=pom.end(); i++)
		if(std::count(pocetak1, kraj1, *i) != 0){
			matrica[brojac].push_back(*i);
			matrica[brojac].push_back(0);
			brojac++;
		}
	for(auto i(pom.begin()); i!=pom.end(); i++)
<a name="1"></a><font color="#00FF00"><a href="match835-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if(std::count(pocetak2, kraj2, *i) != 0){
			matrica[brojac].push_back(*i);
			matrica[brojac].push_back(0);
			brojac++;
		}
	std::sort(matrica.begin(), matrica.end(), [](const std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; &amp;a, const std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; &amp;b){return a[0]&gt;b[0];});
</font>	return matrica;
}

template &lt;typename tip1, typename tip2, typename tip3&gt;
auto UvrnutaRazlika(tip1 pocetak1, tip1 kraj1, tip2 pocetak2, tip2 kraj2, tip3 f) -&gt; std::vector&lt;std::vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt;{
	int brojac(0);
	std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; pom;
	tip1 pocetak1_pomocni1(pocetak1);
	tip2 pocetak2_pomocni1(pocetak2);
	bool valja(true);
	for(auto i(pocetak1); i != kraj1; i++){
		for(auto j(pocetak2); j != kraj2; j++)
			if(f(*i) == f(*j)) valja = false;
		if(valja) pom.push_back(*i);
		valja = true;
	}
	for(auto i(pocetak2); i != kraj2; i++){
		for(auto j(pocetak1); j != kraj1; j++)
			if(f(*i) == f(*j)) valja = false;
		if(valja) pom.push_back(*i);
		valja = true;
	}
	std::vector&lt;std::vector&lt;decltype(*pocetak1+*pocetak1)&gt;&gt; matrica;
	pocetak1=pocetak1_pomocni1;
	pocetak2=pocetak2_pomocni1;
	matrica.resize(int(pom.size()));
	std::sort(pom.begin(), pom.end());
	for(auto i(pom.begin()); i!=pom.end(); i++){
		if(std::count(pocetak1, kraj1, *i) != 0){
			matrica[brojac].push_back(*i);
			matrica[brojac].push_back(f(*i));
			brojac++;
		}
	}
	for(auto i(pom.begin()); i!=pom.end(); i++){
		if(std::count(pocetak2, kraj2, *i) != 0){
<a name="5"></a><font color="#FF0000"><a href="match835-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

			matrica[brojac].push_back(*i);
			matrica[brojac].push_back(f(*i));
			brojac++;
		}
	}
	std::sort(matrica.begin(), matrica.end(), [](const std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; &amp;a, const std::vector&lt;decltype(*pocetak1+*pocetak1)&gt; &amp;b){return a[0]&gt;b[0];});
</font>	return matrica;
}


int main (){
	std::vector&lt;int&gt; niz1;
	std::vector&lt;int&gt; niz2;
	int n1, n2;
	bool valja(true);
<a name="2"></a><font color="#0000FF"><a href="match835-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	std::cin &gt;&gt; n1;
	std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	for(int i(0); i&lt;n1; i++){
		int temp;
		std::cin &gt;&gt; temp;
</font>		for(int j(0); j&lt;int(niz1.size()); j++)
			if(niz1[j]==temp){
				valja=false;
				i--;
			}
		if(valja) niz1.push_back(temp);
		valja=true;
	}
<a name="3"></a><font color="#00FFFF"><a href="match835-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	std::cin &gt;&gt; n2;
	std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	for(int i(0); i&lt;n2; i++){
		int temp;
		std::cin &gt;&gt; temp;
</font>		for(int j(0); j&lt;int(niz2.size()); j++)
			if(niz2[j]==temp){ 
				valja=false;
				i--;
			}
		if(valja) niz2.push_back(temp);
		valja=true;
	}
	std::vector&lt;std::vector&lt;int&gt;&gt; mat1 = UvrnutiPresjek(niz1.begin(), niz1.end(), niz2.begin(), niz2.end(), [](int x){int suma(0); do{suma+=abs(x%10); x/=10;}while(x!=0); return suma;});
	auto mat2 = UvrnutaRazlika(niz1.begin(), niz1.end(), niz2.begin(), niz2.end(), BrojProstihFaktora);
	std::cout &lt;&lt; "Uvrnuti presjek kontejnera:" &lt;&lt; std::endl;
	for(int i(0); i&lt;mat1.size(); i++){
		for(int j(0); j&lt;3; j++)
			std::cout &lt;&lt; std::setw(6) &lt;&lt; mat1[i][j] &lt;&lt; " ";
		std::cout &lt;&lt; std::endl;
	}
	std::cout &lt;&lt; "Uvrnuta razlika kontejnera:" &lt;&lt; std::endl;
	for(int i(0); i&lt;mat2.size(); i++){
		for(int j(0); j&lt;2; j++)
			std::cout &lt;&lt; std::setw(6) &lt;&lt; mat2[i][j] &lt;&lt; " ";
		std::cout &lt;&lt; std::endl;
	}
	std::cout &lt;&lt; "Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
