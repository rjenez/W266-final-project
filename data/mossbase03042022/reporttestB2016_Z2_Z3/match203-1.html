<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2675.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4425.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;type_traits&gt;
#include &lt;cmath&gt;

bool Prime (long long int n) { //ok
	if (n==2) return true;
	if (n&lt;=1 || n%2==0) return false;
	for (int i = 3; i*i &lt;= n; i++) if (n%i == 0) return false;
	return true;
}

int SumaCifara(long long int num) { //ok
	int sum(0);
	while(num!=0) {
		sum+=(std::abs(num%10));
		num/=10;
	}
	return sum;
}

int SumaDjelilaca(long long int num) { //ok
	int sum(0);
	for (int i = 1; i &lt;= std::abs(num); i++) {
		if (num%i == 0) sum+=i;
		if (num == i) break;
	}
	return sum;
}

bool Perfect (long long int n) {
	int sum(0);
	for (int i = 1; i &lt; n; i++) {
		if (n%i == 0) sum+=i;
		if (n-1==i) break;
	}
	return sum == n;
}

int BrojProstihFaktora(long long int num) { //ok
	if (num==0) return 0;
	int count(0);
	for (int i = 2; i &lt;= num; i++) {
		if (num%i==0) {
			if (Prime(i)) {
				count++;
				long long int tmp(num);
				tmp/=i;
				if (tmp*i!=num) continue;
				while (tmp%i==0 &amp;&amp; tmp!=0) {
					count++;
					long long int ltmp = tmp;
					tmp/=i;
					if (tmp*i!=ltmp) break;
				}
			}
		}
		if (i == num) break;
	}
	return count;
}

int BrojSavrsenihDjelilaca(long long int num) {
	if (num==0) return 0;
	int count(0);
	for (int i = 1; i &lt;= num; i++) {
		if (num%i==0) {
			if (Perfect(i)) count++;
		}
		if (i==num) break;
	}
	return count;
}
template &lt;typename Typ1, typename Typ2&gt; 
<a name="0"></a><font color="#FF0000"><a href="match203-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	auto UvrnutiPresjek (Typ1 start1, Typ1 end1, Typ2 start2, Typ2 end2) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt;&gt; {
		typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt;&gt; Tip;
		typedef std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt; Type;
</font>		typedef typename std::remove_reference&lt;decltype(*start1)&gt;::type T1;
		Typ1 begin1(start1), finish1(end1);
		Typ2 begin2(start2), finish2(end2);
		Tip vrati;
		int vel(0);  
		
		while (start1!=end1) {
			T1 x = *start1;
			while (start2!=end2) {
				T1 y = *start2;
				if(x==y) {
					bool in(false);
					for (int i = 0; i&lt;vel; i++) {
						if (vrati[i][0]==*start1 &amp;&amp; vrati[i][1]==0 &amp;&amp; vrati[i][2]==0) in = true;
					}
					if (!in) {
						vel++;
						vrati.resize(vel);
						vrati.at(vel-1).push_back(*start1);
						vrati.at(vel-1).push_back(0);
						vrati.at(vel-1).push_back(0);
					}
				}
				start2++;
			}
			start2=begin2;
			start1++;
		}
		
<a name="6"></a><font color="#00FF00"><a href="match203-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		std::sort(vrati.begin(), vrati.end(),
				  [] (Type val1, Type val2) {
				  	return val1[0] &lt; val2[0];
				  });
		
		return vrati;
	}

template &lt;typename Typ1, typename Typ2, typename T1, typename T2&gt; 
</font><a name="1"></a><font color="#00FF00"><a href="match203-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

	auto UvrnutiPresjek (Typ1 start1, Typ1 end1, Typ2 start2, Typ2 end2, T1 f(T2)) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt;&gt; {
		typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt;&gt; Tip;
		typedef std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt; Type;
</font>		Typ1 begin1(start1), finish1(end1);
		Typ2 begin2(start2), finish2(end2);
		
		Tip vrati;
		int vel(0);
		while (start1 != end1) {
			T1 x = f (*start1);
			while (start2!=end2) {
				T1 y = f(*start2);
				if (x == y) {
					
					bool in(false);
					for (int i = 0; i &lt; vel; i++) {
						if (vrati[i][0]==*start1 &amp;&amp; vrati[i][1]==*start2 &amp;&amp; vrati[i][2]==x) in = true;
					}
					
					if (!in) {
						vel++;
						vrati.resize(vel);
						vrati.at(vel-1).push_back(*start1);
						vrati.at(vel-1).push_back(*start2);
						vrati.at(vel-1).push_back(x);
					}
				}
				start2++;
			}
			start2 = begin2;
			start1++;
		}
		
<a name="4"></a><font color="#FF00FF"><a href="match203-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		std::sort(vrati.begin(), vrati.end(),
				  [] (Type val1, Type val2) {
				  	if (val1[2]!=val2[2]) return val1[2] &lt; val2[2];
</font>				  	else if(val1[0]!=val2[0]) return val1[0] &lt; val2[0];
				  	else return val1[1] &lt; val2[1];
				  });
		
		return vrati;
	}

template &lt;typename Typ1, typename Typ2&gt; 
<a name="2"></a><font color="#0000FF"><a href="match203-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

	auto UvrnutaRazlika (Typ1 start1, Typ1 end1, Typ2 start2, Typ2 end2) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt;&gt; {
		typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt;&gt; Tip;
		typedef std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt; Type;
</font>		typedef typename std::remove_reference&lt;decltype(*start1)&gt;::type T1;
		Typ1 begin1(start1), finish1(end1);
		Typ2 begin2(start2), finish2(end2);
		
		Tip vrati;
		int vel(0);
		while (start1!=end1) {
			T1 x = *start1;
			while (start2!=end2) {
				T1 y = *start2;
				if (x==y) break;
				start2++;
			}
			if (start2==end2) {
				bool in(false);
					for (int i = 0; i &lt; vel; i++) {
						if (vrati[i][0] == *start1 &amp;&amp; vrati[i][1]==0) in = true;
					}
				if (!in) {
					vel++;
					vrati.resize(vel);
					vrati.at(vel-1).push_back(*start1);
					vrati.at(vel-1).push_back(0);
				}
			}
			
			start2 = begin2;
			start1++;
		}
		
		start1 = begin1; end1=finish1;
		start2 = begin2; end2=finish2;
		
		while (start2!=end2) {
			T1 x = *start2;
			while (start1!=end1) {
				T1 y = *start1;
				if (x==y) break;
				start1++;
			}
			if (start1==end1) {
				bool in(false);
					for (int i = 0; i &lt; vel; i++) {
						if (vrati[i][0]==*start2 &amp;&amp; vrati[i][1]==0) in=true;
					}
				if(!in) {
					vel++;
					vrati.resize(vel);
					vrati.at(vel-1).push_back(*start2);
					vrati.at(vel-1).push_back(0);
				}
			}
			start1 = begin1;
			start2++;
		}
		
<a name="7"></a><font color="#0000FF"><a href="match203-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		std::sort (vrati.begin(), vrati.end(), [] (Type val1, Type val2) {return val1[0]&gt;val2[0];});
		return vrati;
	}

template &lt;typename Typ1, typename Typ2, typename T1, typename T2&gt;
</font><a name="3"></a><font color="#00FFFF"><a href="match203-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

	auto UvrnutaRazlika (Typ1 start1, Typ1 end1, Typ2 start2, Typ2 end2, T1 f(T2)) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt;&gt; {
		typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt;&gt; Tip;
		typedef std::vector&lt;typename std::remove_reference&lt;decltype(*start1)&gt;::type&gt; Type;
</font>		Typ1 begin1(start1), finish1(end1);
		Typ2 begin2(start2), finish2(end2);
		
		Tip vrati;
		int vel(0);
		while (start1 != end1) {
			T1 x = f(*start1);
			while(start2!=end2) {
				T1 y = f(*start2);
				if (x == y) break;
				start2++;
			}
			if (start2==end2) {
				bool in(false);
					for (int i = 0; i &lt; vel; i++) {
						if (vrati[i][0]==*start1 &amp;&amp; vrati[i][1]==x) in = true;
					}
				
				if (!in) {
					vel++;
					vrati.resize(vel);
					vrati.at(vel-1).push_back(*start1);
					vrati.at(vel-1).push_back(x);
				}
			}

			start2 = begin2;
			start1++;
		}
		start1 = begin1; end1=finish1;
		start2 = begin2; end2=finish2;
		
		while (start2!=end2) {
			T1 x = f(*start2);
			while (start1!=end1) {
				T1 y = f(*start1);
				if (x==y) break;
				start1++;
			}
			if (start1==end1) {
				bool in(false);
					for (int i = 0; i &lt; vel; i++) {
						if (vrati[i][0]==*start2 &amp;&amp; vrati[i][1]==x) in = true;
					}
				if(!in) {
					vel++;
					vrati.resize(vel);
					vrati.at(vel-1).push_back(*start2);
					vrati.at(vel-1).push_back(x);
				}
			}
			start1 = begin1;
			start2++;
		}

<a name="5"></a><font color="#FF0000"><a href="match203-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		std::sort(vrati.begin(), vrati.end(),
				  [] (Type val1, Type val2) {
				  	if (val1[0]!=val2[0]) return val1[0]&gt;val2[0];
</font>				  	else return val1[1]&gt;val2[1];
				  });
		
		return vrati;
		
	}
	
int main () {
	
	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	int n1;
<a name="8"></a><font color="#00FFFF"><a href="match203-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	std::cin &gt;&gt; n1;
	std::deque&lt;int&gt; dek1(n1);
	std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	for (int i = 0; i &lt; n1; i++) {
</font>		int tmp;
		std::cin&gt;&gt;tmp;
		bool in (false);
		for (int j = 0; j &lt; i; j++) if (dek1.at(j)==tmp) {
			in = true;
			i--;
		}
		if (!in) dek1.at(i) = tmp;
	}
	
	std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	int n2;
<a name="9"></a><font color="#FF00FF"><a href="match203-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	std::cin &gt;&gt; n2;
	std::deque&lt;int&gt; dek2(n2);
	std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	for (int i = 0; i &lt; n2; i++) {
</font>		int tmp;
		std::cin &gt;&gt; tmp;
		bool in(false);
		for (int j = 0; j &lt; i; j++) if (dek2.at(j)==tmp) {
			in = true;
			i--;
		}
		if (!in) dek2.at(i) = tmp;
	}
	
	std::cout &lt;&lt; "Uvrnuti presjek kontejnera:" &lt;&lt; std::endl;
	auto presjek = UvrnutiPresjek(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), SumaCifara);
	for (int i = 0; i &lt; presjek.size(); i++) {
		for (int j = 0; j &lt; 3; j++) {
			std::cout &lt;&lt; std::setw(6) &lt;&lt; presjek.at(i).at(j) &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
	
	std::cout &lt;&lt; "Uvrnuta razlika kontejnera:" &lt;&lt; std::endl;
	auto razlika = UvrnutaRazlika(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), BrojProstihFaktora);
	for (int i = 0; i &lt; razlika.size(); i++) {
		for (int j = 0; j &lt; 2; j++) {
			std::cout &lt;&lt; std::setw(6) &lt;&lt; razlika.at(i).at(j) &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
	
	std::cout &lt;&lt; "Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
