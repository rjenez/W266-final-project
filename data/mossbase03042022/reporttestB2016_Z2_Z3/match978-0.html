<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student5581.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student5581.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;type_traits&gt;
#include &lt;iomanip&gt;

bool JeProst(long long int n){
	if(n&lt;=1) return false;
	
	n=std::fabs(n);
	long long int korijen=std::sqrt(n);
	
	for(int i=2;i&lt;=korijen;i++)
		if(n%i==0)
			return false;
	return true;
}

bool Ima(int broj, std::deque&lt;int&gt; dek){
	for(int i=0;i&lt;dek.size();i++)
		if(broj==dek[i])
			return true;
	return false;
}

int SumaDjelilaca(long long int n){
	
	n=std::fabs(n);
	
	int suma(n);
	
	for ( int i=1 ; i&lt;=n/2 ; i++ ){
		if(n % i == 0)
			suma+=i;
	}
	
	return suma;
}

bool JeSavrsen(long long int n){
	n=std::fabs(n);
	long long int suma_djelilaca=SumaDjelilaca(n);
	return suma_djelilaca-n==n;
}

int SumaCifara(long long int n){
	int suma=0;
<a name="2"></a><font color="#0000FF"><a href="match978-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	while(n!=0){
		suma+=std::abs(n%10);
		n/=10;
	}
	return suma;
}

int BrojProstihFaktora(long long int n){
	
	int brojac(0);
</font>	
	n=std::fabs(n);
	
	for(int i=1;i&lt;=n;i++){
		while(JeProst(i)&amp;&amp;n%i==0){
			brojac++;
			n/=i;
		}
	}
	return brojac;
}

int BrojSavrsenihDjelilaca(long long int n){
	
	int brojac(0);
	
	for(int i=1;i&lt;=n/2;i++){
		if(n%i==0&amp;&amp;JeSavrsen(i))
			brojac++;
	}
	if(JeSavrsen(n)) brojac++;
	return brojac;
}

template&lt;typename TipPrvogBloka, typename TipDrugogBloka, typename ParametarFunkcije, typename PovratniTipFunkcije&gt;

std::vector&lt;std::vector&lt;PovratniTipFunkcije&gt;&gt; UvrnutiPresjek(TipPrvogBloka pocetak1, TipPrvogBloka kraj1, TipDrugogBloka pocetak2, TipDrugogBloka kraj2, PovratniTipFunkcije funkcija(ParametarFunkcije)){
	
	std::vector&lt;std::vector&lt;PovratniTipFunkcije&gt;&gt; presjek;
	
	std::vector&lt;PovratniTipFunkcije&gt; red;
	
	while(pocetak1!=kraj1){
		
		TipDrugogBloka pom=pocetak2;
		while(pom!=kraj2){
			
			if(funkcija(*pocetak1)==funkcija(*pom)){
				std::vector&lt;PovratniTipFunkcije&gt; red(3);
				red[0]=*pocetak1;
				red[1]=*pom;
				red[2]=funkcija(*pocetak1);
				presjek.push_back(red);
			}
			pom++;
		}
		pocetak1++;
	}
	
	std::sort(presjek.begin(),presjek.end(),[](std::vector&lt;PovratniTipFunkcije&gt; a, std::vector&lt;PovratniTipFunkcije&gt; b){
		if(a[2]&lt;b[2]) return true;
		else if(a[2]&gt;b[2]) return false;
		else {
			if(a[0]&lt;b[0]) return true;
			else if(a[0]&gt;b[0]) return false;
			else return (a[1]&lt;b[1]);
		}
	});
	
	return presjek;
}

template &lt;typename TipPrvogBloka, typename TipDrugogBloka&gt;

auto UvrnutiPresjek(TipPrvogBloka pocetak1, TipPrvogBloka kraj1, TipDrugogBloka pocetak2, TipDrugogBloka kraj2) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt;{
	
	typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; matrica;
	
	typename std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; red(3);
	while(pocetak1!=kraj1){
		TipDrugogBloka pom=pocetak2;
		while(pom!=kraj2){
			if(*pom == *pocetak1){
				red[0] = *pom;
				red[1] = typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type {};
				red[2] = typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type {};
				matrica.push_back(red);
			}
			pom++;
		}
		pocetak1++;
	}
	
<a name="3"></a><font color="#00FFFF"><a href="match978-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	std::sort(matrica.begin(),matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; a, std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; b){return a[0]&lt;b[0];});
	
	return matrica;
}

template&lt;typename TipPrvogBloka, typename TipDrugogBloka, typename ParametarFunkcije, typename PovratniTipFunkcije&gt;
</font>
std::vector&lt;std::vector&lt;PovratniTipFunkcije&gt;&gt; UvrnutaRazlika(TipPrvogBloka pocetak1, TipPrvogBloka kraj1, TipDrugogBloka pocetak2, TipDrugogBloka kraj2, PovratniTipFunkcije funkcija(ParametarFunkcije)){
	
	std::vector&lt;std::vector&lt;PovratniTipFunkcije&gt;&gt; matrica;
	
	std::vector&lt;PovratniTipFunkcije&gt; red(2);
	
	bool ima(0);
	
	TipPrvogBloka pom2=pocetak1;
	TipDrugogBloka pom=pocetak2;
	
	while(pom2!=kraj1){
		pom=pocetak2;
		ima=0;
		while(pom!=kraj2){
			if(funkcija(*pom2) == funkcija(*pom)){
				ima=1;
				break;
			}
			pom++;
		}
		if(!ima){
			red[0]=*pom2;
			red[1]=funkcija(*pom2);
			matrica.push_back(red);
		}
		pom2++;
	}
	pom=pocetak2;
	pom2=pocetak1;
	while(pom!=kraj2){
		pom2=pocetak1;
		ima=0;
		while(pom2!=kraj1){
			if(funkcija(*pom2)==funkcija(*pom)){
				ima=1;
				break;
			}
			pom2++;
		}
		if(!ima){
			red[0]=*pom;
			red[1]=funkcija(*pom);
			matrica.push_back(red);
			
		}
		pom++;
	}
	
	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;PovratniTipFunkcije&gt; a, std::vector&lt;PovratniTipFunkcije&gt; b){
		if(a[0]&gt;b[0]) return true;
		else if(b[0]&gt;a[0]) return false;
		else return a[1]&lt;b[1];
	} );
	
		return matrica;
	}

template &lt;typename TipPrvogBloka, typename TipDrugogBloka&gt;
auto UvrnutaRazlika(TipPrvogBloka pocetak1, TipPrvogBloka kraj1, TipDrugogBloka pocetak2, TipDrugogBloka kraj2) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; {
	
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; matrica;
	std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; red(2);
	
	bool ima=0;
	
	TipPrvogBloka pom1=pocetak1;
	TipDrugogBloka pom2=pocetak2;
	
	while(pom1!=kraj1){
		pom2=pocetak2;
		ima=0;
		while(pom2!=kraj2){
			if(*pom1==*pom2){
				ima=1;
				break;
			}
			pom2++;
		}
		if(!ima){
			red[0]=*pom1;
			red[1]=typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type {};
			matrica.push_back(red);
		}
		pom1++;
	}
	pom1=pocetak1;
	pom2=pocetak2;
	while(pom2!=kraj2){
		pom1=pocetak1;
		ima=0;
		while(pom1!=kraj1){
			if(*pom1==*pom2){
				ima=1;
				break;
			}
			pom1++;
		}
		if(!ima){
			red[0]=*pom2;
			red[1]=typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type {};
			matrica.push_back(red);
		}
		pom2++;
	}
	
	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; a, std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; b){
		return a[0]&gt;b[0];
	});
	
	return matrica;
}

int main ()
{
	std::deque&lt;int&gt; dek1,dek2;
	int x;
	
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	std::cin&gt;&gt;x;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	int broj;
	
	for(int i=0 ; i&lt;x ; i++){
		std::cin&gt;&gt;broj;
		while(Ima(broj,dek1))std::cin&gt;&gt;broj;
		
		dek1.push_back(broj);
	}
	
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;x;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	
	for(int i=0;i&lt;x;i++){
		std::cin&gt;&gt;broj;
		while(Ima(broj, dek2)) std::cin&gt;&gt;broj;
		
		dek2.push_back(broj);
	}
	
<a name="1"></a><font color="#00FF00"><a href="match978-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

	std::cout&lt;&lt;"Uvrnuti presjek kontejnera: "&lt;&lt;std::endl;
	auto presjek = UvrnutiPresjek(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), SumaCifara);
	
	for(int i=0;i&lt;presjek.size();i++){
		for(int j=0;j&lt;3;j++){
			std::cout&lt;&lt;std::setw(6)&lt;&lt;presjek[i][j]&lt;&lt;" ";
</font>		}
<a name="0"></a><font color="#FF0000"><a href="match978-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera: "&lt;&lt;std::endl;
	auto razlika = UvrnutaRazlika(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), BrojProstihFaktora);
	
	for(int i=0;i&lt;razlika.size();i++){
		for(int j=0;j&lt;2;j++){
			std::cout&lt;&lt;std::setw(6)&lt;&lt;razlika[i][j]&lt;&lt;" ";
</font>		}
		std::cout&lt;&lt;std::endl;
	}
	
	std::cout&lt;&lt;"Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
