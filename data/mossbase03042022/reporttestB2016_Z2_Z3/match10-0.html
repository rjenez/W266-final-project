<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student8794.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student8794.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: i javni ATo-vi su dio postavke

	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba

*/
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include &lt;algorithm&gt;
#include&lt;functional&gt;
#include&lt;iomanip&gt;
#include &lt;deque&gt;
//template&lt;typename tip&gt;
<a name="2"></a><font color="#0000FF"><a href="match10-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_13.gif"/></a>

template &lt;typename IterTip1, typename IterTip2&gt;
auto UvrnutiPresjek(IterTip1 a1, IterTip1 a2,IterTip2 b1, IterTip2 b2) -&gt;std::vector&lt;std::vector&lt;decltype(*a1+*b1)&gt;&gt;{
	IterTip1 a11=a1;
	IterTip2 b11=b1;
	std::vector&lt;IterTip1&gt; prva;
	std::vector&lt;IterTip2&gt; druga;
	std::vector&lt;decltype(*a1+*b1)&gt; funkcija;

while(a1!=a2) {
	auto b1p=b1;
	while(b1p!=b2)
	{
		if(*a1==*b1p)
		{

			prva.push_back(a1);
			funkcija.push_back(0);
		}
		b1p++;
	}
	a1++;
}
std::vector&lt;std::vector&lt;decltype(*a11+*b11)&gt;&gt; niz(funkcija.size(), std::vector&lt;decltype(*a11+*b11)&gt;(3));;
for(int i=0;i&lt;funkcija.size();i++)
{
	niz[i][0]=*(prva[i]);
	niz[i][1]=0;
	niz[i][2]=funkcija[i];
}
std::sort(niz.begin(),niz.end(),[](std::vector&lt;decltype(*a11+*b11)&gt; niz1,std::vector&lt;decltype(*a11+*b11)&gt; niz2)-&gt;bool
{
	if(niz1[2]&lt;niz2[2]) return true;
	else if(niz1[2]&gt;niz2[2]) return false;
</font>	else
	{
	if(niz1[0]&lt;niz2[0]) return true;
	else if(niz1[0]&gt;niz2[0]) return false;
	else
	{
<a name="1"></a><font color="#00FF00"><a href="match10-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_15.gif"/></a>

		if(niz1[1]&lt;niz2[1]) return true;
	else if(niz1[1]&gt;niz2[1]) return false;
	}
	}
}

);
return niz;
}





template &lt;typename IterTip1, typename IterTip2,typename tip1&gt;
auto UvrnutiPresjek(IterTip1 a1, IterTip1 a2,IterTip2 b1, IterTip2 b2,tip1 f) -&gt;std::vector&lt;std::vector&lt;decltype(*a1+*b1)&gt;&gt;{
	IterTip1 a11=a1;
	IterTip2 b11=b1;
	std::vector&lt;IterTip1&gt; prva;
	std::vector&lt;IterTip2&gt; druga;
	std::vector&lt;decltype(*a1+*b1)&gt; funkcija;

while(a1!=a2) {
	auto b1p=b1;
	while(b1p!=b2)
	{
		if(f(*a1)==f(*b1p))
		{
			prva.push_back(a1);
			druga.push_back(b1p);
			funkcija.push_back(f(*a1));
		}
		b1p++;
	}
	a1++;
}
std::vector&lt;std::vector&lt;decltype(*a11+*b11)&gt;&gt; niz(funkcija.size(), std::vector&lt;decltype(*a11+*b11)&gt;(3));;
for(int i=0;i&lt;funkcija.size();i++)
{
	niz[i][0]=*(prva[i]);
	niz[i][1]=*(druga[i]);
	niz[i][2]=funkcija[i];
}
std::sort(niz.begin(),niz.end(),[](std::vector&lt;decltype(*a11+*b11)&gt; niz1,std::vector&lt;decltype(*a11+*b11)&gt; niz2)-&gt;bool
{
	if(niz1[2]&lt;niz2[2]) return true;
	else if(niz1[2]&gt;niz2[2]) return false;
</font>	else
	{
	if(niz1[0]&lt;niz2[0]) return true;
	else if(niz1[0]&gt;niz2[0]) return false;
	else
	{
<a name="0"></a><font color="#FF0000"><a href="match10-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_65.gif"/></a>

		if(niz1[1]&lt;niz2[1]) return true;
	else if(niz1[1]&gt;niz2[1]) return false;
	}
	}
});
return niz;
}

































template &lt;typename IterTip1, typename IterTip2&gt;
auto UvrnutaRazlika(IterTip1 a1, IterTip1 a2,IterTip2 b1, IterTip2 b2) -&gt;std::vector&lt;std::vector&lt;decltype(*a1+*b1)&gt;&gt;{
	IterTip1 a11=a1,apom=a1;
	IterTip2 b11=b1,bpom=b1;
	std::vector&lt;IterTip1&gt; prva;
	std::vector&lt;decltype(*a1+*b1)&gt; funkcija;

while(a1!=a2) {
	auto b1p=b1;
	bool postoji=false;
	while(b1p!=b2)
	{
		if(*a1==*b1p)
		{
postoji=true;
		}
		b1p++;
	}
	if(!postoji)
	{
		prva.push_back(a1);
	}
	a1++;
}

while(bpom!=b2) {
	auto a1p=apom;
	bool postoji=false;
	while(a1p!=a2)
	{
		if(*bpom==*a1p)
		{
postoji=true;
		}
		a1p++;
	}
	if(!postoji)
	{
		prva.push_back(bpom);
	}
	bpom++;
}






std::vector&lt;std::vector&lt;decltype(*a11+*b11)&gt;&gt; niz(prva.size(), std::vector&lt;decltype(*a11+*b11)&gt;(2));;
for(int i=0;i&lt;prva.size();i++)
{
	niz[i][0]=*(prva[i]);
	niz[i][1]=(0);
}
std::sort(niz.begin(),niz.end(),[](std::vector&lt;decltype(*a11+*b11)&gt; niz1,std::vector&lt;decltype(*a11+*b11)&gt; niz2)-&gt;bool
{
		if(niz1[0]&gt;niz2[0]) return true;
	else if(niz1[0]&lt;niz2[0]) return false;
	else
	{
		if(niz1[1]&gt;niz2[1]) return true;
	else if(niz1[1]&lt;niz2[1]) return false;
	}
});
return niz;
}





template &lt;typename IterTip1, typename IterTip2,typename tip1&gt;
auto UvrnutaRazlika(IterTip1 a1, IterTip1 a2,IterTip2 b1, IterTip2 b2,tip1 f) -&gt;std::vector&lt;std::vector&lt;decltype(*a1+*b1)&gt;&gt;{
	IterTip1 a11=a1,apom=a1;
	IterTip2 b11=b1,bpom=b1;
	std::vector&lt;IterTip1&gt; prva;
	std::vector&lt;decltype(*a1+*b1)&gt; funkcija;

while(a1!=a2) {
	auto b1p=b1;
	bool postoji=false;
	while(b1p!=b2)
	{
		
		if(f(*a1)==f(*b1p))
		{
			postoji=true;
		}
		b1p++;
	}
	if(!postoji)
	{
		
			prva.push_back(a1);
			funkcija.push_back(f(*a1));
	}
	a1++;
}


while(bpom!=b2) {
	auto a1p=apom;
	bool postoji=false;
	while(a1p!=a2)
	{
		
		if(f(*a1p)==f(*bpom))
		{
			postoji=true;
		}
		a1p++;
	}
	if(!postoji)
	{
		
			prva.push_back(bpom);
			funkcija.push_back(f(*bpom));
	}
	bpom++;
}


std::vector&lt;std::vector&lt;decltype(*a11+*b11)&gt;&gt; niz(prva.size(), std::vector&lt;decltype(*a11+*b11)&gt;(2));;
for(int i=0;i&lt;prva.size();i++)
{
	niz[i][0]=*(prva[i]);
	niz[i][1]=funkcija[i];
}
std::sort(niz.begin(),niz.end(),[](std::vector&lt;decltype(*a11+*b11)&gt; niz1,std::vector&lt;decltype(*a11+*b11)&gt; niz2)-&gt;bool
{
		if(niz1[0]&gt;niz2[0]) return true;
	else if(niz1[0]&lt;niz2[0]) return false;
	else
	{
		if(niz1[1]&gt;niz2[1]) return true;
	else if(niz1[1]&lt;niz2[1]) return false;
	}
});
return niz;
}









int SumaCifara(long long int x)
{
	int k=0;
	while(x!=0)
	{
		k=k+x%10;
		x=x/10;
	}
	return k;
}

int SumaDjelilaca(long long int x)
{
	int k=0;
	for(int i=1;i&lt;=x;i++)
	if(x%i==0)
	k+=i;
	return k;
}
bool jeLiProst(long long int x)
{
	if(x==2) return true;
	for(int i=2;i&lt;x/2;i++)
	if(x%i==0) return false;
	return true;
}
int BrojProstihFaktora(long long int x)
{
	int k=0;
	for(int i=2;i&lt;=x;i++)
	{
		if(x%i==0)
		{
			if(jeLiProst(i))
			{
				x=x/i;
				i=1;
			k++;
			}
		}
	}
	return k;
}
bool jeLiJednakZbiruDjelilaca(long long int x)
{
	int k=0;
	for(int i=1;i&lt;x;i++)
	if(x%i==0) k+=i;
	return x==k;
}
int BrojSavrsenihDjelilaca(long long int x)
{
	int k=0;
	for(int i=2;i&lt;=x;i++)
	{
			if(x%i==0 &amp;&amp; jeLiJednakZbiruDjelilaca(i))
			{
			k++;
			}
	}
	return k;
}
int main ()
{
	
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	int prvi;
	std::cin&gt;&gt;prvi;
	std::deque&lt;int&gt; dek1,dek2;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	std::vector&lt;int&gt; prviDek,drugiDek;
	for(int i=0;i&lt;prvi;i++)
	{
		int p;
		std::cin&gt;&gt;p;
		bool postoji=false;
		for(int j=0;j&lt;dek1.size();j++)
		if(p==dek1[j]) {postoji=true; i--;}
		if(!postoji)
		dek1.push_back(p);
	}
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;prvi;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	for(int i=0;i&lt;prvi;i++)
	{
		int p;
		std::cin&gt;&gt;p;
		bool postoji=false;
		for(int j=0;j&lt;dek2.size();j++)
		if(p==dek2[j]) {postoji=true; i--;}
		if(!postoji)
		dek2.push_back(p);
	}


	auto p1=UvrnutiPresjek(dek1.begin(),dek1.end(),dek2.begin(),dek2.end(),SumaCifara);
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera:"&lt;&lt;std::endl;
	
	for(int i=0;i&lt;p1.size();i++)
    {

        for(int j=0;j&lt;3;j++)
        if(j==0)
            std::cout&lt;&lt;std::setw(6)&lt;&lt;p1[i][j];
            else
            std::cout&lt;&lt;std::setw(7)&lt;&lt;p1[i][j];
        std::cout&lt;&lt;" "&lt;&lt;std::endl;
    }
    std::cout&lt;&lt;"Uvrnuta razlika kontejnera:"&lt;&lt;std::endl;
    auto p2=UvrnutaRazlika(dek1.begin(),dek1.end(),dek2.begin(),dek2.end(),BrojProstihFaktora);
    	for(int i=0;i&lt;p2.size();i++)
    {

        for(int j=0;j&lt;2;j++)
            std::cout&lt;&lt;std::setw(6)&lt;&lt;p2[i][j]&lt;&lt;" ";
</font>        std::cout&lt;&lt;std::endl;
    }
    std::cout&lt;&lt;"Dovidjenja!";
    
	return 0;
}

</pre>
</body>
</html>
