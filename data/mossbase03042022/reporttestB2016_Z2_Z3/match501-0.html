<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2155.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2155.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
int SumaCifri(long long int x){
    if(x==0)return 0;
    return abs(x%10)+abs(SumaCifri(x/10));
}
int SumaDjelilaca(long long int x){
    int suma(0);
    if(x &gt;= 0)
        for(int i(1);i &lt;= x;i++){
            if(x%i==0)suma+=i;
        }
    else for(int i(-1);i &gt;= x;i--){
        if(x%i==0)suma+=abs(i);
    }

    return suma;
}
int BrojProstihFaktora(long long int x){
    int brojac(0);
    if(x &gt;= 0)
        for(int i(2);i &lt;= x;i++){
            if(x%i==0){
                while(x%i==0)x/=i,brojac++;
            }
        }
    else for(int i(-2);i &gt;= x;i--){
            if(x%i==0){
                while(x%i==0)x/=i,brojac++;
            }
        }
    return brojac;
}
int BrojSavrsenihDjelilaca(long long int x){
    int brojac(0);
    if(x &gt;= 0)
        for(int i(1);i &lt;= x;i++){
            if(x%i==0 &amp;&amp; abs(i)==SumaDjelilaca(i)-abs(i))brojac++;
        }
    else for(int i(-1);i &gt;= x;i--){
            if(x%i==0 &amp;&amp; abs(i)==SumaDjelilaca(i)-abs(i))brojac++;
        }
    return brojac;
}
template &lt;typename Tip1,typename Tip2,typename Tip3,typename Tip4&gt;
    auto UvrnutiPresjek(Tip1 beg1,Tip1 end1,Tip2 beg2,Tip2 end2,Tip3 funk(Tip4)) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(funk(*beg1))&gt;::type&gt;&gt;{
        
<a name="1"></a><font color="#00FF00"><a href="match501-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

        std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(funk(*beg1))&gt;::type&gt;&gt; matrica;
        
        while(beg1 != end1){
            Tip2 tmp(beg2);
            while(tmp != end2){
                if(funk(*beg1) == funk(*tmp)){
                 
                   matrica.push_back({*beg1,*tmp,funk(*beg1)});
                }
                tmp++;
            }
            beg1++;
        }
        std::sort(std::begin(matrica),std::end(matrica),[](std::vector&lt;typename std::remove_reference&lt;decltype(funk(*beg1))&gt;::type&gt; x,std::vector&lt;typename std::remove_reference&lt;decltype(funk(*beg1))&gt;::type&gt; y){
</font>            if(x[2] &lt; y[2]){
                return true;
            }else if(x[2] &gt; y[2]){
                return false;
            }else{
                if(x[0] &lt; y[0]) return true;
                else if(x[0] &gt; y[0]) return false;
                else{
                    return x[1] &lt; y[1];
                }
            }
        });
        return matrica;
    }
template &lt;typename Tip1,typename Tip2&gt;
<a name="5"></a><font color="#FF0000"><a href="match501-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    auto UvrnutiPresjek(Tip1 beg1,Tip1 end1,Tip2 beg2,Tip2 end2) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*beg1)&gt;::type&gt;&gt;{
</font>        
        std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*beg1)&gt;::type&gt;&gt; matrica;
        
        while(beg1 != end1){
            Tip2 tmp(beg2);
            while(tmp != end2){
                if(*beg1 == *tmp){
                 
                   matrica.push_back({*beg1,0,0});
                }
                tmp++;
            }
            beg1++;
        }
        std::sort(std::begin(matrica),std::end(matrica));
        return matrica;
    }	
	
template &lt;typename Tip1,typename Tip2,typename Tip3,typename Tip4&gt;
    auto UvrnutaRazlika(Tip1 beg1,Tip1 end1,Tip2 beg2,Tip2 end2,Tip3 funk(Tip4)) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(funk(*beg1))&gt;::type&gt;&gt;{
<a name="0"></a><font color="#FF0000"><a href="match501-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(funk(*beg1))&gt;::type&gt;&gt; matrica;
	Tip1 tmp1(beg1);
	Tip2 tmp2(beg2);
	while(tmp1!=end1){
	    Tip2 tmp(beg2);
	    bool x(true);
	    while(tmp != end2){
	        if(funk(*tmp1) == funk(*tmp)){
	            x = false;
	            break;
	        }
	       
	        tmp++;
	    }
	     if(x){
	            matrica.push_back({*tmp1,funk(*tmp1)});
</font>	        }
	    tmp1++;
	}
	while(tmp2!=end2){
<a name="4"></a><font color="#FF00FF"><a href="match501-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

	    Tip1 tmp(beg1);
	    bool x(true);
	    while(tmp != end1){
	        if(funk(*tmp2) == funk(*tmp)){
	            x = false;
	            break;
	        }
	       
	        tmp++;
	    }
	     if(x){
	            matrica.push_back({*tmp2,funk(*tmp2)});
</font>	        }
	    tmp2++;
	}
	std::sort(std::begin(matrica),std::end(matrica),[](std::vector&lt;typename std::remove_reference&lt;decltype(funk(*beg1))&gt;::type&gt; x,std::vector&lt;typename std::remove_reference&lt;decltype(funk(*beg1))&gt;::type&gt; y){
            if(x[0] &lt; y[0]){
                return false;
            }else if(x[0] &gt; y[0]){
                return true;
            }else{
                return x[1] &gt; y[1];
            }
        });
	return matrica;
    }
template &lt;typename Tip1,typename Tip2&gt;
<a name="6"></a><font color="#00FF00"><a href="match501-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    auto UvrnutaRazlika(Tip1 beg1,Tip1 end1,Tip2 beg2,Tip2 end2) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*beg1)&gt;::type&gt;&gt;{
</font><a name="2"></a><font color="#0000FF"><a href="match501-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*beg1)&gt;::type&gt;&gt; matrica;
	Tip1 tmp1(beg1);
	Tip2 tmp2(beg2);
	while(tmp1!=end1){
	    Tip2 tmp(beg2);
	    bool x(true);
	    while(tmp != end2){
	        if(*tmp1 == *tmp){
	            x = false;
	            break;
	        }
	       
	        tmp++;
	    }
	     if(x){
	            matrica.push_back({*tmp1,0});
</font>	        }
	    tmp1++;
	}
<a name="3"></a><font color="#00FFFF"><a href="match501-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	while(tmp2!=end2){
	    Tip1 tmp(beg1);
	    bool x(true);
	    while(tmp != end1){
	        if(*tmp2 == *tmp){
	            x = false;
	            break;
	        }
	       
	        tmp++;
	    }
	     if(x){
	            matrica.push_back({*tmp2,0});
</font>	        }
	    tmp2++;
	}
	std::sort(matrica.rbegin(),matrica.rend());
	return matrica;
    }
int main ()
{
    int n;
    std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
    std::cin &gt;&gt; n;
    std::deque&lt;int&gt; a;
    std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
    for(int i(0);i &lt; n;i++){
        int x;
        bool test(true);
        std::cin &gt;&gt; x;
        for(int j(0);j &lt; i;j++){
            if(a[j]==x){
                test=false;
                break;
                
            }
        }
        if(test)a.push_back(x);
        else i--;
    }
    std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
    std::cin &gt;&gt; n;
    std::deque&lt;int&gt; b;
    std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
    for(int i(0);i &lt; n;i++){
        int x;
        bool test(true);
        std::cin &gt;&gt; x;
        for(int j(0);j &lt; i;j++){
            if(b[j]==x){
                test=false;
                break;
                
            }
        }
        if(test)b.push_back(x);
        else i--;
    }
    
    std::cout &lt;&lt; "Uvrnuti presjek kontejnera:\n";
    auto matrica(UvrnutiPresjek(a.begin(),a.end(),b.begin(),b.end(),SumaCifri));
    for(auto x: matrica){
        for(auto y:x)std::cout &lt;&lt; std::setw(6) &lt;&lt; y &lt;&lt; " ";
        std::cout &lt;&lt; "\n";
    }
    std::cout &lt;&lt; "Uvrnuta razlika kontejnera:\n";
    matrica =(UvrnutaRazlika(a.begin(),a.end(),b.begin(),b.end(),BrojProstihFaktora));
    for(auto x: matrica){
        for(auto y: x)std::cout &lt;&lt; std::setw(6) &lt;&lt; y &lt;&lt; " ";
        std::cout &lt;&lt; "\n";
    }
    std::cout &lt;&lt; "Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
