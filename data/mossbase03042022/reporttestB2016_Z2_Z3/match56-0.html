<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student1639.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student1639.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iterator&gt;
#include &lt;iomanip&gt;

using namespace std;

<a name="0"></a><font color="#FF0000"><a href="match56-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template&lt;typename TipPrvi, typename TipDrugi&gt;
auto UvrnutiPresjek(TipPrvi pocetak1, TipPrvi kraj1, TipDrugi pocetak2, TipDrugi kraj2) -&gt; vector&lt;vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt;   
{
    vector&lt;vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; rezultujuca (1);
    int red_matrice(0);
    
    for(auto i = pocetak1; i!=kraj1; i++)
    {
        for(auto j = pocetak2; j!=kraj2; j++)
        {
            if(*i==*j)
            {
                rezultujuca.at(red_matrice).push_back(*i);
                rezultujuca.at(red_matrice).push_back(0);
                rezultujuca.at(red_matrice).push_back(0);
                rezultujuca.resize(rezultujuca.size()+1);
                red_matrice++;
            }
        }
    }
    
    rezultujuca.resize(rezultujuca.size()-1);
    sort(rezultujuca.begin(), rezultujuca.end(), [](const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;a, const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;b)-&gt;bool {return a.at(0)&lt;b.at(0);});
    
    return rezultujuca;
}

template&lt;typename TipPrvi, typename TipDrugi, typename Proizvoljni1, typename Proizvoljni2&gt;
auto UvrnutiPresjek (TipPrvi pocetak1, TipPrvi kraj1, TipDrugi pocetak2, TipDrugi kraj2, Proizvoljni1 funkcija (Proizvoljni2)) -&gt; vector&lt;vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt;   
{   
    vector&lt;vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; rezultujuca (1); // da mogu nesto adresirat 
    int red_matrice(0);
    for(auto i = pocetak1; i!=kraj1; i++)
    {
        for(auto j = pocetak2; j!=kraj2; j++)
        {
            if(funkcija(*i)==funkcija(*j))
            {
                rezultujuca.at(red_matrice).push_back(*i);
                rezultujuca.at(red_matrice).push_back(*j);
                rezultujuca.at(red_matrice).push_back(funkcija(*i));
                rezultujuca.resize(rezultujuca.size()+1); // rasiri za novi red da mozes adresirati
                red_matrice++;
            }
        }
    }
    
    rezultujuca.resize(rezultujuca.size()-1); // uvijek ce biti onaj prazni red viska
    
    sort(rezultujuca.begin(), rezultujuca.end(), [](const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;a, const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;b)-&gt;bool {return a.at(1)&lt;b.at(1);});
    stable_sort(rezultujuca.begin(), rezultujuca.end(), [](const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;a, const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;b)-&gt;bool {return a.at(0)&lt;b.at(0);});
    stable_sort(rezultujuca.begin(), rezultujuca.end(), [](const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;a, const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;b)-&gt;bool {return a.at(2)&lt;b.at(2);});
    
    return rezultujuca;
}

template&lt;typename TipPrvi, typename TipDrugi&gt;
auto UvrnutaRazlika (TipPrvi pocetak1, TipPrvi kraj1, TipDrugi pocetak2, TipDrugi kraj2) -&gt; vector&lt;vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt;
{
    vector&lt;vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; matrica (1);
    int red_matrice(0);
    for(auto i = pocetak1; i!=kraj1; i++)
    {
        if(find(pocetak2,kraj2,*i)==kraj2)
        {
            matrica.at(red_matrice).push_back(*i);
            matrica.at(red_matrice).push_back(0);
            matrica.resize(matrica.size()+1);
            red_matrice++;
        }
    }
    
    for(auto i = pocetak2; i!=kraj2; i++)
    {
        if(find(pocetak1, kraj1, *i)==kraj1)
        {
            matrica.at(red_matrice).push_back(*i);
            matrica.at(red_matrice).push_back(0);
            matrica.resize(matrica.size()+1);
            red_matrice++;
        }
    }
    
    matrica.resize(matrica.size()-1);
    
    sort(matrica.begin(), matrica.end(), [](const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;a, const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;b)-&gt;bool {return a.at(0)&gt;b.at(0);});
    
    return matrica;
}

template&lt;typename TipPrvi, typename TipDrugi, typename Proizvoljni1, typename Proizvoljni2&gt;
auto UvrnutaRazlika (TipPrvi pocetak1, TipPrvi kraj1, TipDrugi pocetak2, TipDrugi kraj2, Proizvoljni1 funkcija (Proizvoljni2)) -&gt; vector&lt;vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt;
{
    vector&lt;vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; matrica (1);
    vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; rezultati1(1), rezultati2(1);
    int brojac(0), red_matrice(0);
    bool nema_istog(true);
  
    for(auto i = pocetak1; i!=kraj1; i++)
    {
        nema_istog=true;
        for(auto j = pocetak2; j!=kraj2; j++)
        {
            if(funkcija(*i)==funkcija(*j))
            {
                nema_istog=false;
                break;
            }
        }
        
        if(nema_istog)
        {
            matrica.at(red_matrice).push_back(*i);
            matrica.at(red_matrice).push_back(funkcija(*i));
            matrica.resize(matrica.size()+1);
            red_matrice++;
        }
    }
    
   
    for(auto i = pocetak2; i!=kraj2; i++)
    {
        nema_istog=true;
        for(auto j = pocetak1; j!=kraj1; j++)
        {
            if(funkcija(*i)==funkcija(*j))
            {
                nema_istog=false;
                break;
            }
        }
        
        if(nema_istog)
        {
            matrica.at(red_matrice).push_back(*i);
            matrica.at(red_matrice).push_back(funkcija(*i));
            matrica.resize(matrica.size()+1);
            red_matrice++;
        }
    }
    
    matrica.resize(matrica.size()-1);
    sort(matrica.begin(), matrica.end(), [](const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;a, const vector&lt;typename remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&amp;b)-&gt;bool {return a.at(0)&gt;b.at(0);});
    return matrica;
}

bool ImaLiGaVec(deque&lt;int&gt; dek, int broj) // ovo je moglo i preko find
{
    for(int i = 0 ; i&lt;dek.size(); i++) {
        if(dek.at(i)==broj) return true;
    }
    return false;
}

int SumaCifara (long long int broj)
{
    int suma(0), cifra(0);
    while(broj!=0)
    {
        cifra=broj%10;
        suma+=cifra;
        broj/=10;
    }
    
    return suma;
}

int SumaDjelilaca (long long int broj)
{
    int suma_djelilaca(1);
    if (broj==0) return 0;
    
    broj=abs(broj);
    if(broj!=1) suma_djelilaca+=broj;
  
    
    for(int i=2; i&lt;broj; i++)
        if(broj%i==0) suma_djelilaca+=i;
        
    return suma_djelilaca;
}

bool DaLiJeProst(int n)
{
    if(n==1) return false;
    if(n&lt;=0) return false;
    if(n%2 == 0 &amp;&amp; n != 2 ) return false; //ako je paran sigurno nije prost (osim ako je 2)
    bool prost=true;

    double korijen=sqrt(n); // da ne racuna korijen milion puta unutar petlje

    for(unsigned int i=2; i&lt;=korijen ; i++) {
        if(n%i==0) {
            return false;
        }
    }

    return prost;
}

int BrojSavrsenihDjelilaca (long long int broj)
{
    int broj_savrsenih(0);
    for(int i = 2; i&lt;=broj; i++) // ovdje ne moze korijen jer savrseni budu veliki brojevi
    {
        if(broj%i==0 and i==SumaDjelilaca(i)-i) broj_savrsenih++;
    }
    
    return broj_savrsenih;
}

int BrojProstihFaktora(long long int broj)
{
    int broj_prostih_faktora(0);
    double korijen=sqrt(broj);
    
    for(int i = 2; i&lt;=korijen; i++)
    {
        while(DaLiJeProst(i) and broj%i==0)
        {
            broj_prostih_faktora++;
            broj/=i;
        }
    }
    
    if(broj&gt;1) broj_prostih_faktora++;
    
    return broj_prostih_faktora;
}

template &lt;typename Tip&gt;
void IspisMatrice (Tip matrica)
{
    for(int i=0; i&lt;matrica.size(); i++) {
        for(int j=0; j&lt;(matrica.at(i).size()); j++) {
            cout &lt;&lt; setw(6) &lt;&lt;matrica[i][j]&lt;&lt; " " ;
        }
       if(i!=matrica.size()-1) cout &lt;&lt; endl;
    }
 }

int main () 
{
    int broj_elemenata, broj;
    cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
    cin &gt;&gt; broj_elemenata;
    deque&lt;int&gt; dek1 (1);
    cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
    for(int i=0; i&lt;=broj_elemenata; i++)
    {
        cin &gt;&gt; broj;

        if(!ImaLiGaVec(dek1, broj) and broj!=0) dek1.push_back(broj); // nulu ce uvijek naci kao prvi element
        else if (broj==0) dek1.push_back(0);
    }
    
   dek1.pop_front(); // mice onu nulu sto nam je sluzila da ne bude prazan dek u pocetku
    
   cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
   cin &gt;&gt; broj_elemenata;
   deque&lt;int&gt; dek2 (1);
   cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
   for(int i=0; i&lt;=broj_elemenata; i++)
   {
       cin &gt;&gt; broj;
       if(!ImaLiGaVec(dek2, broj) and broj!=0) dek2.push_back(broj);
       else if (broj==0) dek2.push_back(0);
   }
   
   dek2.pop_front(); 
   
   cout &lt;&lt; "Uvrnuti presjek kontejnera:" &lt;&lt; endl;
   IspisMatrice(UvrnutiPresjek(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), SumaCifara));
   cout &lt;&lt; endl &lt;&lt;"Uvrnuta razlika kontejnera:" &lt;&lt; endl;
   IspisMatrice(UvrnutaRazlika(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), BrojProstihFaktora)); 
   cout &lt;&lt; endl &lt;&lt; "Dovidjenja!";
</font>	return 0;
}</pre>
</body>
</html>
