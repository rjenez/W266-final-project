<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student7977.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student7977.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;type_traits&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

template&lt; typename NekiTip &gt;
NekiTip absulutno(NekiTip n){
	if(n&lt;0){
		n *= (-1);
		return n;
	}
	return n;
}

int f(long long int n){
	if(n == 0) return 0;
	if(n &lt; 1) return absulutno(int(n*10)) + f(n - int(n));
	return absulutno(n%10) + f(n/10);
}

int SumaDjelilaca(long long int n){
	n = absulutno(n);
	int suma_d(n);
	for(int i=1; i&lt;=n/2; i++){
		if(n%i == 0){
			suma_d += i;
		}
	}
	return suma_d;
}

bool DaLiJeProst(int n){
	for(int i=2; i&lt;=n/2; i++){
		if(n%i == 0){
			return false;
		}
	}
	if(n &lt;= 1) return false;
	return true;
}

int BrojProstihFaktora(long long int n){
	int broj_pf(0);
	for(int i=2; i&lt;=n/2; i++){
		if(n%i == 0 &amp;&amp; DaLiJeProst(i)){
			broj_pf++;
			for(int j=2; 1; j++){
				if(n%int(pow(i , j)) == 0){
					broj_pf++;
					continue;
				}
				break;
			}
		}
	}
	if(DaLiJeProst(n)) broj_pf++;
	return broj_pf;
}

bool SavrsenBroj(int n){
	int suma_d(0);
	for(int i=1; i&lt;n; i++){
		if(n%i == 0) suma_d += i;
	}
	if(n == suma_d) return true;
	return false;
}

int BrojSavrsenihDjelilaca(long long int n){
	int broj_sd(0);
	for(int i=1; i&lt;=n; i++){
		if(n%i==0){
			if(SavrsenBroj(i)) broj_sd++;
		}
	}
	return broj_sd;
}

template &lt;typename Kontejner1, typename Kontejner2, typename PovratniTip, typename PrimaciTip&gt;
auto UvrnutiPresjek(Kontejner1 pocetak1, Kontejner1 iza_kraja1, Kontejner1 pocetak2, Kontejner2 iza_kraja2, PovratniTip funkcija(PrimaciTip)) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt; decltype (*pocetak1 + *pocetak2)&gt;::type&gt;&gt; {
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt; decltype (pocetak1[0] + pocetak2[0])&gt;::type&gt;&gt; v;
	auto pom1(pocetak1);
	auto pom2(pocetak2);
	const double Epsilon(0.0000001);
	int br_redova(0);
	
	while(pom1 != iza_kraja1){
		pom2 = pocetak2;
		while(pom2 != iza_kraja2){
			if(absulutno(funkcija(*pom1) - funkcija(*pom2)) &lt; Epsilon){
<a name="0"></a><font color="#FF0000"><a href="match313-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

				br_redova++;
				v.resize(br_redova);
				v[br_redova-1].resize(3);
				v[br_redova-1][0] = *pom1;
				v[br_redova-1][1] = *pom2;
				v[br_redova-1][2] = funkcija(*pom1);
			}
			pom2++;
		}
		pom1++;
</font>	}
	
	if(v.size() &gt; 1){
		std::sort(std::begin(v), std::end(v), 
		[](std::vector&lt;decltype(pocetak1[0]+pocetak2[0])&gt; v, std::vector&lt;decltype(pocetak1[0]+pocetak2[0])&gt; v1){
				const double Epsilon(0.0000001);
				if(absulutno(v1[2] - v[2])&lt;Epsilon){ 
					if(absulutno(v1[0] - v1[0]) &lt; Epsilon){
						return v &lt; v1;
					}
					return v &lt; v1;
				}
				return v[2] &lt; v1[2];
			} );
	}
	return v;
 }

template &lt;typename Kontejner1, typename Kontejner2&gt;
auto UvrnutiPresjek(Kontejner1 pocetak1, Kontejner1 iza_kraja1, Kontejner2 pocetak2, Kontejner2 iza_kraja2) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(pocetak1[0] + pocetak2[0])&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype (pocetak1[0] + pocetak2[0])&gt;::type&gt;&gt; v;
	auto pom1(pocetak1);
	auto pom2(pocetak2);
	int br_redova(0);
	const double Epsilon(0.0000001);
	
	while(pom1 != iza_kraja1){
		pom2 = pocetak2;
		while(pom2 != iza_kraja2){
			if(absulutno(*pom1 - *pom2) &lt; Epsilon){
<a name="1"></a><font color="#00FF00"><a href="match313-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

				br_redova++;
				v.resize(br_redova);
				v[br_redova-1].resize(3);
				v[br_redova-1][0] = *pom1;
				v[br_redova-1][1] = 0;
				v[br_redova-1][2] = 0;
			}
			pom2++;
</font>		}
		pom1++;
	}
	
	if(v.size() &gt; 1){
		std::sort(std::begin(v), std::end(v));
	}
	return v;
}

template &lt;typename Kontejner1, typename Kontejner2, typename PovratniTip, typename PrimaciTip&gt;
auto UvrnutaRazlika(Kontejner1 pocetak1, Kontejner1 iza_kraja1, Kontejner1 pocetak2, Kontejner2 iza_kraja2, PovratniTip funkcija(PrimaciTip)) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt; decltype (*pocetak1 + *pocetak2)&gt;::type&gt;&gt; {
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype (pocetak1[0] + pocetak2[0])&gt;::type&gt;&gt; v;
	auto pom1(pocetak1);
	auto pom2(pocetak2);
	int br_redova(0);
	const double Epsilon(0.000000001);
	while(pom1 != iza_kraja1){
		pom2 = pocetak2;
		while(pom2 != iza_kraja2){
<a name="2"></a><font color="#0000FF"><a href="match313-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

			if(absulutno(funkcija(*pom1) - funkcija(*pom2)) &lt; Epsilon){
				break;
			}
			pom2++;
		}
		if(pom2 == iza_kraja2){
			br_redova++;
			v.resize(br_redova);
			v[br_redova-1].resize(2);
			v[br_redova-1][0] = *pom1;
			v[br_redova-1][1] = funkcija(*pom1);
		}
		pom1++;
</font>	}
	pom1 = pocetak1;
	pom2 = pocetak2;
	
	while(pom2 != iza_kraja2){
		pom1 = pocetak1;
		while(pom1 != iza_kraja1){
<a name="3"></a><font color="#00FFFF"><a href="match313-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

			if(absulutno(funkcija(*pom1) - funkcija(*pom2)) &lt; Epsilon){
				break;
			}
			pom1++;
		}
		if(pom1 == iza_kraja1){
			br_redova++;
			v.resize(br_redova);
			v[br_redova-1].resize(2);
			v[br_redova-1][0] = *pom2;
			v[br_redova-1][1] = funkcija(*pom2);
		}
		pom2++;
</font>	}
	
	if(v.size() &gt; 1){
		std::sort(std::begin(v), std::end(v), 
		[](std::vector&lt;decltype(pocetak1[0]+pocetak2[0])&gt; v, std::vector&lt;decltype(pocetak1[0]+pocetak2[0])&gt; v1){
			const double Epsilon(0.0000001);
			if(absulutno(v1[0] - v[0]) &lt; Epsilon){
				return v1 &lt; v;
			}
			return  v1[0] &lt; v[0];
		});
	}
	return v;
}

template &lt;typename Kontejner1, typename Kontejner2&gt;
auto UvrnutaRazlika(Kontejner1 pocetak1, Kontejner1 iza_kraja1, Kontejner2 pocetak2, Kontejner2 iza_kraja2) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(pocetak1[0] + pocetak2[0])&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype (pocetak1[0] + pocetak2[0])&gt;::type&gt;&gt; v;
	auto pom1(pocetak1);
	auto pom2(pocetak2);
	int br_redova(0);
	const double Epsilon(0.0000001);
	
	while(pom1 != iza_kraja1){
		pom2 = pocetak2;
		while(pom2 != iza_kraja2){
<a name="4"></a><font color="#FF00FF"><a href="match313-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

			if(absulutno(*pom1 - *pom2) &lt; Epsilon) break;
			
			pom2++;
		}
		if(pom2 == iza_kraja2){
			br_redova++;
			v.resize(br_redova);
			v[br_redova-1].resize(2);
			v[br_redova-1][0] = *pom1;
			v[br_redova-1][1] = 0;
		}
		pom1++;
</font>	}
	
	pom1 = pocetak1;
	pom2 = pocetak2;
	
	while(pom2 != iza_kraja2){
		pom1 = pocetak1;
		while(pom1 != iza_kraja1){
<a name="5"></a><font color="#FF0000"><a href="match313-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

			if(absulutno(*pom1 - *pom2) &lt; Epsilon){
				break;
			}
			pom1++;
		}
		if(pom1 == iza_kraja1){
			br_redova++;
			v.resize(br_redova);
			v[br_redova-1].resize(2);
			v[br_redova-1][0] = *pom2;
			v[br_redova-1][1] = 0;
		}
		pom2++;
</font>	}
	
	if(v.size() &gt; 1){
		std::sort(std::begin(v), std::end(v),
		[](std::vector&lt;decltype(pocetak1[0]+pocetak2[0])&gt; v, std::vector&lt;decltype(pocetak1[0]+pocetak2[0])&gt; v1){ return v1 &lt; v; });
	}
	return v;
}

int main ()
{
	std::deque&lt;int&gt; d, d1;
	int duzina, duzina1, broj;
	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	std::cin &gt;&gt; duzina;
	d.resize(duzina);
	std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	
	for(int i=0; i&lt;duzina; i++){
		std::cin &gt;&gt; broj;
		int j;
		for(j=0; j&lt;i; j++){
			if(broj == d[j]) break;
		}
		if(i == j){
			d[i] = broj;
		}else{
			i--;
		}
	}

	std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	std::cin &gt;&gt; duzina1;
	d1.resize(duzina1);
	std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	
	for(int i=0; i&lt;duzina1; i++){
		std::cin &gt;&gt; broj;
		int j;
		for(j=0; j&lt;i; j++){
			if(broj == d1[j]) break;
		}
		if(i == j){ 
			d1[i] = broj;
		}else{
			i--;
		}
	}
	std::cout &lt;&lt; "Uvrnuti presjek kontejnera: " &lt;&lt; std::endl;
	std::vector&lt;std::vector&lt;int&gt;&gt; v{ UvrnutiPresjek(d.begin(), d.end(), d1.begin(), d1.end(), f) };
	
	for(int i=0; i&lt;v.size(); i++){
		for(int j=0; j&lt;v[i].size(); j++){
			std::cout &lt;&lt; std::setw(6) &lt;&lt; v[i][j] &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
	
	std::cout &lt;&lt; "Uvrnuta razlika kontejnera:" &lt;&lt; std::endl;
	std::vector&lt;std::vector&lt;int&gt;&gt; v1{ UvrnutaRazlika(d.begin(), d.end(), d1.begin(), d1.end(), BrojProstihFaktora) };
	for(int i=0; i&lt;v1.size(); i++){
		for(int j=0; j&lt;v1[i].size(); j++){
			std::cout &lt;&lt; std::setw(6) &lt;&lt; v1[i][j] &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
	std::cout &lt;&lt; "Dovidjenja!";

	return 0;
}</pre>
</body>
</html>
