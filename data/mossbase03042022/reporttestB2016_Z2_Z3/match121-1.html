<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student5863.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student3331.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;type_traits&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match121-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

bool Obicni = false;

int SumaCifara(long long int broj) {
	broj = std::labs(broj);
	int suma=0;
	while(broj){
		suma += broj%10;
		broj/=10;
	}
	
	return suma;
}


int SumaDjelilaca(long long int broj){
	broj = std::labs(broj);
	int suma = 0; //suma += broj &lt;broj
	for(int i=1; i&lt;= broj; i++)
	if(broj%i == 0) suma += i;
	
	return suma;
}


int BrojProstihFaktora(long long int broj) {
	broj = std::labs(broj);
	if(broj == 1) return 1;
	int prosti=0;
	
	for(int i=2; i&lt;= broj; i++) {
		if( broj%i == 0 ) {prosti++; broj/=i; i=1; }
	}
	
	return prosti;
}

bool Savrsen(long long int broj) {
	if(broj == 1) return true;
	int suma=0;
	for(int i=1; i&lt;broj; i++){
		if(broj%i == 0) suma+= i;
	}
	if(suma == broj) return true;
	return false;
	
}

int BrojSavrsenihDjelilaca(long long int broj) {
	broj = std::labs(broj);
	int savrseni=0;
	for(int i=2; i&lt;=broj; i++) {
		if(broj%i == 0 &amp;&amp; Savrsen(i)){ savrseni++; broj/=i; i=1; }
	}
		
		return savrseni;
	
}

int ObicniPresjek(long long int jest){
	Obicni = true;
	return jest;
}




template &lt;typename tipPrvog, typename tipDrugog, typename tipUFunkciji=long long int, typename vracenTip=int&gt;
auto UvrnutiPresjek(tipPrvog pocetakP, tipPrvog iza_krajaP, tipDrugog pocetakD, tipDrugog iza_krajaD, vracenTip (*fun)(tipUFunkciji) = ObicniPresjek) -&gt; std::vector&lt;std::vector&lt; decltype(*pocetakP+*pocetakD)&gt;&gt;  {

 std::vector&lt; decltype(*pocetakP+ *pocetakD)&gt; vek;
 std::vector&lt;std::vector&lt; decltype(*pocetakP+*pocetakD)&gt;&gt; matrica;
tipDrugog pomocni = pocetakD;

 
 while(pocetakP != iza_krajaP){
 	pocetakD = pomocni;
 	while (pocetakD != iza_krajaD) {
 		vek.resize(0);
 		if(fun(*pocetakP) == fun(*pocetakD)){ 
 			vek.push_back(*pocetakP);
 			if(Obicni) 	vek.push_back(0);
 			else vek.push_back(*pocetakD);
 			if(Obicni) 	vek.push_back(0);
 			else vek.push_back(fun(*pocetakP));
 			matrica.push_back(vek);
 		
 		}
 		pocetakD++;
 	}
 	pocetakP++;
 }
 
 std::sort(matrica.begin(),matrica.end(), [](const std::vector&lt;decltype(*pocetakP+*pocetakD)&gt; &amp;a, const std::vector&lt;decltype(*pocetakP+*pocetakD)&gt; &amp;b)
 {  if(a[2] != b[2]) return a[2] &lt; b[2];
 	else if(a[2] == b[2] &amp;&amp; a[0] != b[0]) return a[0] &lt; b[0];
 	 return a[1] &lt; b[1];
 });

 
 return matrica;
}



template &lt;typename tipPrvog, typename tipDrugog, typename tipUFunkciji=long long int, typename vracenTip=int&gt;
auto UvrnutaRazlika(tipPrvog pocetakP, tipPrvog iza_krajaP, tipDrugog pocetakD, tipDrugog iza_krajaD, vracenTip (*fun)(tipUFunkciji) = ObicniPresjek) -&gt; std::vector&lt;std::vector&lt;decltype(*pocetakP+ *pocetakD)&gt;&gt;  {
 int vel =0,vel1=0;
 tipDrugog po = pocetakD;
 tipPrvog l = pocetakP;
 while (l != iza_krajaP) {
 	vel1++;
 	l++;
 	
 }

 while (po != iza_krajaD) {
 	vel++;
 	po++;
 	
 } 
 std::vector&lt;decltype(*pocetakP + *pocetakD)&gt; vek;
 std::vector&lt;std::vector&lt;decltype(*pocetakP+ *pocetakD)&gt;&gt; matrica;
tipDrugog pomocni = pocetakD;
tipPrvog pom = pocetakP;

 int brojacRazlictih=0;
 while(pocetakP != iza_krajaP){
 	pocetakD = pomocni;
 	brojacRazlictih = 0;
 	while (pocetakD != iza_krajaD) {
 		vek.resize(0);
 		if(fun(*pocetakP) != fun(*pocetakD)){
 			brojacRazlictih++;
 			if(brojacRazlictih == vel){
 				vek.push_back(*pocetakP);
 				if(Obicni) vek.push_back(0);
 				else vek.push_back(fun(*pocetakP));
 				matrica.push_back(vek);
 			}
 		}
 		pocetakD++;
 	}
    pocetakP++;
 }
 pocetakD = pomocni;
 while(pocetakD != iza_krajaD){
 	pocetakP = pom;
 	brojacRazlictih = 0;
 	while (pocetakP != iza_krajaP) {
 		vek.resize(0);
 		if(fun(*pocetakD) != fun(*pocetakP)){
 			brojacRazlictih++;
 			if(brojacRazlictih == vel1){
 				vek.push_back(*pocetakD);
 				if(Obicni) vek.push_back(0);
 				else vek.push_back(fun(*pocetakD));
 				matrica.push_back(vek);
 			}
 		}
 		pocetakP++;
 	}
    pocetakD++;
 }
 
 
 
 std::sort(matrica.begin(),matrica.end(), [](const std::vector&lt;decltype(*pocetakP+*pocetakD)&gt; &amp;a, const std::vector&lt;decltype(*pocetakP+*pocetakD)&gt; &amp;b)//std::begin(matrica) da moze i niz primit
 {  if(a[0] != b[0]) return a[0] &gt; b[0];
 	 return a[1] &gt; b[1];
 });
 
 
 return matrica;
}

template&lt;typename tip, typename uporedivT&gt;
bool imalVec(tip kolekcija ,uporedivT element  ){
	for(int i=0; i&lt;kolekcija.size(); i++){
		if(kolekcija.at(i) == element) return true;
	}
	return false;
}




int main () 
{
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	int el1,el2;
	int broj;
	std::vector&lt;int&gt; v1,v2;
	std::cin&gt;&gt;el1;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	while (el1) {
		std::cin&gt;&gt;broj;
		if(!imalVec(v1,broj)){
		v1.push_back(broj);
		el1--;
		}
	}
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;el2;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	while(el2){
		std::cin&gt;&gt;broj;
		if(!imalVec(v2,broj)){
		v2.push_back(broj);
		el2--;
		}
	}
	
//	std::vector&lt;std::vector&lt;int&gt;&gt; matrica,mat;
     auto	matrica = UvrnutiPresjek(std::begin(v1), std::end(v1), std::begin(v2), std::end(v2),SumaCifara);
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera: "&lt;&lt;std::endl;
	for(int i=0; i&lt; matrica.size(); i++){
		for(int j=0; j&lt;matrica.at(0).size(); j++)
		std::cout&lt;&lt;std::setw(6)&lt;&lt;matrica.at(i).at(j)&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}
     auto mat = UvrnutaRazlika(std::begin(v1), std::end(v1), std::begin(v2), std::end(v2),BrojProstihFaktora);
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera: "&lt;&lt;std::endl;
	for(int i=0; i&lt; mat.size(); i++){
		for(int j=0; j&lt;mat.at(0).size(); j++)
		std::cout&lt;&lt;std::setw(6)&lt;&lt;mat.at(i).at(j)&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Dovidjenja!";

	
	
	
	return 0;
</font>}</pre>
</body>
</html>
