<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4415.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student8051.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;deque&gt;
// Prije nego sto krenete provjeravati kod, zelim da kazem da je kod "jako mrljavo" i "traljavo" napisan. Kod je napisan u preko 250 linija, mada sam svjestan da se moze puno krace i efikasnije napisati.
bool prost (long long int k)    //	Funkcija koja mi govori da li je broj prost ili ne.
{
	if(k==1)
		return false;
 auto  kor(sqrt(k));
	for(long long int i=2;i&lt;=kor;i++)
		if(k%i==0)
			return false;
	return true;
}
int SumaCifara(long long int n)		//	Funkcija racuna sumu cifara broja koji je poslat kao parametar. 
{
	int s(0);
	while(n!=0)
	{
		s+=abs(n%10);
		n/=10;
	}
	return s;
}
int BrojSavrsenihDjelilaca(long long int f){	//	Funkcija koja salje broj savrsenih djelilaca nekog broja. 
	long long int k(4);
	int  s(0);
	do
	{
		if(prost(k-1))	
		{
			if(f%(k*(k-1)/2)==0)
				s++;
		}
		k*=2;
		
	}while(k&lt;=f);
	return s;
}

int SumaDjelilaca(long long int p){		//	Funkcija koja racuna sumu svih djelilaca nekog broja poslan kao parametar.
	if(p==0)
		return 0;
	if(p==1||p==-1)
		return 1;
	long long int s(abs(p)+1);
	for(long long int i=2;i&lt;=abs(p/2);i++)
	{
		if(p%i==0)
			s+=i;
	}
	return s;
}
int BrojProstihFaktora(long long int f)		//	Sam naziv ove funkcije govori sta se radi.
{
	if(prost(f))
		return 1;
	int s(0);
	long long int k=2,p(f);
	while(k&lt;=abs(f/2))
	{
		if(!prost(k))
		{
			k+=2;
		}
		else{
		while(p%k==0)
		{
			s++;
			p/=k;
			p=abs(p);
		}
		if(k==2)
			k++;
		else
			k+=2;
		p=f;
		}
	}
	return s;
}
template&lt;typename tip,typename tip2, typename tip3,typename tip4&gt;
void Unos(std::vector&lt;tip&gt;&amp;v,tip2 const &amp;a, tip3 const &amp;b,tip4 const  &amp;f)	// Funkcija koja vrsi unos clanova u vektor.
{
	v.push_back(a);
	v.push_back(b);
	v.push_back(f);
}
template&lt;typename tip,typename tip2,typename tip3&gt;	//	Kao i prethodna funkcija, samo sa 2 parametra.
void Unos(std::vector&lt;tip&gt;&amp;v, tip2 const  &amp;a, tip3 const &amp;f)
{
	v.push_back(a);
	v.push_back(f);
}

template &lt;typename tip1, typename tip2,typename tip3, typename tip4&gt;
<a name="2"></a><font color="#0000FF"><a href="match633-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

auto UvrnutiPresjek(tip1 poc1, tip1 kr1, tip2 poc2, tip2 kr2, tip3 f(tip4))-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt;
{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt; v;	//	Matrica v koja se salje kao rezultat. 
	tip1 k1;	// Pokazivaci, odnosno iteratori koji nam sluze za "prolazak" kroz kontenjere koje su nam poslati u funkciju.
	tip2 k2;
</font>	while(poc1!=kr1)
	{
		auto fun(f(*poc1));
		k2=poc2;
		while(k2!=kr2)
		{
			if(f(*k2)==fun)	//	Ukoliko ispunjava uslov, punimo v.
			{
				v.resize(v.size()+1);
				Unos(v.at(v.size()-1),*poc1,*k2,fun);
			}
			k2++;
		}
		poc1++;
	}
	poc1--;
<a name="3"></a><font color="#00FFFF"><a href="match633-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	std::sort(v.begin(),v.end(),[](const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;v1,const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;v2){if(v1.at(2)&lt;v2.at(2)||(v1.at(2)==v2.at(2)&amp;&amp;v1.at(0)&lt;v2.at(0))||(v1.at(2)==v2.at(2)&amp;&amp;v1.at(0)==v2.at(0)&amp;&amp;v1.at(1)&lt;v2.at(1))) return true; else return false; }); //Jedna jaaako duga linija koja nam sluzi za sortiranje.
	return v;
}

template &lt;typename tip1, typename tip2&gt;	//	Genericka funkcija koja nam sluzi ako se pozove i sa 4 parametra.
auto UvrnutiPresjek(tip1 poc1, tip1 kr1, tip2 poc2, tip2 kr2)-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt;
</font><a name="4"></a><font color="#FF00FF"><a href="match633-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt; v;
	tip1 k1;
	tip2 k2;
</font>	while(poc1!=kr1)
	{
		k2=poc2;
		while(k2!=kr2)
		{
			if(*k2==*poc1)
			{
				v.resize(v.size()+1);
				Unos(v.at(v.size()-1),*k2,0,0);
			}
			k2++;
		}
		poc1++;
	}
	std::sort(v.begin(),v.end()); //Obicno sortiranje.
	return v;
}

template&lt;typename tip1, typename tip2,typename tip3, typename tip4&gt;
<a name="5"></a><font color="#FF0000"><a href="match633-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

auto UvrnutaRazlika(tip1 poc1, tip1 kr1, tip2 poc2, tip2 kr2, tip3 f(tip4))-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt;
{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt; v; //	Matrica v u kojoj unosimo trazene vrijednosti.
	tip1 k1(poc1);	//	Analogno prethodnoj funkciji, k1 i k2 su iterator/pokazivaci na elemente kontenjera koji su poslani ovoj generickoj funkciji.
</font>	tip2 k2(poc2);	
	while(k1!=kr1)
	{
		auto p(f(*k1));	//	p je vrijednost elementa iz prvog skupa kroz funkciju. 
		k2=std::find_if(poc2,kr2,[f, p](typename std::remove_reference&lt;decltype(*poc2)&gt;::type a){return f(a)==p;});	//	Trazimo zeljenu vrijednost.
		if(k2==kr2)
		{
			v.resize(v.size()+1);	//	Prosirujemo, pa unosimo.
			Unos(v.at(v.size()-1),*k1,p);
		}
		k1++;
	}
	k2=poc2;
	//Ovdje je isti princip, samo sto gledamo elemente iz drugog skupa sa prvim skupom (prethodno je bilo obrnuto).
	while(k2!=kr2)
	{
		auto p=f(*k2);
		k1=std::find_if(poc1,kr1,[f, p](typename std::remove_reference&lt;decltype(*poc1)&gt;::type a){return f(a)==p;});
		if(k1==kr1)
		{
			v.resize(v.size()+1);
			Unos(v.at(v.size()-1),*k2,f(*k2));
		}
		k2++;
	}
	//	Ovdje sortiramo preko onog zadanog kriterija.
<a name="6"></a><font color="#00FF00"><a href="match633-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	std::sort(v.begin(),v.end(),[](const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;v1,const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;v2){if(v1.at(0)&gt;v2.at(0)||(v1.at(0)==v2.at(0)&amp;&amp;v1.at(1)&gt;v2.at(1))) return true; else return false; });
	return v;
}
template&lt;typename tip1, typename tip2&gt;	//	Analogno kao i prethodna funkcija, samo ako se posalje 4, a ne 5 parametara.
auto UvrnutaRazlika(tip1 poc1, tip1 kr1, tip2 poc2, tip2 kr2)-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt;
</font><a name="7"></a><font color="#0000FF"><a href="match633-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt; v;
	tip1 k1(poc1);
</font>	tip2 k2(poc2);
	while(k1!=kr1)
	{
		k2=std::find(poc2,kr2,*k1);
		if(k2==kr2)
		{
			v.resize(v.size()+1);
			Unos(v.at(v.size()-1),*k1,0);
		}
		k1++;
	}
	k2=poc2;
	while(k2!=kr2)
	{
		k1=std::find(poc1,kr1,*k2);
		if(k1==kr1)
		{
			v.resize(v.size()+1);
			Unos(v.at(v.size()-1),*k2,0);
		}
		k2++;
	}
	std::sort(v.begin(),v.end(),[](const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;v1,const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;v2){return v1.at(0)&gt;v2.at(0);});
	return v;
}

int main ()			//	Obicni main program, koji vrsi unos elemenata u 2 kontenjera i vrsi pozivanje funkcije. Naravno, ne mogu se unijeti "duplikati".
{															
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";		
	int n;
	std::cin&gt;&gt;n;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	std::deque&lt;int&gt; d1,d2;
	int k;
	for(int i=0;i&lt;n;i++)
	{
		std::cin&gt;&gt;k;
		auto p=find(d1.begin(),d1.end(),k);
		if(p==d1.end())
			d1.push_back(k);
		else
			i--;
	}
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;n;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	for(int i=0;i&lt;n;i++)
	{
		std::cin&gt;&gt;k;
		auto p=find(d2.begin(),d2.end(),k);
		if(p==d2.end())
			d2.push_back(k);
		else 
			i--;
	}
	std::vector&lt;std::vector&lt;int&gt;&gt; v1{UvrnutiPresjek(d1.begin(), d1.end(), d2.begin(), d2.end(), SumaCifara)};
	std::vector&lt;std::vector&lt;int&gt;&gt; v2{UvrnutaRazlika(d1.begin(), d1.end(), d2.begin(), d2.end(), BrojProstihFaktora)};
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera: "&lt;&lt;std::endl;
	for (const auto&amp; red : v1)
	{
<a name="0"></a><font color="#FF0000"><a href="match633-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

		for (const auto&amp; broj : red)
			std::cout &lt;&lt;std::setw(6)&lt;&lt; broj &lt;&lt; " ";
		std::cout &lt;&lt; std::endl;
	}
	std::cout &lt;&lt;"Uvrnuta razlika kontejnera: "&lt;&lt; std::endl;
</font>	for (const auto &amp; red : v2)
	{
<a name="1"></a><font color="#00FF00"><a href="match633-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		for (const auto &amp; broj : red)
			std::cout &lt;&lt;std::setw(6)&lt;&lt; broj &lt;&lt; " ";
		std::cout &lt;&lt; std::endl;
	}
	std::cout&lt;&lt;"Dovidjenja!";
</font>	return 0;
}</pre>
</body>
</html>
