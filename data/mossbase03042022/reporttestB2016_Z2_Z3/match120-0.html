<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student3219.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student3219.cpp<p></p><pre>
/*B 16/17, Zadaća 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;deque&gt;
#include &lt;iomanip&gt;

<a name="2"></a><font color="#0000FF"><a href="match120-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_13.gif"/></a>

using namespace std;

template &lt;typename T1,typename T2,typename T3,typename T4&gt;

vector&lt;vector&lt;T3&gt; &gt; UvrnutiPresjek(T1 p1, T1 k1, T2 p2, T2 k2, T3 f(T4)) {
	vector&lt;vector&lt;T3&gt; &gt; mat;
	while(p1!=k1) {
		T2 p=p2;
		while(p!=k2) {
			if(f(*p1) == f(*p)) {
				vector&lt;T3&gt; vec;
				vec.push_back(*p1);
				vec.push_back(*p);
				vec.push_back(f(*p1));
				mat.push_back(vec);
			}
			p++;
		}
		p1++;
	}
	
	(mat.begin(), mat.end(), [](vector&lt;T3&gt; x, vector&lt;T3&gt; y) {
		if(x[2]!=y[2]) return x[2]&lt;y[2]; 
		else if(x[0]!=y[0]) return x[0]&lt;y[0]; 
		else return x[1]&lt;y[1];
</font>	});
	return mat;
	
}
<a name="1"></a><font color="#00FF00"><a href="match120-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_28.gif"/></a>

template &lt;typename P1,typename P2&gt;
auto UvrnutiPresjek(P1 p1, P1 k1, P2 p2, P2 k2) -&gt; vector&lt;vector&lt;decltype(*p1+0)&gt; &gt; {
	vector&lt;vector&lt;decltype(*p1+0)&gt; &gt; mat;						// *p1+0 se može koristiti umjesto remove refference, zato što tipovi s kojima mi radimo podržavaju sabiranje, a reference ne
	P1 p=p1;
	while(p1!=k1) {
		P2 p=p2;
		while(p!=k2) {
			if(*p==*p1) {
				mat.push_back({*p,0,0});
			}
			p++;
		}
		p1++;
	}
	sort(mat.begin(), mat.end(), [](vector&lt;decltype(*p+0)&gt; x,vector&lt;decltype(*p+0)&gt; y) { return x[0]&lt;y[0];});
	return mat;
}

template &lt;typename T1,typename T2,typename T3,typename T4&gt;
vector&lt;vector&lt;T3&gt; &gt; UvrnutaRazlika(T1 p1, T1 k1, T2 p2, T2 k2, T3 f(T4)) {
	
	vector&lt;vector&lt;T3&gt; &gt; mat;
	vector&lt;T3&gt; vec;
	T1 pom1=p1;
	T2 pom2=p2;
	bool ima=false;
	while(pom1!=k1) {
		ima=false;
		pom2=p2;
		while(pom2!=k2) {
			if(f(*pom1) == f(*pom2)) ima=true;
			pom2++;
		}
		if(!ima) {
			vec.push_back(*pom1);
			vec.push_back(f(*pom1));
			mat.push_back(vec);
			vec.resize(0);
		}
		pom1++;
	}
	pom1=p1; pom2=p2;
	while(pom2!=k2) {
		ima=false;
		pom1=p1;
		while(pom1!=k1) {
			if(f(*pom1) == f(*pom2)) ima=true;
				
			pom1++;
		}
		if(!ima) {
			vec.push_back(*pom2);
			vec.push_back(f(*pom2));
			mat.push_back(vec);
			vec.resize(0);
		}
		pom2++;
	}
	sort(mat.begin(), mat.end(), [](vector&lt;T3&gt; a, vector&lt;T3&gt; b) {if(a[0]!=b[0]) return a[0]&gt;b[0]; else return a[1]&gt;b[1]; });
</font>	return mat;
}
<a name="0"></a><font color="#FF0000"><a href="match120-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_54.gif"/></a>

template &lt;typename T1, typename T2&gt;

auto UvrnutaRazlika(T1 p1, T1 k1, T2 p2, T2 k2) -&gt; vector&lt;vector&lt;decltype(*p1+0)&gt; &gt; {
	vector&lt;vector&lt;decltype(*p1+0)&gt; &gt; mat;						// *p1+0 se može koristiti umjesto remove refference, zato što tipovi s kojima mi radimo podržavaju sabiranje, a reference ne
	T1 pom1=p1;
	T2 pom2=p2;
	while(pom1!=k1) {
		pom2=p2;
		bool nema=true;
		while(pom2!=k2) {
			if(*pom1==*pom2) nema=false;
			
			pom2++;	
		}
		if(nema) {
			mat.push_back({*pom1,0});
		}
		pom1++;
	}
	pom1=p1; pom2=p2;
	while(pom2!=k2) {
		pom1=p1;
		bool nema=true;
		while(pom1!=k1) {
			if(*pom1==*pom2) nema=false;
			
			pom1++;	
		}
		if(nema) {
			mat.push_back({*pom2,0});
		}
		pom2++;
	}
	sort(mat.begin(), mat.end(), [](vector&lt;decltype(*p1+0)&gt;  x, vector&lt;decltype(*p1+0)&gt;  y) { return x[0]&gt;y[0];});
	return mat;
}

int SumaDjelilaca(long long int broj) {
	int suma=0;
	if(broj&lt;0) broj=-broj;
	for(int i(1);i&lt;=broj;i++){
		if(broj%i==0) suma+=i;
	}
	return suma;
}

int BrojProstihFaktora(long long int broj) {
	int brojac=0;
	while(broj&gt;=2) {
		for(int i(2);i&lt;=broj;i++) {
			if(broj%i==0) {
				brojac++;
				broj/=i;
				break;
			}
		}
	}
	return brojac;
}
bool SavrsenBroj(long long int broj) {
	long long int suma=0;
	for(int i(1);i&lt;broj;i++) {
		if(broj%i==0) suma+=i;
	}
	return (suma==broj);
}
int BrojSavrsenihDjelilaca(long long int broj) {
	int brojac=0;
	for(int i(2);i&lt;=broj;i++) {
		if(broj%i==0) {
			if(SavrsenBroj(i)) brojac++;
		}
	}
	return brojac;
}

int SumaCifara(long long int broj) {
	int suma=0;
	while(broj!=0) {
		suma+=(broj%10);
		broj=broj/10;
	}
	return suma;
}

int main ()
{
	cout&lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	int n; cin&gt;&gt;n;
	cout&lt;&lt; "Unesite elemente prvog kontejnera: ";
	deque&lt;int&gt; dek;
	int i=0,k;
	
	while(i&lt;n) {
		cin&gt;&gt; k;
		bool ima=false;
		for(int j(0);j&lt;dek.size();j++) {
			if (dek[j]==k) ima=true;
		}
		if(!ima) { dek.push_back(k); i++; }
		
	}
	
	cout&lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	int n1;
	cin&gt;&gt;n1;
	cout&lt;&lt; "Unesite elemente drugog kontejnera: ";
	deque&lt;int&gt; dek1;
	i=0;
	
	while(i&lt;n1) {
		cin&gt;&gt; k;
		bool ima=false;
		for(int j(0);j&lt;dek1.size();j++) {
			if (dek1[j]==k) ima=true;
		}
		if(!ima) { dek1.push_back(k); i++; }
	}
	
	cout &lt;&lt; "Uvrnuti presjek kontejnera:\n";
	vector&lt;vector&lt;int&gt; &gt; mat;
	mat=UvrnutiPresjek(dek.begin(),dek.end(),dek1.begin(),dek1.end(),SumaCifara);
	for(int i(0);i&lt;mat.size();i++) {
		for(int j(0);j&lt;mat[i].size();j++) {
			cout &lt;&lt; setw(6) &lt;&lt; mat[i][j]&lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
	cout &lt;&lt; "Uvrnuta razlika kontejnera:\n";
	vector&lt;vector&lt;int&gt; &gt; mat1;
	mat1=UvrnutaRazlika(dek.begin(),dek.end(),dek1.begin(),dek1.end(),BrojProstihFaktora);
	for(int i(0);i&lt;mat1.size();i++) {
		for(int j(0);j&lt;mat1[i].size();j++) {
			cout &lt;&lt; setw(6) &lt;&lt; mat1[i][j]&lt;&lt;" " ;
		}
		cout&lt;&lt; endl;
	}
	cout &lt;&lt; "Dovidjenja!";
</font>	return 0;
}</pre>
</body>
</html>
