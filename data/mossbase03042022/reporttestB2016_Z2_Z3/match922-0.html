<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2513.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2513.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: i javni ATo-vi su dio postavke

	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba

*/
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
using namespace std;


template &lt;typename tip&gt;
<a name="5"></a><font color="#FF0000"><a href="match922-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

auto vratiIsto(tip param) -&gt; decltype(param)
{
	return param;
}

//Funkcija uvrnuti presjek sa pet parametara
template &lt;typename itip1, typename itip2, typename ftip&gt;
auto UvrnutiPresjek(itip1 poc1, itip1 kraj1, itip2 poc2, itip2 kraj2, ftip fun = vratiIsto) -&gt; vector&lt;vector&lt;decltype(*poc1 + *poc1)&gt;&gt; {
</font>	vector&lt;vector&lt;decltype(*poc1 + *poc1)&gt;&gt; matrica;
	while(poc1 != kraj1) {
		auto walker = poc2;
		while(walker != kraj2) {

			if(fun(*poc1) == fun(*walker)) {
				matrica.push_back(vector&lt;decltype(*poc1 + *poc1)&gt; {*poc1, *walker, fun(*poc1)});
			}
			walker++;
		}
		poc1++;
	}
	sort(matrica.begin(), matrica.end(), [](vector&lt;decltype(*poc1 + *poc1)&gt; v1, vector&lt;decltype(*poc1 + *poc1)&gt; v2) {
		if(v1[2] != v2[2]) return v1[2] &lt; v2[2];
		if(v1[0] != v2[0]) return v1[0] &lt; v2[0];
		return v1[1] &lt; v2[1];
	});
	return matrica;
}

//Funkcija uvrnuti presjek sa cetiri parametra
template &lt;typename itip1, typename itip2&gt;
auto UvrnutiPresjek(itip1 poc1, itip1 kraj1, itip2 poc2, itip2 kraj2) -&gt; vector&lt;vector&lt;decltype(*poc1 + *poc1)&gt;&gt; {
	vector&lt;vector&lt;decltype(*poc1 + *poc1)&gt;&gt; matrica;
	while(poc1 != kraj1) {
		auto walker = poc2;
		while(walker != kraj2) {

			if(*poc1 == *walker) {
				matrica.push_back(vector&lt;decltype(*poc1 + *poc1)&gt; {*poc1, 0, 0});
			}
			walker++;
		}
		poc1++;
	}
	sort(matrica.begin(), matrica.end(), [](vector&lt;decltype(*poc1 + *poc1)&gt; v1, vector&lt;decltype(*poc1 + *poc1)&gt; v2) {
		if(v1[2] != v2[2]) return v1[2] &lt; v2[2];
		if(v1[0] != v2[0]) return v1[0] &lt; v2[0];
		return v1[1] &lt; v2[1];
	});
	return matrica;
}

//Uvrnuta razlika sa pet parametara
template &lt;typename itip1, typename itip2, typename ftip&gt;
auto UvrnutaRazlika(itip1 poc1, itip1 kraj1, itip2 poc2, itip2 kraj2, ftip fun = vratiIsto) -&gt; vector&lt;vector&lt;decltype(*poc1 + *poc1)&gt;&gt; {
<a name="0"></a><font color="#FF0000"><a href="match922-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

	vector&lt;vector&lt;decltype(*poc1 + *poc1)&gt;&gt; matrica;
	auto walker1 = poc1;
	while(walker1 != kraj1) {
		bool nemapara = true;
		auto walker2 = poc2;
		while(walker2 != kraj2) {
			if(fun(*walker1) == fun(*walker2)) {
				nemapara = false;
				break;
			}
			walker2++;
		}
		if(nemapara) {
</font>			matrica.push_back(vector&lt;decltype(*poc1 + *poc1)&gt; {*walker1, fun(*walker1)});
		}
		walker1++;
	}

<a name="2"></a><font color="#0000FF"><a href="match922-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	auto walker2 = poc2;
	while(walker2 != kraj2) {
		bool nemapara = true;
		auto walker1 = poc1;
		while(walker1 != kraj1) {
			if(fun(*walker2) == fun(*walker1)) {
				nemapara = false;
				break;
			}
			walker1++;
		}
		if(nemapara) {
</font>			matrica.push_back(vector&lt;decltype(*poc1 + *poc1)&gt; {*walker2, fun(*walker2)});
		}
		walker2++;
	}
	sort(matrica.begin(), matrica.end(), [](vector&lt;decltype(*poc1 + *poc1)&gt; v1, vector&lt;decltype(*poc1 + *poc1)&gt; v2) {
		if(v1[0] != v2[0]) return v1[0] &gt; v2[0];
		return v1[1] &gt; v2[1];
	});
	return matrica;
}

//uvrnuta razlika sa cetiri parametra
template &lt;typename itip1, typename itip2&gt;
auto UvrnutaRazlika(itip1 poc1, itip1 kraj1, itip2 poc2, itip2 kraj2) -&gt; vector&lt;vector&lt;decltype(*poc1 + *poc1)&gt;&gt; {
<a name="1"></a><font color="#00FF00"><a href="match922-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	vector&lt;vector&lt;decltype(*poc1 + *poc1)&gt;&gt; matrica;
	auto walker1 = poc1;
	while(walker1 != kraj1) {
		bool nemapara = true;
		auto walker2 = poc2;
		while(walker2 != kraj2) {
			if(*walker1 == *walker2) {
				nemapara = false;
				break;
			}
			walker2++;
		}
		if(nemapara) {
			matrica.push_back(vector&lt;decltype(*poc1 + *poc1)&gt; {*walker1, 0});
</font>		}
		walker1++;
	}

<a name="3"></a><font color="#00FFFF"><a href="match922-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	auto walker2 = poc2;
	while(walker2 != kraj2) {
		bool nemapara = true;
		auto walker1 = poc1;
		while(walker1 != kraj1) {
			if(*walker2 == *walker1) {
				nemapara = false;
				break;
			}
			walker1++;
		}
		if(nemapara) {
			matrica.push_back(vector&lt;decltype(*poc1 + *poc1)&gt; {*walker2, 0});
</font>		}
		walker2++;
	}
	sort(matrica.begin(), matrica.end(), [](vector&lt;decltype(*poc1 + *poc1)&gt; v1, vector&lt;decltype(*poc1 + *poc1)&gt; v2) {
		if(v1[0] != v2[0]) return v1[0] &gt; v2[0];
		return v1[1] &gt; v2[1];
	});
	return matrica;
}


//FUNKCIJE
int SumaDjelilaca(long long int broj)
{
	int suma {0};
	for(int i {1}; i &lt;= broj; i++) {
		if(broj % i == 0) {
			suma += i;
		}
	}
	return suma;
}

int BrojProstihFaktora(long long int n)
{
	int brojac {0};
	bool prosti_faktor;
	for(int i = 2; i &lt;= n; i++) {
		prosti_faktor = true;
		if(n%i != 0) continue;
		for(int j = 2; j &lt; i; j++) {
			if(i%j == 0) {
				prosti_faktor = false;
				break;
			}
		}
		if(prosti_faktor)
		{
			while(n%i == 0)
			{
				brojac++;
				n /= i;
			}
		}
	}
	return brojac;
}

bool DaLiJeSavrsen(long long int n)
{
	long long int suma {0};
<a name="4"></a><font color="#FF00FF"><a href="match922-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

	for(long long int i {1}; i &lt; n; i++) {
		if(n % i == 0) {
			suma += i;
		}
	}
	if(n == suma) return true;
	return false;
}
int BrojSavrsenihDjelilaca(long long int n)
</font>{
	int brojac {0};
	for(long long int i {1}; i &lt;= n; i++) {
		if(n % i == 0 &amp;&amp; (DaLiJeSavrsen(i) == true)) {
			brojac++;
		}
	}
	return brojac;
}
bool DaLiJeuDeku(deque&lt;int&gt; dek, int n)
{
	for(int i {0}; i &lt; dek.size(); i++) {
		if(dek[i] == n) return true;
	}
	return false;
}

int SumaCifri(long long int n)
{
	int suma {0};
	while(n != 0) {
		suma += abs(n%10);
		n/=10;
	}
	return suma;
}

int main ()
{
	int n, m;
	cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	cin &gt;&gt; n;
	deque&lt;int&gt; dek1;
	cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	int broj;
	for(int i {0}; i &lt; n; i++) {
		cin &gt;&gt; broj;
		if(DaLiJeuDeku(dek1, broj) == true) {
			i--;
			continue;
		} 
		else dek1.push_back(broj);
	}

	cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	cin &gt;&gt; m;
	deque&lt;int&gt; dek2;
	cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	for(int i {0}; i &lt; m; i++) {
		cin &gt;&gt; broj;
		if(DaLiJeuDeku(dek2, broj) == true) {
			i--;
			continue;
		} 
		else dek2.push_back(broj);
	}

	auto presjek = UvrnutiPresjek(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), SumaCifri);

	cout &lt;&lt; "Uvrnuti presjek kontejnera: " &lt;&lt; endl;
	for(int i {0}; i &lt; presjek.size(); i++) {
		for(int j {0}; j &lt; presjek[i].size(); j++)
			cout &lt;&lt; setw(6) &lt;&lt; presjek[i][j] &lt;&lt; " ";
		cout &lt;&lt; endl;
	}

	auto razlika = UvrnutaRazlika(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), BrojProstihFaktora);
	cout &lt;&lt; "Uvrnuta razlika kontejnera: " &lt;&lt; endl;
	for(int i {0}; i &lt; razlika.size(); i++) {
		for(int j {0}; j &lt; razlika[i].size(); j++)
			cout &lt;&lt; setw(6) &lt;&lt; razlika[i][j] &lt;&lt; " ";
		cout &lt;&lt; endl;
	}
	cout &lt;&lt; "Dovidjenja!";
	return 0;
}
</pre>
</body>
</html>
