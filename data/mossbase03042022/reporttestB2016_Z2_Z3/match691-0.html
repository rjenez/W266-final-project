<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4377.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4377.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;deque&gt;
#include &lt;iomanip&gt;

int SumaDjelilaca(int n)
{
	int suma(0);
	if(n&lt;0) n*=-1;
	for(int i = n; i&gt;0; i--) if(n%i==0) suma+=i;
	return suma;
}

int BrojSavrsenihDjelilaca(int n)
{
	int brojac(0);
	if(n&lt;0) n*=-1;
	for(int i=2; i&lt;=n; i++)
	{
		if(n % i == 0)
		{
			if(i == (SumaDjelilaca(i)-i))
			{
				brojac++;
			}
		}
	}
	return brojac;
}

int SumaCifara(int n)
{
	int suma(0);
	while(n!=0)
	{
		suma += n%10;
		n/=10;
	}
	return suma;
}

int BrojProstihFaktora(int n)
{
	int brojac(0);
	while (n%2==0)
	{
		brojac++;
		n/=2;
	}
	
	for(int i=3; i&lt;n; i+=2)
	while(n%i == 0)
	{
		brojac++;
		n/=i;
	}
	
	if(n&gt;2) brojac++;
	
	return brojac;
}

int Parno(int n)
{
	if(n%2 == 0) return 1;
	return 0;
}

template &lt;typename Tip, typename Tip2, typename FTip, typename ArgTip&gt;
auto UvrnutiPresjek(Tip a1, Tip a2, Tip2 b1, Tip2 b2, FTip f(ArgTip)) -&gt; std::vector&lt;std::vector&lt;ArgTip&gt;&gt;
{
	Tip ca1(a1);  // Kopije pokazivaca
	Tip2 cb1(b1);
	
	std::vector&lt;std::vector&lt;ArgTip&gt;&gt; matrica;
	int i(0);
	while(a1 != a2)
	{
		while(b1 != b2)
		{
			if(f(*a1) == f(*b1)) 
			{
				matrica.resize(matrica.size()+1);
				matrica[i].resize(3);
<a name="1"></a><font color="#00FF00"><a href="match691-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

				matrica[i][0] = *a1;
				matrica[i][1] = *b1;
				matrica[i][2] = f(*a1);
				i++;
			}
			b1++;
		}
		b1 = cb1;
</font>		a1++;
	}
	a1 = ca1;
	
	std::sort(matrica.begin(), matrica.end(), [] (std::vector&lt;ArgTip&gt; x, std::vector&lt;ArgTip&gt; y) { if(x[2] == y[2]) if(x[0] == y[0]) return x[1] &lt; y[1]; else return x[0] &lt; y[0]; return x[2] &lt; y[2];});
	return matrica;
}

template &lt;typename Tip, typename Tip2&gt;
auto UvrnutiPresjek(Tip a1, Tip a2, Tip2 b1, Tip2 b2) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*a1)&gt;::type&gt;&gt;
{
	Tip ca1(a1);  // Kopije pokazivaca
	Tip2 cb1(b1);
	
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*a1)&gt;::type&gt;&gt; matrica;
	int i(0);
	while(a1 != a2)
	{
		while(b1 != b2)
		{
			if(*a1 == *b1) 
			{
				matrica.resize(matrica.size()+1);
				matrica[i].resize(3);
<a name="0"></a><font color="#FF0000"><a href="match691-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

				matrica[i][0] = *a1;
				matrica[i][1] = 0;
				matrica[i][2] = 0;
				i++;
			}
			b1++;
		}
		b1 = cb1;
</font>		a1++;
	}
	a1 = ca1;
	
	std::sort(matrica.begin(), matrica.end(), [] (std::vector&lt;typename std::remove_reference&lt;decltype(*a1)&gt;::type&gt; x, std::vector&lt;typename std::remove_reference&lt;decltype(*a1)&gt;::type&gt; y) { if(x[2] == y[2]) if(x[0] == y[0]) return x[1] &lt; y[1]; else return x[0] &lt; y[0]; return x[2] &lt; y[2];});
	return matrica;
}

template &lt;typename Tip, typename Tip2, typename FTip, typename ArgTip&gt;
auto UvrnutaRazlika(Tip a1, Tip a2, Tip2 b1, Tip2 b2, FTip f(ArgTip)) -&gt; std::vector&lt;std::vector&lt;ArgTip&gt;&gt;
{
	Tip ca1(a1);  // Kopije pokazivaca
	Tip2 cb1(b1);
	
	bool ima_par (false);
	int i(0);
	std::vector&lt;std::vector&lt;ArgTip&gt;&gt; matrica;
	while(a1 != a2)
	{
		ima_par = false;
		while(b1 != b2)
		{
			if(f(*a1) == f(*b1)) 
			{
				ima_par = true;
				break;
			}
			b1++;
		}
		
		if(!ima_par)
		{
			matrica.resize(matrica.size()+1);
			matrica[i].resize(2);
<a name="2"></a><font color="#0000FF"><a href="match691-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

			matrica[i][0] = *a1;
			matrica[i][1] = f(*a1);
			i++;
		}
		
		b1 = cb1;
		a1++;
	}
	a1 = ca1;
	
	
	
	//-------------------------------------------------------------------
	ima_par = false;
</font>	while(b1 != b2)
	{
		ima_par = false;
		while(a1 != a2)
		{
			if(f(*a1) == f(*b1)) 
			{
				ima_par = true;
				break;
			}
			a1++;
		}
		
		if(!ima_par)
		{
			matrica.resize(matrica.size()+1);
			matrica[i].resize(2);
<a name="4"></a><font color="#FF00FF"><a href="match691-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

			matrica[i][0] = *b1;
			matrica[i][1] = f(*b1);
			i++;
		}
		
		a1 = ca1;
		b1++;
</font>	}
	b1 = cb1;
	
	
	std::sort(matrica.begin(), matrica.end(), [] (std::vector&lt;ArgTip&gt; x, std::vector&lt;ArgTip&gt; y) { if(x[0] == y[0]) return x[1] &gt; y[1]; return x[0] &gt; y[0];});
	return matrica;
}

template &lt;typename Tip, typename Tip2&gt; // Kad je podrazumjevana - preklapanje
auto UvrnutaRazlika(Tip a1, Tip a2, Tip2 b1, Tip2 b2) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*a1)&gt;::type&gt;&gt;
{
	Tip ca1(a1);  // Kopije pokazivaca
	Tip2 cb1(b1);
	
	bool ima_par (false);
	int i(0);
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*a1)&gt;::type&gt;&gt; matrica;
	while(a1 != a2)
	{
		ima_par = false;
		while(b1 != b2)
		{
			if(*a1 == *b1) 
			{
				ima_par = true;
				break;
			}
			b1++;
		}
		
		if(!ima_par)
		{
			matrica.resize(matrica.size()+1);
			matrica[i].resize(2);
<a name="3"></a><font color="#00FFFF"><a href="match691-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			matrica[i][0] = *a1;
			matrica[i][1] = 0;
			i++;
		}
		
		b1 = cb1;
		a1++;
	}
	a1 = ca1;
	
	
	
	//-------------------------------------------------------------------
	ima_par = false;
</font>	while(b1 != b2)
	{
		ima_par = false;
		while(a1 != a2)
		{
			if(*a1 == *b1) 
			{
				ima_par = true;
				break;
			}
			a1++;
		}
		
		if(!ima_par)
		{
			matrica.resize(matrica.size()+1);
			matrica[i].resize(2);
<a name="5"></a><font color="#FF0000"><a href="match691-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

			matrica[i][0] = *b1;
			matrica[i][1] = 0;
			i++;
		}
		
		a1 = ca1;
		b1++;
</font>	}
	b1 = cb1;
	
	
	std::sort(matrica.begin(), matrica.end(), [] (std::vector&lt;typename std::remove_reference&lt;decltype(*a1)&gt;::type&gt; x, std::vector&lt;typename std::remove_reference&lt;decltype(*a1)&gt;::type&gt; y) { if(x[0] == y[0]) return x[1] &gt; y[1]; return x[0] &gt; y[0];});
	return matrica;
}


int main2 ()
{
	std::cout &lt;&lt; BrojProstihFaktora(123456) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(56789) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(12121281) &lt;&lt; " ";
std::cout &lt;&lt; BrojProstihFaktora(4512698) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(202248) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(181287) &lt;&lt; " ";
std::cout &lt;&lt; BrojProstihFaktora(45698) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(2048) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(8128);
	
	return 0;
}

int main()
{
	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	int br1;
	std::cin &gt;&gt; br1;
	std::deque&lt;int&gt; kont1(br1);
	int broj;
	std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	for(int i=0; i&lt;br1; i++)
	{
		bool logika (false);
		std::cin &gt;&gt; broj;
		for(auto j:kont1)
		{
			if(j == broj)
			{
				i--;
				logika = true;
				break;
			}
		}
<a name="6"></a><font color="#00FF00"><a href="match691-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if(!logika) kont1[i] = broj;
	}
	
	std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	std::cin &gt;&gt; br1;
	std::deque&lt;int&gt; kont2(br1);
</font>	std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	for(int i=0; i&lt;br1; i++)
	{
		bool logika (false);
		std::cin &gt;&gt; broj;
		for(auto j:kont2)
		{
			if(j == broj)
			{
				i--;
				logika = true;
				break;
			}
		}
		if(!logika) kont2[i] = broj;
		
	}
	
	
	
	std::cout &lt;&lt; "Uvrnuti presjek kontejnera: \n";
	std::vector&lt;std::vector&lt;int&gt;&gt; m{UvrnutiPresjek(kont1.begin(), kont1.end(), kont2.begin(), kont2.end(), SumaCifara)};
	
	
	for(auto red : m) 
 	{
 		for(auto x : red) std::cout &lt;&lt; std::right &lt;&lt; std::setw(6) &lt;&lt; x &lt;&lt; " ";
 		std::cout &lt;&lt; std::endl;
 	}
 	
 	std::cout &lt;&lt; "Uvrnuta razlika kontejnera: \n";
	std::vector&lt;std::vector&lt;int&gt;&gt; m2{UvrnutaRazlika(kont1.begin(), kont1.end(), kont2.begin(), kont2.end(), BrojProstihFaktora)};
	
	
	for(auto red : m2) 
 	{
 		for(auto x : red) std::cout &lt;&lt; std::right &lt;&lt; std::setw(6) &lt;&lt; x &lt;&lt; " ";
 		std::cout &lt;&lt; std::endl;
 	}
 	
 	std::cout &lt;&lt; std::endl &lt;&lt; "Dovidjenja!";
 	
	return 0;
}</pre>
</body>
</html>
