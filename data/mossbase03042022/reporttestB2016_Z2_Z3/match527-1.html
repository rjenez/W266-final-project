<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student8957.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4647.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

int SumaDjelilaca (long long int broj) {
	int brojac=0;
	for(long long int i=1; i&lt;=abs(broj); i++) {
		if (abs(broj)%i==0) brojac=brojac+i;
	}
	return brojac;
}

std::vector&lt;long long int&gt; prosti(long long int br) {
	long long int broj=abs(br);
	std::vector&lt;long long int&gt; v;
	for(long long int i=2; i&lt;=broj; i++){
		int m=1;
		for(long long int j=2; j&lt;std::sqrt(i); j++){
			if(i%j==0) m=0; break;
		}
		if(m!=0) v.push_back(i);
	}
	return v;
}
int BrojProstihFaktora (long long int b) {
	long long int broj=abs(b);
	int br=0;
	std::vector&lt;long long int&gt; v=prosti(broj);
	for(long long int m=0; m&lt;v.size(); m++) {
		while(broj%v[m]==0 ) {br++; broj=broj/v[m];}
	}
	return br;
}

bool savrsen(long long int br){
	long long int broj=abs(br);
	long long int suma=0;
	for(long long int i=1; i&lt;broj; i++) {
		if(broj%i==0) suma=suma+i;
	}
	if(suma==broj) return true;
	else return false;
}
int BrojSavrsenihDjelilaca (long long int br) {
	long long int broj=abs(br);
	int brojac=0;    
	for(long long int i=1; i&lt;=broj; i++) {
		if (broj%i==0 &amp;&amp; savrsen(i)==true) {
			brojac++;
		}
	}
	return brojac;
}

int SumaCifara (long long int br) {
	long long int broj=abs(br);
	int suma=0;
	while(broj!=0) {
		int cifra=broj%10;
		broj=broj/10;
		suma=suma+cifra;
	}
	return suma;
}
template &lt;typename itertip1, typename itertip2, typename fun_tip&gt;
std::vector&lt;std::vector&lt;int&gt;&gt; UvrnutiPresjek (itertip1 poc1, itertip1 kraj1, itertip2 poc2, itertip2 kraj2, fun_tip f) {
	std::vector&lt;std::vector&lt;int&gt;&gt; matrica/*(1, std::vector&lt;int&gt;(3))*/;
	int red=0;
	itertip2 p=poc2;
	while (poc1!=kraj1) {
		poc2=p;
		while(poc2!=kraj2) {
			if(f(abs(*poc1))==f(abs(*poc2))) {
				matrica.resize(red+1);
<a name="0"></a><font color="#FF0000"><a href="match527-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

				matrica[red].resize(3);
				matrica[red][0]=*poc1;
				matrica[red][1]=*poc2;
				matrica[red][2]=f(*poc1);
				red++;
			}
			poc2++;
		}
		poc1++;
	}
	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;int&gt; p1, std::vector&lt;int&gt; p2){
</font>		if(p1[2]==p2[2]) {
			if(p1[0]==p2[0]) {if(p1[1]&lt;p2[1]) return true;}
			return(p1[0]&lt;p2[0]);}
			return(p1[2]&lt;p2[2]);
	});
	return matrica;
}

template &lt;typename itertip1, typename itertip2&gt;
auto UvrnutiPresjek (itertip1 poc1, itertip1 kraj1, itertip2 poc2, itertip2 kraj2) -&gt;std::vector&lt;std::vector&lt;decltype((*poc1+0))&gt;&gt;{
	std::vector&lt;std::vector&lt;decltype((*poc1+0))&gt;&gt;  matrica;
	int red=0;
	itertip2 p=poc2;
	while (poc1!=kraj1) {
		poc2=p;
		while(poc2!=kraj2) {
			if(*poc1==*poc2) {
				matrica.resize(red+1);
<a name="2"></a><font color="#0000FF"><a href="match527-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

				matrica[red].resize(3);
				matrica[red][0]=*poc1;
				matrica[red][1]=0;
				matrica[red][2]=0;
				red++;
			}
			poc2++;
		}
		poc1++;
</font>	}
	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;int&gt; p1, std::vector&lt;int&gt; p2){
			return(p1[0]&lt;p2[0]);
	});
	return matrica;
}

template &lt;typename itertip1, typename itertip2, typename fun_tip&gt;
std::vector&lt;std::vector&lt;int&gt;&gt; UvrnutaRazlika(itertip1 poc1, itertip1 kraj1, itertip2 poc2, itertip2 kraj2, fun_tip f) {
	std::vector&lt;std::vector&lt;int&gt;&gt; matrica;
	int red=0;
	bool a=false;
	itertip2 p2=poc2;
	itertip1 p1=poc1;
	while (poc1!=kraj1) {
		poc2=p2;
		while(poc2!=kraj2) {
			if(f(abs(*poc1))==f(abs(*poc2))) a=true;
			poc2++;
		}
		if(a==false) {
			matrica.resize(red+1);
<a name="3"></a><font color="#00FFFF"><a href="match527-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			matrica[red].resize(2);
			matrica[red][0]=*poc1;
			matrica[red][1]=f(*poc1);
			red++;
</font>			
		}
		a=false;
		poc1++;
	}
	bool b=false;
	poc1=p1;
	poc2=p2;
	while (poc2!=kraj2) {
		poc1=p1;
		while(poc1!=kraj1) {
			if(f(abs(*poc1))==f(abs(*poc2))) b=true;
			poc1++;
		}
		if(b==false) {
			matrica.resize(red+1);
<a name="4"></a><font color="#FF00FF"><a href="match527-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

			matrica[red].resize(2);
			matrica[red][0]=*poc2;
			matrica[red][1]=f(*poc2);
			red++;
</font>		}
		b=false;
		poc2++;
	}
	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;int&gt; p1, std::vector&lt;int&gt; p2){
		if(p1[0]==p2[0]) {
			return(p1[1]&gt;p2[1]);}
			return(p1[0]&gt;p2[0]);
	});
	return matrica;
}

template &lt;typename itertip1, typename itertip2&gt;
auto UvrnutaRazlika (itertip1 poc1, itertip1 kraj1, itertip2 poc2, itertip2 kraj2) -&gt;std::vector&lt;std::vector&lt;decltype((*poc1)+(*poc1))&gt;&gt;{
	std::vector&lt;std::vector&lt;decltype((*poc1)+(*poc1))&gt;&gt; matrica;
	int red=0;
	bool a=false;
	itertip2 p2=poc2;
	itertip1 p1=poc1;
	while (poc1!=kraj1) {
		poc2=p2;
		while(poc2!=kraj2) {
			if((*poc1)==(*poc2)) a=true;
			poc2++;
		}
		if(a==false) {
			matrica.resize(red+1);
<a name="5"></a><font color="#FF0000"><a href="match527-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

			matrica[red].resize(2);
			matrica[red][0]=*poc1;
			matrica[red][1]=0;
			red++;
</font>			
		}
		a=false;
		poc1++;
	}
	bool b=false;
	poc1=p1;
	poc2=p2;
	while (poc2!=kraj2) {
		poc1=p1;
		while(poc1!=kraj1) {
			if(*poc1==*poc2) b=true;
			poc1++;
		}
		if(b==false) {
			matrica.resize(red+1);
<a name="6"></a><font color="#00FF00"><a href="match527-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

			matrica[red].resize(2);
			matrica[red][0]=*poc2;
			matrica[red][1]=0;
			red++;
</font>		}
		b=false;
		poc2++;
	}
<a name="1"></a><font color="#00FF00"><a href="match527-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	std::sort(matrica.begin(), matrica.end(), [](std::vector&lt;int&gt; p1, std::vector&lt;int&gt; p2){
			return(p1[0]&gt;p2[0]);
	});
	return matrica;
}

int main ()
{
	int n1;
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	std::cin&gt;&gt;n1;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	std::deque&lt;int&gt; dek1;
</font>	dek1.resize(n1);
	for(int i=0; i&lt;n1; i++) {
		std::cin&gt;&gt;dek1[i];
		for(int j=0; j&lt;i; j++)
		if(dek1[i]==dek1[j]) i--;
	
	}
	int n2;
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;n2;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	std::deque&lt;int&gt; dek2;
	dek2.resize(n2);
	for(int i=0; i&lt;n2; i++) {
		std::cin&gt;&gt;dek2[i];
		for(int j=0; j&lt;i; j++)
		if(dek2[i]==dek2[j]) i--;
	
	}
	auto mat=UvrnutiPresjek(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), SumaCifara);
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera:"&lt;&lt;std::endl;
	for(int i=0; i&lt;mat.size(); i++) {
		for(int j=0; j&lt;mat[0].size(); j++)
		std::cout&lt;&lt;std::setw(6)&lt;&lt;mat[i][j]&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}
	auto mat1=UvrnutaRazlika(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), BrojProstihFaktora);
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera:"&lt;&lt;std::endl;
	for(int i=0; i&lt;mat1.size(); i++) {
		for(int j=0; j&lt;mat1[0].size(); j++)
		std::cout&lt;&lt;std::setw(6)&lt;&lt;mat1[i][j]&lt;&lt;" ";
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Dovidjenja!";
	
	return 0;
}</pre>
</body>
</html>
