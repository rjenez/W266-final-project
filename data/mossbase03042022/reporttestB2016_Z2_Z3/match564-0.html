<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student6889.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student6889.cpp<p></p><pre>
/*B 16/17, Zadaća 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;iomanip&gt;
bool isti(std::deque&lt;int&gt; vektor, int broj){
	for(int i=0;i&lt;vektor.size();i++){
		if(broj==vektor[i])return false;
	}
	return true;
}
/*int brojdjelilaca(long long int broj){
	int suma(0);
	for(int i=1;i&lt;broj;i++){
		if(broj%i==0){
			suma+=i;
		}
	}
	return suma;
}*/
int brojdjelilaca(long long int broj){
	int s(0);
	for(long long int i=1;i&lt;=broj-1;i++)  {    
        if(broj%i==0)s+=i;
	}
    if(s!=broj)return -1;
    return s;
   }
int SumaDjelilaca(long long int broj){
	int suma(0);
	if(broj==0)return 0;
	for(int i=1;i&lt;=std::abs(broj);i++){
		if(std::abs(broj)%i==0)suma+=i;;
	}
	return suma;
}
bool savrsen(long long int broj){
	long long int suma(0);
	if(broj==0)return 0;
	for(int i=1;i&lt;std::abs(broj);i++){
<a name="5"></a><font color="#FF0000"><a href="match564-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		if(std::abs(broj)%i==0)suma+=i;;
	}
	
	if(suma==broj)return true;
	return false;
}

int BrojSavrsenihDjelilaca(long long int broj){
	int suma(0);
</font>	if(broj%2!=0)return 0; //nema neparnih savrsenih brojeva
	for(long long int i=1;i&lt;=broj;i++){
		if(broj%i==0 &amp;&amp; savrsen(i)==true){
			suma++;
			}
	}
	return suma;
}
int BrojDjelilaca(long long int broj){
	int suma(0);
	while(broj!=0){
	suma+=broj%10;
	broj/=10;
	
	}
	return suma;
}

bool DaLiJeProst(long long int broj){
	if(broj&lt;2)return false;
	if(broj==2)return true;
	for(int i=2;i*i&lt;=broj;i++){
		if(broj%i==0)return false;
	}
	return true;
}
int BrojProstihFaktora(long long int broj){
	int suma(0);
	if(broj&lt;0)return 0;
	if(broj==2)return 1;
	for(int i=2;i*i&lt;=broj;i++){
			if(DaLiJeProst((i))==true){
				if(broj%i==0){
				suma++;
				broj/=i;
				i=0;}
				
			}
		}
	return suma+1;
}
template&lt;typename Tip1, typename Tip2&gt;
auto UvrnutiPresjek(Tip1 p1, Tip1 p2, Tip2 p3, Tip2 p4)-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
	typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	typedef std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; Vektor;
	Matrica nova;
	for(auto it1=p1;it1!=p2;it1++){
		for(auto it2=p3;it2!=p4;it2++){
			if(*it1==*it2){
				Vektor neki(3);
				neki.at(0)=*it1;
				neki.at(1)=0;
				neki.at(2)=0;
			    nova.push_back(neki);
			}
		}
	}
	std::sort(nova.begin(),nova.end(), [](Vektor p1, Vektor p2){
		if(p1[2]==p2[2]){
			if(p1[0]&lt;p2[0])return p1[0]&lt;p2[0];
			if(p1[0]==p2[0])return p1[1]&lt;p2[1];
			if(p1[1]&gt;p2[1])return p1[1]&gt;p2[1];
		}
		if(p1[2]&lt;p2[2])return p1[2]&lt;p2[2];
<a name="1"></a><font color="#00FF00"><a href="match564-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		return p1[2]&lt;p2[2];
	});
	return nova;
}
template &lt;typename Tip1, typename Tip2, typename TipF&gt;
auto UvrnutiPresjek(Tip1 p1, Tip1 p2, Tip2 p3, Tip2 p4,TipF f) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
</font>	typedef  std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	typedef  std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; vektor;
	Matrica nova;
	for(auto it1=p1;it1!=p2;it1++){
		for(auto it2=p3;it2!=p4;it2++){
			if(f(*it1)==f(*it2)){
				vektor neki(3);
				neki.at(0)=*it1;
				neki.at(1)=*it2;
				neki.at(2)=f(*it1);
			    nova.push_back(neki);
			}
		}
	}
	std::sort(nova.begin(), nova.end(), [](vektor p1, vektor p2){
		if(p1[2]==p2[2]){
			if(p1[0]==p2[0])return p1[1]&lt;p2[1];
			if(p1[0]&lt;p2[0])return p1[0]&lt;p2[0];
		//	if(p1[0]==p2[0])return p1[1]&lt;p2[1];
			if(p1[1]&gt;p2[1])return p1[1]&lt;p2[1];
		}
	//	if(p1[2]&gt;p2[2])return p1[0]&lt;p2[0];
		if(p1[2]&lt;p2[2])return p1[2]&lt;p2[2];
		return p2[2]&gt;p1[2];
	});
	return nova;
}
template &lt;typename Tip1, typename Tip2&gt;
auto UvrnutaRazlika(Tip1 p1, Tip1 p2, Tip2 p3, Tip2 p4) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
	typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	typedef std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; Vektor;
	Matrica uvrnuta;
	for(auto it1=p1;it1!=p2;it1++){
		bool isti(false);
		for(auto it2=p3;it2!=p4;it2++){
			if(*it1==*it2){
				isti=true;
				break;
			}
		}
		if(isti==false){
			Vektor v(2);
		    v.at(0)=*it1;
			v.at(1)=0;
			uvrnuta.push_back(v);
		}
	}
	for(auto it2=p3;it2!=p4;it2++){
	 	bool isti(false);
		for(auto it1=p1;it1!=p2;it1++){
			if(*it1==*it2){isti=true;break;}
		}
		if(isti==false){
			Vektor v(2);
			v.at(0)=*it2;
			v.at(1)=0;
			uvrnuta.push_back(v);
		}
	}
	std::sort(uvrnuta.begin(),uvrnuta.end(), [](Vektor p1,Vektor p2){
		if(p1[1]==p2[1]){
			if(p1[0]&gt;p2[0])return p1[0]&gt;p2[0];
			if(p1[0]==p2[0])return p1[1]&gt;p2[1];
			//if(p1[1]&gt;p2[1])return p1[1]&gt;p2[1];
		}
		if(p1[1]&gt;p2[1])return p1[1]&gt;p2[1];
<a name="2"></a><font color="#0000FF"><a href="match564-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		return p2[1]&gt;p1[1];
	});
	
/*	std::sort(uvrnuta.begin(), uvrnuta.end(), [](Vektor p1, Vektor p2){
		if(p1[1]==p2[1]){
			if(p1[0]&gt;p2[0])return p1[0]&gt;p2[0];
			if(p1[0]==p2[0])return p1[1]&gt;p2[1];
		}
		if(p1[1]&gt;p2[1])return p1[1]&gt;p2[1];
	});*/
return uvrnuta;
}
template &lt;typename Tip, typename Tipp, typename Tiip&gt;
auto UvrnutaRazlika(Tip p1, Tip p2, Tipp p3, Tipp p4,Tiip g) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
</font>	typedef std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; Matrica;
	typedef std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; Vektor;
	Matrica uvrnuta;
	for(auto it1=p1;it1!=p2;it1++){
		bool isti(false);
		for(auto it2=p3;it2!=p4;it2++){
			if(g(*it1)==g(*it2)){
				isti=true;
				break;
			}
		}
		if(isti==false){
			Vektor v(2);
		    v.at(0)=*it1;
			v.at(1)=g(*it1);
			uvrnuta.push_back(v);
		}
	}
	for(auto it2=p3;it2!=p4;it2++){
	 	bool isti(false);
		for(auto it1=p1;it1!=p2;it1++){
			if(g(*it1)==g(*it2)){isti=true;break;}
		}
		if(isti==false){
			Vektor v(2);
			v.at(0)=*it2;
			v.at(1)=(g(*it2));
			uvrnuta.push_back(v);
		}
	}
	std::sort(uvrnuta.begin(),uvrnuta.end(), [](Vektor p1,Vektor p2){
		if(p1[1]==p2[1]){
			if(p1[0]&gt;p2[0])return p1[0]&gt;p2[0];
			if(p1[0]==p2[0])return p1[1]&lt;p2[1];
			;
		}
		if(p1[0]&lt;p2[0])return p1[0]&lt;p1[0];
<a name="0"></a><font color="#FF0000"><a href="match564-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

		if(p1[1]&lt;p2[1])return p1[0]&gt;p2[0];
		return p2[1]&lt;p1[1];
	});
	/*	std::sort(uvrnuta.begin(), uvrnuta.end(), [](Vektor p1, Vektor p2){
		if(p1[1]==p2[1]){
			if(p1[0]&lt;p2[0])return p1[0]&lt;p2[0];
			if(p1[0]==p2[0])return p1[1]&lt;p2[1];
			if(p1[1]&gt;p2[1])return p1[1]&gt;p2[1];
		}
		if(p1[1]&lt;p2[1])return p1[1]&lt;p2[1];
		return p2[1]&gt;p1[1];
	});*/
	return uvrnuta;
}
int main ()
{
	//AT7 - test funkcija sa 4 parametra čiji su elementi tipa int
//Funkcija UvrnutaRazlika sa 4 parametra radi analogno kao i funkcija 
//UvrnutiPresjek sa 4 parametra, dakle običnu razliku skupova

/*	std::deque&lt;int&gt; d1{1, 2, 3}, d2{2, 4, 3, 5};
    std::vector&lt;std::vector&lt;int&gt;&gt; v1{UvrnutiPresjek(d1.begin(), d1.end(), d2.begin(), d2.end())};
	std::vector&lt;std::vector&lt;int&gt;&gt; v2{UvrnutaRazlika(d1.begin(), d1.end(), d2.begin(), d2.end())};
	for (std::vector&lt;int&gt;&amp; red : v1)
	{
		for (int&amp; broj : red)
			std::cout &lt;&lt; broj &lt;&lt; " ";
		std::cout &lt;&lt; std::endl;
	}
	std::cout &lt;&lt; std::endl;
	for (std::vector&lt;int&gt;&amp; red : v2)
	{
		for (int&amp; broj : red)
			std::cout &lt;&lt; broj &lt;&lt; " ";
		std::cout &lt;&lt; std::endl;
	}*/
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	int broj1;
	std::cin&gt;&gt;broj1;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
</font>	std::deque&lt;int&gt; v1;
	for(int i=0;i&lt;broj1;i++){
		int novi;
		std::cin&gt;&gt;novi;
<a name="6"></a><font color="#00FF00"><a href="match564-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		if(isti(v1,novi)==true)v1.push_back(novi);
		else i--;
	}
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	int broj2;
	std::cin&gt;&gt;broj2;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
</font>	std::deque&lt;int&gt; v2;
/*	std::deque&lt;int&gt; d1{6, 168, 28, 12}, d2{1, 28, 51, 6};
    std::vector&lt;std::vector&lt;int&gt;&gt; a{UvrnutiPresjek(d1.begin(), d1.end(), d2.begin(), d2.end(), BrojSavrsenihDjelilaca)};
	std::vector&lt;std::vector&lt;int&gt;&gt; b{UvrnutaRazlika(d1.begin(), d1.end(), d2.begin(), d2.end(), BrojSavrsenihDjelilaca)};
	for(int i=0;i&lt;a.size();i++){
		for(int j=0;j&lt;a[i].size();j++){
			std::cout&lt;&lt;a[i][j]&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}*/
	for(int i=0;i&lt;broj2;i++){
		int novi;
		std::cin&gt;&gt;novi;
<a name="4"></a><font color="#FF00FF"><a href="match564-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		if(isti(v2,novi)==true)v2.push_back(novi);
		else i--;
	}
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera:"&lt;&lt;std::endl;
	auto mat(UvrnutiPresjek(v1.begin(), v1.end(), v2.begin(), v2.end(), BrojDjelilaca));
</font>	for(int i=0;i&lt;mat.size();i++){
		for(int j=0;j&lt;mat[i].size();j++){
			std::cout&lt;&lt;std::setw(6)&lt;&lt;mat.at(i).at(j)&lt;&lt;" ";
		}
<a name="3"></a><font color="#00FFFF"><a href="match564-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera:"&lt;&lt;std::endl;
	auto mat1(UvrnutaRazlika(v1.begin(),v1.end(),v2.begin(),v2.end(),BrojProstihFaktora));
</font>	for(int i=0;i&lt;mat1.size();i++){
		for(int j=0;j&lt;mat1[i].size();j++){
			std::cout&lt;&lt;std::setw(6)&lt;&lt;mat1.at(i).at(j)&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Dovidjenja!";
/*	std::cout&lt;&lt;BrojSavrsenihDjelilaca(168);
	std::cout &lt;&lt; BrojSavrsenihDjelilaca(123456) &lt;&lt; " " &lt;&lt; BrojSavrsenihDjelilaca(56789) &lt;&lt; " " &lt;&lt; BrojSavrsenihDjelilaca(12121281) &lt;&lt; " ";
std::cout &lt;&lt; BrojSavrsenihDjelilaca(83328) &lt;&lt; " " &lt;&lt; BrojSavrsenihDjelilaca(1176) &lt;&lt; " " &lt;&lt; BrojSavrsenihDjelilaca(181287) &lt;&lt; " ";
std::cout &lt;&lt; BrojSavrsenihDjelilaca(45698) &lt;&lt; " " &lt;&lt; BrojSavrsenihDjelilaca(2048) &lt;&lt; " " &lt;&lt; BrojSavrsenihDjelilaca(8128);
std::cout &lt;&lt; BrojProstihFaktora(123456) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(56789) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(12121281) &lt;&lt; " ";
std::cout &lt;&lt; BrojProstihFaktora(4512698) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(202248) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(181287) &lt;&lt; " ";
std::cout &lt;&lt; BrojProstihFaktora(45698) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(2048) &lt;&lt; " " &lt;&lt; BrojProstihFaktora(8128);	*/
return 0;
}</pre>
</body>
</html>
