<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4416.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student8864.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
<a name="1"></a><font color="#00FF00"><a href="match106-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

bool Prost(int n){
	for(int i=2;i&lt;n;i++) if(n%i==0) return false;
	return true;
}
bool Savrsen(int n){
	int suma(0);
	for(int i=1;i&lt;n;i++){
		if(n%i==0) suma+=i;
	}
	if(suma==n) return true;
	return false;
}
int SumaDjelilaca(long long int n){
	int suma(0);
	for(int i=1;i&lt;=abs(n);i++) if(n%i==0) suma+=i;
	return suma;
}
int SumaCifara(long long int n){
	int suma(0);
	while (n!=0){
		suma+=abs(n%10);
		n/=10;
	}
	return suma;
}
int BrojProstihFaktora(long long int n){
	int brojac(0);
	for(int i=2;i&lt;=n;i++){
		if(n%i==0 &amp;&amp; Prost(i)){
			brojac++;
			n/=i;
			i=1;
		}
	}
	return brojac;
}
int BrojSavrsenihDjelilaca(long long int n){
	int brojac(0);
	for(int i=2;i&lt;=n;i++){
		if(n%i==0 &amp;&amp; Savrsen(i)){
			brojac++;
			n/=i;
			i=1;
		}
	}
	return brojac;
}
template &lt;typename itip1,typename itip2&gt;
auto UvrnutiPresjek(itip1 p1,itip1 p2,itip2 p3,itip2 p4)-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
</font><a name="4"></a><font color="#FF00FF"><a href="match106-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_7.gif"/></a>

	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type &gt;&gt; matrica;
	itip1 temp;
	while(p1!=p2){
		temp=p3;
		while(temp!=p4){
			if(*p1==*temp){
				matrica.resize(matrica.size()+1);
				matrica[matrica.size()-1].push_back(*p1);
				matrica[matrica.size()-1].push_back(0);
				matrica[matrica.size()-1].push_back(0);
				temp=p4-1;
			}
			temp++;
		}
		p1++;
	}
	return matrica;
}
template &lt;typename itip1,typename itip2,typename ptip1,typename ptip2&gt;
auto UvrnutiPresjek (itip1 p1,itip1 p2, itip2 p3, itip2 p4, ptip1 funkcija(ptip2))-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
</font><a name="5"></a><font color="#FF0000"><a href="match106-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type &gt;&gt; matrica;
	while(p1!=p2){
		auto pom1(p3);
		while(pom1!=p4){
			if(funkcija(*p1)==funkcija(*pom1)){
				matrica.resize(matrica.size()+1);
				matrica[matrica.size()-1].push_back(*p1);
				matrica[matrica.size()-1].push_back(*pom1);
				matrica[matrica.size()-1].push_back(funkcija(*p1));
			}
			pom1++;
		}
		p1++;
	}
	std::sort(matrica.begin(),matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; a,std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; b){if(a[2]&lt;b[2]) return true;
</font><a name="8"></a><font color="#00FFFF"><a href="match106-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	else if(a[2]&gt;b[2]) return false;
</font>	else if(a[0]&lt;b[0]) return true;
	else if(a[0]&gt;b[0]) return false;
<a name="7"></a><font color="#0000FF"><a href="match106-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	else if(a[1]&lt;b[1]) return true;
	else if(a[1]&gt;b[1]) return false;
	return true;});
	return matrica;
}
template&lt;typename itip1,typename itip2&gt;
auto UvrnutaRazlika (itip1 p1,itip1 p2, itip2 p3,itip2 p4)-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
</font><a name="3"></a><font color="#00FFFF"><a href="match106-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_11.gif"/></a>

	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; matrica;
	auto pom1(p1);
	bool ubaci;
	while(pom1!=p2){
		ubaci=true;
		auto pom3(p3);
		while(pom3!=p4){
			if(*pom1==*pom3) ubaci=false;
			pom3++;
		}
		if(ubaci){
			matrica.resize(matrica.size()+1);
			matrica[matrica.size()-1].push_back(*pom1);
			matrica[matrica.size()-1].push_back(0);
		}
		pom1++;
	}
	while(p3!=p4){
		pom1=p1;
		ubaci=true;
		while(pom1!=p2){
			if(*pom1==*p3) ubaci=false;
			pom1++;
		}
		if(ubaci){
			matrica.resize(matrica.size()+1);
			matrica[matrica.size()-1].push_back(*p3);
			matrica[matrica.size()-1].push_back(0);
		}
		p3++;
	}
	std::sort(matrica.begin(),matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;a,std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;b){
</font><a name="6"></a><font color="#00FF00"><a href="match106-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

		if(a[0]&gt;b[0]) return true;
		return false;
	});
	return matrica;
}
template &lt;typename itip1,typename itip2,typename ptip1,typename ptip2&gt;
auto UvrnutaRazlika (itip1 p1,itip2 p2,itip2 p3,itip2 p4,ptip1 funkcija(ptip2))-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
</font><a name="2"></a><font color="#0000FF"><a href="match106-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt; matrica;
	auto pom1(p1);
	bool ubaci;
	while(pom1!=p2){
		ubaci=true;
		auto pom3(p3);
		while(pom3!=p4){
			if(funkcija(*pom1)==funkcija(*pom3)) ubaci=false;
			pom3++;
		}
		if(ubaci){
			matrica.resize(matrica.size()+1);
			matrica[matrica.size()-1].push_back(*pom1);
			matrica[matrica.size()-1].push_back(funkcija(*pom1));
		}
		pom1++;
	}
	while(p3!=p4){
		ubaci=true;
		pom1=p1;
		while(pom1!=p2){
			if(funkcija(*p3)==funkcija(*pom1)) ubaci=false;
			pom1++;
		}
		if(ubaci){
			matrica.resize(matrica.size()+1);
			matrica[matrica.size()-1].push_back(*p3);
			matrica[matrica.size()-1].push_back(funkcija(*p3));
		}
		p3++;
	}
	std::sort(matrica.begin(),matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; a,std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt; b){
</font><a name="0"></a><font color="#FF0000"><a href="match106-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_25.gif"/></a>

		if (a[0]&gt;b[0]) return true;
		if (a[0]&lt;b[0]) return false;
		if(a[1]&gt;b[1]) return true;
		return false;
	});
	return matrica;
}
int main (){
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	int s1,s2;
	std::cin&gt;&gt;s1;
	if(s1&lt;0){
		std::cout&lt;&lt;"broj elemenata ne moze biti negativan!";
		return 0;
	}	
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	std::deque&lt;int&gt; d1;
	int temp;
	bool ubaci;
	for(int i=0;i&lt;s1;i++){
		ubaci=true;
		std::cin&gt;&gt;temp;
		for(int j=0;j&lt;d1.size();j++){
			if (temp==d1[j]) ubaci=false;
		}
		if(ubaci) d1.push_back(temp);
		else i--;
	}
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;s2;
	if(s2&lt;0){
		std::cout&lt;&lt;"Broj elemenata ne moze biti negativan!";
		return 0;
	}
	std::deque&lt;int&gt; d2;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	for(int i=0;i&lt;s2;i++){
		ubaci=true;
		std::cin&gt;&gt;temp;
		for(int j=0;j&lt;d2.size();j++){
			if(temp==d2[j]) ubaci=false;
		}
		if(ubaci) d2.push_back(temp);
		else i--;
	}
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera:\n";
	auto a(UvrnutiPresjek(d1.begin(),d1.end(),d2.begin(),d2.end(),SumaCifara));
	for(int i=0;i&lt;a.size();i++){
		for(int j=0;j&lt;3;j++){
			std::cout&lt;&lt;std::setw(6)&lt;&lt;a[i][j]&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera:\n";
	auto b(UvrnutaRazlika(d1.begin(),d1.end(),d2.begin(),d2.end(),BrojProstihFaktora));
	for(int i=0;i&lt;b.size();i++){
		for(int j=0;j&lt;2;j++){
			std::cout&lt;&lt;std::setw(6)&lt;&lt;b[i][j]&lt;&lt;" ";
</font>		}
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
