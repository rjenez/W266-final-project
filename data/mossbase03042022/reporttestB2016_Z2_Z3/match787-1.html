<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2513.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student9998.cpp<p></p><pre>
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;type_traits&gt;
#include&lt;iomanip&gt;
#include&lt;deque&gt;
#include&lt;cstdlib&gt;

int SumaDjelilaca (long long int n){ //za min_int max_int
    long long int suma=0;
    for(int i=1;i&lt;=abs(n);i++){
        if(n%i==0) suma+=i;
    }
    return suma;
}

int SumaCifara(long long int n){
    long long int suma=0;
    if(n&lt;0) n=-n;
    while(n!=0){
        suma+=n%10;
        n/=10;
    }
    return suma;
}


int BrojProstihFaktora (long long int n){ //max int i sta za negativne brojeve
    long long int broj=0;
    for(int i=2;i&lt;=n;i++){
        if(n%i==0){ 
            broj++;
            n/=i;
            i--;
        }
    }
    return broj;
}

bool savrsen(int n){
    if(n&lt;=0) return false;
    int suma=0;
    for(int i=1;i&lt;=n/2;i++){
        if(n%i==0) suma+=i;
    }
   return suma==n;
}

int BrojSavrsenihDjelilaca(long long int n){ //max int
    long long int broj=0;
    for(int i=1;i&lt;=n;i++){
        if(n%i==0 &amp;&amp; savrsen(i)) broj++;
    }
    return broj;
}


template&lt;typename iter_pok1, typename iter_pok2&gt;

auto UvrnutiPresjek (iter_pok1 p1, iter_pok1 k1, iter_pok2 p2, iter_pok2 k2)-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;&gt; { //ispravi ovo, pomocna 
    std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;&gt;mat;

        while(p1!=k1){
            auto j=p2;
            while(j!=k2){
                if(*p1==*j){
                   mat.push_back({*p1,0,0});
                }
                j++;
            }
            p1++;
        }
        
        std::sort(mat.begin(), mat.end(), [](std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;red1, std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt; red2){
            if(red1[2]==red2[2]){
                if(red1[0]!=red2[0]) return red1[0]&lt;red2[0];
<a name="2"></a><font color="#0000FF"><a href="match787-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

                else return red1[1]&lt;red1[1];
            }
            return red1[2]&lt;red2[2];
        });
        
        return mat;
}
   
   
    
    template&lt;typename iter_pok1, typename iter_pok2,typename tip1, typename tip2&gt;
</font>    
auto UvrnutiPresjek(iter_pok1 p1,iter_pok1 k1, iter_pok2 p2, iter_pok2 k2, tip1 (*f)(tip2)) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;&gt; {
<a name="4"></a><font color="#FF00FF"><a href="match787-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;&gt;mat ;
    
    //popuni matricu
        while(p1!=k1){
            iter_pok2 j=p2;
            while(j!=k2){
                if(f(*p1)==f(*j)){
                    mat.push_back({*p1,*j,f(*p1)});
</font>                    
                }
                j++;
            }
            p1++;
        }
        
    // sortiraj
    std::sort(mat.begin(), mat.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;red1, std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;red2){ //tip
        if(red1[2]==red2[2]){
            if(red1[0]!=red2[0]) return red1[0]&lt;red2[0];
            else return red1[1]&lt;red2[1];
        }
        return red1[2]&lt;red2[2];
    });
   
    return mat;
}



template&lt;typename iter_pok1, typename iter_pok2&gt;

auto UvrnutaRazlika (iter_pok1 p1, iter_pok1 k1, iter_pok2 p2, iter_pok2 k2)-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1+ *p2)&gt;::type&gt;&gt;{
    
<a name="1"></a><font color="#00FF00"><a href="match787-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

     std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;&gt;mat;
     
        iter_pok1 p=p1;
        while(p!=k1){
            auto j=p2;
            bool ima=false; //ima istih
            while(j!=k2){
                if(*p==*j) {ima=true; break;}
</font>                j++;
            }
            if(!ima) mat.push_back({*p,0});
            p++;
        }
        
<a name="5"></a><font color="#FF0000"><a href="match787-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        while(p2!=k2){
            auto j=p1;
            bool ima=false;
            while(j!=k1){
                if(*p2==*j) {ima=true; break;}
</font>                j++;
            }
           if(!ima) mat.push_back({*p2,0});
            p2++;
        }
         
     
     std::sort(mat.begin(), mat.end(), [](std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;red1, std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;red2){
         if(red1[0]==red2[0]){
             return red1[1]&gt;red2[1];
         }
         return red1[0]&gt;red2[0];
     });
     
     return mat;
}

     
template&lt;typename iter_pok1, typename iter_pok2, typename tip1, typename tip2&gt;
auto UvrnutaRazlika(iter_pok1 p1, iter_pok1 k1, iter_pok2 p2, iter_pok2 k2, tip1 (*f)(tip2))-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;&gt;{

std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt;&gt; mat;
<a name="0"></a><font color="#FF0000"><a href="match787-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

     iter_pok1 prvi=p1;
     iter_pok2 drugi=p2;
     
     while(p1!=k1){
         auto j=p2;
         bool ima=false;
         while(j!=k2){
             if(f(*p1)==f(*j)){
                ima=true;
                break;
             }
             j++;
         }
         if(!ima){ 
</font>             mat.push_back({*p1,f(*p1)});
         }
         p1++;
     }
     
      while(drugi!=k2){
<a name="3"></a><font color="#00FFFF"><a href="match787-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

         auto j=prvi;
         bool ima=false;
         while(j!=k1){
             if(f(*drugi)==f(*j)){
                 ima=true;
                 break;
             }
             j++;
         }
         if(!ima){
</font>             mat.push_back({*drugi,f(*drugi)});
         }
         drugi++;
     }
     
     
     std::sort(mat.begin(), mat.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt; red1, std::vector&lt;typename std::remove_reference&lt;decltype(*p1+*p2)&gt;::type&gt; red2){ //tip
<a name="6"></a><font color="#00FF00"><a href="match787-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

         if(red1[0]==red2[0]){
             return red1[1]&gt;red2[1];
         }
         return red1[0]&gt;red2[0];
     });
    
    return mat;
}


int main ()
</font>{
    std::deque&lt;int&gt;d1, d2;
    std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
    int n1;
    std::cin&gt;&gt;n1;
    std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
    for(int i=0;i&lt;n1;i++){
        int a;
        std::cin&gt;&gt;a;
        if(std::find(d1.begin(),d1.end(),a)==d1.end()) d1.push_back(a);
        else i--;
    }
    
    
    std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
    int n2;
    std::cin&gt;&gt;n2;
    
    std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
    for(int i=0;i&lt;n2;i++){
        int b;
        std::cin&gt;&gt;b;
        if(std::find(d2.begin(),d2.end(),b)==d2.end()) d2.push_back(b);
        else i--;
    }
  
    std::cout&lt;&lt;"Uvrnuti presjek kontejnera:"&lt;&lt;std::endl;
    std::vector&lt;std::vector&lt;int&gt;&gt;mat=UvrnutiPresjek(d1.begin(),d1.end(),d2.begin(),d2.end(),SumaCifara);
    for(int i=0;i&lt;mat.size();i++){
        for(int j=0;j&lt;mat[i].size();j++)
        std::cout&lt;&lt;std::setw(6)&lt;&lt;mat[i][j]&lt;&lt;" ";
        std::cout&lt;&lt;std::endl;
    }
    
    std::cout&lt;&lt;"Uvrnuta razlika kontejnera:"&lt;&lt;std::endl;
    std::vector&lt;std::vector&lt;int&gt;&gt;mat1=UvrnutaRazlika(d1.begin(),d1.end(), d2.begin(), d2.end(),BrojProstihFaktora);
    for(int i=0;i&lt;mat1.size();i++){
        for(int j=0;j&lt;mat1[i].size();j++)
            std::cout&lt;&lt;std::setw(6)&lt;&lt;mat1[i][j]&lt;&lt;" ";
            std::cout&lt;&lt;std::endl;
    }
    
    std::cout&lt;&lt;"Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
