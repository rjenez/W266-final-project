<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student9358.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student9358.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;type_traits&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;

template &lt;typename itertip1, typename itertip2, typename tip, typename povtip&gt;
auto UvrnutiPresjek(itertip1 poc1, itertip1 izakraja1, itertip2 poc2, itertip2 izakraja2, povtip funkcija(tip)) -&gt; std::vector&lt;std::vector&lt; typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt;{
    std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt; Matrica;
	for(itertip1 i=poc1;i&lt;izakraja1;i++){
	    for(itertip2 j=poc2;j&lt;izakraja2;j++){
	        if(funkcija(*i)==funkcija(*j)) {
<a name="0"></a><font color="#FF0000"><a href="match988-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

	        	std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; v;
	            v.push_back(*i);                         //dodavanje elemenata u vektor, zatim vektora u matricu//                     
	            v.push_back(*j);
	            v.push_back(funkcija(*i));
	            Matrica.push_back(v);
	        }
	    }
	}
	//sortiranje vektora matrice po zadanom kriteriju//
	std::sort(Matrica.begin(),Matrica.end(),[] (const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;a, const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;b) 
</font>	{
		if(a[2]!=b[2]) return a[2]&lt;b[2];
		else if(a[2]==b[2] &amp;&amp; a[0]!=b[0]) return a[0]&lt;b[0];
		return a[1]&lt;b[1];
	});
	return Matrica;
}

template &lt;typename itertip1, typename itertip2&gt;                            //obicni presjek//
auto UvrnutiPresjek(itertip1 poc1, itertip1 izakraja1, itertip2 poc2, itertip2 izakraja2) -&gt; std::vector&lt;std::vector&lt; typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt; Matrica;
	for(itertip1 i=poc1;i&lt;izakraja1;i++){
		for(itertip2 j=poc2;j&lt;izakraja2;j++){
			if(*i==*j){
				std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; v;
<a name="1"></a><font color="#00FF00"><a href="match988-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

				v.push_back(*i);
				v.push_back(0);
				v.push_back(0);
				Matrica.push_back(v);
			}
		}
	}
	std::sort(Matrica.begin(),Matrica.end(), [] (const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;a, const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;b)
</font>	{
		return(a[0]&lt;b[0]);
	});
	return Matrica;
}


template &lt;typename itertip1, typename itertip2, typename tip, typename povtip&gt;
auto UvrnutaRazlika(itertip1 poc1, itertip1 izakraja1, itertip2 poc2, itertip2 izakraja2, povtip funkcija(tip)) -&gt; std::vector&lt;std::vector&lt; typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt; Matrica;
	bool postoji=false;
	for(itertip1 i=poc1;i&lt;izakraja1;i++){                    //provjera za elemente prvog bloka da li imaju svoj par u drugom bloku
		postoji=false;
		for(itertip2 j=poc2;j&lt;izakraja2;j++){
			if(funkcija(*i)==funkcija(*j)) {postoji=true; break;}   //ako postoji element za koji je zadovoljen uslov, ne treba ga smjestati u matricu
		}
		if(postoji==false){
			std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; v;
	     	v.push_back(*i);                                  //smjestanje elemenata koji nemaju svog "para"
			v.push_back(funkcija(*i));
			Matrica.push_back(v);
		}
	}
	postoji=false;
	for(itertip2 i=poc2;i&lt;izakraja2;i++){                     //provjera za elemente drugog bloka da li imaju svoj par u prvom bloku
		postoji=false;
		for(itertip1 j=poc1;j&lt;izakraja1;j++){
			if(funkcija(*i)==funkcija(*j)) {postoji=true; break;}
		}
		if(postoji==false){
			std::vector&lt;typename std::remove_reference&lt;decltype(*poc2)&gt;::type&gt; v1;
<a name="2"></a><font color="#0000FF"><a href="match988-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

			v1.push_back(*i);
			v1.push_back(funkcija(*i));
			Matrica.push_back(v1);
		}
	}
	//sortiranje dobijene matrice po zadanom kriteriju
	std::sort(Matrica.begin(),Matrica.end(),[] (const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;a, const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;b){
</font><a name="4"></a><font color="#FF00FF"><a href="match988-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		if(a[0]!=b[0]) return a[0]&gt;b[0];
		else return a[1]&lt;b[1];
</font>	});
	return Matrica;
}

template&lt;typename itertip1, typename itertip2&gt;
auto UvrnutaRazlika(itertip1 poc1, itertip1 izakraja1, itertip2 poc2, itertip2 izakraja2) -&gt; std::vector&lt;std::vector&lt; typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt;&gt; Matrica;
	bool postoji=false;
	for(itertip1 i=poc1;i&lt;izakraja1;i++){
		postoji=false;
		for(itertip2 j=poc2;j&lt;izakraja2;j++){
			if(*i==*j) {postoji=true;break;}
		}
		if(postoji==false){
			std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; v;
			v.push_back(*i);
			v.push_back(0);
			Matrica.push_back(v);
		}
	}
	postoji=false;
	for(itertip2 i=poc2;i&lt;izakraja2;i++){
		postoji=false;
		for(itertip1 j=poc1;j&lt;izakraja1;j++){
			if(*i==*j) {postoji=true;break;}
		}
		if(postoji==false){
			std::vector&lt;typename std::remove_reference&lt;decltype(*poc2)&gt;::type&gt; v1;
<a name="3"></a><font color="#00FFFF"><a href="match988-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			v1.push_back(*i);
			v1.push_back(0);
			Matrica.push_back(v1);
		}
	}
	std::sort(Matrica.begin(), Matrica.end(), [] (const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;a, const std::vector&lt;typename std::remove_reference&lt;decltype(*poc1)&gt;::type&gt; &amp;b){
</font>    return a[0]&gt;b[0];		
	});
	
	return Matrica;
}
	
int SumaCifara(long long int a){
	int suma=0;
	while(a!=0){
		suma=suma+a%10;
		a=a/10;
	}
    return suma;
}

int BrojProstihFaktora(long long int a){
	int broj(0);
	for(int i=2;i&lt;=a;i++){
		if(a%i==0) {
			broj++;
			a=a/i;
		}
		while(a%i==0){
			a=a/i;
			broj++;
		}
	}
	return broj;
}

int SumaDjelilaca(long long int a){
	int suma(0);
	for(int i=1;i&lt;=std::abs(a);i++){
		if(std::abs(a)%i==0) suma=suma+i;
	}
	return suma;
}

int BrojSavrsenihDjelilaca(long long int a){
	int br(0), suma(0);
	for(int i=1;i&lt;=std::abs(a);i++){
		suma=0;
		if(std::abs(a)%i==0){
			for(int j=1;j&lt;i;j++){
				if(i%j==0) suma=suma+j;
			}
		if(i==suma) br++;
		}
	}
	return br;
}

int main ()
{   std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
    int n1,n2;
    std::cin&gt;&gt;n1;
    std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
    int broj;
    bool postoji=false;
    std::deque&lt;int&gt; v1;
    std::deque&lt;int&gt; v2;
    for(int i=0;i&lt;n1;i++){
    	postoji=false;
    	std::cin&gt;&gt;broj;
    	for(int j=0;j&lt;v1.size();j++){
    		if(v1[j]==broj) {postoji=true; i--;}
    	}
<a name="5"></a><font color="#FF0000"><a href="match988-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    	if(postoji==false) v1.push_back(broj);
    }
    std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
    std::cin&gt;&gt;n2;
    std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
    for(int i=0;i&lt;n2;i++){
</font>    	postoji=false;
    	std::cin&gt;&gt;broj;
    	for(int j=0;j&lt;v2.size();j++){
    		if(v2[j]==broj) {postoji=true;i--;}
    	}
    	if(postoji==false) v2.push_back(broj);
    }
    auto Matrica=UvrnutiPresjek(v1.begin(),v1.end(),v2.begin(),v2.end(),SumaCifara);
    std::cout&lt;&lt;"Uvrnuti presjek kontejnera:"&lt;&lt;std::endl;
    for(int i=0;i&lt;Matrica.size();i++){
    	for(int j=0;j&lt;3;j++){
    		std::cout&lt;&lt;std::right&lt;&lt;std::setw(6)&lt;&lt;Matrica[i][j]&lt;&lt;" ";
    	}
    	std::cout&lt;&lt;std::endl;
    }
    auto Matrica1=UvrnutaRazlika(v1.begin(),v1.end(),v2.begin(),v2.end(),BrojProstihFaktora);
    std::cout&lt;&lt;"Uvrnuta razlika kontejnera:"&lt;&lt;std::endl;
    for(int i=0;i&lt;Matrica1.size();i++){
    	for(int j=0;j&lt;2;j++){
    		std::cout&lt;&lt;std::right&lt;&lt;std::setw(6)&lt;&lt;Matrica1[i][j]&lt;&lt;" ";
    	}
    	std::cout&lt;&lt;std::endl;
    }
    std::cout&lt;&lt;"Dovidjenja!"&lt;&lt;std::endl;
	return 0;
}</pre>
</body>
</html>
