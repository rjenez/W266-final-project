<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2464.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student9589.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/

#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;type_traits&gt;
#include &lt;deque&gt;
#include &lt;iomanip&gt;

// broj ne smije pocinjati nulom
int SumaCifara(long long int broj) {
	
	int rezultat{};
	broj = fabs(broj);
	
	while (broj != 0) {
		rezultat = rezultat + (broj % 10);
		broj = broj / 10;
	}
	
	return rezultat;
	
	
}


int SumaDjelilaca(long long int broj) {
	
	int rezultat = 0;
	broj = fabs(broj);
	
	for (long long int i = 1; i &lt;= broj; i++) {
		
		if (broj % i == 0) 
		    rezultat = rezultat + i;
		    
	}
	return rezultat;
}

int BrojProstihFaktora(long long int broj) {
	int rezultat {};
	broj = fabs(broj);
	
	if (broj == 0)
	    rezultat = 0;
	else if (broj == 1) 
	    rezultat = 1;
	else {
		int ostatak = broj % 2;
		
		while (ostatak == 0) {
			rezultat = rezultat + 1;
			broj = broj / 2;
			ostatak = broj % 2;
			
		}
		
		for (long long int i=3; i &lt;= broj; i = i + 2) {
			int ostatak = broj % i;
			
			while (ostatak == 0) {
				rezultat++;
				broj = broj / i;
				ostatak = broj % i;
			}
		}
	}
	
	return rezultat;
}


int BrojSavrsenihDjelilaca(long long int broj) {
	int rezultat {};
	broj = fabs(broj);
	
	for (long long int i = 1; i &lt;= broj; i++) {
		int suma = SumaDjelilaca(i) - i;
		
		if (suma == i &amp;&amp; broj % i == 0)
		    rezultat++;
		    
	}
	
	return rezultat;
}


template &lt;typename T1&gt;

bool Jednaki(T1 x, T1 y, double eps = 1e-10) {
	bool uslov = (x &lt; 0 &amp;&amp; y &gt; 0) || (x &gt; 0 &amp;&amp; y &lt; 0);
	
	if (uslov) return false;
	    return std::fabs(x-y) &lt;= eps*(std::fabs(x)+std::fabs(y));
}

<a name="1"></a><font color="#00FF00"><a href="match322-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

template &lt;typename T1, typename T2, typename T3, typename T4&gt;

auto UvrnutiPresjek (T1 pocetak1, T1 kraj1, T2 pocetak2, T2 kraj2, T4 funkcija_kriterija(T3))-&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype (*pocetak1)&gt;::type&gt;&gt; {
</font>	typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak2)&gt;::type&gt;&gt; matrica;
<a name="6"></a><font color="#00FF00"><a href="match322-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	while (pocetak1 != kraj1) {
		T4 br_vrij1 = funkcija_kriterija(*pocetak1);
		T2 temp = pocetak2;
		
		while (temp != kraj2) {
			T4 br_vrij2 = funkcija_kriterija(*temp);
			
			if (Jednaki(br_vrij1, br_vrij2)) {
</font>				std::vector &lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; pomocni(3);
				pomocni[0] = *pocetak1;
				pomocni[1] = *temp;
				pomocni[2] = br_vrij1;
				matrica.push_back(pomocni);
			}
			temp++;
		}
		pocetak1++;
	}

	
	std::sort(matrica.begin(), matrica.end(), [](typename std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak2)&gt;::type&gt; vek1,
	typename std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak2)&gt;::type&gt; vek2) {
		if (!Jednaki(vek1[2],vek2[2])) return vek1[2] &lt; vek2[2];
		else if((Jednaki(vek1[2], vek2[2])) &amp;&amp; !Jednaki(vek1[0], vek2[0])) return vek1[0] &lt; vek2[0];
		return vek1[1] &lt; vek2[1];});
	return matrica;
	
	}
	
template &lt;typename T1, typename T2&gt;
<a name="4"></a><font color="#FF00FF"><a href="match322-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

auto UvrnutiPresjek (T1 pocetak1, T1 kraj1, T2 pocetak2, T2 kraj2) -&gt; typename std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; {
</font>	typename std::vector &lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; matrica;
	while(pocetak1 != kraj1) {
		T2 temp=pocetak2;
		while(temp != kraj2) {
			if(Jednaki(*pocetak1, *temp)) {
				std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; pomocni(3);
				pomocni[0]=*pocetak1;
				pomocni[1]=0;
				pomocni[2]=0;
				matrica.push_back(pomocni);
			}
			temp++;
		}
		pocetak1++;
	}
<a name="0"></a><font color="#FF0000"><a href="match322-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	std::sort (matrica.begin(), matrica.end(),[](typename std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;vek1, typename std::vector &lt;typename std::remove_reference &lt;decltype(*pocetak1)&gt;::type&gt; vek2) {
		return vek1[0] &lt; vek2[0];});
		return matrica;
	}
	
	template &lt;typename T1, typename T2, typename T3, typename T4&gt;
	auto UvrnutaRazlika (T1 pocetak1, T1 kraj1, T2 pocetak2, T2 kraj2, T4 funkcija_kriterija(T3)) -&gt; typename std::vector&lt;std::vector &lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; {
</font>		typename std::vector &lt;std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; matrica;
<a name="2"></a><font color="#0000FF"><a href="match322-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	T1 temp1=pocetak1;
	while (temp1 != kraj1) {
		T4 br_vrij1 = funkcija_kriterija (*temp1);
		bool status = false;
		T2 temp2 = pocetak2;
		while (temp2 != kraj2) {
			T4 br_vrij2 = funkcija_kriterija (*temp2);
			if (Jednaki(br_vrij1, br_vrij2)) {
</font>				status = true;
				break;
			}
			temp2++;
		}
		if (!status) {
			std::vector &lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; pomocni(2);
			pomocni[0]=*temp1;
			pomocni[1]=br_vrij1;
			matrica.push_back(pomocni);
		}
		temp1++;
	}
<a name="3"></a><font color="#00FFFF"><a href="match322-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	while (pocetak2 != kraj2) {
		T4 br_vrij2 = funkcija_kriterija(*pocetak2);
		bool status = false;
		T1 temp = pocetak1;
		while (temp != kraj1) {
			T4 br_vrij1 = funkcija_kriterija (*temp);
			if (Jednaki(br_vrij1, br_vrij2)) {
</font>				status = true;
				break;
			}
			temp++;
		}
		if (!status) {
			std::vector &lt;typename std::remove_reference&lt;decltype(*pocetak2)&gt;::type&gt; pomocni(2);
			pomocni[0] = *pocetak2;
			pomocni[1] = br_vrij2;
			matrica.push_back(pomocni);
		}
		pocetak2++;
	}
	
	std::sort (matrica.begin(), matrica.end(), [](typename std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; vek1,
	typename std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; vek2) {
		if (!Jednaki(vek1[0], vek2[0])) return vek1[0] &gt; vek2[0];
		return vek1[1] &gt; vek2[1];});
		return matrica;
}

template &lt;typename T1, typename T2&gt;
<a name="5"></a><font color="#FF0000"><a href="match322-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	auto UvrnutaRazlika (T1 pocetak1, T1 kraj1, T2 pocetak2, T2 kraj2) -&gt; typename std::vector&lt;std::vector &lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; {
</font>	typename std::vector&lt;std::vector &lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt;&gt; matrica;
	T1 temp1=pocetak1;
	while (temp1==kraj1) {
		bool status=false;
		T2 temp2 = pocetak2;
		while (temp2 != kraj2) {
			if (Jednaki(*temp1, *temp2)) {
				status = true;
				break;
			}
			temp2++;
		}
		if(!status) {
			std::vector &lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; pomocni(2);
			pomocni[0] = *temp1;
			pomocni[1] = 0;
			matrica.push_back(pomocni);
		}
		temp1++;
	}
	while (pocetak2 != kraj2) {
		bool status = false;
		T1 temp = pocetak1;
		while (temp != kraj1) {
			if(Jednaki(*temp, *pocetak2)) {
				status = true;
				break;
			}
			temp++;
		}
		if (!status) {
				std::vector &lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; pomocni(2);
				pomocni[0] = *pocetak2;
				pomocni[1] = 0;
				matrica.push_back(pomocni);
		}
		pocetak2++;
	}
	std::sort (matrica.begin(), matrica.end(), [](typename std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; vek1,
	typename std::vector&lt;typename std::remove_reference&lt;decltype(*pocetak1)&gt;::type&gt; vek2) {
		return vek1[0] &gt; vek2[0];});
		return matrica;
		
	}
	
int main ()
{
	int ukupno {};
	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	std::cin &gt;&gt; ukupno;
	std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
    std::deque&lt;int&gt; d1(ukupno);
    int unos {};
    
    for (int i = 0; i &lt; ukupno; i++) {
    	std::cin &gt;&gt; unos;
    	bool status = false;
    	
    	for (int j = 0; j &lt; d1.size(); j++) {
    		if (Jednaki(unos, d1[j])) {
    			status = true;
    			break;
    		}
    	}
    	if (!status) d1[i] = unos;
    	else i--;
    	}
    	
    int ukupno2 {};
    std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
    std::cin &gt;&gt; ukupno2;
    std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
    std::deque&lt;int&gt; d2 (ukupno2);
    
    for(int i = 0; i &lt; ukupno2; i++) {
    	std::cin &gt;&gt; unos;
    	bool status = false;
    	
    	for(int j = 0; j &lt; d1.size(); j++)
    	    if (Jednaki(unos, d2[j])) {
    	    	status = true;
    	    	break;
    	    }
    	    
    	 if (!status) d2[i] = unos;
    	 else i--;
    }
    
    std::vector&lt;std::vector&lt;int&gt;&gt; uvrnutiPresjek = UvrnutiPresjek(d1.begin(), d1.end(), d2.begin(), d2.end(), SumaCifara);
    std::vector&lt;std::vector&lt;int&gt;&gt; uvrnutaRazlika = UvrnutaRazlika(d1.begin(), d1.end(), d2.begin(), d2.end(), BrojProstihFaktora);
<a name="7"></a><font color="#0000FF"><a href="match322-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    std::cout &lt;&lt; "Uvrnuti presjek kontejnera: \n";	
    
    for (int i = 0; i &lt; uvrnutiPresjek.size(); i++) {
    	for (int j = 0; j &lt; uvrnutiPresjek[i].size(); j++) {
</font>    	    std::cout &lt;&lt; std::right &lt;&lt; std::setw(6) &lt;&lt; uvrnutiPresjek[i][j] &lt;&lt; " ";
    	}
    	    std::cout &lt;&lt; std::endl;
    }
    
<a name="8"></a><font color="#00FFFF"><a href="match322-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    std::cout &lt;&lt; "Uvrnuta razlika kontejnera: \n";
    for (int i = 0; i &lt; uvrnutaRazlika.size(); i++) {
    	for (int j = 0; j &lt; uvrnutaRazlika[i].size(); j++){
</font>    	    std::cout &lt;&lt; std::right &lt;&lt; std::setw(6) &lt;&lt; uvrnutaRazlika[i][j] &lt;&lt; " ";
    	}
    std::cout &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; "Dovidjenja!";
	return 0;

}</pre>
</body>
</html>
