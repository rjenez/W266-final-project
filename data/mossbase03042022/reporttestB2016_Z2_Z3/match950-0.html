<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student3424.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student3424.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

int SumaCifara(long long int n)
{
	int suma(0);
	while(n != 0)
	{
		suma += n%10;
		n /= 10;
	}
	return suma;
}

int SumaDjelilaca(long long int n)
{
	if(n &lt; 0) n *= -1; 
	else if(n == 0) return 0;
	int suma(0);
	for(int i(1); i &lt;= n; i++)
	{
		if(n%i == 0)
		  suma += i;
	}
	return suma;
}

int BrojProstihFaktora(long long int n)
{
	int br(0);
	for(int i(2); i &lt;= n; i++)
	{
		if(n%i == 0)
		{
			br++;
			n /= i;
			i = 1;
		}
	}
	return br;
}

bool Savrsen(long long int n)
{
	int suma(0);
	for(int i(1); i &lt; n; i++)
	{
		if(n%i == 0)
		  suma += i;
	}
	if(suma == n) return true;
	return false;
}

int BrojSavrsenihDjelilaca(long long int n)
{
	int br(0);
<a name="2"></a><font color="#0000FF"><a href="match950-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	for(int i(1); i &lt;= n; i++)
	{
	    if(n%i == 0)
	    {
	    	if(Savrsen(i))
	    	  br++;
		}
	}
	return br;
}

template&lt;typename Tip1, typename Tip2, typename TipF, typename TipP&gt;
auto UvrnutiPresjek(Tip1 poc1, Tip1 kra1, Tip2 poc2, Tip2 kra2, TipF f(TipP x)) -&gt; std::vector&lt;std::vector&lt;decltype(*poc1 + 0)&gt;&gt; 
</font><a name="3"></a><font color="#00FFFF"><a href="match950-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

{
	std::vector&lt;std::vector&lt;decltype(*poc1 + 0)&gt;&gt; mat;
</font>	while(poc1 != kra1)
	{
		Tip2 poc3(poc2), kra3(kra2);
		while(poc3 != kra3)
		{
			if(f(*poc1) == f(*poc3))
			{
				std::vector&lt;decltype(*poc1 + 0)&gt; v{*poc1, *poc3, f(*poc1)};
				mat.push_back(v);
			}
			poc3++;
		}
		poc1++;
	}
	
	std::sort(std::begin(mat), std::end(mat), [] (std::vector&lt;decltype(*poc1 + 0)&gt; x, std::vector&lt;decltype(*poc1 + 0)&gt; y)
	{if(x[2] == y[2]){if(x[0] == y[0]){return x[1] &lt; y[1];}return x[0] &lt; y[0];}return x[2] &lt; y[2];});
	return mat;
}

// Verzija sa 4 parametra
template&lt;typename Tip1, typename Tip2&gt;
<a name="0"></a><font color="#FF0000"><a href="match950-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

auto UvrnutiPresjek(Tip1 poc1, Tip1 kra1, Tip2 poc2, Tip2 kra2) -&gt; std::vector&lt;std::vector&lt;decltype(*poc1 + 0)&gt;&gt; 
{
	std::vector&lt;std::vector&lt;decltype(*poc1 + 0)&gt;&gt; mat;
</font>	while(poc1 != kra1)
	{
		Tip2 poc3(poc2), kra3(kra2);
		while(poc3 != kra3)
		{
			if(*poc1 == *poc3)
			{
				std::vector&lt;decltype(*poc1 + 0)&gt; v{*poc1, 0, 0};
				mat.push_back(v);
			}
			poc3++;
		}
		poc1++;
	}
	std::sort(std::begin(mat), std::end(mat), [] (std::vector&lt;decltype(*poc1 + 0)&gt; x, std::vector&lt;decltype(*poc1 + 0)&gt; y){return x[0] &lt; y[0];});
	return mat;
}

template&lt;typename Tip1, typename Tip2, typename TipF, typename TipP&gt;
<a name="4"></a><font color="#FF00FF"><a href="match950-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

auto UvrnutaRazlika(Tip1 poc1, Tip1 kra1, Tip2 poc2, Tip2 kra2, TipF f(TipP x)) -&gt; std::vector&lt;std::vector&lt;decltype(*poc1 + 0)&gt;&gt;
{
	std::vector&lt;std::vector&lt;decltype(*poc1 + 0)&gt;&gt; mat;
</font>	Tip1 Trenutni(poc1);
	while(Trenutni != kra1)
	{
		Tip2 pomocni(poc2);
		bool par(false);
		while(pomocni != kra2)
		{
			if(f(*Trenutni) == f(*pomocni))
			{
				par = true;
				break;
			}
			pomocni++;
		}
		if(par == false)
		{
			std::vector&lt;decltype(*poc1 + 0)&gt; v{*Trenutni, f(*Trenutni)};
			mat.push_back(v);
		}
		Trenutni++;
	}
	while(poc2 != kra2)
	{
		Tip2 pomocni(poc1);
		bool par(false);
		while(pomocni != kra1)
		{
			if(f(*poc2) == f(*pomocni))
			{
				par = true;
				break;
			}
			pomocni++;
		}
		if(par == false)
		{
			std::vector&lt;decltype(*poc1 + 0)&gt; v{*poc2, f(*poc2)};
			mat.push_back(v);
		}
		poc2++;
	}
	std::sort(std::begin(mat), std::end(mat), [] (std::vector&lt;decltype(*poc1 + 0)&gt; x, std::vector&lt;decltype(*poc1 + 0)&gt; y) 
												 {if(x[0] == y[0]){return x[1] &gt; y[1];} return x[0] &gt; y[0];});
	return mat;
}

// Verzija sa 4 parametra
template&lt;typename Tip1, typename Tip2&gt;
<a name="1"></a><font color="#00FF00"><a href="match950-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

auto UvrnutaRazlika(Tip1 poc1, Tip1 kra1, Tip2 poc2, Tip2 kra2) -&gt; std::vector&lt;std::vector&lt;decltype(*poc1 + 0)&gt;&gt;
{
	std::vector&lt;std::vector&lt;decltype(*poc1 + 0)&gt;&gt; mat;
</font>	Tip1 Trenutni(poc1);
	while(Trenutni != kra1)
	{
		Tip2 pomocni(poc2);
		bool par(false);
		while(pomocni != kra2)
		{
			if(*Trenutni == *pomocni)
			{
				par = true;
				break;
			}
			pomocni++;
		}
		if(par == false)
		{
			std::vector&lt;decltype(*poc1 + 0)&gt; v{*Trenutni, 0};
			mat.push_back(v);
		}
		Trenutni++;
	}
	while(poc2 != kra2)
	{
		Tip2 pomocni(poc1);
		bool par(false);
		while(pomocni != kra1)
		{
			if(*poc2 == *pomocni)
			{
				par = true;
				break;
			}
			pomocni++;
		}
		if(par == false)
		{
			std::vector&lt;decltype(*poc1 + 0)&gt; v{*poc2, 0};
			mat.push_back(v);
		}
		poc2++;
	}
	std::sort(std::begin(mat), std::end(mat), [] (std::vector&lt;decltype(*poc1 + 0)&gt; x, std::vector&lt;decltype(*poc1 + 0)&gt; y) {return x[0] &gt; y[0];});
	return mat;
}

template&lt;typename Tip&gt;
bool ImaLiGa(const std::deque&lt;Tip&gt; &amp;dek, int n)
{
	for(int i(0); i &lt; dek.size(); i++)
	{
		if(dek[i] == n)
		  return true;
	}
	return false;
}

template&lt;typename Tip&gt;
void Unos(std::deque&lt;Tip&gt; &amp;dek, int vel)
{
	int n;
	for(int i(0); i &lt; vel; i++)
	{
		std::cin &gt;&gt; n;
		if(ImaLiGa(dek, n) == false)
		  dek.push_back(n);
		else
		  i--;
	}
}

template&lt;typename Tip&gt;
void IspisiMatricu(const std::vector&lt;std::vector&lt;Tip&gt;&gt; &amp;mat)
{
	for(int i(0); i &lt; mat.size(); i++)
	{
		for(int j(0); j &lt; mat[i].size(); j++)
		{
			std::cout &lt;&lt; std::setw(6) &lt;&lt; mat[i][j] &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
	}
}

int main ()
{
	int vel;
	std::cout &lt;&lt; "Unesite broj elemenata prvog kontejnera: ";
	std::cin &gt;&gt; vel;
	std::cout &lt;&lt; "Unesite elemente prvog kontejnera: ";
	std::deque&lt;int&gt; cont1;
	Unos(cont1, vel);
	
	int vel2;
	std::cout &lt;&lt; "Unesite broj elemenata drugog kontejnera: ";
	std::cin &gt;&gt; vel2;
	std::cout &lt;&lt; "Unesite elemente drugog kontejnera: ";
	std::deque&lt;int&gt; cont2;
	Unos(cont2, vel2);
	
	std::cout &lt;&lt; "Uvrnuti presjek kontejnera:" &lt;&lt; std::endl;
	auto matP(UvrnutiPresjek(std::begin(cont1), std::end(cont1), std::begin(cont2), std::end(cont2), SumaCifara));
	IspisiMatricu(matP);
	
	std::cout &lt;&lt; "Uvrnuta razlika kontejnera:" &lt;&lt; std::endl;
	auto matR(UvrnutaRazlika(std::begin(cont1), std::end(cont1), std::begin(cont2), std::end(cont2), BrojProstihFaktora));
	IspisiMatricu(matR);
	std::cout &lt;&lt; "Dovidjenja!";
	return 0;
}</pre>
</body>
</html>
