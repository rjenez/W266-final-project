<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student3301.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student3301.cpp<p></p><pre>

/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke
	
	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
	
*/
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;type_traits&gt;


template &lt;typename PokTip1, typename PokTip2, typename Tip1, typename Tip2&gt;
std::vector&lt;std::vector&lt;Tip1&gt;&gt; UvrnutiPresjek(PokTip1 p1, PokTip1 p2, PokTip2 p3, PokTip2 p4, Tip2 f(Tip1) ){
	std::vector&lt;std::vector&lt;Tip1&gt;&gt; Matrica;
	int brojac(0);
	PokTip1 pok1(p1), pok2(p2);
	while(pok1!=pok2){
		PokTip2 pok3(p3);
		while(pok3!=p4){
			if(f(*pok1)==f(*pok3)){
				Matrica.resize(Matrica.size()+1);
				Matrica[Matrica.size()-1].resize(3);
				Matrica[brojac][0] = *pok1;
				Matrica[brojac][1] = *pok3;
				Matrica[brojac][2] = f(*pok1);
				brojac++;
			}
		pok3++;
		}
	pok1++;
	}



return Matrica;
}

template&lt;typename poktip1, typename poktip2&gt;
auto UvrnutiPresjek(poktip1 p1, poktip1 p2, poktip2 p3, poktip2 p4)-&gt;typename std::remove_reference&lt;std::vector&lt;std::vector&lt;decltype(*p1)&gt;&gt;&gt;::type{
	typename std::remove_reference&lt;std::vector&lt;std::vector&lt;decltype(*p1)&gt;&gt;&gt;::type Matrica;
	int brojac(0);
	poktip1 pok1(p1);
	while(pok1!=p2){
		poktip2 pok3(p3);
		while(pok3!=p4){
			if(*pok1==*pok3){
				Matrica.resize(Matrica.size()+1);
				Matrica[Matrica.size()-1].resize(3);
				Matrica[brojac][0] = *pok1;
				Matrica[brojac][1] = 0;
				Matrica[brojac][2] = 0;
				brojac++;
			}
			pok3++;
		}
		pok1++;
	}
	return Matrica;
}


template &lt;typename poktip1, typename poktip2, typename tip1, typename tip2&gt;
std::vector&lt;std::vector&lt;tip1&gt;&gt; UvrnutaRazlika (poktip1 p1, poktip1 p2, poktip2 p3, poktip2 p4, tip2 f(tip1)){
	std::vector&lt;std::vector&lt;tip1&gt;&gt; Matrica;
	int brojac(0);
	poktip1 pok1(p1);
<a name="1"></a><font color="#00FF00"><a href="match962-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	poktip2 pok3(p3);
	while(pok1!=p2) {
       pok3 = p3;
       while (pok3!=p4) {
       	  if(f(*pok1)==f(*pok3))
       	    break;
       	  pok3++;
       }
       if(pok3==p4){
       	Matrica.resize(Matrica.size()+1);
</font>       	Matrica[Matrica.size()-1].resize(2);
       	Matrica[brojac][0] = *pok1;
       	Matrica[brojac][1] = f(*pok1);
       	brojac++;
       }
       pok1++;
	}
	pok1 = p1;
	pok3 = p3;
<a name="3"></a><font color="#00FFFF"><a href="match962-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	while(pok3!=p4){
		pok1 = p1;
		while (pok1!=p2) {
			if(f(*pok3)==f(*pok1))
			  break;
			pok1++;
		}
	    if(pok1==p2){
	    	Matrica.resize(Matrica.size()+1);
</font>	    	Matrica[Matrica.size()-1].resize(2);
	    	Matrica[brojac][0] = *pok3;
	    	Matrica[brojac][1] = f(*pok3);
	    	brojac++;
	    }
	 pok3++;  
	}
return Matrica;
}

template &lt;typename poktip1, typename poktip2&gt;
auto UvrnutaRazlika(poktip1 p1, poktip1 p2, poktip2 p3, poktip2 p4)-&gt; typename std::remove_reference&lt;std::vector&lt;std::vector&lt;decltype(*p1)&gt;&gt;&gt;::type {
	typename std::remove_reference&lt;std::vector&lt;std::vector&lt;decltype(*p1)&gt;&gt;&gt;::type Matrica;
	poktip1 pok1(p1);
	poktip2 pok3(p3);
	int brojac(0);
<a name="4"></a><font color="#FF00FF"><a href="match962-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

	while(pok1!=p2){
		pok3 = p3;
		while(pok3!=p4){
			if(*pok1==*pok3)
			  break;
			pok3++;
		}
		if(pok3==p4){
			Matrica.resize(Matrica.size() + 1);
</font>			Matrica[Matrica.size() - 1].resize(2);
			Matrica[brojac][0] = *pok1;
			Matrica[brojac][1] = 0;
			brojac++;
		}
		pok1++;
	}
	pok1 = p1;
	pok3 = p3;
<a name="5"></a><font color="#FF0000"><a href="match962-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

	while(pok3!=p4){
		pok1 = p1;
		while (pok1!=p2) {
			if(*pok3==*pok1)
			  break;
			pok1++;
		}
		if(pok1==p2){
			Matrica.resize(Matrica.size() + 1);
</font>			Matrica[Matrica.size() - 1].resize(2);
			Matrica[brojac][0] = *pok3;
			Matrica[brojac][1] = 0;
			brojac++;
		}
	pok3++;
	}
	return Matrica;
}

int SumaDjelilaca (long long int n){
	int suma(0);
	for(int i=1; i&lt;=n; i++){
		if(n%i==0)
		  suma+=i;
	}
return suma;
}

int SumaCifara(long long int n){
	int suma(0);
	while(n!=0){
		suma+=std::abs(n%10);
		n/=10;
	}
return suma;
}


int BrojProstihFaktora (long long int n){
	int brojac(0);
	long long int a(n);
	//while(a!=0){
		for(int k=2; k&lt;=n; k++){
			bool z(true);
			for(int i=2; i&lt;k; i++){
				if(k%i==0){
					z = false;
					break;
				}
			}
		if(a%k==0 &amp;&amp; z){
			while(a%k==0){
				brojac++;
				a/=k;
			}
		}
		}
//	}
return brojac;
}

int BrojSavrsenihDjelilaca (long long int n){
	int brojac(0);
	//long long int a(n);
<a name="0"></a><font color="#FF0000"><a href="match962-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	for(int k=2; k&lt;=n; k++){
		if(n%k==0){
			int suma(0);
			for(int l=2; l&lt;k; l++){
				if(k%l==0)
				  suma+=l;
			}
		if(suma==k)
		   brojac++;
		}
	}
return brojac;	
</font>}




int main ()
{
	
	int n,m;
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	std::cin&gt;&gt;n;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	std::deque&lt;int&gt; dek1(n) ;
	for(int i=0; i&lt;n; i++)
	  std::cin&gt;&gt;dek1[i];
	std::cin.clear();
	std::cin.ignore(10000, '\n');
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;m;

	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	std::deque&lt;int&gt; dek2(m);
	for(int i=0; i&lt;m; i++)
	  std::cin&gt;&gt;dek2[i];
	auto mat1(UvrnutiPresjek(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), SumaCifara));
   // auto mat1(UvrnutiPresjek(dek1.begin(), dek1.end(), dek2.begin(), dek2.end() ));
<a name="2"></a><font color="#0000FF"><a href="match962-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	std::cout&lt;&lt;"Uvrnuti presjek kontejnera: "&lt;&lt;std::endl;
	for(int i=0; i&lt;mat1.size(); i++){
		for(int j=0; j&lt;mat1[i].size(); j++)
</font>		  std::cout&lt;&lt;mat1[i][j]&lt;&lt;" ";
		  
		std::cout&lt;&lt;std::endl;
	}
	auto mat2(UvrnutaRazlika(dek1.begin(), dek1.end(), dek2.begin(), dek2.end(), SumaCifara ));
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera: \n";
	for(int i=0; i&lt;mat2.size(); i++){
		for(int j=0; j&lt;mat2[i].size(); j++){
			std::cout&lt;&lt;mat2[i][j]&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	return 0;
}</pre>
</body>
</html>
