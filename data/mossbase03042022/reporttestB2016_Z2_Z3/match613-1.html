<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student8139.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student1649.cpp<p></p><pre>
/*B 16/17, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: i javni ATo-vi su dio postavke

	Autotestovi by Berina Cocalic. Sva pitanja, sugestije
	i prijave gresaka saljite na mail: bcocalic1@etf.unsa.ba
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;type_traits&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;iomanip&gt;
int SumaDjelilaca(long long int x){
	int Suma(0);
	if(x&lt;0){ for(int i=-1;i&gt;=x;i--) if(!(x%i)) Suma-=i;}
	else{ for(int i=1;i&lt;=x;i++) if(!(x%i)) Suma+=i;}
	return Suma;
}
int BrojProstihFaktora(long long int x){
	int Brojac(0);
	while(1){
		for(int i=2;i&lt;=x;i++) if(!(x%i)){
			Brojac++;
			x/=i;
			break;
		}
		if(x==1) break;
	}
	return Brojac;
}
int BrojSavrsenihDjelilaca(long long int x){
	int Brojac(0);
	for(int i=1;i&lt;=x;i++){
		if(!(x%i)){
			int Suma(0);
			for(int j=1;j&lt;i;j++) if(!(i%j)) Suma+=j;
			if(Suma==i) Brojac++;
		}
	}
	return Brojac;
}
int SumaCifara(long long int x){
	int Suma(0);
	while(x!=0){
		Suma+=x%10;
		x/=10;
	}
	if(Suma&lt;0) Suma=-Suma;
	return Suma;
}
template &lt;typename Tip1,typename Tip2,typename Tip3, typename Tip4&gt;
auto UvrnutiPresjek (Tip1 Pocetak1, Tip1 Kraj1, Tip2 Pocetak2, Tip2 Kraj2, Tip3 Funkcija (Tip4) ) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;&gt; Matrica;
	while(Pocetak1!=Kraj1){
		auto Pomocna(Pocetak2);
		while(Pomocna!=Kraj2){
			if(Funkcija(*Pocetak1)==Funkcija(*Pomocna)){
				Matrica.push_back(std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;());
				Matrica[Matrica.size()-1].push_back(*Pocetak1);
				Matrica[Matrica.size()-1].push_back(*Pomocna);
<a name="2"></a><font color="#0000FF"><a href="match613-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

				Matrica[Matrica.size()-1].push_back(Funkcija(*Pocetak1));
			}
			Pomocna++;
		}
		Pocetak1++;
	}
	std::sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt; v1,std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt; v2){if (v1[2]&lt;v2[2]) return true; else{ if(v1[2]==v2[2]){ if(v1[0]&lt;v2[0]) return true; else{ if(v1[0]==v2[0]) if(v1[1]&lt;v2[1]) return true;}}}  return false;});
</font><a name="0"></a><font color="#FF0000"><a href="match613-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	return Matrica;
</font>}
template &lt;typename Tip1,typename Tip2&gt;
auto UvrnutiPresjek (Tip1 Pocetak1, Tip1 Kraj1, Tip2 Pocetak2, Tip2 Kraj2)-&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;&gt; Matrica;
	while(Pocetak1!=Kraj1){
		auto Pomocna(Pocetak2);
		while(Pomocna!=Kraj2){
			if((*Pocetak1)==(*Pomocna)){
				Matrica.push_back(std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;());
				Matrica[Matrica.size()-1].push_back(*Pocetak1);
				Matrica[Matrica.size()-1].push_back(0);
<a name="4"></a><font color="#FF00FF"><a href="match613-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

				Matrica[Matrica.size()-1].push_back(0);
			}
			Pomocna++;
		}
		Pocetak1++;
	}
	std::sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt; v1,std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt; v2) {return v1[0]&lt;v2[0];} );
</font>	return Matrica;
}
template &lt;typename Tip1,typename Tip2,typename Tip3, typename Tip4&gt;
<a name="5"></a><font color="#FF0000"><a href="match613-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

auto UvrnutaRazlika(Tip1 Pocetak1, Tip1 Kraj1, Tip2 Pocetak2, Tip2 Kraj2, Tip3 Funkcija (Tip4) ) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;&gt; Matrica;
	auto Pomocna1(Pocetak1);
</font>	while(Pomocna1!=Kraj1){
		auto Pomocna2(Pocetak2);
		bool Jednaki(false);
		while(Pomocna2!=Kraj2){
			if(Funkcija(*Pomocna1)==Funkcija(*Pomocna2)){
				Jednaki=true;
				break;
			}
			Pomocna2++;
		}
		if(!Jednaki){
			Matrica.push_back(std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;());
			Matrica[Matrica.size()-1].push_back(*Pomocna1);
			Matrica[Matrica.size()-1].push_back(Funkcija(*Pomocna1));
		}
		Pomocna1++;
	}
<a name="1"></a><font color="#00FF00"><a href="match613-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	auto Pomocna2(Pocetak2);
	while(Pomocna2!=Kraj2){
		Pomocna1=Pocetak1;
		bool Jednaki(false);
		while(Pomocna1!=Kraj1){
			if(Funkcija(*Pomocna1)==Funkcija(*Pomocna2)){
				Jednaki=true;
				break;
			}
			Pomocna1++;
		}
		if(!Jednaki){
</font>			Matrica.push_back(std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;());
			Matrica[Matrica.size()-1].push_back(*Pomocna2);
			Matrica[Matrica.size()-1].push_back(Funkcija(*Pomocna2));
		}
		Pomocna2++;
	}
<a name="3"></a><font color="#00FFFF"><a href="match613-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	std::sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt; v1,std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt; v2){if (v1[0]&gt;v2[0]) return true; else if(v1[0]==v2[0]) if(v1[1]&gt;v2[1]) return true; return false; });
</font>	return Matrica;
}
template&lt;typename Tip1,typename Tip2&gt;
auto UvrnutaRazlika(Tip1 Pocetak1,Tip1 Kraj1,Tip2 Pocetak2, Tip2 Kraj2) -&gt; std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;&gt;{
	std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;&gt; Matrica;
	auto Pomocna1(Pocetak1);
	while(Pomocna1!=Kraj1){
		auto Pomocna2(Pocetak2);
		bool Jednaki(false);
		while(Pomocna2!=Kraj2){
			if(*Pomocna1==*Pomocna2){
				Jednaki=true;
				break;
			}
			Pomocna2++;
		}
		if(!Jednaki){
			Matrica.push_back(std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;());
			Matrica[Matrica.size()-1].push_back(*Pomocna1);
			Matrica[Matrica.size()-1].push_back(0);
		}
		Pomocna1++;
	}
	auto Pomocna2(Pocetak2);
<a name="6"></a><font color="#00FF00"><a href="match613-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	while(Pomocna2!=Kraj2){
		Pomocna1=Pocetak1;
		bool Jednaki(false);
		while(Pomocna1!=Kraj1){
			if(*Pomocna1==*Pomocna2){
				Jednaki=true;
				break;
			}
			Pomocna1++;
		}
		if(!Jednaki){
</font>			Matrica.push_back(std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt;());
			Matrica[Matrica.size()-1].push_back(*Pomocna2);
			Matrica[Matrica.size()-1].push_back(0);
		}
		Pomocna2++;
	}
	std::sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt; v1,std::vector&lt;typename std::remove_reference&lt;decltype(*Pocetak1)&gt;::type&gt; v2){if(v1[0]&gt;v2[0]) return true; return false;});
	return Matrica;
}
int main (){
	int Vel1,Vel2;
	std::deque&lt;int&gt; Dek1,Dek2;
	std::cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	std::cin&gt;&gt;Vel1;
	std::cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	while(Dek1.size()&lt;Vel1){
		int x;
		bool VecUnesen(false);
		std::cin&gt;&gt;x;
		for(auto &amp;y:Dek1) if(y==x){ VecUnesen=true; break;}
		if(!VecUnesen) Dek1.push_back(x);
	}
	std::cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	std::cin&gt;&gt;Vel2;
	std::cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	while(Dek2.size()&lt;Vel2){
		int x;
		bool VecUnesen(false);
		std::cin&gt;&gt;x;
		for(auto &amp;y:Dek2) if(y==x){ VecUnesen=true; break;}
		if(!VecUnesen) Dek2.push_back(x);
	}
	std::cout&lt;&lt;"Uvrnuti presjek kontejnera:\n";
	auto Presjek(UvrnutiPresjek(Dek1.begin(),Dek1.end(),Dek2.begin(),Dek2.end(), SumaCifara));
	for(auto &amp;x: Presjek){
		for(auto &amp;y: x){
			std::cout&lt;&lt;std::right&lt;&lt;std::setw(6)&lt;&lt;y&lt;&lt;" ";
		}	
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Uvrnuta razlika kontejnera:\n";
	auto Razlika(UvrnutaRazlika(Dek1.begin(),Dek1.end(),Dek2.begin(),Dek2.end(), BrojProstihFaktora));
	for(auto &amp;x: Razlika){
		for(auto &amp;y: x){
			std::cout&lt;&lt;std::right&lt;&lt;std::setw(6)&lt;&lt;y&lt;&lt;" ";
		}
		std::cout&lt;&lt;std::endl;
	}
	std::cout&lt;&lt;"Dovidjenja!";
	return 0;
}
</pre>
</body>
</html>
