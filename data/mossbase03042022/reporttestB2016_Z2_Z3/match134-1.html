<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2886.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4852.cpp<p></p><pre>
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;iomanip&gt;
#include&lt;algorithm&gt;
#include&lt;type_traits&gt;
#include&lt;deque&gt;
<a name="1"></a><font color="#00FF00"><a href="match134-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_21.gif"/></a>

int f(int x){
    int suma=0;
    int c;
    while(x!=0){
        c=abs(x%10);
        x=x/10;
        suma=suma+c;
    }
    return suma;
}
template&lt;typename tip1,typename tip2&gt;
auto UvrnutiPresjek(tip1 p1,tip1 k1,tip2 p2,tip2 k2)-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
    int n(0);
    std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;Matrica(n,std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;(3));
 	auto pomocni1(p1);
 	auto pomocni2(p2);
 	typename std::remove_reference&lt;decltype(*p1)&gt;::type output1; 
 	typename std::remove_reference&lt;decltype(*p2)&gt;::type output2;
 	while(pomocni1!=k1){
 	    output1=*pomocni1;
 	    while(pomocni2!=k2){
 	        output2=*pomocni2;
 	        if(output1==output2){
 	            n++;
 	            Matrica.resize(n);
 	            Matrica[n-1].push_back(*pomocni1);
 	            Matrica[n-1].push_back(0);
 	            Matrica[n-1].push_back(0);
 	        }
 	        pomocni2++;
 	    }
 	    pomocni1++;pomocni2=p2;
 	}
 		sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;a,std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;m){
</font><a name="0"></a><font color="#FF0000"><a href="match134-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_76.gif"/></a>

 	    if(a[2]&lt;m[2])
 	    return true;
 	    else return false;
 	});
 	return Matrica;
 }
 template&lt;typename tip1,typename tip2&gt;
auto UvrnutaRazlika(tip1 p1,tip1 k1,tip2 p2,tip2 k2)-&gt;std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;&gt;{
    int n(0);
    std::vector&lt;std::vector&lt;typename std::remove_reference&lt;decltype((*p1))&gt;::type&gt;&gt;Matrica(n,std::vector&lt;typename std::remove_reference&lt;decltype(*p1)&gt;::type&gt;(2));
 	auto pomocni1(p1);
 	int t=1;
 	auto pomocni2(p2);
 	typename std::remove_reference&lt;decltype(*p1)&gt;::type output1; 
 	typename std::remove_reference&lt;decltype(*p2)&gt;::type output2;
 	while(pomocni1!=k1){
 	    t=1;
 	    output1=*pomocni1;
 	    while(pomocni2!=k2){
 	        output2=*pomocni2;
 	        if(output1==output2){
 	            t=0;break;
 	        }
 	        pomocni2++;
 	    }
 	    if(t){
 	       n++;
 	            Matrica.resize(n);
 	            Matrica[n-1].push_back(*pomocni1);
 	            Matrica[n-1].push_back(0); 
 	    }
 	    pomocni1++;pomocni2=p2;
 	}
 	pomocni1=p1;pomocni2=p2;
 	while(pomocni2!=k2){
 	    t=1;
 	    output2=*pomocni2;
 	    while(pomocni1!=k1){
 	        output1=*pomocni1;
 	        if(output2==output1){
 	            t=0;break;
 	        }
 	        pomocni1++;
 	    }
 	    if(t){
 	       n++;
 	            Matrica.resize(n);
 	            Matrica[n-1].push_back(*pomocni2);
 	            Matrica[n-1].push_back(0); 
 	    }
 	    pomocni2++;pomocni1=p1;
 	}
  	sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;decltype(f(*p1))&gt;a,std::vector&lt;decltype(f(*p1))&gt;m){
 	    if(a[0]&gt;m[0]||(a[0]==m[0]&amp;&amp;a[1]&gt;m[1]))
 	    return true;
 	    else return false;
 	});
 	return Matrica;
 }
 template&lt;typename tip1,typename tip2,typename funkcija&gt;
auto UvrnutiPresjek(tip1 p1,tip1 k1,tip2 p2,tip2 k2,funkcija f)-&gt;std::vector&lt;std::vector&lt;decltype(f(*p1))&gt;&gt;{
    int n(0);
    std::vector&lt;std::vector&lt;decltype(f(*p1))&gt;&gt;Matrica(n,std::vector&lt;decltype(f(*p1))&gt;(3));
 	auto pomocni1(p1);
 	auto pomocni2(p2);
 	decltype(f(*p1)) output1; 
 	decltype(f(*p2)) output2;
 	while(pomocni1!=k1){
 	    output1=f(*pomocni1);
 	    while(pomocni2!=k2){
 	        output2=f(*pomocni2);
 	        if(output1==output2){
 	            n++;
 	            Matrica.resize(n);
 	            Matrica[n-1].push_back(*pomocni1);
 	            Matrica[n-1].push_back(*pomocni2);
 	            Matrica[n-1].push_back(output1);
 	        }
 	        pomocni2++;
 	    }
 	    pomocni1++;pomocni2=p2;
 	}
 	sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;decltype(f(*p1))&gt;a,std::vector&lt;decltype(f(*p1))&gt;m){
 	    if(a[2]&lt;m[2])
 	    return true;
 	    else return false;
 	});
 	return Matrica;
 }
 template&lt;typename tip1,typename tip2,typename funkcija&gt;
auto UvrnutaRazlika(tip1 p1,tip1 k1,tip2 p2,tip2 k2,funkcija f)-&gt;std::vector&lt;std::vector&lt;decltype(f(*p1))&gt;&gt;{
    int n(0);
    int t=1;
    std::vector&lt;std::vector&lt;decltype(f(*p1))&gt;&gt;Matrica(n,std::vector&lt;decltype(f(*p1))&gt;(2));
 	auto pomocni1(p1);
 	auto pomocni2(p2);
 	decltype(f(*p1)) output1; 
 	decltype(f(*p2)) output2;
 	while(pomocni1!=k1){
 	    t=1;
 	    output1=f(*pomocni1);
 	    while(pomocni2!=k2){
 	        output2=f(*pomocni2);
 	        if(output1==output2){
 	            t=0;break;
 	        }
 	        pomocni2++;
 	    }
 	    if(t){
 	         n++;
 	            Matrica.resize(n);
 	            Matrica[n-1].push_back(*pomocni1);
 	            Matrica[n-1].push_back(output1);
 	    }
 	    pomocni1++;pomocni2=p2;
 	}
 		while(pomocni2!=k2){
 	    t=1;
 	    output2=f(*pomocni2);
 	    while(pomocni1!=k1){
 	        output1=f(*pomocni1);
 	        if(output2==output1){
 	            t=0;break;
 	        }
 	        pomocni1++;
 	    }
 	    if(t){
 	         n++;
 	            Matrica.resize(n);
 	            Matrica[n-1].push_back(*pomocni2);
 	            Matrica[n-1].push_back(output1);
 	    }
 	    pomocni2++;pomocni1=p1;
 	}
 	sort(Matrica.begin(),Matrica.end(),[](std::vector&lt;decltype(f(*p1))&gt;a,std::vector&lt;decltype(f(*p1))&gt;m){
 	    if(a[0]&gt;m[0]||(a[0]==m[0]&amp;&amp;a[1]&gt;m[1]))
 	    return true;
 	    else return false;
 	});
 	return Matrica;
 }
int main ()
{
	return 0;
</font>}</pre>
</body>
</html>
