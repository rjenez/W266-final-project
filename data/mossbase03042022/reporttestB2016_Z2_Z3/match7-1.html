<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student2967.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z2/Z3/student4296.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cfloat&gt;
<a name="0"></a><font color="#FF0000"><a href="match7-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::string;
using std::deque;
int f(long long int a)
{
	int n(a),suma=0;
	while(n!=0) {
		suma+=n%10;
		n=n/10;
	}
	return suma;
}
int SumaDjelilaca(long long int a)
{
	int suma{};
	if(a&lt;0)
		a=fabs(a);
	for(int i=1; i&lt;=a; i++)
		if(a%i==0)
			suma+=i;
	return suma;
}
int BrojProstihFaktora(long long int a)
{
	
	int br{},b;
	int k=a%2;
	if(a==0)
		return 0;
	while(k==0) {
		b=a/2;
		a=b;
		k=a%2;
		br++;
	}
	for(int j=3; j&lt;=a; j+=2) {
		if(j&lt;=0)
			break;
		int k=a%j;
		while(k==0) {
			b=a/j;
			a=b;
			br++;
			k=a%j;
		}
		if(j==a)
			break;
	}
	return br;
}

int BrojSavrsenihDjelilaca(long long int a)
{
	int suma {},br {};
	for(int i=2; i&lt;=a; i++){
		if(a%i==0) {
			for(int j=1; j&lt;i; j++) {
				if(i%j==0) {
					suma+=j;
				}
			}
			if(suma==i)
				br++;
			suma=0;
		}
		if(i==a)
			break;
	}
	return br;
}
template &lt;typename tip1, typename tip2, typename tip3, typename tip4&gt;
auto UvrnutiPresjek(tip1 p1, tip1 k1, tip2 p2, tip2 k2, tip3 f(tip4))-&gt; vector&lt;vector&lt;decltype(*p1+0)&gt;&gt; {
	vector&lt;vector&lt;decltype(*p1+0)&gt;&gt; M;
	if(p1-k1==0) return M;
	else if(p2-k2==0) return M;
	auto poc1(p1);
	auto kraj1(k1);
	auto poc2(p2);
	auto kraj2(k2);
	int i{};
	while(p1!=k1) {
		while(p2!=k2) {
			if(fabs(f(*p1)-f(*p2))&lt;DBL_MIN) {
				M.resize(i+1);
				M[i].push_back(*p1);
				M[i].push_back(*p2);
				M[i].push_back(f(*p1));
				i++;
			}
			p2++;
		}
		p1++;
		p2=poc2;
	}
	p1=poc1;
	std::sort(M.begin(), M.end(),[](const std::vector&lt;decltype(*p1+0)&gt;&amp; a, const std::vector&lt;decltype(*p1+0)&gt;&amp; b) {
		if(fabs(a[2]-b[2])&lt;DBL_MIN) {
			if(fabs(a[0]-b[0])&lt;DBL_MIN) {
				if(fabs(a[1]-b[1])&lt;DBL_MIN)
					return false;
				else return a[1]&lt;b[1];
			} else return a[0]&lt;b[0];
		}
		return a[2]&lt;b[2];
	});
	for(int i=0; i&lt;int(M.size())-1; i++) {
		for(int j=i+1; j&lt;M.size(); j++)
			if(M[i]==M[j]) {
				M.erase(M.begin()+j);
				j--;
			}
	}
	return M;
}
template &lt;typename tip1, typename tip2&gt;
auto UvrnutiPresjek(tip1 p1, tip1 k1, tip2 p2, tip2 k2)-&gt; vector&lt;vector&lt;decltype(*p1+0)&gt;&gt; {
	vector&lt;vector&lt;decltype(*p1+0)&gt;&gt; M;
	if(p1-k1==0) return M;
	else if(p2-k2==0) return M;
	auto poc1(p1);
	auto kraj1(k1);
	auto poc2(p2);
	auto kraj2(k2);
	int i{};
	while(p1!=k1) {
		while(p2!=k2) {
			if(*p1==*p2) {
				M.resize(i+1);
				M[i].push_back(*p1);
				M[i].push_back(0);
				M[i].push_back(0);
				i++;
			}
			p2++;
		}
		p1++;
		p2=poc2;
	}
	p1=poc1;
	std::sort(M.begin(), M.end(),[](const std::vector&lt;decltype(*p1+0)&gt;&amp; a, const std::vector&lt;decltype(*p1+0)&gt;&amp; b) {
		if(fabs(a[2]-b[2])&lt;DBL_MIN) {
			if(fabs(a[0]-b[0])&lt;DBL_MIN) {
				if(fabs(a[1]-b[1])&lt;DBL_MIN)
					return false;
				else return a[1]&lt;b[1];
			} else return a[0]&lt;b[0];
		}
		return a[2]&lt;b[2];
	});
	for(int i=0; i&lt;int(M.size())-1; i++) {
		for(int j=i+1; j&lt;M.size(); j++)
			if(M[i]==M[j]) {
				M.erase(M.begin()+j);
				j--;
			}
	}

	return M;
}
template &lt;typename tip1, typename tip2,typename tip3, typename tip4&gt;
auto UvrnutaRazlika(tip1 p1, tip1 k1, tip2 p2, tip2 k2, tip3 f(tip4))-&gt; vector&lt;vector&lt;decltype(*p1+0)&gt;&gt; {
vector&lt;vector&lt;decltype(*p1+0)&gt;&gt;	M;	
	auto poc1(p1);
	auto kraj1(k1);
	auto poc2(p2);
	auto kraj2(k2);
	int i{};
	bool NemaPara=false;
	while(p1!=k1) {
		while(p2!=k2) {
			if(fabs(f(*p1)-f(*p2))&lt;DBL_MIN) {

				NemaPara=true;
			}
			p2++;
		}
		if(!NemaPara) {
			M.resize(i+1);
			M[i].push_back(*p1);
			M[i].push_back(f(*p1));
			i++;
		}
		NemaPara=false;
		p1++;
		p2=poc2;
	}
	p1=poc1;
	p2=poc2;
	while(p2!=k2) {

		while(p1!=k1) {
			if(fabs(f(*p1)-f(*p2))&lt;DBL_MIN) {

				NemaPara=true;
			}
			p1++;
		}
		if(!NemaPara) {

			M.resize(i+1);
			M[i].push_back(*p2);
			M[i].push_back(f(*p2));
			i++;

		}
		NemaPara=false;
		p2++;
		p1=poc1;
	}
	std::sort(M.begin(), M.end(),[](const vector&lt;decltype(*p1+0)&gt;&amp; a, const vector&lt;decltype(*p1+0)&gt; &amp; b) {
		if(fabs(a[0]-b[0])&lt;DBL_MIN)
			return (a[1]&gt;b[1]);
		else return a[0]&gt;b[0];
	});
	
	for(int i=0; i&lt;int(M.size())-1; i++) {
		for(int j=i+1; j&lt;M.size(); j++)
			if(M[i]==M[j]) {
				M.erase(M.begin()+j);
				j--;
			}
	}
	return M;
}
template &lt;typename tip1, typename tip2&gt;
auto UvrnutaRazlika(tip1 p1, tip1 k1, tip2 p2, tip2 k2)-&gt; vector&lt;vector&lt;decltype(*p1+0)&gt;&gt; {
vector&lt;vector&lt;decltype(*p1+0)&gt;&gt;	M;	
	auto poc1(p1);
	auto kraj1(k1);
	auto poc2(p2);
	auto kraj2(k2);
	int i{};
	bool NemaPara=false;
	while(p1!=k1) {
		while(p2!=k2) {
			if(fabs(*p1-*p2)&lt;DBL_MIN) {

				NemaPara=true;
			}
			p2++;
		}
		if(!NemaPara) {
			M.resize(i+1);
			M[i].push_back(*p1);
			M[i].push_back(0);
			i++;
		}
		NemaPara=false;
		p1++;
		p2=poc2;
	}
	p1=poc1;
	p2=poc2;
	while(p2!=k2) {

		while(p1!=k1) {
			if(fabs(*p1-*p2)&lt;DBL_MIN) {

				NemaPara=true;
			}
			p1++;
		}
		if(!NemaPara) {

			M.resize(i+1);
			M[i].push_back(*p2);
			M[i].push_back(0);
			i++;

		}
		NemaPara=false;
		p2++;
		p1=poc1;
	}
	std::sort(M.begin(), M.end(),[](const vector&lt;decltype(*p1+0)&gt;&amp; a, const vector&lt;decltype(*p1+0)&gt; &amp; b) {
		if(fabs(a[0]-b[0])&lt;DBL_MIN)
			return (a[1]&gt;b[1]);
		else return a[0]&gt;b[0];
	});
	
	for(int i=0; i&lt;int(M.size())-1; i++) {
		for(int j=i+1; j&lt;M.size(); j++)
			if(M[i]==M[j]) {
				M.erase(M.begin()+j);
				j--;
			}
	}
	return M;
}
int main ()
{
	int n1,n2;
	int i {},br {};
	cout&lt;&lt;"Unesite broj elemenata prvog kontejnera: ";
	cin&gt;&gt;n1;
	cout&lt;&lt;"Unesite elemente prvog kontejnera: ";
	bool ima=false;
	deque&lt;int&gt; D1;
	while(i!=n1) {
		cin&gt;&gt;br;
		for(int j=0; j&lt;D1.size(); j++)
			if(fabs(br-D1[j])&lt;DBL_MIN)
				ima=true;
		if(!ima) {
			D1.push_back(br);
			i++;
		}
		ima=false;
	}
	cout&lt;&lt;"Unesite broj elemenata drugog kontejnera: ";
	cin&gt;&gt;n2;
	cout&lt;&lt;"Unesite elemente drugog kontejnera: ";
	deque&lt;int&gt; D2;
	i=0;
	while(i!=n2) {
		cin&gt;&gt;br;
		for(int j=0; j&lt;D2.size(); j++)
			if(fabs(br-D2[j])&lt;DBL_MIN)
				ima=true;
		if(!ima) {
			D2.push_back(br);
			i++;
		}
		ima=false;
	}
	vector&lt;vector&lt;int&gt;&gt; P;
	P=UvrnutiPresjek(D1.begin(), D1.end(),D2.begin(), D2.end(),f);
	cout&lt;&lt;"Uvrnuti presjek kontejnera:"&lt;&lt;endl;
	for(int i=0; i&lt;P.size(); i++) {
		for(int j=0; j&lt;3; j++)
			cout&lt;&lt;std::setw(6)&lt;&lt;P[i][j]&lt;&lt;" ";
		cout&lt;&lt;endl;
	}
	vector&lt;vector&lt;int&gt;&gt; R;
	R=UvrnutaRazlika(D1.begin(), D1.end(),D2.begin(), D2.end(), BrojProstihFaktora);
	cout&lt;&lt;"Uvrnuta razlika kontejnera:"&lt;&lt;endl;
	for(int i=0; i&lt;R.size(); i++) {
		for(int j=0; j&lt;2; j++)
			cout&lt;&lt;std::setw(6)&lt;&lt;R[i][j]&lt;&lt;" ";
		cout&lt;&lt;endl;
	}
	cout&lt;&lt;"Dovidjenja!"&lt;&lt;endl;
</font>	return 0;
}</pre>
</body>
</html>
