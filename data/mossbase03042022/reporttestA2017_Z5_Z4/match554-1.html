<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z4/student7507.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z4/student6267.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct Prodavnica {
	char naziv[100];
<a name="2"></a><font color="#0000FF"><a href="match554-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

	int ID;
};
struct Artikal {
	char naziv[100];
	double cijena;
	int prodavnica;
};

int ucitaj_artikle(struct Artikal *niz, int kap)
{
	int ucitano;
	FILE* dat = fopen("artikli.bin", "rb");
</font>	if (!dat) {
		printf("Neuspjesno otvaranje datoteke!");
		exit(1);
	}
	ucitano = fread(niz, sizeof(struct Artikal), kap, dat);
	fclose(dat);
	return ucitano;
}

int ucitaj_prodavnice(struct Prodavnica *niz, int kap)
{
	FILE* dat = fopen("prodavnice.txt", "r");
	int j;
	char temp;
	if (!dat) {
		printf("Neuspjesno otvaranje datoteke!");
		exit(1);
	}
	int i=0;
	while (i&lt;kap) {
		j=-1;
		do {
			if(j&lt;99)
				j++;
			else {
				do {
					temp=fgetc(dat); // Ako dodje do 100tog elementa, pomjeramo pokazivac u datoteci do broja ne radeci nista vise sa nizom, da ne bi otisli van granica niza
				} while(temp!=',');
				break;
			}
			niz[i].naziv[j]=fgetc(dat);
		} while(niz[i].naziv[j]!=',' &amp;&amp; niz[i].naziv[j]!=EOF); // fgetc se koristi zbog moguceg postojanja razmaka
		niz[i].naziv[j]='\0';
		if (fscanf(dat, "%d\n", &amp;niz[i].ID)!=1)
			break;
		i++;
	}
	fclose(dat);
	return i;
}
int izbaci_skupe(struct Prodavnica *p, int np, struct Artikal *a,int na)
{
	float prosjecnacijenasvih=0, prosjecnacijenaprodavnice, sumasvih=0, sumaprodavnice;
	int i=0, brojartikala=0, brojartikalaprodavnice, j;
	for (i=0; i&lt;na; i++) {
		sumasvih+=a[i].cijena;
		brojartikala++;
	}
	if (brojartikala&gt;0) prosjecnacijenasvih=sumasvih/brojartikala;

	for (i=0; i&lt;np; i++) {
		sumaprodavnice=0;
		brojartikalaprodavnice=0;
<a name="1"></a><font color="#00FF00"><a href="match554-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

		prosjecnacijenaprodavnice=0;
		for(j=0; j&lt;na; j++) {
			if (a[j].prodavnica==p[i].ID) {
				sumaprodavnice+=a[j].cijena; // Ako se ID podudara sa brojem prodavnice artikla, onda dodajemo na sumu, i trazimo prosjecnu cijenu
</font>				brojartikalaprodavnice++;
			}
		}
		if (brojartikalaprodavnice&gt;0) prosjecnacijenaprodavnice=sumaprodavnice/brojartikalaprodavnice;
<a name="0"></a><font color="#FF0000"><a href="match554-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

		if (prosjecnacijenaprodavnice&gt;prosjecnacijenasvih) {
			for (j=i; j&lt;np-1; j++) // Standardni algoritam za izbacivanje iz niza
				p[j]=p[j+1];
			np--;
			i--;
		}
	}
	return np;
}
int sacuvaj (struct Prodavnica *p, int n, const char *ime_datoteke)
</font>{
	FILE* dat;
	dat=fopen(ime_datoteke, "wb");
	if (dat==NULL)
		return 0;
	int i;
	for(i=0; i&lt;n; i++) {
		fwrite(&amp;p[i], sizeof(struct Prodavnica), 1, dat);
		if (ferror(dat))
			return 0;
	}
	fclose(dat);
	return 1;
}
int main()
{
	int i, j;
	struct Prodavnica p[] = {
		{"Amko", 1},
		{"Bingo", 2},
		{"Konzum", 3},
	};
	struct Artikal a[] = {
		{"Kiseli kupus", 10, 4},
		{"Bickl", 1000, 5},
		{"Krastavci", 2, 4}
	};
	a[0].prodavnica=1;
	a[1].prodavnica=2;
	a[3].prodavnica=1;

	i = izbaci_skupe(p, 3, a, 3);
	for (j = 0; j &lt; i; ++j)
		printf ("%s, ID: %d\n", p[j].naziv, p[j].ID);
	return 0;
}
</pre>
</body>
</html>
