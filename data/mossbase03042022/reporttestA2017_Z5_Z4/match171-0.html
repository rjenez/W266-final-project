<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z4/student7977.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z4/student7977.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct Prodavnica {
    char naziv[100];
    int ID;
};
struct Artikal {
    char naziv[100];
    double cijena;
    int prodavnica;
};
 
int ucitaj_artikle (struct Artikal *niz, int kap)
{

	int i;
	FILE* otvori = fopen("artikli.bin", "rb");

	if(otvori==NULL) {
		printf("Navedena datoteka ne postoji!");
		exit(1);
	}

	i=0;
	while ((i&lt;kap) &amp;&amp; (fread(niz[i].naziv, 1, 20, otvori)==20) &amp;&amp; (fread(&amp;niz[i].cijena, 8, 1, otvori)==1) &amp;&amp; (fread(&amp;niz[i].prodavnica, 4, 1, otvori)==1))
		i++;

	fclose(otvori);
	return i;
}
 
int ucitaj_prodavnice(struct Prodavnica *niz, int kap)
{
    FILE* dat = fopen("prodavnice.txt", "r");
    int j;
    char temp;
    if (!dat) {
        printf("Neuspjesno otvaranje datoteke!");
        exit(1);
    }
    int i=0;
    while (i&lt;kap) {
        j=-1;
        do {
            if(j&lt;99)
                j++;
            else {
                do {
                    temp=fgetc(dat); // Ako dodje do 100tog elementa, pomjeramo pokazivac u datoteci do broja ne radeci nista vise sa nizom, da ne bi otisli van granica niza
                } while(temp!=',');
                break;
            }
<a name="1"></a><font color="#00FF00"><a href="match171-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

            niz[i].naziv[j]=fgetc(dat);
        } while(niz[i].naziv[j]!=',' &amp;&amp; niz[i].naziv[j]!=EOF); // fgetc se koristi zbog moguceg postojanja razmaka
        niz[i].naziv[j]='\0';
        if (fscanf(dat, "%d\n", &amp;niz[i].ID)!=1)
            break;
        i++;
</font>    }
    fclose(dat);
    return i;
}
int izbaci_skupe(struct Prodavnica *p, int np, struct Artikal *a,int na)
{
    float prosjecnacijenasvih=0, prosjecnacijenaprodavnice, sumasvih=0, sumaprodavnice;
<a name="0"></a><font color="#FF0000"><a href="match171-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

    int i=0, brojartikala=0, brojartikalaprodavnice, j;
    for (i=0; i&lt;na; i++) {
        sumasvih+=a[i].cijena;
        brojartikala++;
    }
    if (brojartikala&gt;0) prosjecnacijenasvih=sumasvih/brojartikala;
 
    for (i=0; i&lt;np; i++) {
        sumaprodavnice=0;
        brojartikalaprodavnice=0;
        prosjecnacijenaprodavnice=0;
        for(j=0; j&lt;na; j++) {
            if (a[j].prodavnica==p[i].ID) {
                sumaprodavnice+=a[j].cijena; // Ako se ID podudara sa brojem prodavnice artikla, onda dodajemo na sumu, i trazimo prosjecnu cijenu
                brojartikalaprodavnice++;
            }
        }
        if (brojartikalaprodavnice&gt;0) prosjecnacijenaprodavnice=sumaprodavnice/brojartikalaprodavnice;
</font><a name="2"></a><font color="#0000FF"><a href="match171-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

        if (prosjecnacijenaprodavnice&gt;prosjecnacijenasvih) {
            for (j=i; j&lt;np-1; j++) // Standardni algoritam za izbacivanje iz niza
                p[j]=p[j+1];
            np--;
            i--;
        }
    }
    return np;
}
int sacuvaj (struct Prodavnica *p, int n, const char *ime_datoteke)
</font>{
    FILE* dat;
    dat=fopen(ime_datoteke, "wb");
    if (dat==NULL)
        return 0;
    int i;
    for(i=0; i&lt;n; i++) {
        fwrite(&amp;p[i], sizeof(struct Prodavnica), 1, dat);
        if (ferror(dat))
            return 0;
    }
    fclose(dat);
    return 1;
}
int main()
{
    int i, j;
    struct Prodavnica p[] = {
        {"Amko", 1},
        {"Bingo", 2},
        {"Konzum", 3},
    };
    struct Artikal a[] = {
        {"Kiseli kupus", 10, 4},
        {"Bickl", 1000, 5},
        {"Krastavci", 2, 4}
    };
    a[0].prodavnica=1;
    a[1].prodavnica=2;
    a[3].prodavnica=1;
 
    i = izbaci_skupe(p, 3, a, 3);
    for (j = 0; j &lt; i; ++j)
        printf ("%s, ID: %d\n", p[j].naziv, p[j].ID);
    return 0;
}</pre>
</body>
</html>
