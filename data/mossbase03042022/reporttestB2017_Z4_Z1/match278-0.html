<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z4/Z1/student9451.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z4/Z1/student9451.cpp<p></p><pre>
<a name="1"></a><font color="#00FF00"><a href="match278-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_19.gif"/></a>

/B2017/2018: ZadaÄ‡a 4, Zadatak 1
#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;cmath&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;


const double pi=4*atan(1);
const double eps=0.000001;
bool Jednakost(double k1,double k2)
{
    return abs(k1-k2)&lt;eps*(abs(k1)+abs(k2));
}

class Kugla
{   
    double x,y,z,r;
    public:
    explicit Kugla(double r = 0):x(0),y(0),z(0)
    {
        r=0;
    }
    Kugla(double x, double y, double z, double r = 0):x(x),y(y),z(z),r(r){};
    explicit Kugla(const std::tuple&lt;double, double, double&gt; &amp;centar, double r = 0):
        x(get&lt;0&gt;(centar)),y(get&lt;1&gt;(centar)),z(get&lt;2&gt;(centar)),r(r){};
    double DajX() const{ return x;}
    double DajY() const{ return y;}
    double DajZ() const{ return z;}
    std::tuple&lt;double, double, double&gt; DajCentar() const
    {
        return make_tuple(x,y,z);
    }
    double DajPoluprecnik() const
    {
        return r;
    }
    double DajPovrsinu() const
    {
        return r*r*pi;
    }
    double DajZapreminu() const
    {
        return (4/3)*r*r*r*pi;
    }
    Kugla &amp;PostaviX(double x)
    {
        Kugla::x=x;
        return *this;
    }
    Kugla &amp;PostaviY(double y)
</font>    {
        Kugla::y=y;
        return *this;
    }
    Kugla &amp;PostaviZ(double z)
    {
        Kugla::z=z;
        return *this;
    }
    Kugla &amp;PostaviCentar(double x, double y, double z)
    {
        Kugla::x=x;
        Kugla::y=y;
        Kugla::z=z;
        return *this;
    }
<a name="0"></a><font color="#FF0000"><a href="match278-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_75.gif"/></a>

    Kugla &amp;PostaviCentar(const std::tuple&lt;double, double, double&gt; &amp;centar)
    {
        Kugla::x=get&lt;0&gt;(centar);
        Kugla::y=get&lt;1&gt;(centar);
        Kugla::z=get&lt;2&gt;(centar);
        return *this;
    }
    Kugla &amp;PostaviPoluprecnik(double r)
    {
        Kugla::r=r;
        return *this;
    }
    void Ispisi() const
    {
        cout&lt;&lt;"{("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;","&lt;&lt;z&lt;&lt;"),"&lt;&lt;r&lt;&lt;"}"&lt;&lt;endl;
    }
    
    void Transliraj(double delta_x, double delta_y, double delta_z)
    {
        x=x+delta_x;
        y=y+delta_y;
        z=z+delta_z;
    }
    friend bool DaLiSuIdenticne(const Kugla &amp;k1, const Kugla &amp;k2)
    {
        return Jednakost(k1.DajX(),k2.DajX()) &amp;&amp; Jednakost(k1.DajY(),k2.DajY()) &amp;&amp; 
            Jednakost(k1.DajZ(),k2.DajZ()) &amp;&amp; Jednakost(k1.DajPoluprecnik(),k2.DajPoluprecnik());
    }
    friend bool DaLiSuPodudarne(const Kugla &amp;k1, const Kugla &amp;k2)
    {
        return Jednakost(k1.DajPoluprecnik(),k2.DajPoluprecnik());
    }
    friend bool DaLiSuKoncentricne(const Kugla &amp;k1, const Kugla &amp;k2)
    {
        return Jednakost(get&lt;0&gt;(k1.DajCentar()),get&lt;0&gt;(k2.DajCentar()))
         &amp;&amp;    Jednakost(get&lt;1&gt;(k1.DajCentar()),get&lt;1&gt;(k2.DajCentar()))
         &amp;&amp;    Jednakost(get&lt;2&gt;(k1.DajCentar()),get&lt;2&gt;(k2.DajCentar()));
         
    }
   
    friend bool DaLiSeDodirujuIzvana(const Kugla &amp;k1, const Kugla &amp;k2)
    {
        if(k1.DajPoluprecnik()&lt;k2.DajPoluprecnik())
        {
           return Jednakost(k2.DajPoluprecnik()+k1.DajPoluprecnik(),RastojanjeCentara(k1,k2));
       
        }
        
        return Jednakost(k1.DajPoluprecnik()+k2.DajPoluprecnik(),RastojanjeCentara(k1,k2));
       
    }
    friend bool DaLiSeDodirujuIznutra(const Kugla &amp;k1, const Kugla &amp;k2)
    {
        
        if(k1.DajPoluprecnik()&lt;k2.DajPoluprecnik())
        {
           return Jednakost(k2.DajPoluprecnik()-k1.DajPoluprecnik(),RastojanjeCentara(k1,k2));
       
        }
        
        return Jednakost(k1.DajPoluprecnik()-k2.DajPoluprecnik(),RastojanjeCentara(k1,k2));
       
    }
   
    friend bool DaLiSePreklapaju(const Kugla &amp;k1, const Kugla &amp;k2)
    {
        
        
        return (k1.DajPoluprecnik()+k2.DajPoluprecnik()&lt;RastojanjeCentara(k1,k2)) 
            &amp;&amp; (k2.DajPoluprecnik()-k1.DajPoluprecnik()&gt;RastojanjeCentara(k1,k2));
                
       
    }
   
    friend bool DaLiSeSijeku(const Kugla &amp;k1, const Kugla &amp;k2)
    {
        if(k1.DajPoluprecnik()&lt;k2.DajPoluprecnik())
        {
           return (k2.DajPoluprecnik()+k1.DajPoluprecnik()&gt;RastojanjeCentara(k1,k2) &amp;&amp; k2.DajPoluprecnik()-k1.DajPoluprecnik()&lt;RastojanjeCentara(k1,k2));
       
        }
        
         return (k1.DajPoluprecnik()+k2.DajPoluprecnik()&gt;RastojanjeCentara(k1,k2) &amp;&amp; k1.DajPoluprecnik()-k2.DajPoluprecnik()&lt;RastojanjeCentara(k1,k2));
       
    }
   
    bool DaLiSadrzi(const Kugla &amp;k) const
    {
           return (this-&gt;DajPoluprecnik()&lt;RastojanjeCentara(*this,k)) 
               &amp;&amp; (k.DajPoluprecnik()&gt;RastojanjeCentara(*this,k));
                  
    }
   
    friend double RastojanjeCentara(const Kugla &amp;k1, const Kugla &amp;k2)
    {
       double r=sqrt((k2.DajX()-k1.DajX())*(k2.DajX()-k1.DajX())+(k2.DajY()-k1.DajY())*(k2.DajY()-k1.DajY())+(k2.DajZ()-k1.DajZ())*(k2.DajZ()-k1.DajZ()));
       return r;
    }
};



int main ()
{
   int n;
   cout&lt;&lt;"Unesite broj kugla: ";
   cin&gt;&gt;n;
   vector&lt;shared_ptr&lt;Kugla&gt;&gt; Lopte;
   
   for(int i=0;i&lt;n;i++)
   {
       cout&lt;&lt;"Unesite centar "&lt;&lt;i+1&lt;&lt;". kugle: ";
       int x,y,z;
       cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
       cout&lt;&lt;"Unesite poluprecnik "&lt;&lt;i+1&lt;&lt;". kugle: ";
       double  r;
       cin&gt;&gt;r;
       Lopte.push_back(make_shared&lt;Kugla&gt;(x,y,z,r));
   }
   
   cout&lt;&lt;"Unesite parametre translacije (delta_x,delta_y,delta_z): ";
   int dx,dy,dz;
   cin&gt;&gt;dx&gt;&gt;dy&gt;&gt;dz;
   transform(Lopte.begin(),Lopte.end(),Lopte.begin(),[dx,dy,dz](shared_ptr&lt;Kugla&gt; s)
   {
       s-&gt;Transliraj(dx,dy,dz);
       return s;
   });
   
   sort(Lopte.begin(),Lopte.end(),[](shared_ptr&lt;Kugla&gt; s1,shared_ptr&lt;Kugla&gt; s2)
            {
                double v1=s1-&gt;DajZapreminu();
                double v2=s2-&gt;DajZapreminu();
                
                return v1&lt;v2;
            }
       );
    
    cout&lt;&lt;"Kugle nakon obavljenje transformacije imaju sljedece vrijednosti: "&lt;&lt;endl;
    for_each(Lopte.begin(),Lopte.end(),[](shared_ptr&lt;Kugla&gt; s)
                {
                    s-&gt;Ispisi();
                }
            );
            
    auto s=max_element(Lopte.begin(),Lopte.end(),[](shared_ptr&lt;Kugla&gt;s1,shared_ptr&lt;Kugla&gt;s2)
                {
                    return s1-&gt;DajPovrsinu()&lt;s2-&gt;DajPovrsinu();    
                }
            );
    cout&lt;&lt;"Kugla sa najvecom povrsinom je: "; 
    s-&gt;get()-&gt;Ispisi();
    bool flag=0;int br=-1;
    
    vector&lt;shared_ptr&lt;Kugla&gt;&gt;::iterator it=Lopte.begin();
    vector&lt;shared_ptr&lt;Kugla&gt;&gt;::iterator it1=Lopte.end();
    
    for_each(Lopte.begin(),Lopte.end(),[&amp;flag,&amp;br,&amp;it,it1](shared_ptr&lt;Kugla&gt; s1)
            {   
                it++;
                for_each(it,it1,[&amp;flag,s1](shared_ptr&lt;Kugla&gt; s2)
                {
                    if(DaLiSeSijeku(*s1,*s2))
                    {   
                        flag=1;
                        cout&lt;&lt;"Presjecaju se kugle: ";
                        s1-&gt;Ispisi();
                        s2-&gt;Ispisi();
                    }
                });      
                
            });
     
    if(!flag) cout&lt;&lt;"Ne postoje kugle koje se presjecaju!";       
	return 0;
</font>}
</pre>
</body>
</html>
