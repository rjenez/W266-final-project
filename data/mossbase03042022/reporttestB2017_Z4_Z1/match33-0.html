<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z4/Z1/student5961.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z4/Z1/student5961.cpp<p></p><pre>
<a name="1"></a><font color="#00FF00"><a href="match33-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_28.gif"/></a>

/B2017/2018: ZadaÄ‡a 4, Zadatak 1
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;tuple&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

class Kugla {
    private:
        double x, y, z, r;
        /// additional functions and variables
		constexpr static double PI = 4 * atan(1);
		constexpr static double ERROR = std::pow(10, -10);
		
        void static checkCenter(const double&amp; _r) { if(_r &lt; 0) throw std::domain_error("Ilegalan poluprecnik"); }
        bool static _equal(const double&amp; x, const double&amp; y) { return std::fabs(x - y) &lt;= ERROR * (std::fabs(x) + std::fabs(y)); };
        double static _SQR(const double&amp; x) { return x*x; };
        double static _distance(const double&amp; x1, const double&amp; y1, const double&amp; z1, 
                            const double&amp; x2, const double&amp; y2, const double&amp; z2) { return _SQR(x1 - x2) + _SQR(y1 - y2) + _SQR(z1 - z2); }
        bool static CenterIn(const Kugla&amp; k1, const Kugla&amp; k2) { return RastojanjeCentara(k1, k2) &lt;= std::fabs(k1.r - k2.r) + ERROR; }
        bool static CenterOut(const Kugla&amp; k1, const Kugla&amp; k2) { return RastojanjeCentara(k1, k2) &gt; k1.r + k2.r - ERROR; }
    // public interface
    public:
        /// constructors
        explicit Kugla(double r = 0);
        Kugla(double x, double y, double z, double r = 0);
        explicit Kugla(const std::tuple&lt;double, double, double&gt; &amp;centar, double r = 0);
        
        /// inspectors
        double DajX() const { return x; };
        double DajY() const { return y; };
        double DajZ() const { return z; };
        std::tuple&lt;double, double, double&gt; DajCentar() const { return std::make_tuple(this-&gt;DajX(), this-&gt;DajY(), this-&gt;DajZ()); };
        double DajPoluprecnik() const { return r; };
        double DajPovrsinu() const { return 4 * PI * _SQR(this-&gt;DajPoluprecnik()); };
        double DajZapreminu() const { return this-&gt;DajPovrsinu() * this-&gt;DajPoluprecnik() / 3.; };
        void Ispisi() const;
        bool DaLiSadrzi(const Kugla &amp;k) const;
        
        /// mutators
        Kugla &amp;PostaviX(double x) { Kugla::x = x; return *this; };
        Kugla &amp;PostaviY(double y) { Kugla::y = y; return *this; };
        Kugla &amp;PostaviZ(double z) { Kugla::z = z; return *this; };
        Kugla &amp;PostaviCentar(double x, double y, double z) { return this-&gt;PostaviX(x).PostaviY(y).PostaviZ(z); };
        Kugla &amp;PostaviCentar(const std::tuple&lt;double, double, double&gt; &amp;centar) { return this-&gt;PostaviX(std::get&lt;0&gt;(centar)).PostaviY(std::get&lt;1&gt;(centar)).PostaviZ(std::get&lt;2&gt;(centar)); };
        Kugla &amp;PostaviPoluprecnik(double r) { checkCenter(r); Kugla::r = r; return *this; };
        void Transliraj(double delta_x, double delta_y, double delta_z);
        
        /// friend functions
        friend bool DaLiSuIdenticne(const Kugla &amp;k1, const Kugla &amp;k2);
</font>        friend bool DaLiSuPodudarne(const Kugla &amp;k1, const Kugla &amp;k2);
        friend bool DaLiSuKoncentricne(const Kugla &amp;k1, const Kugla &amp;k2);
        friend bool DaLiSeDodirujuIzvana(const Kugla &amp;k1, const Kugla &amp;k2);
        friend bool DaLiSeDodirujuIznutra(const Kugla &amp;k1, const Kugla &amp;k2);
<a name="0"></a><font color="#FF0000"><a href="match33-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_67.gif"/></a>

        friend bool DaLiSePreklapaju(const Kugla &amp;k1, const Kugla &amp;k2);
        friend bool DaLiSeSijeku(const Kugla &amp;k1, const Kugla &amp;k2);
        friend double RastojanjeCentara(const Kugla &amp;k1, const Kugla &amp;k2);
};

// implementation of constructors
Kugla::Kugla(double r) : x(0), y(0), z(0) {
    checkCenter(r);
    Kugla::r = r;
}
Kugla::Kugla(double x, double y, double z, double r) : x(x), y(y), z(z) {
    checkCenter(r);
    Kugla::r = r;
}
Kugla::Kugla(const std::tuple&lt;double, double, double&gt; &amp;centar, double r) : 
    x(std::get&lt;0&gt;(centar)), 
    y(std::get&lt;1&gt;(centar)),
    z(std::get&lt;2&gt;(centar)) {
    checkCenter(r);
    Kugla::r = r;
}
/// implementation of additional inspectors and mutators
void Kugla::Ispisi() const { 
    std::cout &lt;&lt; "{(" &lt;&lt; this-&gt;DajX() &lt;&lt; "," &lt;&lt;this-&gt;DajY() &lt;&lt; ","&lt;&lt;this-&gt;DajZ() &lt;&lt; "),"&lt;&lt;this-&gt;DajPoluprecnik() &lt;&lt;"}" &lt;&lt; std::endl; 
}
void Kugla::Transliraj(double delta_x, double delta_y, double delta_z) {
    this-&gt;PostaviX(this-&gt;DajX() + delta_x).PostaviY(this-&gt;DajY() + delta_y).PostaviZ(this-&gt;DajZ() + delta_z);
}
/// friend functions implementation
bool DaLiSuIdenticne(const Kugla &amp;k1, const Kugla &amp;k2) {
    return DaLiSuPodudarne(k1, k2) &amp;&amp; DaLiSuKoncentricne(k1, k2); 
}
bool DaLiSuPodudarne(const Kugla &amp;k1, const Kugla &amp;k2) {
    return Kugla::_equal(k1.DajPoluprecnik(), k2.DajPoluprecnik()); 
}
bool DaLiSuKoncentricne(const Kugla &amp;k1, const Kugla &amp;k2) {
    return Kugla::_equal(k1.DajX(), k2.DajX()) &amp;&amp; Kugla::_equal(k1.DajY(), k2.DajY()) &amp;&amp; Kugla::_equal(k1.DajZ(), k2.DajZ());
}
bool DaLiSeDodirujuIzvana(const Kugla &amp;k1, const Kugla &amp;k2) {
    return Kugla::_equal(RastojanjeCentara(k1, k2), k1.DajPoluprecnik() + k2.DajPoluprecnik()) &amp;&amp; 
            (Kugla::CenterOut(k1, k2));
}
bool DaLiSeDodirujuIznutra(const Kugla &amp;k1, const Kugla &amp;k2) {
    bool _return(false);
    
    if(Kugla::CenterIn(k1, k2))
        _return = Kugla::_equal(RastojanjeCentara(k1, k2) + k1.r, k2.r);
    if(!_return &amp;&amp; Kugla::CenterIn(k2, k1))
        _return = Kugla::_equal(RastojanjeCentara(k1, k2) + k2.r, k1.r);
    
    if(_return &amp;&amp; DaLiSuIdenticne(k1, k2) &amp;&amp; k1.r &gt; Kugla::ERROR)
        _return = false;
    return _return;
}
double RastojanjeCentara(const Kugla &amp;k1, const Kugla &amp;k2) {
    return std::sqrt(Kugla::_distance(k1.DajX(), k1.DajY(), k1.DajZ(), k2.DajX(), k2.DajY(), k2.DajZ()));
}
bool Kugla::DaLiSadrzi(const Kugla &amp;k) const {
    return Kugla::CenterIn(k, *this) &amp;&amp; r &gt;= RastojanjeCentara(k, *this) + k.r;
}
bool DaLiSePreklapaju(const Kugla &amp;k1, const Kugla &amp;k2) {
    return DaLiSeSijeku(k1, k2) || Kugla::CenterIn(k1, k2) || DaLiSeDodirujuIznutra(k1, k2) || DaLiSeDodirujuIzvana(k1, k2);
}
bool DaLiSeSijeku(const Kugla &amp;k1, const Kugla &amp;k2) {
    bool _return(false);
    
    if(Kugla::CenterIn(k1, k2))
        _return = k1.r + RastojanjeCentara(k1, k2) &gt; k2.r;
    else if(Kugla::CenterIn(k2, k1))
        _return = k2.r + RastojanjeCentara(k1, k2) &gt; k1.r;
    else 
        _return = RastojanjeCentara(k1, k2) &lt; k1.r + k2.r;
    
    return _return;
}

/// read function
Kugla UnesiKuglu(int id = 1) {
    double x, y, z, r;
    for(;;) {
        std::cout &lt;&lt; "Unesite centar " &lt;&lt; id &lt;&lt; ". kugle: "; std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        if(!std::cin) {
            std::cout &lt;&lt; "Neispravan centar\n"; 
            std::cin.clear(); std::cin.ignore(10000, '\n');
            continue;
        }
        std::cout &lt;&lt; "Unesite poluprecnik " &lt;&lt; id &lt;&lt; ". kugle: "; std::cin &gt;&gt; r;
        if(!std::cin || r &lt; 0) {
            std::cout &lt;&lt; "Ilegalan poluprecnik\n"; 
            if(!std::cin) { std::cin.clear(); std::cin.ignore(10000, '\n'); }
            continue;
        }
        break;
    } 
    return Kugla(x, y, z, r);
}

// main program logic
int main () {
    int n;
    std::vector&lt;std::shared_ptr&lt;Kugla&gt;&gt; _kugle;
    std::cout &lt;&lt; "Unesite broj kugla: "; 
    for(;;) {
        std::cin &gt;&gt; n;
        if(!std::cin || n &lt;= 0) {
            if(!std::cin) { std::cin.clear(); std::cin.ignore(10000, '\n'); }
            std::cout &lt;&lt; "Neispravan broj kugli, unesite ponovo!\n";
            continue;
        } break;
    }
    /// read spheres
    for(int i = 1; i &lt;= n; ++i)  _kugle.push_back(std::make_shared&lt;Kugla&gt;(UnesiKuglu(i)));
    /// transform spheres
    double dx, dy, dz;
    std::cout &lt;&lt; "Unesite parametre translacije (delta_x,delta_y,delta_z): "; 
    for(;;) {
        std::cin &gt;&gt; dx &gt;&gt; dy &gt;&gt; dz;
        if(!std::cin) {
            std::cout &lt;&lt; "Neispravni parametri translacije, unesite ponovo!\n";
            std::cin.clear(); std::cin.ignore(10000, '\n'); 
            continue;
        } break;
    }
    /// translate spheres
    std::transform(_kugle.begin(), _kugle.end(), _kugle.begin(), [dx, dy, dz](std::shared_ptr&lt;Kugla&gt; _kugla) {
        _kugla-&gt;Transliraj(dx, dy, dz);
        return _kugla;
    });
    /// sort spheres by volume
    std::sort(_kugle.begin(), _kugle.end(), [](const std::shared_ptr&lt;Kugla&gt; &amp;_kugla1, const std::shared_ptr&lt;Kugla&gt; &amp;_kugla2) {
        return _kugla1-&gt;DajZapreminu() &lt; _kugla2-&gt;DajZapreminu();
    });
    /// print spheres after transformation and sort
    std::cout &lt;&lt; "Kugle nakon obavljenje transformacije imaju sljedece vrijednosti: \n";
    std::for_each(_kugle.begin(), _kugle.end(), [](const std::shared_ptr&lt;Kugla&gt; &amp;_kugla) {
        _kugla-&gt;Ispisi(); 
    });
    /// find and print max element (by surface area)
    auto _max (std::max_element(_kugle.begin(), _kugle.end(), [](const std::shared_ptr&lt;Kugla&gt; &amp;_kugla1, const std::shared_ptr&lt;Kugla&gt; &amp;_kugla2) {
        return _kugla1-&gt;DajPovrsinu() &lt; _kugla2-&gt;DajPovrsinu();
    }));
    if(_max != _kugle.end()) { std::cout &lt;&lt; "Kugla sa najvecom povrsinom je: "; (*_max)-&gt;Ispisi(); }
    else std::cout &lt;&lt; "Kugla sa najvecom povrsinom nije pronadjena.\n";
    /// print spheres that intersect 
    bool _exists(false);
    std::vector&lt;std::shared_ptr&lt;Kugla&gt; &gt;::iterator _pos (_kugle.begin()), _end(_kugle.end());
    std::for_each(_kugle.begin(), _kugle.end(), [_kugle, &amp;_exists, &amp;_pos, &amp;_end](const std::shared_ptr&lt;Kugla&gt; &amp;_prev) {
       ++_pos;
       std::for_each(_pos, _end, [_prev, &amp;_exists](const std::shared_ptr&lt;Kugla&gt; &amp;_next)  {
            if(DaLiSeSijeku(*_prev, *_next)) {
                std::cout &lt;&lt; "Presjecaju se kugle: ";
                _prev-&gt;Ispisi();  
                _next-&gt;Ispisi();
                _exists = true;
            }
       });
    });
    if(!_exists) std::cout &lt;&lt; "Ne postoje kugle koje se presjecaju!";
</font>	return 0;
}</pre>
</body>
</html>
