<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z4/Z1/student1066.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z4/Z1/student1066.cpp<p></p><pre>
<a name="2"></a><font color="#0000FF"><a href="match182-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

/B2017/2018: Zadaća 4, Zadatak 1

#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;cmath&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

#define PI (atan(1)*4)
#define EPS 1e-10


typedef std::tuple&lt;double, double, double&gt; XYZ;

class Kugla
{
  double x,y,z,r;
public:

  explicit Kugla (double r = 0) {
    if (r&lt;0) throw std::domain_error ("Ilegalan poluprecnik");
    x=0;
    y=0;
    z=0;
    Kugla::r=r;
  }

  Kugla (double x, double y, double z, double r=0) {
</font>    if (r&lt;0) throw std::domain_error ("Ilegalan poluprecnik");
<a name="1"></a><font color="#00FF00"><a href="match182-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

    Kugla::x=x;
    Kugla::y=y;
    Kugla::z=z;
    Kugla::r=r;
  }

  explicit Kugla (const XYZ &amp;centar, double r = 0) {
    if (r&lt;0) throw std::domain_error ("Ilegalan poluprecnik");
    x=std::get&lt;0&gt;(centar);
    y=std::get&lt;1&gt;(centar);
    z=std::get&lt;2&gt;(centar);
    Kugla::r=r;
  }

  double DajX () const {
    return x;
  }

  double DajY () const {
    return y;
  }

  double DajZ () const {
    return z;
  }

  XYZ DajCentar () const {
    XYZ centar(std::tie (x,y,z));
    return centar;
  }

  double DajPoluprecnik () const {
    return r;
  }

  double DajPovrsinu () const {
    return 4*r*r*PI;
  }

  double DajZapreminu () const {
    return 4*r*r*r*PI/3;
</font>  }

  Kugla &amp;PostaviX (double x) {
    Kugla::x=x;
    return *this;
  }

  Kugla &amp;PostaviY (double y) {
    Kugla::y=y;
    return *this;
  }

  Kugla &amp;PostaviZ (double z) {
    Kugla::z=z;
    return *this;
  }

<a name="3"></a><font color="#00FFFF"><a href="match182-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

  Kugla &amp;PostaviCentar (double x, double y, double z) {
    Kugla::x=x;
    Kugla::y=y;
    Kugla::z=z;
    return *this;
  }

  Kugla &amp;PostaviCentar(const XYZ &amp;centar) {
    PostaviCentar(std::get&lt;0&gt;(centar),std::get&lt;1&gt;(centar), std::get&lt;2&gt;(centar));
    return *this;
  }

  Kugla &amp;PostaviPoluprecnik (double r) {
    if (r&lt;0) throw std::domain_error ("Ilegalan poluprecnik");
</font>    Kugla::r=r;
    return *this;
  }

  void Ispisi () const {
<a name="0"></a><font color="#FF0000"><a href="match182-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_72.gif"/></a>

    std::cout&lt;&lt;"{("&lt;&lt;DajX()&lt;&lt;","&lt;&lt;DajY()&lt;&lt;","&lt;&lt;DajZ()&lt;&lt;"),"&lt;&lt;DajPoluprecnik()&lt;&lt;"}" &lt;&lt;std::endl;
  }

  void Transliraj (double delta_x, double delta_y, double delta_z) {
    PostaviCentar(x+delta_x,y+delta_y, z+delta_z);
  }
// ? ? ? da li se moze uporedjivati tuple koji sadrzi double
  friend bool DaLiSuIdenticne (const Kugla &amp;k1, const Kugla &amp;k2) {
    if (k1.DajCentar()==k2.DajCentar() &amp;&amp; fabs(k1.DajPoluprecnik()-k2.DajPoluprecnik()) &lt;= EPS*( fabs(k1.DajPoluprecnik()) + fabs(k2.DajPoluprecnik()) )) return true;
    return false;
  }  
  
  friend bool DaLiSuPodudarne (const Kugla &amp;k1, const Kugla &amp;k2) {
    if (k1.DajPoluprecnik()&lt;EPS &amp;&amp; k2.DajPoluprecnik()&lt;EPS) return true;
    return fabs(k1.DajPoluprecnik()-k2.DajPoluprecnik()) &lt; EPS*( fabs(k1.DajPoluprecnik()) + fabs(k2.DajPoluprecnik()) );
    }
    
  friend bool DaLiSuKoncentricne (const Kugla &amp;k1, const Kugla &amp;k2) {
      return (k1.DajCentar()==k2.DajCentar());
    }
  
  friend bool DaLiSeDodirujuIzvana (const Kugla &amp;k1, const Kugla &amp;k2){
    if (DaLiSuKoncentricne(k1,k2) &amp;&amp; k1.DajPoluprecnik()&lt;EPS &amp;&amp; k2.DajPoluprecnik()&lt;EPS) return true;
    if ( fabs( RastojanjeCentara(k1,k2) - (k1.DajPoluprecnik()+k2.DajPoluprecnik())) &lt; EPS* (fabs(RastojanjeCentara(k1,k2))
    + fabs (k1.DajPoluprecnik()+k2.DajPoluprecnik()) ) )return true;
    return false;
  } // Izvana se dodiruju akko im je rastojanje centara jednako zbiru poluprecnika
  
  friend bool DaLiSeDodirujuIznutra (const Kugla &amp;k1, const Kugla &amp;k2){
    // mora vaziti da je rastojanje centara + poluprecnik manje kugle == poluprecniku vece kugle
    if (DaLiSuKoncentricne(k1,k2) &amp;&amp; k1.DajPoluprecnik()&lt;EPS &amp;&amp; k2.DajPoluprecnik()&lt;EPS) return true;
    if (DaLiSuIdenticne(k1,k2)) return false;  // ako su iste kugle onda se ne dodiruju iznutra jer imaju beskonacno mnogo tacaka dodira a po definiciji je dodir dvije kugle kad postoji jedna zajednicka tacka
    if (k1.DajPoluprecnik()&lt;k2.DajPoluprecnik()) 
    if ( fabs(RastojanjeCentara(k1,k2)+k1.DajPoluprecnik() - k2.DajPoluprecnik()) &lt; EPS*( fabs(RastojanjeCentara(k1,k2)+k1.DajPoluprecnik() ) + fabs(k2.DajPoluprecnik()) ) ) return true;
    else return false;
    else 
    if ( fabs(RastojanjeCentara(k1,k2)+k2.DajPoluprecnik() - k1.DajPoluprecnik()) &lt; EPS*( fabs(RastojanjeCentara(k1,k2)+k2.DajPoluprecnik() ) + fabs(k1.DajPoluprecnik()) ) ) return true;
    return false;
  }
  
  friend bool DaLiSePreklapaju (const Kugla &amp;k1, const Kugla &amp;k2){
    // preklapaju se akko je rastojanje centara manji od zbira poluprecnika
    if (DaLiSuIdenticne(k1,k2)) return false;
    return RastojanjeCentara(k1,k2) &lt; (k1.DajPoluprecnik()+k2.DajPoluprecnik());
  }  // trebace popraviti
  
  friend bool DaLiSeSijeku (const Kugla &amp;k1, const Kugla &amp;k2){
    if (DaLiSuKoncentricne(k1,k2) &amp;&amp; k1.DajPoluprecnik()&lt;EPS &amp;&amp; k2.DajPoluprecnik()&lt;EPS) return false;
    if (DaLiSuIdenticne(k1,k2)) return true; // ako su dvije kugle identicne onda se one i sjeku
    // dvije kugle se sjeku akko je rastojanje između centara manje od zbira poluprecnika dvije kugle i rastojanje centara je vece od apsolutne vrijednosti razlike poluprecnika jer u suptortnom bi se jedna kugla mogla u cijelosti nalaziti druge kugle
    if ((RastojanjeCentara(k1,k2) &lt; (k1.DajPoluprecnik()+k2.DajPoluprecnik())) &amp;&amp; RastojanjeCentara(k1,k2) &gt;
    fabs (k1.DajPoluprecnik()-k2.DajPoluprecnik()) ) return true; 
    return false;
  }  // trebace popraviti
  
  bool DaLiSadrzi (const Kugla &amp;k) {
    return ( (RastojanjeCentara(k,*this) - DajPoluprecnik()) + k.DajPoluprecnik() &lt;= EPS);
  }

  friend double RastojanjeCentara (const Kugla &amp;k1, const Kugla &amp;k2);
};

double Kvadrat(double x) {
  return x*x;
}

double RastojanjeCentara(const Kugla &amp;k1, const Kugla &amp;k2) {
  return sqrt( Kvadrat( k1.DajX() - k2.DajX() ) + Kvadrat( k1.DajY() - k2.DajY() ) + Kvadrat ( k1.DajZ() - k2.DajZ() ) );
}

typedef std::vector&lt;std::shared_ptr&lt;Kugla&gt;&gt; VektorPametnihKugli;
typedef std::shared_ptr&lt;Kugla&gt; PametnaKugla;

int main ()
{
  /*
  Kugla kugla (2,0,0,2);
  XYZ tapl (1,2,3);
  Kugla kugla2 (2,0,0,2);
  //std::cout&lt;&lt;"R="&lt;&lt;kugla.DajPoluprecnik()&lt;&lt;" X="&lt;&lt;kugla.DajX()&lt;&lt;" Y="&lt;&lt;kugla.DajY()&lt;&lt;" Z="&lt;&lt;kugla.DajZ()&lt;&lt;std::endl;
  kugla.Ispisi();
  std::cout&lt;&lt;std::endl;
  kugla.PostaviX(2).PostaviY(3).PostaviZ(5).PostaviPoluprecnik(6);
  kugla.Ispisi();
  std::cout&lt;&lt;std::endl;
  kugla2.Ispisi();
  std::cout&lt;&lt;std::endl;
  kugla2.PostaviCentar(12,12,13);
  kugla2.Ispisi();
  std::cout&lt;&lt;std::endl;
  kugla2.PostaviCentar(tapl);
  kugla2.Ispisi();
  std::cout&lt;&lt;std::endl;
  kugla.PostaviCentar(4,0,0).PostaviPoluprecnik(2);
  kugla2.PostaviCentar(4,0,0).PostaviPoluprecnik(2);
  std::cout&lt;&lt;std::boolalpha&lt;&lt;"Da li su identicne: "&lt;&lt;DaLiSuIdenticne(kugla, kugla2)&lt;&lt;//" \nRastojanje centara: "&lt;&lt;RastojanjeCentara(kugla, kugla2)&lt;&lt;
  " \nDa li se dodiruju izvana: "&lt;&lt;DaLiSeDodirujuIzvana(kugla, kugla2)&lt;&lt;" \nDa li se dodiruju iznutra: "&lt;&lt;DaLiSeDodirujuIznutra(kugla, kugla2)&lt;&lt;
  " \nDa li se preklapaju: "&lt;&lt;DaLiSePreklapaju(kugla, kugla2)&lt;&lt;" \nDa li se sjeku: "&lt;&lt;DaLiSeSjeku(kugla2,kugla)&lt;&lt;" \nDa li su podudarne: "&lt;&lt;
  DaLiSuPodudarne(kugla,kugla2)&lt;&lt;" \nDa li su koncentricne: "&lt;&lt;DaLiSuKoncentricne(kugla,kugla2)&lt;&lt;"\nDa li sadrzi: "&lt;&lt;
  kugla.Kugla::DaLiSadrzi(kugla2);*/
  
 try {
    int n;
    std::cout&lt;&lt;"Unesite broj kugla: ";
    while(1){
    std::cin&gt;&gt;n;
    if (n&lt;=0 || !std::cin || std::cin.peek()!='\n') {
      std::cout&lt;&lt;"Neispravan broj kugli, unesite ponovo!"&lt;&lt;std::endl;
      std::cin.clear();
      std::cin.ignore(10000,'\n');
    }
    else break;
    }
    VektorPametnihKugli kugle (n,nullptr);  // 

    for (int i = 0; i&lt;n; i++){
      double x,y,z,r;
      
        std::cout&lt;&lt;"Unesite centar "&lt;&lt;i+1&lt;&lt;". kugle: ";
        std::cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
        if (!std::cin) {
          std::cin.clear();
        std::cin.ignore(10000,'\n');
          std::cout&lt;&lt;"Neispravan centar \n"; i--; continue;
        }
        kugle.at(i) = PametnaKugla (new Kugla(0));
          
        try {
        kugle.at(i)-&gt;PostaviCentar(x,y,z);
        std::cout&lt;&lt;"Unesite poluprecnik "&lt;&lt;i+1&lt;&lt;". kugle: ";
        std::cin&gt;&gt;r;
        if (!std::cin) {
          std::cin.clear();
          std::cin.ignore(10000,'\n');
          std::cout&lt;&lt;"Ilegalan poluprecnik \n"; i--; continue;
        }
        kugle.at(i)-&gt;PostaviPoluprecnik(r);}
        catch (std::domain_error izuzetak) {
          std::cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
          i--;
        }
    }
        // također implementirati za pogresno unesene podatke
      std::cout&lt;&lt;"Unesite parametre translacije (delta_x,delta_y,delta_z): ";
      
      double delta_x,delta_y,delta_z;
      while (1){
      std::cin&gt;&gt;delta_x&gt;&gt;delta_y&gt;&gt;delta_z;
      if (!std::cin){
        std::cout&lt;&lt;"Neispravni parametri translacije, unesite ponovo!"&lt;&lt;std::endl;
        std::cin.clear();
        std::cin.ignore(10000,'\n');
      }
      else break;
      }
      VektorPametnihKugli::iterator it(kugle.begin()); // postavljam iterator na pocetak vektora pametnih kugli
      
      std::transform (it, it+n,it, [delta_x,delta_y,delta_z] (PametnaKugla k1) {
        k1-&gt;Transliraj(delta_x,delta_y,delta_z);
        return k1;
      });
      
      std::sort (it, it+n, [] (PametnaKugla k1, PametnaKugla k2){
        return k1-&gt;DajZapreminu()&lt;k2-&gt;DajZapreminu();
      });
      
      std::cout&lt;&lt;"Kugle nakon obavljenje transformacije imaju sljedece vrijednosti: \n";
      std::for_each (it, it+n, [] (PametnaKugla k) {
        k-&gt;Ispisi();
      });
      
      std::cout&lt;&lt;"Kugla sa najvecom povrsinom je: ";
      VektorPametnihKugli::iterator max = std::max_element (it, it+n, [] (PametnaKugla k1, PametnaKugla k2){
        return k1-&gt;DajPovrsinu() &lt; k2-&gt;DajPovrsinu();
      });
      
      (*max)-&gt;Ispisi();  // Ispisuje kuglu sa najvecom povrsinom
      std::cout&lt;&lt;std::endl;
      int brojac(1);
      bool nema(true);
      std::for_each(it, it+n, [&amp;brojac,kugle,&amp;nema] (PametnaKugla k1){
       
        std::for_each (kugle.begin()+brojac, kugle.end(), [k1,&amp;nema] (PametnaKugla k2){
              if (DaLiSeSijeku(*k1,*k2)) {
                nema=false;
                std::cout&lt;&lt;"Presjecaju se kugle: ";
                k1-&gt;Ispisi();
                std::cout&lt;&lt;std::endl;
                k2-&gt;Ispisi();
                std::cout&lt;&lt;std::endl;
              }    
        }); 
        brojac++;
      }
    );
    if (nema) std::cout&lt;&lt;"Ne postoje kugle koje se presjecaju!";
  }
    
  catch (std::domain_error izuzetak){
    std::cout&lt;&lt;izuzetak.what();
</font>  }
  return 0;
}
</pre>
</body>
</html>
