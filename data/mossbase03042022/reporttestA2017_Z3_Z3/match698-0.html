<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z3/student4949.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z3/student4949.c<p></p><pre>
#include &lt;stdio.h&gt;
#define BREL 1000
#define BRCIF 1000

<a name="1"></a><font color="#00FF00"><a href="match698-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

int izbaci_cifre(int niz1[],  int n1, int niz2[], int n2)
{

	int i, j, temp, novibroj, koeficijent_cifre, cifra;
</font>
	if (n2&gt;10) {
		return 0;  /*Najjednostavniji uslov za provjeriti jer postoji samo 10 jednocifrenih brojeva, a to znaci da ako imamo vi≈°e od 10
		clanova tog niza, neke od cifara se moraju ponavljati ili mozda nisu cjelobrojni jednocifreni clanovi. U tom slucaju fja vraca 0.*/
	}
	for(i=0; i&lt;n2; i++) {
		if(niz2[i]&lt;0 || niz2[i]&gt;9)
			return 0;
	}

	for(i=0; i&lt;n2; i++) {
<a name="0"></a><font color="#FF0000"><a href="match698-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

		for(j=i+1; j&lt;n2; j++) {
			if(niz2[i]==niz2[j])	/*Provjerava ukoliko imamo 2 iste cifre u nizu cifara*/
				return 0;
		}
	}
	/* "novibroj" cemo koristiti kako bi neometano prolazili kroz sve cifre broja preko varijable "temp" dok u "novibroj" spremamo sve cifre
	koje trebaju ostati u broju pomnozene s odgovarajucim koeficijentom. */
	for(i=0; i&lt;n1; i++) {
		for(j=0; j&lt;n2; j++) {
			novibroj=0;
			koeficijent_cifre=1;   /* Prvim djeljenjem nekog broja sa 10 dobijamo jednocifren ostatak tako da koeficijent cifre koju posmatramo
									pocinje sa 1, a kasnije se mnozi sa 10 iduci prema deseticama, stoticama itd. */
			if(niz1[i]&lt;0)
				temp=-1*niz1[i];  /* Poredimo samo cifre, a ne kompletne brojeve, pa ukoliko je neki od brojeva negativan, treba ga pretvoriti u pozitivan,
</font>									ali bez modifikovanja niza, da nam se ne bi desilo da neka cifra ne bude izbacena jer je ostao minus ispred nje*/
			else
				temp=niz1[i];
			while(temp!=0) {
				cifra=temp%10;
				temp=temp/10;   /*Sve varijable su cjelobrojne, stoga nema potrebe uzimanja (int) dijela za skracivanje broja.*/
				if(cifra!=niz2[j]) {
					novibroj=novibroj+(koeficijent_cifre*cifra);
					koeficijent_cifre=koeficijent_cifre*10;
				}
			}

			if(niz1[i]&lt;0)
				niz1[i]=novibroj*(-1); /*Ukoliko je broj bio negativan na pocetku, mora biti negativan i poslije izbacivanja cifara*/
			else
				niz1[i]=novibroj;  /* Broj i-tog indeksa poslije promjene sada odgovara novom broju i kao takav je spremljen u novi niz*/
		}
	}
	return 1;
}
int main()
{
<a name="2"></a><font color="#0000FF"><a href="match698-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

	int nizbrojeva[BREL], nizcifara[BRCIF], nBr, nCif, i;

	printf("Unesite broj elemenata prvog niza: \n");
	scanf("%d", &amp;nBr);

	printf("Unesite niz cijelih brojeva: \n");
	for(i=0; i&lt;nBr; i++)
		scanf("%d", &amp;nizbrojeva[i]);
</font>
	printf("Unesite broj cifara drugog niza: \n");
	scanf("%d", &amp;nCif);

	printf("Unesite niz cifara: ");
	for(i=0; i&lt;nCif; i++)
		scanf("%d", &amp;nizcifara[i]);

	izbaci_cifre(&amp;nizbrojeva[0], nBr, &amp;nizcifara[0], nCif);
	printf("Niz brojeva glasi:");
	for(i=0; i&lt;nBr; i++) {
		printf("%d ", nizbrojeva[i]);
	}
	return 0;
}
</pre>
</body>
</html>
