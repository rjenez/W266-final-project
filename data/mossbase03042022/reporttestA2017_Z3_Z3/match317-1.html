<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z3/student8860.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z3/Z3/student9613.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

<a name="1"></a><font color="#00FF00"><a href="match317-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_23.gif"/></a>

int izbaci_cifre (int *niz, int vel, int *red, int vel1)
{

	int i=0, j, k=0, s=0, l, niz1[100]= {0}, znak=0;
	/* Provjeravamo da li su cifre u trazenom opsegu */
	for(i=0; i&lt;vel1; i++)
		if(red[i]&lt;0 || red[i]&gt;9)
</font>			return 0;

	for(i=0; i&lt;vel1; i++) {
		for(j=i+1; j&lt;vel1; j++)
<a name="0"></a><font color="#FF0000"><a href="match317-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_65.gif"/></a>

			if(red[i]==red[j])
				return 0;
	}

	for(s=0; s&lt;vel; s++) {
		/* Korisitimo promjenljivu znak koju postavljamo na 1 ako je clan niza negativan, a ostaje nula ako je clan niza pozitivan */
		znak=0;
		if(niz[s]&lt;0)
			znak=1;

		i=0;
		do {
			niz1[i]=(abs(niz[s]))%10;
			i++;
			niz[s]=niz[s]/10;
		} while(niz[s]!=0);

		for(k=0; k&lt;i; k++) {
			for(l=0; l&lt;vel1; l++) {
				if(niz1[k]==red[l]) {
					for(j=k; j&lt;i-1; j++)
						niz1[j]=niz1[j+1];
					i--;
					k--;
					break;
				}
			}
		}

		niz[s]=0;

		for(j=0; j&lt;i; j++)
			niz[s]+=round(niz1[j]*pow(10, j));
		/* Ako je clan niza negativan, znak ce biti jedan pa ga zbog toga mnozimo sa (-1) */
		if(znak==1)
			niz[s]=niz[s]*(-1);
	}
	return 1;
}

int main()
{
	return 0;
</font>}</pre>
</body>
</html>
