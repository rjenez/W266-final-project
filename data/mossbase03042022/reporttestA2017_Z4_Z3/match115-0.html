<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z4/Z3/student5366.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z4/Z3/student5366.c<p></p><pre>
#include &lt;stdio.h&gt;
int duzina_stringa (char*s){
	int d=0;
	while(*s!='\0') {
		d++;
		s++;
	}
	return d;
}

<a name="1"></a><font color="#00FF00"><a href="match115-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_33.gif"/></a>

void najduzi_bp(char *s1, char *s2) {
	char *pocetak;
	char *kraj;
	char *pom1;
	char *pom2;
	char *temp;
	char *temp2;
	char *sacuvaj=s2;
	int brojac=0;
	int cs=32;
	int max=0;
	while(*s1!='\0'){
		/*pomocna varijabla cs koja nam pomaze jer program ne pravi razliku izmedju velikih i malih slova*/
		if(*s1&gt;='A' &amp;&amp; *s1&lt;='Z') cs=32;
		else if(*s1&gt;='a' &amp;&amp; *s1&lt;='z') cs=-32;
		temp=s1;
		temp++;
		/*Pomocnom varijablom temp prolazimo do kraja stringa ili do kraja rijeci(rijec - neprekinuti niz slova)*/
		while( ((*temp!=*s1 &amp;&amp; *temp!=*s1+cs) || *temp==' ') &amp;&amp; (*temp!='\0') &amp;&amp; ((*s1&gt;='A' &amp;&amp; *s1&lt;='Z') || (*s1&gt;='a' &amp;&amp; *s1&lt;='z'))){
</font>			temp++;
		}
		/*ako ono na sta pokazuje temp nije slovo i ako nije jednako onom na sto pokazuje s1, to znaci da se ono na sto pokazuje s1 nijednom nije pojavilo u podstringu*/
<a name="0"></a><font color="#FF0000"><a href="match115-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_42.gif"/></a>

		if(((*temp&lt;'a' || *temp&lt;'z') &amp;&amp; (*temp&lt;'A' &amp;&amp; *temp&gt;'Z')) || (*temp=='\0') || (*temp=*s1) || (*temp==*s1+cs)) {
			/*Postavljamo pokazivac pocetak na s1, jer sada znamo da je ono na sta pokazuje s1 pocetak podstringa koji mozda odgovara uslovu zadatka*/
			pocetak = s1;
			kraj=temp;
			/*u datom podstringu ima jos karaktera koji se eventualno mogu ponavljati, pa pomocnim brojacima pom1 i pom2 prolazimo kroz..*/
			pom1=s1;
			pom1++;
			pom2=pom1;
			pom2++;
			/*Ako se jos neki karakter ponavlja vie puta, vratimo pokazivac kraj unazad, tj. smanjujemo podstring dok ne pronadjemo podstring u kojem..*/
			while(pom1&lt;kraj) {
				if(*pom1&gt;='A' &amp;&amp; *pom1&lt;='Z') cs=-32;
				else if(*pom1&gt;='a' &amp;&amp; *pom1&lt;='z') cs=32;
				while(((*pom1!=*pom2 &amp;&amp; *pom1!=*pom2+cs) || ((*pom2&lt;'a' || *pom2&gt;'z') &amp;&amp; (*pom2&lt;'A' || *pom2&gt;'Z'))) &amp;&amp; *pom2!='\0' &amp;&amp; pom2&lt;kraj){
					pom2++;
				}
				kraj=pom2;
				pom1++;
				pom2=pom1;
				pom2++;
			}
			/*Kada pronadjemo podstring koristimo temp2 da bismo dosli do kraja podstringa i izracunali njegovu velicinu*/
			temp2=pocetak;
			while(temp2&lt;kraj){
				brojac++;
				temp2++;
			}
			/*Jedino ako je velicina tog podstr veca od prethodno upisanog, dati podstring se upisuje u drugi string*/
			if(brojac&gt;max){
				max=brojac;
				while(pocetak&lt;kraj) {
					*s2=*pocetak;
					s2++;
					pocetak++;
				}
				*s2='\0';
			}
		}
		/*koristimo pokazivac sacuvaj da vratimo s2 na pocetak drugog stringa, jer cemo mozda pronaci veci podstr*/
		brojac=0;
		s2=sacuvaj;
		s1++;
</font>	}
}



int main() {
	char primjer[] = "Ovo je neki primjer teksta";
	char prazni[1000] = "";
	najduzi_bp(primjer, prazni);
	printf("%s", primjer);
	return 0;
}</pre>
</body>
</html>
