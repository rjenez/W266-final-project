<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student8909.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student8909.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 3

#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

template &lt;typename TipElemenata&gt;
    struct Matrica
    {
        int br_redova, br_kolona;
        TipElemenata **elementi = nullptr;
    };
    
<a name="2"></a><font color="#0000FF"><a href="match955-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

template &lt;typename TipElemenata&gt;
    void PSSkalarom (Matrica &lt;TipElemenata&gt; mat, double skalar)
    {
        for(int i=0; i&lt;mat.br_redova; i++)
        {
            for(int j=0; j&lt;mat.br_kolona; j++)
</font>            {
                mat.elementi[i][j] = mat.elementi[i][j] * skalar;
            }
        }
    }
    
template &lt;typename TipElemenata&gt;
    void UnistiMatricu(Matrica &lt;TipElemenata&gt; mat)
    {
        if(!mat.elementi) return;
        for(int i=0; i&lt;mat.br_redova; i++) delete[] mat.elementi[i];
        delete[] mat.elementi;
        mat.elementi = nullptr;
    }
    
template &lt;typename TipElemenata&gt;
    Matrica &lt;TipElemenata&gt; StvoriMatricu (int br_redova, int br_kolona)
    {
        Matrica &lt;TipElemenata&gt; mat;
        mat.br_redova = br_redova;
        mat.br_kolona = br_kolona;
        mat.elementi = new TipElemenata*[br_redova];
        for(int i=0; i&lt;br_redova; i++) mat.elementi[i] = nullptr;
        try{
            for(int i=0; i&lt;br_redova; i++)
                mat.elementi[i] = new TipElemenata[br_kolona];
        }
        catch(...) {
            UnistiMatricu(mat);
            throw;
        }
        return mat;
    }
    
template &lt;typename TipElemenata&gt;
    void UnesiMatricu(char ime_matrice, Matrica &lt;TipElemenata&gt; &amp;mat)
    {
        for(int i=0; i&lt;mat.br_redova; i++)
            for(int j=0; j&lt;mat.br_kolona; j++)
            {
                std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i+1 &lt;&lt; "," &lt;&lt; j+1 &lt;&lt; ") = ";
                std::cin &gt;&gt; mat.elementi[i][j];
            }
    }
    
template &lt;typename TipElemenata&gt;
    void IspisiMatricu (const Matrica &lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost = 6, bool treba_brisati = false)
    {
        for(int i=0; i&lt;mat.br_redova; i++)
        {
            for(int j=0; j&lt;mat.br_kolona; j++)
                std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; std::setprecision(preciznost) &lt;&lt; mat.elementi[i][j];
                std::cout &lt;&lt; std::endl;
        }
        if(treba_brisati == true) UnistiMatricu(mat);
    }
    
template &lt;typename TipElemenata&gt;
    Matrica &lt;TipElemenata&gt; ZbirMatrica (const Matrica &lt;TipElemenata&gt; &amp;m1, const Matrica &lt;TipElemenata&gt; &amp;m2)
    {
        if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
            throw std::domain_error ("Matrice nemaju jednake dimenzije!");
            
            auto m3 (StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
            for(int i=0; i&lt;m1.br_redova; i++)
                for(int j=0; j&lt;m1.br_kolona; j++)
                    m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
                    
                    return m3;
    }
    
template &lt;typename TipElemenata&gt;
    Matrica &lt;TipElemenata&gt; ProduktMatrica (const Matrica &lt;TipElemenata&gt; &amp;m1, const Matrica &lt;TipElemenata&gt; &amp;m2)
    {
        if(m1.br_kolona != m2.br_redova)
            throw std::domain_error ("Matrice nisu saglasne za mnozenje");
            
        auto m3 (StvoriMatricu &lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona));
        for(int i=0; i&lt;m1.br_redova; i++)
        {
            for(int j=0; j&lt;m2.br_kolona; j++)
            {
                TipElemenata suma=0;
                for(int k=0; k&lt;m2.br_redova; k++)
                    suma = suma + m1.elementi[i][k] * m2.elementi[k][j];
                m3.elementi[i][j] = suma;
            }
        }
        return m3;
    }
    
template &lt;typename TipElemenata&gt;
    Matrica &lt;TipElemenata&gt; MatricniPolinom (Matrica &lt;TipElemenata&gt; mat, std::vector&lt;double&gt; v)
    {
        if(mat.br_kolona != mat.br_redova)
            throw std::domain_error ("Matrica mora biti kvadratna");
        auto mat_polinom (StvoriMatricu &lt;TipElemenata&gt; (mat.br_kolona, mat.br_kolona));
        
        for(int i=0; i&lt;mat.br_redova; i++)
<a name="1"></a><font color="#00FF00"><a href="match955-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

            for(int j=0; j&lt;mat.br_kolona; j++)
                mat_polinom.elementi[i][j] = 0;
        
        for(int i=0; i&lt;v.size(); i++)
        {
            if(v[i] == 0) continue;
            
            try
            {
                auto jed_matrica (StvoriMatricu &lt;TipElemenata&gt; (mat.br_redova, mat.br_kolona));
                for(int i=0; i&lt;mat.br_redova; i++)
</font>                    for(int j=0; j&lt;mat.br_kolona; j++)
                    {
<a name="0"></a><font color="#FF0000"><a href="match955-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

                        if(i==j) jed_matrica.elementi[i][j] = 1;
                        else jed_matrica.elementi[i][j] = 0;
                    }
                    for(int j=0; j&lt;i; j++)
                    {
                        auto temp(jed_matrica);
                        try
                        {
                            jed_matrica = ProduktMatrica(mat, jed_matrica);
                            UnistiMatricu(temp);
                        }
                        catch(...)
                        {
                            UnistiMatricu(jed_matrica);
                            throw;
                        }
                    }
                    PSSkalarom(jed_matrica, v[i]);
                    try
                    {
                        auto temp(mat_polinom);
                        mat_polinom = ZbirMatrica(mat_polinom, jed_matrica);
                        UnistiMatricu(jed_matrica);
                        UnistiMatricu(temp);
                    }
                    catch(...)
                    {
                        UnistiMatricu(jed_matrica);
                        throw;
                    }
            }
            catch(...)
            {
                UnistiMatricu(mat_polinom);
                throw;
            }
        }
        return mat_polinom;
    }

int main()
{
  // std::cout &lt;&lt; "sve je ok";
  
  Matrica &lt;double&gt; a;
</font>  std::vector&lt;double&gt; K;
  int m;
  
  std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
  std::cin &gt;&gt; m;
  
  try
  {
      a = StvoriMatricu &lt;double&gt; (m, m);
      std::cout &lt;&lt; "Unesite elemente matrice A: " &lt;&lt; std::endl;
      UnesiMatricu('A', a);
      std::cout &lt;&lt; "Unesite red polinoma: ";
      int n;
      std::cin &gt;&gt; n;
      std::cout &lt;&lt; "Unesite koeficijente polinoma: ";
      
      for(int i=0; i&lt;n+1; i++)
      {
          double broj;
<a name="3"></a><font color="#00FFFF"><a href="match955-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

          std::cin &gt;&gt; broj;
          K.push_back(broj);
      }
      IspisiMatricu(MatricniPolinom(a, K), 10, 6, true);
      UnistiMatricu(a);
  }
  catch(...)
  {
      UnistiMatricu(a);
</font>  }
    
    return 0;
}</pre>
</body>
</html>
