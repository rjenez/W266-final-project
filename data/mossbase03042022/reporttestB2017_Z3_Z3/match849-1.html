<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student5348.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student9272.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
using namespace std;
template&lt;typename TipElemenata&gt;
 struct Matrica{
   int br_redova,br_kolona;
   TipElemenata **elementi=nullptr;
 };
 
 template&lt;typename TipElemenata&gt;
 void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat) {                          
     if(!mat.elementi) return;
     for(int i=0;i&lt;mat.br_redova;i++) delete[] mat.elementi[i];
     delete [] mat.elementi;
     mat.elementi=nullptr;
 }
 
 template&lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova,int br_kolona){
     Matrica&lt;TipElemenata&gt; mat;
     mat.br_redova=br_redova;
     mat.br_kolona=br_kolona;
     
     mat.elementi=new TipElemenata*[br_redova];
     for(int i=0;i&lt;br_redova;i++) mat.elementi[i]=nullptr;
     try{
         for(int i=0;i&lt;br_redova;i++){
             mat.elementi[i]=new TipElemenata[br_kolona];
         }
     }
     catch(...){
         UnistiMatricu(mat);
         throw;
     }
     return mat;
 }
 
 template&lt;typename TipElemenata&gt;
  void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat){
<a name="1"></a><font color="#00FF00"><a href="match849-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

      for(int i=0;i&lt;mat.br_redova;i++){
          for(int j=0;j&lt;mat.br_kolona;j++){
              cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
              cin&gt;&gt;mat.elementi[i][j];
          }
      }
  }
  
 template&lt;typename TipElemenata&gt;
 void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat,int sirina_ispisa,int preciznost, bool treba_brisati){
</font><a name="0"></a><font color="#FF0000"><a href="match849-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

     for(int i=0;i&lt;mat.br_redova;i++){
         for(int j=0;j&lt;mat.br_kolona;j++){
             cout&lt;&lt;setw(sirina_ispisa)&lt;&lt;setprecision(preciznost)&lt;&lt;mat.elementi[i][j];
         }
         cout&lt;&lt;endl;
     }
     if(treba_brisati==true){
         UnistiMatricu(mat);
     }
 }
 template&lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1,const Matrica&lt;TipElemenata&gt; &amp;m2){
     if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona)
     throw domain_error("Matrice nemaju jednake dimenzije!");
     auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova,m1.br_kolona));
     for(int i=0;i&lt;m1.br_redova;i++){
</font>         for(int j=0;j&lt;m1.br_kolona;j++){
             m3.elementi[i][j]=m1.elementi[i][j]+m2.elementi[i][j];
         }
     }
     return m3;
 }
template&lt;typename TipElemenata&gt;
<a name="3"></a><font color="#00FFFF"><a href="match849-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

Matrica&lt;TipElemenata&gt; ProduktMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2){
    if(m1.br_kolona!=m2.br_redova){
     throw domain_error("Matrice nisu saglasne za mnozenje");
    } 
    Matrica&lt;TipElemenata&gt; m3;
</font>        double element(0);
        m3=StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona);
        for(int i=0;i&lt;m3.br_redova;i++){
            for(int j=0;j&lt;m3.br_kolona;j++){
                for(int k=0;k&lt;m1.br_kolona;k++){
                    element+=((m1.elementi[i][k])*(m2.elementi[k][j]));
                }
                m3.elementi[i][j]=element;
                element=0;
            }
        }
    return m3;
}
template&lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; PomnoziMatricuSkalarom(const Matrica&lt;TipElemenata&gt; &amp;M, int a){
    Matrica&lt;TipElemenata&gt; pomnozena;
    pomnozena=StvoriMatricu&lt;TipElemenata&gt;(M.br_redova,M.br_kolona);
    for(int i=0; i&lt;M.br_redova; i++){
        for(int j=0; j&lt;M.br_kolona; j++){
            pomnozena.elementi[i][j]=a*(M.elementi[i][j]);
        }
    }
    
    return pomnozena;
}

template&lt;typename TipElemenata,typename NekiTip&gt;
Matrica&lt;TipElemenata&gt; MatricniPolinom(const Matrica&lt;TipElemenata&gt; &amp;A, int n, NekiTip it){
    if(n&lt;0) throw domain_error("Neispravan stepen polinoma");
    Matrica&lt;TipElemenata&gt; mat=StvoriMatricu&lt;TipElemenata&gt;(A.br_redova, A.br_kolona);
    for(int i=0;i&lt;=n;i++){
        if(i==0){
            for(int j=0;j&lt;mat.br_redova;j++){
                for(int k=0;k&lt;mat.br_kolona;k++){
<a name="2"></a><font color="#0000FF"><a href="match849-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

                    if(j==k){
                        mat.elementi[j][k]=1;
                    }
                    else{
                        mat.elementi[j][k]=0;
                    }
                }
            }
            Matrica&lt;TipElemenata&gt; pomocna;
</font>            pomocna=PomnoziMatricuSkalarom&lt;TipElemenata&gt;(mat,*it);
            for(int redovi=0; redovi&lt;mat.br_redova; redovi++){
                for(int kolone=0; kolone&lt;mat.br_kolona; kolone++){
                    mat.elementi[redovi][kolone]=pomocna.elementi[redovi][kolone];
                }
            }
            UnistiMatricu(pomocna);
            
        }
        else if(i==1){
            Matrica&lt;TipElemenata&gt; pomocna;
            pomocna=PomnoziMatricuSkalarom&lt;TipElemenata&gt;(A,*it);
            Matrica&lt;TipElemenata&gt; zbir= ZbirMatrica&lt;TipElemenata&gt; (mat,pomocna);
            UnistiMatricu(pomocna);
            
            for(int redovi=0;redovi&lt;mat.br_redova;redovi++){
                for(int kolone=0; kolone&lt;mat.br_redova; kolone++){
                    mat.elementi[redovi][kolone]=zbir.elementi[redovi][kolone];
                 }
            }
            UnistiMatricu(zbir);
        }
        else{
            Matrica&lt;TipElemenata&gt; temp;
            temp=StvoriMatricu&lt;TipElemenata&gt;(A.br_redova,A.br_kolona);
            for(int redovi=0; redovi&lt;mat.br_redova;redovi++){
                for(int kolone=0;kolone&lt;mat.br_kolona;kolone++){
                    temp.elementi[redovi][kolone]=A.elementi[redovi][kolone];
                }
            }
            
            for(int l=1;l&lt;i;l++){
                Matrica&lt;TipElemenata&gt; pomocna;
                pomocna=ProduktMatrica&lt;TipElemenata&gt;(temp,A);
                for(int redovi=0;redovi&lt;mat.br_redova;redovi++){
                    for(int kolone=0; kolone&lt;mat.br_kolona;kolone++){
                        temp.elementi[redovi][kolone]=pomocna.elementi[redovi][kolone];
                    }
                }
                UnistiMatricu(pomocna);
                
            }
            Matrica&lt;TipElemenata&gt; pomocna;
            pomocna=PomnoziMatricuSkalarom&lt;TipElemenata&gt;(temp,*it);
            for(int redovi=0; redovi&lt;mat.br_redova; redovi++){
                for(int kolone=0; kolone&lt;mat.br_kolona; kolone++){
                    temp.elementi[redovi][kolone]=pomocna.elementi[redovi][kolone];
                }
            }
            
            UnistiMatricu(pomocna);
            pomocna=ZbirMatrica&lt;TipElemenata&gt;(mat,temp);
            for(int redovi=0; redovi&lt;mat.br_redova; redovi++){
                for(int kolone=0; kolone&lt;mat.br_kolona; kolone++){
                    mat.elementi[redovi][kolone]=pomocna.elementi[redovi][kolone];
                }
            }
            UnistiMatricu(temp);
            UnistiMatricu(pomocna);
        }
        it++;
    }
    return mat;
}


int main ()
{
    Matrica&lt;int&gt; a,krajnja;
    int n;
    cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    cin&gt;&gt;n;
    try{
        a=StvoriMatricu&lt;int&gt;(n,n);
        cout&lt;&lt;"Unesite elemente matrice A:\n";
        UnesiMatricu('A',a);
        cout&lt;&lt;"Unesite red polinoma: ";
        int m;
        cin&gt;&gt;m;
        cout&lt;&lt;"Unesite koeficijente polinoma: ";
        list&lt;double&gt; lista; 
        for(int i=0;i&lt;=m;i++){
        double x;
        cin&gt;&gt;x;
        lista.push_back(x);
        
       }
       krajnja=MatricniPolinom&lt;int&gt;(a,m,lista.begin());
       UnistiMatricu(a);
       IspisiMatricu(krajnja,10,6,true);
    }
    catch(bad_alloc){
        cout&lt;&lt;"Nema dovoljno memorije!\n";
          UnistiMatricu(krajnja);
    }
    catch(domain_error izuzetak){                                             
     cout&lt;&lt;izuzetak.what();
       UnistiMatricu(krajnja);
    }
  return 0;
}
</pre>
</body>
</html>
