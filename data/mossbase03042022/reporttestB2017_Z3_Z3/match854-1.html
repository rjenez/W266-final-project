<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student6168.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student4966.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
template &lt;typename TipElemenata&gt;
struct Matrica {
    int br_redova, br_kolona;
    TipElemenata** elementi=nullptr;
};
template &lt;typename TipElemenata&gt;
void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat) {
    if (!mat.elementi) return;
    for (int i=0;i&lt;mat.br_redova;i++)
        delete[] mat.elementi[i];
    delete[] mat.elementi;
    mat.elementi=nullptr;
}
template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) {
    Matrica&lt;TipElemenata&gt; mat;
    mat.br_redova=br_redova; mat.br_kolona=br_kolona;
    try {
        mat.elementi=new TipElemenata*[br_redova]();
        for (int i=0;i&lt;br_redova;i++) 
            mat.elementi[i]= new TipElemenata[br_kolona];
    }
    catch(...) {
        UnistiMatricu(mat);
        throw;
    }
    return mat;
}
template &lt;typename TipElemenata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) {
    for (int i=0;i&lt;mat.br_redova;i++) {
        for (int j=0;j&lt;mat.br_redova;j++) {
            std::cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            std::cin&gt;&gt;mat.elementi[i][j];
        }
    }
}
template &lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false) {
    for (int i=0;i&lt;mat.br_redova;i++) {
        for (int j=0;j&lt;mat.br_kolona;j++) {
<a name="0"></a><font color="#FF0000"><a href="match854-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_10.gif"/></a>

            std::cout&lt;&lt;std::setw(sirina_ispisa)&lt;&lt;std::setprecision(preciznost)&lt;&lt;mat.elementi[i][j];
        }
        std::cout&lt;&lt;std::endl;
    }
    if (treba_brisati) UnistiMatricu(mat);
}
template &lt;typename TipElemenata, typename TipElemenata2&gt;
auto ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;mat1, const Matrica&lt;TipElemenata2&gt; &amp;mat2) -&gt;Matrica&lt;decltype(**mat1.elementi+**mat2.elementi)&gt;{
    if (mat1.br_kolona!=mat2.br_kolona || mat1.br_redova!=mat2.br_redova) throw std::domain_error("Matrice nemaju jednake dimenzije!");
    auto mat3(StvoriMatricu&lt;decltype(**mat1.elementi+**mat2.elementi)&gt;(mat1.br_redova, mat1.br_kolona));
    for (int i=0;i&lt;mat3.br_redova;i++) 
        for (int j=0;j&lt;mat3.br_kolona;j++) 
</font>            mat3.elementi[i][j]=mat1.elementi[i][j]+mat2.elementi[i][j];
    return mat3;
}
template &lt;typename TipElemenata, typename TipElemenata2&gt;
<a name="1"></a><font color="#00FF00"><a href="match854-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

auto ProduktMatrica(const Matrica&lt;TipElemenata&gt; &amp;mat1, const Matrica&lt;TipElemenata2&gt; &amp;mat2)-&gt;Matrica&lt;decltype(**mat1.elementi***mat2.elementi)&gt; {
    if (mat1.br_kolona!=mat1.br_redova) throw std::domain_error("Matrice nisu saglasne sa mnozenje");
</font>    auto mat3(StvoriMatricu&lt;decltype(**mat1.elementi***mat2.elementi)&gt;(mat1.br_redova, mat2.br_kolona));
    for (int i=0;i&lt;mat3.br_redova;i++) {
        for (int j=0;j&lt;mat3.br_kolona;j++) {
            decltype(**mat1.elementi***mat2.elementi) suma(0);
            for (int k=0;k&lt;mat1.br_kolona;k++)
                    suma+=mat1.elementi[i][k]*mat2.elementi[k][j];
            mat3.elementi[i][j]=suma;
        }
    }
    return mat3;
}
template &lt;typename TipElemenata, typename TipElemenata2&gt; 
Matrica&lt;TipElemenata&gt; JedinicnaMatrica(const Matrica&lt;TipElemenata2&gt; &amp;mat) {
    auto mat2(StvoriMatricu&lt;TipElemenata&gt;(mat.br_kolona, mat.br_redova));
    for (int i=0;i&lt;mat.br_redova;i++) {
        for (int j=0;j&lt;mat.br_kolona;j++) {
<a name="2"></a><font color="#0000FF"><a href="match854-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

            if (i==j) mat2.elementi[i][j]=1;
            else mat2.elementi[i][j]=0;
        }
    }
    return mat2;
}
template &lt;typename TipElemenata, typename TipKoeficijenta&gt;
void MnozenjeSkalarom(Matrica&lt;TipElemenata&gt; &amp;mat, TipKoeficijenta koef) {
</font>    for (int i=0;i&lt;mat.br_redova;i++) 
<a name="3"></a><font color="#00FFFF"><a href="match854-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

        for (int j=0;j&lt;mat.br_kolona;j++)
            mat.elementi[i][j]*=koef;    
}
template &lt;typename TipElemenata, typename TipElemenata2&gt;
</font>void PrekopirajElemente(const Matrica&lt;TipElemenata&gt; mat1, Matrica&lt;TipElemenata2&gt; mat2) {
    for (int i=0;i&lt;mat1.br_redova;i++) 
        for (int j=0;j&lt;mat1.br_kolona;j++) 
            mat2.elementi[i][j]=mat1.elementi[i][j];
}
template &lt;typename TipElemenata, typename PokTip&gt;
auto MatricniPolinom(const Matrica&lt;TipElemenata&gt; &amp;mat, int n, PokTip pok)-&gt;Matrica&lt;decltype(**mat.elementi**pok)&gt; {
    if (n&lt;0) throw std::domain_error("Neispravan stepen polinoma");
    if (mat.br_kolona!=mat.br_redova) throw std::domain_error("Matrica mora biti kvadratna");
    auto PolMat=StvoriMatricu&lt;decltype(**mat.elementi**pok)&gt;(mat.br_redova, mat.br_kolona);
    for (int i=0;i&lt;=n;i++) {
        if (i==0) {
            auto Jedinicna(JedinicnaMatrica&lt;decltype(*pok***mat.elementi)&gt;(mat));
            MnozenjeSkalarom(Jedinicna, *pok);
            PrekopirajElemente(Jedinicna, PolMat);
            UnistiMatricu(Jedinicna);
        }
        else {
            auto Faktor=StvoriMatricu&lt;TipElemenata&gt;(mat.br_redova, mat.br_kolona);
            PrekopirajElemente(mat, Faktor);
            for (int j=1;j&lt;i;j++) {
                auto temp=Faktor;
                Faktor=ProduktMatrica(Faktor, mat);
                UnistiMatricu(temp);
            }
            MnozenjeSkalarom(Faktor, *pok);
            auto temp2=PolMat;
            PolMat=ZbirMatrica(PolMat, Faktor);
            UnistiMatricu(temp2);
            UnistiMatricu(Faktor);
        }
        pok++;
    }
    return PolMat;
}
int main ()
{
    
    int dim;
    std::cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    std::cin&gt;&gt;dim;
    Matrica&lt;double&gt; mat;
    try {
    mat=StvoriMatricu&lt;double&gt;(dim,dim);
    std::cout&lt;&lt;"Unesite elemente matrice A: "&lt;&lt;std::endl;
    UnesiMatricu('A', mat);
    std::cout&lt;&lt;"Unesite red polinoma: ";
    int red;
    std::cin&gt;&gt;red;
    std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
    std::vector&lt;int&gt; koeficijenti(red+1);
    std::for_each(koeficijenti.begin(), koeficijenti.end(), [](int &amp;x) { std::cin&gt;&gt;x;});
    auto MatPol=MatricniPolinom(mat, red, koeficijenti.begin());
    IspisiMatricu(MatPol, 10, 6, true); 
    }
    catch(std::exception &amp;e) {
        std::cout&lt;&lt;e.what(); 
    }
    UnistiMatricu(mat); 
	return 0;
}</pre>
</body>
</html>
