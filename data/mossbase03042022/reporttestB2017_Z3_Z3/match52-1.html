<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student6517.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student8518.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

template &lt;typename TipElemenata&gt;
struct Matrica {
     int br_redova, br_kolona;
     TipElemenata **elementi=nullptr; // VEOMA BITNA INICIJALIZACIJA!
 };
 
template &lt;typename TipElemenata&gt;
void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat)
 {
     if(!mat.elementi) 
     return;
     
     for(int i=0; i&lt;mat.br_redova; i++) 
     delete[] mat.elementi[i];
     
     delete[] mat.elementi;
     mat.elementi=nullptr;
 }
 
template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona)
 {
     Matrica&lt;TipElemenata&gt; mat;
     mat.br_redova=br_redova; 
     mat.br_kolona=br_kolona;
     mat.elementi=new TipElemenata*[br_redova];
     
     for(int i=0; i&lt;br_redova; i++) 
     mat.elementi[i]=nullptr;
     
     try
     {
         for(int i=0; i&lt;br_redova; i++)
         mat.elementi[i]=new TipElemenata[br_kolona];
     }
     catch(...) 
     {
        UnistiMatricu(mat);
        throw;
     }
     return mat;
 }
 
template &lt;typename TipElemenata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat)
 {
    for(int i=0; i&lt;mat.br_redova; i++)
    {
        for(int j=0; j&lt;mat.br_kolona; j++)
        {
            std::cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            std::cin&gt;&gt;mat.elementi[i][j];
        }
    }
 }
 
template &lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false)
 {
     for(int i=0; i&lt;mat.br_redova; i++) 
     {
         for(int j=0; j&lt;mat.br_kolona; j++)
         std::cout&lt;&lt;std::setprecision(preciznost)&lt;&lt;std::setw(sirina_ispisa)&lt;&lt;mat.elementi[i][j];
         
         std::cout&lt;&lt;std::endl;
     }
     
     if(treba_brisati)
     UnistiMatricu(mat);
 }
 
template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2)
 {
<a name="1"></a><font color="#00FF00"><a href="match52-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona)
    throw std::domain_error("Matrice nemaju jednake dimenzije!");
     
    auto m3=StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona);
     
    for(int i=0; i&lt;m1.br_redova; i++)
</font>        for(int j=0; j&lt;m1.br_kolona; j++)
<a name="0"></a><font color="#FF0000"><a href="match52-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_64.gif"/></a>

         m3.elementi[i][j]=m1.elementi[i][j]+m2.elementi[i][j];
         
     return m3;
 }
 
template&lt;typename Tip1&gt;
bool SaglasneZaMnozenje(const Matrica&lt;Tip1&gt; &amp;m1, const Matrica&lt;Tip1&gt; &amp;m2)
{
    //mora broj redova prve matrice biti isti kao broj kolona druge matrice
    if(m1.br_redova!=m2.br_kolona)
    return false;
    else
    return true;
}

template&lt;typename Tip1&gt;
int Umnozak(const Matrica&lt;Tip1&gt; &amp;m1, const Matrica&lt;Tip1&gt; &amp;m2, int i, int j)
{
    int suma(0);
    for(int k=0; k&lt;m2.br_redova; k++)
        suma+=m2.elementi[i][k]*m1.elementi[k][j];
    
    return suma;
}

template&lt;typename Tip1&gt;
Matrica&lt;Tip1&gt; ProduktMatrica (const Matrica&lt;Tip1&gt; &amp;m1, const Matrica&lt;Tip1&gt; &amp;m2)
{
    if(!SaglasneZaMnozenje(m1, m2))
    throw std::domain_error ("Matrice nisu saglasne za mnozenje");
    
    Matrica&lt;Tip1&gt; produkt = StvoriMatricu&lt;Tip1&gt; (m1.br_redova, m2.br_kolona);
        
    for(int i=0; i&lt;m1.br_redova; i++)
        for(int j=0; j&lt;m2.br_kolona; j++)
           produkt.elementi[i][j]=Umnozak(m1, m2, i, j);
    
    return produkt;
}

template&lt;typename Tip1&gt;
Matrica&lt;Tip1&gt; StvoriJedinicnu(int br_redova, int br_kolona)
{
    //ne treba u ovoj funkciji brisat ako baci izuzeta, jer to vec radi funkcija iz koje se poziva ova funkcija
    Matrica&lt;Tip1&gt; jedinicna = StvoriMatricu&lt;Tip1&gt;(br_redova, br_kolona);
    
    for(int i=0; i&lt;br_redova; i++)
    {
        for(int j=0; j&lt;br_kolona; j++)
        {
            if(i==j)
            jedinicna.elementi[i][j]=1;
            else
            jedinicna.elementi[i][j]=0;
        }
    }
    
    return jedinicna;
}

template&lt;typename Tip1&gt;
void PomnoziMatricuSaSkalarom(Matrica&lt;Tip1&gt; pomnozi, int skalar) //ne treba referenca jer svakako atributi "elementi" pokazuju na isti alocirani prostor
{
    for(int i=0; i&lt;pomnozi.br_redova; i++)
        for(int j=0; j&lt;pomnozi.br_kolona; j++)
        pomnozi.elementi[i][j]*=skalar;
}

template&lt;typename Tip1&gt;
void SaberiMatrice(Matrica&lt;Tip1&gt; prva, Matrica&lt;Tip1&gt; sljedeca)
{
     for(int i=0; i&lt;prva.br_redova; i++)
        for(int j=0; j&lt;sljedeca.br_kolona; j++)
         prva.elementi[i][j]+=sljedeca.elementi[i][j];
}

template&lt;typename Tip1, typename NekiKontejner&gt; 
Matrica&lt;Tip1&gt; IzracunajPolinom( Matrica&lt;Tip1&gt; A, int stepen_polinoma, typename NekiKontejner::iterator it_neki_kontejner)
{
    //da je stepen polinoma pozitivan je provjereno u funkciji iz koje je ova pozvana 
    
    std::vector&lt;Matrica&lt;Tip1&gt;&gt; vekotr_matrica(stepen_polinoma);
    int i(0);
    vekotr_matrica.at(0) = StvoriJedinicnu&lt;Tip1&gt; (A.br_redova, A.br_kolona);
    //stoji izvan try-bloka jer ako funkcija "StvoriMatricu" ne uspije da je stvori, cisti sama stvari za sobom pozivom funkcije "UnistiMatricu"
    
    if(stepen_polinoma&gt;=1)
    {
        i++;  //moramo "i" povecati zbog dealociranja u catch bloku
        vekotr_matrica.at(1)=A;
    }
    
    try
    {
        for( i=2; i&lt;stepen_polinoma; i++)
        {
            vekotr_matrica.at(i) = ProduktMatrica &lt;Tip1&gt; (vekotr_matrica.at(i-1), A);
        }
    }
    catch(...)
    {
        for(int j=0; j&lt;i; j++)        //krece od keca, jer ako se on uspije stvoriti, a ostatk ne, mora ga neko obrisati. Da ide do "i", naredba ".at(j)" bi bila out_of_range
        UnistiMatricu( vekotr_matrica.at(j) );
        
        throw;  //da nema ovoga doslo bi dole do duplog brisanja 
    }
    
    for(int k=0; k&lt;vekotr_matrica.size(); k++)
    {
        PomnoziMatricuSaSkalarom&lt;Tip1&gt;( vekotr_matrica.at(k), *it_neki_kontejner);
        std::advance(it_neki_kontejner, 1);
    }
    
    for(int k=1; k&lt;vekotr_matrica.size(); k++)    //ide od keca, jer se sve druge matrice sabiraju/oduzimaju na prvu u vektoru matrica
    SaberiMatrice&lt;Tip1&gt; (vekotr_matrica.at(0), vekotr_matrica.at(k));
    
    for(int k=1; k&lt;vekotr_matrica.size(); k++)
    UnistiMatricu(vekotr_matrica.at(k));  //ne unistava se prva, jer se ona vraca
    
    return vekotr_matrica.at(0);
}

template &lt;typename Tip1, typename NekiKontejner&gt; 
Matrica&lt;Tip1&gt; MatricniPolinom(Matrica&lt;Tip1&gt; A, int stepen_polinoma, typename NekiKontejner::iterator it_neki_kontejner)
{
    if(stepen_polinoma&lt;0)
    throw std::domain_error ("Neispravan stepen polinoma");
    
    if(A.br_redova!=A.br_kolona)
    throw std::domain_error ("Matrica mora biti kvadratna");
    
    Matrica&lt;Tip1&gt; matricni_polinom = IzracunajPolinom&lt;Tip1, NekiKontejner&gt; (A, stepen_polinoma, it_neki_kontejner);
    
    return matricni_polinom;    
}

int main ()
{
    std::cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    int br_red_kol;
    std::cin&gt;&gt;br_red_kol;
    
    Matrica&lt;int&gt; A;
    try
    {
        A=StvoriMatricu&lt;int&gt;(br_red_kol, br_red_kol);
        std::cout&lt;&lt;"Unesite elemente matrice A:"&lt;&lt;std::endl;;
        UnesiMatricu('A', A);
        
        std::cout&lt;&lt;"Unesite red polinoma: ";
        int red_polinoma;
        std::cin&gt;&gt;red_polinoma;
        
        std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
        std::vector&lt;int&gt; stepeni_polinoma(red_polinoma+1);
        
        for(int i=0; i&lt;=red_polinoma; i++)
            std::cin&gt;&gt;stepeni_polinoma.at(i);
        
        Matrica&lt;int&gt; m_polinom = MatricniPolinom&lt; int, std::vector&lt;int&gt; &gt; (A, (red_polinoma+1), stepeni_polinoma.begin());
        
        IspisiMatricu(m_polinom, 10, 6);
        
        
        UnistiMatricu(m_polinom);
        //UnistiMatricu(A);
    }
    catch(std::domain_error poruka)
    {
        std::cout&lt;&lt;poruka.what();
        UnistiMatricu(A);
    }
    catch(...)
    {
        std::cout&lt;&lt;"Ja uhvatio nesto";
</font>    }
	return 0;
}
</pre>
</body>
</html>
