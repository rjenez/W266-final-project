<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student6410.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student5943.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;new&gt;
using std::endl;
using std::cout;
using std::cin;
template &lt;typename TipElemenata&gt;
 struct Matrica {
 int br_redova, br_kolona;
 TipElemenata **elementi = nullptr; // VEOMA BITNA INICIJALIZACIJA!
 };
template &lt;typename TipElemenata&gt;
 void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat) {
 if(!mat.elementi) return;
 for(int i = 0; i &lt; mat.br_redova; i++) delete[] mat.elementi[i];
 delete[] mat.elementi;
 mat.elementi = nullptr;
 }
template &lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) {
 Matrica&lt;TipElemenata&gt; mat;
 mat.br_redova = br_redova; mat.br_kolona = br_kolona;
 mat.elementi = new TipElemenata*[br_redova];
 for(int i = 0; i &lt; br_redova; i++) mat.elementi[i] = nullptr;
 try {
 for(int i = 0; i &lt; br_redova; i++)
 mat.elementi[i] = new TipElemenata[br_kolona]{};
 }
 catch(...) {
 UnistiMatricu(mat);
 throw;
 }
 return mat;
 }
template &lt;typename TipElemenata&gt;
 void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) {
 for(int i = 0; i &lt; mat.br_redova; i++)
 for(int j = 0; j &lt; mat.br_kolona; j++) {
 std::cout &lt;&lt; ime_matrice
 &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
 std::cin &gt;&gt; mat.elementi[i][j];
 }
 }
template &lt;typename TipElemenata&gt;
 void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false) {
       for(int i = 0; i &lt; mat.br_redova; i++) {
           for(int j = 0; j &lt; mat.br_kolona; j++)
            std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt;std::setprecision(preciznost)&lt;&lt; mat.elementi[i][j];
            std::cout &lt;&lt; std::endl;
       }
       if(treba_brisati) UnistiMatricu(mat);
 }
<a name="6"></a><font color="#00FF00"><a href="match172-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

template &lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1,const Matrica&lt;TipElemenata&gt; &amp;m2) {
 Matrica&lt;TipElemenata&gt; m3;
 m3= (StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
 for(int i = 0; i &lt; m1.br_redova; i++)
</font> for(int j = 0; j &lt; m1.br_kolona; j++)
<a name="8"></a><font color="#00FFFF"><a href="match172-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

 m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
 return m3;
 }

std::vector&lt;double&gt; UnosKoefPolin(int n){
    std::vector&lt;double&gt; vec;
    for(int i(0);i&lt;n+1;i++){
</font><a name="1"></a><font color="#00FF00"><a href="match172-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

        double x;
        std::cin&gt;&gt;x;
        vec.push_back(x);
    }
    
    return vec;
}

template &lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; ProduktMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1,const Matrica&lt;TipElemenata&gt; &amp;m2) {
 if(m1.br_kolona != m2.br_redova)
 throw std::domain_error("Matrice nisu saglasne za mnozenje");
 Matrica&lt;TipElemenata&gt; m3;
 m3=(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona));

 for(int i = 0; i &lt; m1.br_redova;i++){
            int k(0);
</font>            for(int j(0);j&lt;m3.br_kolona;j++){
                double suma(0);
<a name="2"></a><font color="#0000FF"><a href="match172-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

                for(int l(0);l&lt;m2.br_redova;){
                    suma+=m1.elementi[i][l] * m2.elementi[l][j];
                    l++;
                }
                k++;
                m3.elementi[i][j] = suma;
            }
 }
 return m3;
 }
template &lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; NapraviJedinicnu(const Matrica&lt;TipElemenata&gt; &amp;m1) {
  Matrica&lt;TipElemenata&gt; m3;
  m3=(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
    
 for(int i = 0; i &lt; m1.br_redova;i++){
</font>            for(int j(0);j&lt; m1.br_kolona;j++){
<a name="4"></a><font color="#FF00FF"><a href="match172-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

                if(i==j)    m3.elementi[i][j]=1;
                else m3.elementi[i][j]=0;
            }
 }
 return m3;
 }
 template &lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; Skalarno(const Matrica&lt;TipElemenata&gt; &amp;m1,double x) {
  Matrica&lt;TipElemenata&gt; m3;
  m3=(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
 for(int i = 0; i &lt; m1.br_redova;i++){
</font><a name="3"></a><font color="#00FFFF"><a href="match172-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

            for(int j(0);j&lt;m1.br_kolona;j++){
                m3.elementi[i][j]=x*m1.elementi[i][j];
            }
 }
 return m3;
 }
 
  template &lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; NapraviOrginalnu(const Matrica&lt;TipElemenata&gt; &amp;m1) {
  Matrica&lt;TipElemenata&gt; m3;
  m3=(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
 for(int i = 0; i &lt; m1.br_redova;i++){
</font><a name="0"></a><font color="#FF0000"><a href="match172-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

            for(int j(0);j&lt;m1.br_kolona;j++){
                m3.elementi[i][j]=m1.elementi[i][j];
            }
 }
 return m3;
 }
 
 
 template &lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; MatricniPolinom(const Matrica&lt;TipElemenata&gt; &amp;m1,const std::vector&lt;double&gt; &amp;vec) {
 if(m1.br_redova != m1.br_kolona) throw std::domain_error("Matrica mora biti kvadratn");
 Matrica&lt;TipElemenata&gt; m3;
 std::vector&lt;Matrica&lt;TipElemenata&gt;&gt; vektor;
 for(int i = 0; i &lt; (vec.size());i++){
            if(i==0) vektor.push_back(NapraviJedinicnu(m1));
            else if(i==1) {Matrica&lt;TipElemenata&gt; mat;
            mat = NapraviOrginalnu(m1);
            vektor.push_back(mat);}
            else
                vektor.push_back(ProduktMatrica(m1,vektor[i-1]));
            
 }
 std::vector&lt;Matrica&lt;TipElemenata&gt;&gt; vektor1;
 for(int i(0);i&lt;(vec.size());i++){
</font><a name="9"></a><font color="#FF00FF"><a href="match172-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

            vektor1.push_back(Skalarno(vektor[i],vec[i]));
            
 }
 std::vector&lt;Matrica&lt;TipElemenata&gt;&gt; vektor2;

 for(int i(0);i&lt;(vec.size())-1;i++){
</font><a name="5"></a><font color="#FF0000"><a href="match172-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

     if(i==0) vektor2.push_back(ZbirMatrica(vektor1[i],vektor1[i+1]));
     else
        vektor2.push_back(ZbirMatrica(vektor2[i-1],vektor1[i+1]));
     if(i==(vec.size())-2) {m3=vektor2[i];}
 }
 
 for(int i(0);i&lt;vec.size();i++){
</font>    UnistiMatricu(vektor1[i]);UnistiMatricu(vektor[i]);
 }
 for(int i(0);i&lt;(vec.size())-2;i++)
    UnistiMatricu(vektor2[i]);
 return m3;
 }

int main() {
    Matrica&lt;double&gt; a, c; // AUTOMATSKA INICIJALIZACIJA!!!
    int  n;
<a name="10"></a><font color="#FF0000"><a href="match172-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    std::cin &gt;&gt; n;
    try {
        a = StvoriMatricu&lt;double&gt;(n, n);
        std::cout &lt;&lt; "Unesite elemente matrice A: "&lt;&lt;endl;
</font>        UnesiMatricu('A', a);
<a name="7"></a><font color="#0000FF"><a href="match172-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

        std::cout&lt;&lt;"Unesite red polinoma: ";
        int m;
        std::cin&gt;&gt;m;
        std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
        std::vector&lt;double&gt; vec(UnosKoefPolin(m));
    
       
        IspisiMatricu(c = MatricniPolinom&lt;double&gt;(a, vec), 10);
        
        
    }
    catch(std::bad_alloc) {
             std::cout &lt;&lt; "Nema dovoljno memorije!\n";
    }
 UnistiMatricu(a); UnistiMatricu(c);
</font>
 return 0;
}
</pre>
</body>
</html>
