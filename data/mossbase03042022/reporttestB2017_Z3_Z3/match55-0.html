<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student2464.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student2464.cpp<p></p><pre>
<a name="3"></a><font color="#00FFFF"><a href="match55-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

/B2017/2018: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

template &lt;typename TipElementa&gt;
struct Matrica {
    int br_redova;
    int br_kolona;
    TipElementa** elementi=nullptr;
};
template &lt;typename TipElementa&gt;
void UnistiMatricu(Matrica&lt;TipElementa&gt; mat);

template &lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; StvoriMatricu(int br_redova, int br_kolona)
{
    Matrica&lt;TipElementa&gt; mat;
    mat.br_redova=br_redova;
</font>    mat.br_kolona=br_kolona;
    mat.elementi = new TipElementa* [br_redova];
    for(int i=0; i&lt;br_redova; i++) mat.elementi[i]=nullptr;
    try {
        for(int i=0; i&lt;br_redova; i++) mat.elementi[i]=new TipElementa[br_kolona];
    } catch(...) {
        UnistiMatricu(mat);
        throw;
    }
    return mat;
}

template &lt;typename TipElementa&gt;
void UnesiMatricu(char ime, Matrica&lt;TipElementa&gt; &amp;mat)
{
    for(int i=0; i&lt;mat.br_redova; i++) {
        for(int j=0; j&lt;mat.br_kolona; j++) {
<a name="4"></a><font color="#FF00FF"><a href="match55-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

            std::cout&lt;&lt;ime&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            std::cin&gt;&gt;mat.elementi[i][j];
        }
    }
}

template &lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; ZbirMatrica(const Matrica&lt;TipElementa&gt; &amp;a, const Matrica&lt;TipElementa&gt; &amp;b)
</font>{
    if(a.br_redova!=b.br_redova || a.br_kolona!=b.br_kolona) throw std::domain_error("Matrice nemaju jednake dimenzije!");
   
        auto m(StvoriMatricu&lt;TipElementa&gt;(a.br_redova, a.br_kolona));
        for(int i=0; i&lt;a.br_redova; i++)
            for(int j=0; j&lt;a.br_kolona; j++)
                m.elementi[i][j]=a.elementi[i][j]+b.elementi[i][j];
        return m;
    
}

template &lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; ProduktMatrica(const Matrica&lt;TipElementa&gt; &amp;a, const Matrica&lt;TipElementa&gt; &amp;b)
{
    if(a.br_kolona!=b.br_redova) throw  std::domain_error("Matrice nisu saglasne za mnozenje");
<a name="2"></a><font color="#0000FF"><a href="match55-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

    auto m(StvoriMatricu&lt;TipElementa&gt;(a.br_redova, b.br_kolona));
    for(int i=0; i&lt;a.br_redova; i++)
        for (int j=0; j&lt;b.br_kolona; j++) {
            double suma=0;
            for(int k=0; k&lt; b.br_redova; k++) suma+=a.elementi[i][k] * b.elementi[k][j];
            m.elementi[i][j]=suma;
        }
    return m;
}

template&lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; SkalarniProdukt(const Matrica&lt;TipElementa&gt; &amp;mat, double broj)
{
    auto m(StvoriMatricu&lt;TipElementa&gt;(mat.br_redova, mat.br_kolona));
    for(int i=0; i&lt;mat.br_redova; i++)
</font>        for(int j=0; j&lt;mat.br_kolona; j++)
<a name="1"></a><font color="#00FF00"><a href="match55-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_20.gif"/></a>

            m.elementi[i][j]=(mat.elementi[i][j] * broj);
    return m;
}

template&lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; JedinicnaMatrica(int dimenzija)
{
    auto m(StvoriMatricu&lt;TipElementa&gt;(dimenzija, dimenzija));
    for(int i=0; i&lt;dimenzija; i++)
        for(int j=0; j&lt;dimenzija; j++) {
            if(i==j) m.elementi[i][j]=1;
            else m.elementi[i][j]=0;
        }
    return m;
}


template&lt;typename TipElementa, typename IterTip&gt;
Matrica&lt;TipElementa&gt; MatricniPolinom(const Matrica&lt;TipElementa&gt; &amp;mat, int stepen, IterTip it)
{
    if(stepen&lt;0) throw std::domain_error("Neispravan stepen polinoma");
    if(mat.br_redova!=mat.br_kolona) throw std::domain_error("Matrica mora biti kvadratna");

    Matrica&lt;TipElementa&gt; m;
    try {
        

        Matrica&lt;TipElementa&gt; Jedinicna;

        try {
            Jedinicna=JedinicnaMatrica&lt;TipElementa&gt;(mat.br_redova);
            try {
                m=SkalarniProdukt&lt;TipElementa&gt;(Jedinicna, *it);
                it++;
            } catch(...) {
                UnistiMatricu(Jedinicna);
                throw;
            }
            UnistiMatricu(Jedinicna);
        } catch(...) {
            throw;
        }

        try {
            auto Produkt(SkalarniProdukt&lt;TipElementa&gt;(mat, *it));
            it ++;
            
            try {
                m=ZbirMatrica(m, Produkt);
            } catch(...) {
                UnistiMatricu(Produkt);
                throw;
            }
            UnistiMatricu(Produkt);
        } catch(...) {
            throw;
        }

    Matrica&lt;TipElementa&gt; mat_pomocna;
        try {
            mat_pomocna=StvoriMatricu&lt;TipElementa&gt;(mat.br_redova, mat.br_kolona);
            for(int i=0; i&lt;mat.br_redova; i++) {
</font>                for(int j=0; j&lt;mat.br_kolona; j++) {
<a name="0"></a><font color="#FF0000"><a href="match55-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_33.gif"/></a>

                    mat_pomocna.elementi[i][j]=mat.elementi[i][j];
                }
            }
            for(int i=2; i&lt;=stepen; i++) {
                try {
                    mat_pomocna=ProduktMatrica&lt;TipElementa&gt;(mat, mat_pomocna);
                } catch(...) {

                    throw;
                }
                Matrica&lt;TipElementa&gt; sprodukt;
                try {
                    sprodukt=SkalarniProdukt&lt;TipElementa&gt;(mat_pomocna, *it);
                    it++;
                    try {
                        
                        m=ZbirMatrica(m, sprodukt);
                    } catch(...) {
                        UnistiMatricu(sprodukt);

                        throw;
                    }

                    UnistiMatricu(sprodukt);
                } catch(...) {

                    throw;
                }
            }

            UnistiMatricu(mat_pomocna);


        } catch(...) {
            UnistiMatricu(mat_pomocna);
            throw;
        }


        return m;
    }

    catch(...) {
        UnistiMatricu(m);
        throw;
    }
}

template &lt;typename TipElementa&gt;
void IspisiMatricu(const Matrica&lt;TipElementa&gt; &amp;mat, int sirina_ispisa, int preciznost, bool treba_brisati)
{
    for(int i=0; i&lt;mat.br_redova; i++) {
        for(int j=0; j&lt;mat.br_kolona; j++) std::cout&lt;&lt; std::setw(sirina_ispisa) &lt;&lt;std::fixed&lt;&lt;std::setprecision(preciznost)&lt;&lt;mat.elementi[i][j];
        std::cout&lt;&lt;std::endl;
    }
    if(treba_brisati) {
        UnistiMatricu(mat);
    }
}

template &lt;typename TipElementa&gt;
void UnistiMatricu(Matrica&lt;TipElementa&gt; mat)
{
    if(!mat.elementi) return;
    for(int i=0; i&lt;mat.br_redova; i++) {
        delete[] mat.elementi[i];
        mat.elementi[i]=nullptr;
    }
    delete[] mat.elementi;
    mat.elementi=nullptr;
}

int main()
{
    int dim;
    Matrica&lt;double&gt; a,b;
    std::cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    std::cin&gt;&gt;dim;
    try {
        a=StvoriMatricu&lt;double&gt;(dim,dim);
        std::cout&lt;&lt;"Unesite elemente matrice A:"&lt;&lt;std::endl;
        UnesiMatricu('A',a);
        int stepen;
        std::cout&lt;&lt;"Unesite red polinoma: ";
        std::cin&gt;&gt;stepen;
        std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
        std::vector&lt;double&gt; v;
        int k;
        for(int i=0; i&lt;=stepen; i++) {
            std::cin&gt;&gt;k;
            v.push_back(k);
        }

        try {
            IspisiMatricu(MatricniPolinom(a, stepen, v.begin()), 10, 0, true);
        } catch(std::domain_error izuzetak) {
            std::cout&lt;&lt;izuzetak.what()&lt;&lt;std::endl;
        }

    } catch (std::bad_alloc) {
        std::cout&lt;&lt;"Nema dovoljno memorije!";
    }
    UnistiMatricu(a);

    return 0;
</font>}

/*int main_ ()
{
    Matrica&lt;double&gt; a,b,c,d;
    int n,m;
    std::cout&lt;&lt;"Unesite broj redova i kolona za matrice: ";
    std::cin&gt;&gt; n&gt;&gt; m;
    try {
        a=StvoriMatricu&lt;double&gt;(n,m);
        b=StvoriMatricu&lt;double&gt;(n,m);
        std::cout&lt;&lt;"Unesite matricu A: ";
        UnesiMatricu('A',a);
        std::cout&lt;&lt;"Unesite matricu B: ";
        UnesiMatricu('B',b);
        std::cout&lt;&lt;"Zbir ove dvije matrice je: ";
        IspisiMatricu(c=ZbirMatrica(a,b),7);
        IspisiMatricu(d=ProduktMatrica(a,b),7);

    } catch(std::bad_alloc) {
        std::cout&lt;&lt;"Nema dovoljno prostora!";
    }
    UnistiMatricu(a);
    UnistiMatricu(b);
    UnistiMatricu(c);
    UnistiMatricu(d);
    return 0;
}*/
</pre>
</body>
</html>
