<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student1582.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student1582.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

template &lt;typename TipElemenata&gt;
    struct Matrica {
        int br_kolona, br_redova;
        TipElemenata **elementi=nullptr;
    };
    
template &lt;typename TipElemenata&gt;
    void UnistiMatricu (Matrica&lt;TipElemenata&gt; mat) {
        if (!mat.elementi)
            return;
        for (int i=0; i&lt;mat.br_redova; i++)
            delete [] mat.elementi[i];
        delete [] mat.elementi;
        mat.elementi=nullptr;
    }
    
template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; StvoriMatricu (int br_kolona, int br_redova) {
        Matrica&lt;TipElemenata&gt; mat;
        mat.br_redova=br_redova;
        mat.br_kolona=br_kolona;
        mat.elementi=new TipElemenata*[br_redova];
        for (int i=0; i&lt;br_redova; i++) 
            mat.elementi[i]=nullptr;
        try {
            for (int i=0; i&lt;br_redova; i++)
                mat.elementi[i]=new TipElemenata[br_kolona];
        }
        catch (...) {
            UnistiMatricu(mat);
            throw;
        }
        return mat;
    }

template &lt;typename TipElemenata&gt;
    void UnesiMatricu (char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) {
        for (int i=0; i&lt;mat.br_redova; i++)
            for (int j=0; j&lt;mat.br_kolona; j++) {
                std::cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
                std::cin&gt;&gt;mat.elementi[i][j];
            }
    }

template &lt;typename TipElemenata&gt;
    void IspisiMatricu (const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false) {
        for (int i=0; i&lt;mat.br_redova; i++) {
            for (int j=0; j&lt;mat.br_kolona; j++)
<a name="2"></a><font color="#0000FF"><a href="match219-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

                std::cout&lt;&lt;std::setprecision(preciznost)&lt;&lt;std::setw(sirina_ispisa)&lt;&lt;mat.elementi[i][j];
            std::cout&lt;&lt;std::endl;
        }
        if (treba_brisati==true)
            UnistiMatricu(mat);
    }

template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; ZbirMatrica (const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2) {
</font>        if (m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
            throw std::domain_error("Matrice nemaju jednake dimenzije!");
        auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
        for (int i=0; i&lt;m1.br_redova; i++)
            for (int j=0; j&lt;m1.br_kolona; j++)
                m3.elementi[i][j]=m1.elementi[i][j]+m2.elementi[i][j];
        return m3;
    }

template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; ProduktMatrica (const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2) {
        if (m1.br_redova != m2.br_kolona || m1.br_kolona != m2.br_redova)
            throw std::domain_error("Matrice nisu saglasne za mnozenje");
        auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona));
<a name="1"></a><font color="#00FF00"><a href="match219-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_21.gif"/></a>

        for (int i=0; i&lt;m1.br_redova; i++) {
            for (int j=0; j&lt;m2.br_kolona; j++) {
                TipElemenata S;
                S=0;
                for (int k=0; k&lt;m1.br_kolona; k++) {
                    S+=m1.elementi[i][k]*m2.elementi[k][j];
                }
                m3.elementi[i][j]=S;
            }
        }
        return m3;
    }

template &lt;typename TipElemenata, typename ItTip&gt;
    Matrica&lt;TipElemenata&gt; MatricniPolinom (const Matrica&lt;TipElemenata&gt; &amp;mat, int n, ItTip it) {
        if (n&lt;0)
            throw std::domain_error("Neispravan stepen polinoma");
        if (mat.br_redova!=mat.br_kolona)
            throw std::domain_error("Matrica mora biti kvadratna");
        auto Pn (StvoriMatricu&lt;TipElemenata&gt;(mat.br_redova, mat.br_kolona));
        Matrica&lt;TipElemenata&gt; t;
        auto q=it;
        
        for (int i=0; i&lt;=n; i++) {
            t=StvoriMatricu&lt;TipElemenata&gt;(mat.br_redova, mat.br_kolona);
            for (int y1=0; y1&lt;mat.br_redova; y1++)
                for (int y2=0; y2&lt;mat.br_kolona; y2++)
                    t.elementi[y1][y2]=mat.elementi[y1][y2];
        
            if (i==0) {
                for (int y1=0; y1&lt;mat.br_redova; y1++)
                    for (int y2=0; y2&lt;mat.br_kolona; y2++) {
                        if(y1==y2) Pn.elementi[y1][y2]=1;
</font><a name="0"></a><font color="#FF0000"><a href="match219-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_29.gif"/></a>

                        else Pn.elementi[y1][y2]=0;
                    }
                for (int c=0; c&lt;mat.br_redova; c++) 
                    for (int x=0; x&lt;mat.br_kolona; x++){
                        Pn.elementi[x][c]*=(*q);
                    }
                q++;
                UnistiMatricu(t);
            }
        
            if (i!=0) {
                if (i==1) {
                    for (int r1=0; r1&lt;mat.br_redova; r1++) {
                        for (int r2=0; r2&lt;mat.br_kolona; r2++) {
                            t.elementi[r1][r2]=(*q)*mat.elementi[r1][r2];
                        }
                    }
                    auto s=Pn;
                    Pn=ZbirMatrica(Pn, t);
                    q++;
                    UnistiMatricu(s);
                    UnistiMatricu(t);
                }
                else {
                    for (int v=2; v&lt;=i; v++){
                        auto s=t;
                        t=ProduktMatrica(t, mat);
                        UnistiMatricu(s);
                    }
                    for (int e1=0; e1&lt;mat.br_redova; e1++) {
                        for (int e2=0; e2&lt;mat.br_kolona; e2++) {
                            t.elementi[e1][e2]=(*q)*(t.elementi[e1][e2]);
                        }
                    }
                    auto s=Pn;
                    Pn=ZbirMatrica(Pn, t);
                    q++;
                    UnistiMatricu(t);
                    UnistiMatricu(s);
                }
            }
        }
        return Pn;
    }
        

int main ()
{
    Matrica&lt;double&gt; a;
    int dimenzije;
    std::cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    std::cin&gt;&gt;dimenzije;
    std::cout&lt;&lt;"Unesite elemente matrice A:\n";
    
    //try {
        a=StvoriMatricu&lt;double&gt;(dimenzije, dimenzije);
        UnesiMatricu('A', a);
    //}
    //catch(std::bad_alloc) {
      //  std::cout&lt;&lt;"Nema dovoljno memorije!"&lt;&lt;std::endl;
    //}
    
    
    int n;
    std::cout&lt;&lt;"Unesite red polinoma: ";
    std::cin&gt;&gt;n;
    
    std::vector&lt;double&gt; koef;
    double temp;
    std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
    for (int i=0; i&lt;n+1; i++){
        std::cin&gt;&gt;temp;
        koef.push_back(temp);
    }
    
    auto P=MatricniPolinom(a, n, koef.begin());
    IspisiMatricu(P, 10, 6, false);
    UnistiMatricu(P);
    UnistiMatricu(a);
</font>	return 0;
}
</pre>
</body>
</html>
