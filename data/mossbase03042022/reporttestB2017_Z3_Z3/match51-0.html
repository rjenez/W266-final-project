<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student3867.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student3867.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;cstdio&gt;
#include &lt;new&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

<a name="5"></a><font color="#FF0000"><a href="match51-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

template &lt; typename T &gt;
struct Matrica
{
  int br_redova, br_kolona;
  T **elementi { nullptr };
};

template &lt; typename T &gt;
void UnistiMatricu ( Matrica &lt; T &gt; mat )
{
    if ( !mat.elementi )
        return;
    for ( int i = 0; i &lt; mat.br_redova; i++ )
</font>        delete [] mat.elementi [ i ];
    delete [] mat.elementi;
    mat.elementi = nullptr;
}

template &lt; typename T &gt;
Matrica &lt; T &gt; StvoriMatricu ( int br_redova, int br_kolona )
{
    Matrica &lt; T &gt; mat;
    mat.br_redova = br_redova; mat.br_kolona = br_kolona;
    mat.elementi = new T *[ br_redova ];
    
    for ( int i = 0; i &lt; br_redova; i++ )
        mat.elementi [ i ] = nullptr;
    try
    {
<a name="3"></a><font color="#00FFFF"><a href="match51-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

        for ( int i = 0; i &lt; br_redova; i++ )
            mat.elementi [ i ] = new T [ br_kolona ];
    }
    catch ( ... ) { UnistiMatricu ( mat ); throw; }
    
    for ( int i = 0; i &lt; br_redova; i++ )
        for ( int j = 0; j &lt; br_kolona; j++ )
            mat.elementi [ i ] [ j ] = 0;
    
    return mat;
}

template &lt; typename T &gt;
void UnesiMatricu ( char ime_matrice, Matrica &lt; T &gt; &amp;mat )
{
    for ( int i = 0; i &lt; mat.br_redova; i++ )
</font>        for ( int j = 0; j &lt; mat.br_kolona; j++ )
        {
<a name="1"></a><font color="#00FF00"><a href="match51-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_16.gif"/></a>

            std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
            std::cin &gt;&gt; mat.elementi [ i ] [ j ];
        }
}

template &lt; typename T &gt;
void UnesiValMatricu ( T val, Matrica &lt; T &gt; &amp;mat )
{
    for ( int i = 0; i &lt; mat.br_redova; i++ )
        for ( int j = 0; j &lt; mat.br_kolona; j++ )
            mat.elementi [ i ] [ j ] = val;
}

template &lt; typename T &gt;
void UnesiJedinicnuMatricu ( Matrica &lt; T &gt; &amp;a )
{
    for ( int i = 0; i &lt; a.br_redova; i++ )
        a.elementi [ i ] [ i ] = 1;
}

template &lt; typename T &gt;
void IspisiMatricu ( const Matrica &lt; T &gt; &amp;mat, int sirina_ispisa, int preciznost = 6, bool treba_brisati = true )
{
    std::cout.precision ( preciznost );
    for ( int i = 0; i &lt; mat.br_redova; i++ )
    {
        for ( int j = 0; j &lt; mat.br_kolona; j++ )
            std::cout &lt;&lt; std::setw ( sirina_ispisa ) &lt;&lt; mat.elementi [ i ] [ j ];
        std::cout &lt;&lt; std::endl;
</font>    }
    
    if ( treba_brisati )
        UnistiMatricu ( mat );
}

template &lt; typename T &gt;
<a name="4"></a><font color="#FF00FF"><a href="match51-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

Matrica &lt; T &gt; ZbirMatrica ( const Matrica &lt; T &gt; &amp;m1, const Matrica &lt; T &gt; &amp;m2 )
{
    if ( m1.br_redova != m2.br_redova or m1.br_kolona != m2.br_kolona )
        throw std::domain_error ( "Matrice nemaju jednake dimenzije!" );
    auto m3 ( StvoriMatricu &lt; T &gt; ( m1.br_redova, m1.br_kolona ) );
</font>    
    for ( int i = 0; i &lt; m1.br_redova; i++ )
        for ( int j = 0; j &lt; m1.br_kolona; j++ )
<a name="2"></a><font color="#0000FF"><a href="match51-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_10.gif"/></a>

            m3.elementi [ i ] [ j ] = m1.elementi [ i ] [ j ] + m2.elementi [ i ] [ j ];
        
    return m3;
}

template &lt; typename T &gt; 
Matrica &lt; T &gt; ProduktMatrica ( Matrica &lt; T &gt; a, Matrica &lt; T &gt; b )
{
/*** "dot-produkt" parametara 'a' i 'b' ***/
    Matrica &lt; double &gt; product;
    // provjera da li je jedna od matrica "skalarna" matrica
    if ( ( a.br_kolona == 1 and a.br_redova == 1 ) or ( b.br_kolona == 1 and b.br_redova == 1 ) )
        goto SCALAR; // ako jeste, ide na algoritam za mnozenje sa skalarom
    else if ( a.br_kolona != b.br_redova )
        throw std::domain_error ( "Matrice nisu saglasne za mnozenje" );
    // mnozenje saglasnih matrica    
    product = StvoriMatricu &lt; double &gt; ( a.br_redova, b.br_kolona );
    for ( int i = 0; i &lt; a.br_redova; i++ )
        for ( int j = 0; j &lt; b.br_kolona; j++ )
            for ( int k = 0; k &lt; a.br_kolona; k++ )
</font><a name="0"></a><font color="#FF0000"><a href="match51-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_37.gif"/></a>

                product.elementi [ i ] [ j ] += a.elementi [ i ] [ k ] * b.elementi [ k ] [ j ];
    goto END; // preskace algoritam za mnozenje sa skalarom

SCALAR: // algoritam za mnozenje sa skalarom
    product = StvoriMatricu &lt; double &gt; ( ( a.br_redova == 1 ? b.br_redova : a.br_redova ), ( a.br_kolona == 1 ? b.br_kolona : a.br_kolona ) );
    for ( int i = 0; i &lt; product.br_redova; i++ )
        for ( int j = 0; j &lt; product.br_kolona; j++ )
            product.elementi [ i ] [ j ] = ( a.br_redova == 1 ) ? 
                ( a.elementi [ 0 ] [ 0 ] * b.elementi [ i ] [ j ] ) : ( a.elementi [ i ] [ j ] * b.elementi [ 0 ] [ 0 ] );
END:    
    return product;
}

template &lt; typename T, typename IT &gt;
Matrica &lt; T &gt; MatricniPolinom ( Matrica &lt; T &gt; a, int step, IT it )
{
    if ( step &lt; 0 )
        throw std::domain_error ( "Neispravan stepen polinoma" );
    if ( a.br_redova != a.br_kolona )
        throw std::domain_error ( "Matrica mora biti kvadratna " );
      
    Matrica &lt; double &gt; p_Mat { StvoriMatricu &lt; double &gt; ( a.br_redova, a.br_kolona ) }; // polinom matrica
    
    Matrica &lt; double &gt; temp_Mat;
    Matrica &lt; double &gt; dd_Mat;
    Matrica &lt; double &gt; pro_Mat;
    
    for ( int i = 0; i &lt;= step; i++ )
    {
        Matrica &lt; double &gt; t_Mat { StvoriMatricu &lt; double &gt; ( 1, 1 ) }; // koeficijent matrica / skalar
        UnesiValMatricu ( T ( *it++ ), t_Mat );
        
        Matrica &lt; double &gt; pow_Mat { StvoriMatricu &lt; double &gt; ( a.br_redova, a.br_kolona ) }; // stepen matrica
        UnesiJedinicnuMatricu ( pow_Mat );
    
        for ( int j = 0; j &lt; i; j++ )
        { // stepenovanje matrice 'stepen matrica'
            temp_Mat = pow_Mat;
            pow_Mat = ProduktMatrica ( pow_Mat, a );
            UnistiMatricu ( temp_Mat );
        }
        
        pro_Mat = p_Mat;
        p_Mat = ZbirMatrica ( p_Mat, dd_Mat = ProduktMatrica ( pow_Mat, t_Mat ) );
        UnistiMatricu ( pro_Mat );
        
        UnistiMatricu ( dd_Mat );
        UnistiMatricu ( pow_Mat );
        UnistiMatricu ( t_Mat );
        
    }
    
    return p_Mat;
}

int main ( void )
{
    int num;
    std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    std::cin &gt;&gt; num;
    
    Matrica &lt; double &gt; mat { StvoriMatricu &lt; double &gt; ( num, num ) };
    
    std::cout &lt;&lt; "Unesite elemente matrice A:\n";
    UnesiMatricu( 'A', mat );
    
    int step;
    std::cout &lt;&lt; "Unesite red polinoma: ";
    std::cin &gt;&gt; step;
    
    std::vector &lt; int &gt; coeff;
    int i = 0;
    std::cout &lt;&lt; "Unesite koeficijente polinoma: ";
    while ( i++ &lt;= step and std::cin &gt;&gt; num )
        coeff.push_back ( num );
        
    
    IspisiMatricu ( MatricniPolinom ( mat, step, coeff.begin () ), 10, 5 );
    
    UnistiMatricu ( mat );
    
    return 0;
</font>}</pre>
</body>
</html>
