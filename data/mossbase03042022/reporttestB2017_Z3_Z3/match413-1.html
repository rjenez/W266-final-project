<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student2701.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student5562.cpp<p></p><pre>
<a name="4"></a><font color="#FF00FF"><a href="match413-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

/B2017/2018: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;vector&gt;
#include&lt;new&gt;
#include&lt;stdexcept&gt;
#include&lt;functional&gt;

using namespace std;


template&lt;typename TipElemenata&gt;
struct Matrica
{
    int br_redova, br_kolona;
    TipElemenata **elementi=nullptr;
};

template&lt;typename TipElemenata&gt;
</font>void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat)
{
    if(!mat.elementi) return;
    for(int i=0; i&lt;mat.br_redova; i++) delete [] mat.elementi[i];
    delete [] mat.elementi;
    mat.elementi=nullptr;
}
template&lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona)
{
    Matrica&lt;TipElemenata&gt; mat;
    mat.br_kolona=br_kolona;
    mat.br_redova=br_redova;
    try{
        mat.elementi= new TipElemenata*[br_redova];
        for(int i=0; i&lt;br_redova; i++) mat.elementi[i]=nullptr;
        try{
            for(int i=0; i&lt;br_redova; i++) mat.elementi[i]=new TipElemenata[br_kolona];
            return mat;
        }
        catch(...) { throw;}
    } catch(...) { UnistiMatricu(mat); throw;}    
    
}

template&lt;typename TipElemenata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat)
{
    for(int i=0; i&lt;mat.br_redova; i++)
        for(int j=0; j&lt;mat.br_kolona; j++)
            {
                cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
<a name="5"></a><font color="#FF0000"><a href="match413-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

                cin&gt;&gt;mat.elementi[i][j];
            }
            
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;mat1, const Matrica&lt;TipElemenata&gt; &amp;mat2)
</font>{
    auto m3(StvoriMatricu&lt;TipElemenata&gt;(mat1.br_redova, mat1.br_kolona));
    for(int i=0; i&lt;mat1.br_redova; i++)
        for(int j=0; j&lt;mat2.br_kolona; j++)
            m3.elementi[i][j]=mat1.elementi[i][j]+mat2.elementi[i][j];
    return m3;
}


 template&lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt;nule(int a,int b)
 {
     auto r=StvoriMatricu&lt;TipElemenata&gt;(a,b);
     for(int i=0;i&lt;a;i++)
     for(int j=0;j&lt;b;j++)
     r.elementi[i][j]=0;
     return r;
 }
 
 template&lt;typename TipElemenata&gt;
<a name="2"></a><font color="#0000FF"><a href="match413-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

 Matrica&lt;TipElemenata&gt;ProduktMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2)
 {
     if(m1.br_redova!=m1.br_kolona) throw domain_error("Matrice nisu saglasne za mnozenje!");
     auto r=nule&lt;TipElemenata&gt;(m1.br_redova,m1.br_kolona);
     for(int i=0;i&lt;m1.br_redova;i++)
</font>        for(int j=0;j&lt;m2.br_kolona;j++)
            for(int k=0;k&lt;m2.br_redova;k++)
<a name="1"></a><font color="#00FF00"><a href="match413-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

                r.elementi[i][j]+=m1.elementi[i][k]*m2.elementi[k][k];
     return r;
 }
 

template&lt;typename TipElemenata, typename t1&gt;
Matrica&lt;TipElemenata&gt;MatricniPolinom(const Matrica&lt;TipElemenata&gt; &amp;m,int n,t1 p)
{
     if(m.br_kolona!=m.br_redova)throw domain_error("Matrica mora biti kvadratna!");
</font>}

<a name="0"></a><font color="#FF0000"><a href="match413-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

template&lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat,int sirina_ispisa,int preciznost=6,bool treba_brisati=0)
{
    for(int i=0;i&lt;mat.br_redova;i++)
    {
        for(int j=0;j&lt;mat.br_kolona;j++)
        cout&lt;&lt;setw(sirina_ispisa)&lt;&lt;setprecision(preciznost)&lt;&lt;right&lt;&lt;mat.elementi[i][j];
        cout&lt;&lt;endl;
    }
    if(treba_brisati) UnistiMatricu(mat)
</font><a name="3"></a><font color="#00FFFF"><a href="match413-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

;}
int main ()
{
    cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    int n;
    cin&gt;&gt;n;
    try{
        auto mat=StvoriMatricu&lt;int&gt;(n,n);
        cout&lt;&lt;"Unesite elemente matrice A: "&lt;&lt;endl;
        UnesiMatricu('A',mat);
        cout&lt;&lt;"Unesite red polinoma: ";
        int r; cin&gt;&gt;r;
	     vector&lt;int&gt; v;
</font>	     cout&lt;&lt;"Unesite koeficijente polinoma: ";
	     for(int i=0; i&lt;r+1; i++){
	         double df;cin&gt;&gt;df;
	         v.at(i)=df;
	     } 
	     try{
<a name="6"></a><font color="#00FF00"><a href="match413-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

	          auto m2=MatricniPolinom&lt;int&gt;(mat,r,v.begin());
	          IspisiMatricu(m2,10);
	         UnistiMatricu(mat);
	         UnistiMatricu(m2);
	     } catch(...) 
	     {UnistiMatricu(mat);throw;}
    }
    catch(domain_error iz) { cout&lt;&lt;"Izuzetak: "&lt;&lt;iz.what();}
</font>	catch(...) {}
	return 0;
}
</pre>
</body>
</html>
