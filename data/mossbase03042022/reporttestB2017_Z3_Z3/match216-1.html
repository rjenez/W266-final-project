<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student1424.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student6553.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

template &lt;typename TipElemenata&gt;
struct Matrica {
    int br_redova, br_kolona;
    TipElemenata **elementi=nullptr;
};

template &lt;typename TipElemenata&gt;
void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat)
{
    if(!mat.elementi) return;
    for(int i=0; i&lt;mat.br_redova; i++) delete [] mat.elementi[i];
    delete [] mat.elementi;
    mat.elementi=nullptr;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona)
{
<a name="2"></a><font color="#0000FF"><a href="match216-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

    Matrica &lt;TipElemenata&gt; mat;
    mat.br_redova=br_redova;
    mat.br_kolona=br_kolona;
    mat.elementi=new TipElemenata*[br_redova] {};
    try {
        for(int i=0; i&lt;br_redova; i++) mat.elementi[i]=new TipElemenata[br_kolona];
    } catch(std::bad_alloc) {
        UnistiMatricu(mat);
        throw;
    }
    return mat;
}

template &lt;typename TipElemenata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat)
{
    for(int i=0; i&lt;mat.br_redova; i++) {
</font>        for(int j=0; j&lt;mat.br_kolona; j++) {
            std::cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            std::cin&gt;&gt;mat.elementi[i][j];
        }
    }
}
template &lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false)
{
    for(int i=0; i&lt;mat.br_redova; i++) {
        for(int j=0; j&lt;mat.br_kolona; j++)
            std::cout&lt;&lt;std::setw(sirina_ispisa)&lt;&lt;std::setprecision(preciznost)&lt;&lt;mat.elementi[i][j];
        std::cout&lt;&lt;std::endl;
    }
    if(treba_brisati) UnistiMatricu(mat);
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ZbirMatrica (const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2)
{
    if(m1.br_kolona!=m2.br_kolona || m1.br_redova!=m2.br_redova) throw std::domain_error("Matrice nemaju jednake dimenzije!");
    
    auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
    for(int i=0; i&lt;m1.br_redova; i++) {
        for(int j=0; j&lt;m1.br_kolona; j++) {
<a name="1"></a><font color="#00FF00"><a href="match216-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_13.gif"/></a>

            m3.elementi[i][j]=m1.elementi[i][j]+m2.elementi[i][j];
        }
    }
    return m3;
}

template &lt;typename TipElemenata&gt;
void NapraviJedinicnu(Matrica &lt;TipElemenata&gt;&amp; mat,bool jedinicna)
{
    for(int i=0; i&lt;mat.br_redova; i++) {
        for(int j=0; j&lt;mat.br_kolona; j++) {
            if(i==j &amp;&amp; jedinicna) mat.elementi[i][j]=1;
            else mat.elementi[i][j]=0;
        }
    }
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; Transformiraj(Matrica&lt;TipElemenata&gt; mat1,Matrica &lt;TipElemenata&gt; mat2, double k){
    auto mat3(StvoriMatricu&lt;TipElemenata&gt;(mat1.br_redova, mat1.br_kolona));
    
    for(int i=0;i&lt;mat1.br_redova;i++){
</font><a name="0"></a><font color="#FF0000"><a href="match216-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_40.gif"/></a>

        for(int j=0;j&lt;mat1.br_kolona;j++){
            mat3.elementi[i][j]=mat1.elementi[i][j]+k*mat2.elementi[i][j];
        }
    }
    UnistiMatricu(mat1);
    return mat3;
    
}

template &lt;typename TipElemenata&gt;
Matrica &lt;TipElemenata&gt; ProduktMatrica(Matrica&lt;TipElemenata&gt; mat1, Matrica&lt;TipElemenata&gt; mat2, bool unisti=false){
    if(mat1.br_kolona!=mat2.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
    auto mat3(StvoriMatricu&lt;TipElemenata&gt;(mat1.br_redova,mat2.br_kolona));
    for(int i=0;i&lt;mat1.br_redova;i++){
        for(int j=0;j&lt;mat2.br_kolona;j++){
            TipElemenata suma=TipElemenata();
            for(int k=0;k&lt;mat1.br_kolona;k++){
                suma=suma+mat1.elementi[i][k]*mat2.elementi[k][j];
            }
            mat3.elementi[i][j]=suma;
        }
    }
    if(unisti) UnistiMatricu(mat1);
   return mat3; 
    
}

template &lt;typename TipElemenata, typename IterTip&gt;
Matrica &lt;TipElemenata&gt; MatricniPolinom(Matrica &lt;TipElemenata&gt; A, int n, IterTip polinom){
    if(n&lt;0) throw std::domain_error("Neispravan stepen polinoma");
    if(A.br_kolona!=A.br_redova) throw std::domain_error("Matrica mora biti kvadratna");
    
    auto stepen(StvoriMatricu&lt;TipElemenata&gt;(A.br_redova,A.br_redova));
    NapraviJedinicnu(stepen,true);
    auto zbir(StvoriMatricu&lt;TipElemenata&gt;(A.br_redova, A.br_redova));
    NapraviJedinicnu(zbir, false);

    int i=0;
    while(i&lt;=n){
        try{
        zbir=Transformiraj(zbir, stepen,*polinom);
       stepen=ProduktMatrica(stepen, A,true);
       
        polinom++;
        i++;}
        catch(std::bad_alloc){
            UnistiMatricu(zbir);UnistiMatricu(stepen);throw;
        }
    }
    UnistiMatricu(stepen);
 return zbir;   
}


int main ()
{
    int n;
    std::cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    std::cin&gt;&gt;n;
    auto A(StvoriMatricu&lt;double&gt;(n, n));
    try{
    std::cout&lt;&lt;"Unesite elemente matrice A: "&lt;&lt;std::endl;
    
    UnesiMatricu('A', A);
    std::cout&lt;&lt;"Unesite red polinoma: ";
    std::cin&gt;&gt;n;
    std::vector&lt;double&gt; koef(n+1);
    std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
    for(int i=0;i&lt;=n;i++) std::cin&gt;&gt;koef[i];
    auto zbir(MatricniPolinom&lt;double&gt;(A,n, koef.begin() ));
    IspisiMatricu(zbir,10);
        UnistiMatricu(zbir);
    }
    catch(std::bad_alloc){
        
    }
    
    UnistiMatricu(A);
</font>    return 0;
}
</pre>
</body>
</html>
