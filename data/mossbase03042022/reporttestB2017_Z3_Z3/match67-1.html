<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student6410.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student3678.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;new&gt;
template &lt;typename NekiTip&gt;
 struct matrica {
 int redovi, kolone;
 NekiTip **elementi=nullptr; 
 };
template &lt;typename NekiTip&gt;
 void Unistimatricu(matrica&lt;NekiTip&gt; mat) {
 if(!mat.elementi) return;
 for(int i=0; i&lt;mat.redovi; i++) delete[] mat.elementi[i];
 delete[] mat.elementi;
 mat.elementi=nullptr;
 }
template &lt;typename NekiTip&gt;
 matrica&lt;NekiTip&gt; Stvorimatricu(int redovi, int kolone) {
    matrica&lt;NekiTip&gt; mat;
     mat.redovi=redovi; mat.kolone = kolone;
     mat.elementi=new NekiTip*[redovi];
   for(int i=0; i&lt;redovi; i++) mat.elementi[i] = nullptr;
 try {
 for(int i=0; i&lt;redovi; i++)
 mat.elementi[i] = new NekiTip[kolone]{};
 }
 catch(...) {
 Unistimatricu(mat);
 throw;
 }
 return mat;
 }
template &lt;typename NekiTip&gt;
 void Unesimatricu(char ime_matrice, matrica&lt;NekiTip&gt; &amp;mat) {
 for(int i=0; i&lt;mat.redovi; i++)
 for(int j=0; j&lt;mat.kolone; j++) {
 std::cout &lt;&lt; ime_matrice
 &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
 std::cin &gt;&gt; mat.elementi[i][j];
 }
 }
template &lt;typename NekiTip&gt;
 void Ispisimatricu(const matrica&lt;NekiTip&gt; &amp;mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false) {
       for(int i=0; i&lt;mat.redovi; i++) {
           for(int j=0; j&lt;mat.kolone; j++)
            std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt;std::setprecision(preciznost)&lt;&lt; mat.elementi[i][j];
            std::cout &lt;&lt; std::endl;
       }
       if(treba_brisati) Unistimatricu(mat);
 }
<a name="3"></a><font color="#00FFFF"><a href="match67-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

template &lt;typename NekiTip&gt;
 matrica&lt;NekiTip&gt; Zbirmatrica(const matrica&lt;NekiTip&gt; &amp;mat1,const matrica&lt;NekiTip&gt; &amp;mat2) {
 matrica&lt;NekiTip&gt; mat3;
 mat3= (Stvorimatricu&lt;NekiTip&gt;(mat1.redovi, mat1.kolone));
 for(int i=0; i&lt;mat1.redovi; i++)
</font> for(int j=0; j&lt;mat1.kolone; j++)
<a name="1"></a><font color="#00FF00"><a href="match67-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_19.gif"/></a>

 mat3.elementi[i][j] = mat1.elementi[i][j] + mat2.elementi[i][j];
 return mat3;
 }

std::vector&lt;double&gt; UnosKoefPolin(int n){
    std::vector&lt;double&gt; vec;
    for(int i=0;i&lt;n+1;i++){
        double x;
        std::cin&gt;&gt;x;
        vec.push_back(x);
    }
    
    return vec;
}

template &lt;typename NekiTip&gt;
 matrica&lt;NekiTip&gt; Produktmatrica(const matrica&lt;NekiTip&gt; &amp;mat1,const matrica&lt;NekiTip&gt; &amp;mat2) {
 if(mat1.kolone != mat2.redovi)
 throw std::domain_error("matrice nisu saglasne za mnozenje");
 matrica&lt;NekiTip&gt; mat3;
 mat3=(Stvorimatricu&lt;NekiTip&gt;(mat1.redovi, mat2.kolone));

 for(int i=0; i&lt;mat1.redovi;i++){
            int k = 0;
            for(int j=0;j&lt;mat3.kolone;j++){
                double suma(0);
                for(int l = 0;l&lt;mat2.redovi;){
                    suma+=mat1.elementi[i][l] * mat2.elementi[l][j];
                    l++;
                }
                k++;
                mat3.elementi[i][j] = suma;
            }
 }
 return mat3;
 }
template &lt;typename NekiTip&gt;
 matrica&lt;NekiTip&gt; NapraviJedinicnu(const matrica&lt;NekiTip&gt; &amp;mat1) {
  matrica&lt;NekiTip&gt; mat3;
  mat3=(Stvorimatricu&lt;NekiTip&gt;(mat1.redovi, mat1.kolone));
    
 for(int i=0; i&lt;mat1.redovi;i++){
</font>            for(int j=0;j&lt; mat1.kolone;j++){
<a name="2"></a><font color="#0000FF"><a href="match67-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

                if(i==j)    mat3.elementi[i][j]=1;
                else mat3.elementi[i][j]=0;
            }
 }
 return mat3;
 }
 template &lt;typename NekiTip&gt;
 matrica&lt;NekiTip&gt; Skalarno(const matrica&lt;NekiTip&gt; &amp;mat1,double x) {
  matrica&lt;NekiTip&gt; mat3;
  mat3=(Stvorimatricu&lt;NekiTip&gt;(mat1.redovi, mat1.kolone));
 for(int i=0; i&lt;mat1.redovi;i++){
            for(int j=0;j&lt;mat1.kolone;j++){
                mat3.elementi[i][j]=x*mat1.elementi[i][j];
            }
 }
 return mat3;
 }
 
  template &lt;typename NekiTip&gt;
 matrica&lt;NekiTip&gt; NapraviOrginalnu(const matrica&lt;NekiTip&gt; &amp;mat1) {
  matrica&lt;NekiTip&gt; mat3;
  mat3=(Stvorimatricu&lt;NekiTip&gt;(mat1.redovi, mat1.kolone));
 for(int i=0; i&lt;mat1.redovi;i++){
</font><a name="0"></a><font color="#FF0000"><a href="match67-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_31.gif"/></a>

            for(int j=0;j&lt;mat1.kolone;j++){
                mat3.elementi[i][j]=mat1.elementi[i][j];
            }
 }
 return mat3;
 }
 
 
 template &lt;typename NekiTip&gt;
 matrica&lt;NekiTip&gt; matricniPolinom(const matrica&lt;NekiTip&gt; &amp;mat1,const std::vector&lt;double&gt; &amp;vec) {
 if(mat1.redovi != mat1.kolone) throw std::domain_error("matrica mora biti kvadratn");
 matrica&lt;NekiTip&gt; mat3;
 std::vector&lt;matrica&lt;NekiTip&gt;&gt; v;
 for(int i=0; i&lt;(vec.size());i++){
            if(i==0) v.push_back(NapraviJedinicnu(mat1));
            else if(i==1) {matrica&lt;NekiTip&gt; mat;
            mat = NapraviOrginalnu(mat1);
            v.push_back(mat);}
            else
                v.push_back(Produktmatrica(mat1,v[i-1]));
            
 }
 std::vector&lt;matrica&lt;NekiTip&gt;&gt; v1;
 for(int i=0;i&lt;(vec.size());i++){
            v1.push_back(Skalarno(v[i],vec[i]));
            
 }
 std::vector&lt;matrica&lt;NekiTip&gt;&gt; v2;

 for(int i=0;i&lt;(vec.size())-1;i++){
     if(i==0) v2.push_back(Zbirmatrica(v1[i],v1[i+1]));
     else
        v2.push_back(Zbirmatrica(v2[i-1],v1[i+1]));
     if(i==(vec.size())-2) {mat3=v2[i];}
 }
 
 for(int i=0;i&lt;vec.size();i++){
    Unistimatricu(v1[i]);Unistimatricu(v[i]);
 }
 for(int i=0;i&lt;(vec.size())-2;i++)
    Unistimatricu(v2[i]);
 return mat3;
 }

int main() {
    matrica&lt;double&gt; a;
    matrica&lt;double&gt; c;
    int  n;
    std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    std::cin &gt;&gt; n;
    try {
        a = Stvorimatricu&lt;double&gt;(n, n);
        std::cout &lt;&lt; "Unesite elemente matrice A: "&lt;&lt;std::endl;
        Unesimatricu('A', a);
        std::cout&lt;&lt;"Unesite red polinoma: ";
        int m;
        std::cin&gt;&gt;m;
        std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
        std::vector&lt;double&gt; vec(UnosKoefPolin(m));
    
       
        Ispisimatricu(c = matricniPolinom&lt;double&gt;(a, vec), 10);
        
        
    }
    catch(std::bad_alloc) {
             std::cout &lt;&lt; "Nema dovoljno memorije!\n";
    }
 Unistimatricu(a); Unistimatricu(c);
</font>
 return 0;
}</pre>
</body>
</html>
