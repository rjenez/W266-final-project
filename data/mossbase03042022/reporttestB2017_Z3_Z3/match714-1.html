<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student1313.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student7507.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

template &lt;typename TipElemenata&gt;
    struct Matrica{
        int br_redova, br_kolona;
        TipElemenata **elementi=nullptr;
    };

template &lt;typename TipElemenata&gt;
void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat){
    if(!mat.elementi) return;
    for(int i=0; i&lt;mat.br_redova; i++) delete[] mat.elementi[i];
    delete[] mat.elementi;
    mat.elementi=nullptr;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona){
    Matrica&lt;TipElemenata&gt; mat;
    mat.br_redova=br_redova; mat.br_kolona=br_kolona;
    mat.elementi = new TipElemenata*[br_redova];
    for(int i=0; i&lt;br_redova; i++) mat.elementi[i]=nullptr;
    try {
        for(int i=0; i&lt;br_redova; i++)
            mat.elementi[i] = new TipElemenata[br_kolona];
    }
    catch (...) {
        UnistiMatricu(mat);
        throw;
    }
    return mat;
    
}

template &lt;typename TipElemenata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat){
    for(int i=0; i&lt;mat.br_redova; i++){
        for(int j=0; j&lt;mat.br_kolona; j++){
            std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i+1 &lt;&lt; "," &lt;&lt; j+1 &lt;&lt; ") = ";
            std::cin &gt;&gt; mat.elementi[i][j];
        }
    }
}

template &lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt; mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false){
    for(int i=0; i&lt;mat.br_redova; i++){
        for(int j=0; j&lt;mat.br_kolona; j++)
            std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; std::setprecision(preciznost) &lt;&lt; mat.elementi[i][j];
        std::cout &lt;&lt; std::endl;
    }
    if(treba_brisati) UnistiMatricu(mat);
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ZbirMatrica (const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2){
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona){
        throw std::domain_error("Matrica nemaju jednake dimenzije!");
    }
    //auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova,m1.br_kolona));
    for(int i=0; i&lt;m1.br_redova; i++)
        for(int j=0; j&lt;m1.br_kolona; j++)
            m1.elementi[i][j]=m1.elementi[i][j] + m2.elementi[i][j];
    return m1;
}
template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ProduktMatrica(const Matrica&lt;TipElemenata&gt; a, const Matrica&lt;TipElemenata&gt; b){
    if(a.br_kolona != b.br_redova)
        throw std::domain_error ("Matrice nisu saglasne za mnozenja");
    auto c(StvoriMatricu&lt;TipElemenata&gt;(a.br_redova, b.br_kolona));
    for(int i=0; i&lt;c.br_redova; i++){
        for(int j=0; j&lt;c.br_kolona; j++){
            c.elementi[i][j]={};
        }
    }
    int k(0);
    for(int i=0; i&lt;a.br_redova; i++){
        //TipElemenata suma{};
        for(int j=0; j&lt;b.br_kolona; j++){
            TipElemenata suma{};
            for(int l=0; l&lt;a.br_kolona; l++)
                suma+=a.elementi[i][l]*b.elementi[l][j];
                c.elementi[i][k]=suma;
                k++;
        }
        k=0;
    }
    return c;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; MnozenjeSkalarom(Matrica&lt;TipElemenata&gt; &amp;a, double b){
    for(int i=0; i&lt;a.br_redova; i++){
        for(int j=0; j&lt;a.br_kolona; j++){
            a.elementi[i][j] *= b;
        }
    }
    return a;
}

template&lt;typename TipElemenata, typename NekiTip&gt;
Matrica&lt;TipElemenata&gt; MatricniPolinom (Matrica&lt;TipElemenata&gt; m1, int n, NekiTip pk){
    if(n&lt;0) throw std::domain_error("Neispravan stepen polonoma");
    if(m1.br_kolona != m1.br_redova) {
        UnistiMatricu(m1);
<a name="1"></a><font color="#00FF00"><a href="match714-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

        throw std::domain_error("Matrica mora biti kvadratna");
    }
    
   /* auto b(StvoriMatricu&lt;TipElemenata&gt;(a.br_redova, a.br_kolona));
    for(int i=0; i&lt;b.br_redova; i++){
        for(int j=0; j&lt;b.br_kolona; j++){
            b.elementi[i][j]=0;
        }
    }
    
    bool logicka(false);
    auto pom(StvoriMatricu&lt;TipElemenata&gt;(a.br_redova, a.br_kolona));
    auto c(StvoriMatricu&lt;TipElemenata&gt;(a.br_redova, a.br_kolona));
    for(int k=0; k&lt;c.br_redova; k++)
        for(int j=0; j&lt;c.br_kolona; j++){
            c.elementi[k][j]=a.elementi[k][j];
        }
        
    
    int i=0;
    while (i&lt;=n) {
        if(i==0){
            for(int k=0; k&lt;b.br_redova; k++)
                for(int j=0; j&lt;b.br_kolona; j++)
                    if(k==j){
                        b.elementi[k][j]=*pk;
                        pk++;}
                        i++;
        }
        else{
            if(logicka){
                auto pom2=c;
                c=ProduktMatrica(c,a);
                UnistiMatricu(pom2);
            }
            for(int k=0; k&lt;c.br_redova; k++)
                for(int j=0; j&lt;c.br_kolona; j++)
                    pom.elementi[k][j] = c.elementi[k][j];
            ZbirMatrica(b, MnozenjeSkalarom(pom,*pk));
            logicka = true;
        }
       
    }
    
    UnistiMatricu(c);
    UnistiMatricu(pom);
     return b;*/
     
    auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
    auto jedinicna(StvoriMatricu&lt;TipElemenata&gt;(m1.br_kolona, m1.br_kolona));
    for(int i=0; i&lt;m1.br_redova; i++)
</font>        for(int j=0; j&lt;m1.br_kolona; j++)
<a name="3"></a><font color="#00FFFF"><a href="match714-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

            if(i==j) jedinicna.elementi[i][j]=1;
            else jedinicna.elementi[i][j]=0;
    
    for(int i=0; i&lt;m1.br_redova; i++)
        for(int j=0; j&lt;m1.br_kolona; j++)
</font><a name="0"></a><font color="#FF0000"><a href="match714-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

            m3.elementi[i][j]=jedinicna.elementi[i][j];
            
    for(int i=0; i&lt;m1.br_redova; i++)
        for(int j=0; j&lt;m1.br_kolona; j++){
            m3.elementi[i][j] *= *pk;
            }
    for(int i=0; i&lt;m1.br_redova; i++)
        for(int j=0; j&lt;m1.br_kolona; j++)
            jedinicna.elementi[i][j]=m1.elementi[i][j];
            
    auto jedinicna2(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
    
    for(int i=0; i&lt;m1.br_redova; i++)
</font>        for(int j=0; j&lt;m1.br_kolona; j++){
            jedinicna2.elementi[i][j]=jedinicna.elementi[i][j];
        }
    
    int k=1;
    while (k&lt;n) {
        for(int i=0; i&lt;m1.br_redova; i++)
<a name="4"></a><font color="#FF00FF"><a href="match714-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

            for(int j=0; j&lt;m1.br_kolona; j++){
                m3.elementi[i][j]+=(jedinicna.elementi[i][j] * (*pk));
                }
        pk++;
</font>        
        auto jedinicna3(ProduktMatrica(jedinicna, jedinicna2));
        for(int i=0; i&lt;m1.br_redova; i++)
<a name="2"></a><font color="#0000FF"><a href="match714-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

            for(int j=0; j&lt;m1.br_kolona; j++)
                jedinicna.elementi[i][j]= jedinicna3.elementi[i][j];
                UnistiMatricu(jedinicna3);
        k++;
    }
    UnistiMatricu(jedinicna);
    UnistiMatricu(jedinicna2);
    return m3;
}



int main ()
{
    std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: " ;
</font>    int n;
    std::cin &gt;&gt; n;
    try{
        auto a(StvoriMatricu&lt;double&gt;(n,n));
        std::cout &lt;&lt; "Unesite elementi matrice A: " &lt;&lt; std::endl;
        UnesiMatricu('A', a);
        std::cout &lt;&lt; "Unesite red polinoma: " ;
        int red;
        std::cin &gt;&gt; red;
        std::cout &lt;&lt; "Unesite koeficijente polinoma: " ;
        std::vector&lt;double&gt;koeficijenti;
        for(int i=0; i&lt;=red; i++){
            int broj;
            std::cin &gt;&gt; broj;
            koeficijenti.push_back(broj);
            
        }
        auto pok(koeficijenti.begin());
       
        IspisiMatricu(MatricniPolinom(a,red, pok),10,6,true);
        UnistiMatricu(a);
    }
    catch(...){
        std::cout &lt;&lt; "Greska" &lt;&lt; std::endl;
    }
	return 0;
}
</pre>
</body>
</html>
