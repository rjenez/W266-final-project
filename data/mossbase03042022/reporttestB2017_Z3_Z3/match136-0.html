<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student3717.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student3717.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;list&gt;

template &lt;typename TipElemenata&gt;
struct Matrica{
    int br_redova,br_kolona;
    TipElemenata **elementi=nullptr;
};

template &lt;typename TipElemenata&gt;
void UnistiMatricu(Matrica&lt;TipElemenata&gt; m){
    if(!m.elementi) return;
        for(int i=0; i&lt;m.br_redova; i++) delete[] m.elementi[i];
        delete[] m.elementi;
    m.elementi=nullptr;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona){
    Matrica&lt;TipElemenata&gt;m;
    m.br_redova=br_redova;
    m.br_kolona=br_kolona;
    m.elementi=new TipElemenata *[br_redova];
        for(int i=0; i&lt;br_redova; i++){
            m.elementi[i]=nullptr;
        }
        
    try{
            for(int i= 0; i&lt;br_redova; i++){
                m.elementi[i]=new TipElemenata[br_kolona];
            }
    }catch(...){
        UnistiMatricu(m);
        throw;
    }
    return m;
}

template &lt;typename TipElemenata&gt;
void UnesiMatricu(char ime, Matrica&lt;TipElemenata&gt;&amp;m){
    for(int i=0; i&lt;m.br_redova; i++){
        for(int j=0; j&lt;m.br_kolona; j++) {
<a name="3"></a><font color="#00FFFF"><a href="match136-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

            std::cout&lt;&lt;ime&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            std::cin&gt;&gt;m.elementi[i][j];
        }
    }
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt;ZbirMatrica(const Matrica&lt;TipElemenata&gt;&amp;m1, const Matrica&lt;TipElemenata&gt;&amp;m2){
</font>    if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona  ) {
        throw std:: domain_error("Matrice nemaju jednake dimenzije!");
    }
    auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
        for(int i=0; i&lt; m1.br_redova; i++){
            for(int j=0; j&lt;m1.br_kolona; j++){
                m3.elementi[i][j]=m1.elementi[i][j]+m2.elementi[i][j];
            }
        }
    return m3;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt;ProduktMatrica(const Matrica&lt;TipElemenata&gt;&amp;m1, const Matrica&lt;TipElemenata&gt;&amp;m2){
    if(m1.br_kolona!=m2.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
    auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona));
        for(int i=0; i&lt; m1.br_redova; i++){
<a name="4"></a><font color="#FF00FF"><a href="match136-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

            for(int j=0; j&lt;m2.br_kolona; j++){
            m3.elementi[i][j]=0;
            }
        }
        for(int i=0; i&lt;m1.br_redova; i++){
            for(int j=0; j&lt;m2.br_kolona; j++){
                for(int k=0; k&lt;m1.br_kolona; k++) m3.elementi[i][j]+=m1.elementi[i][k]*m2.elementi[k][j];
</font><a name="2"></a><font color="#0000FF"><a href="match136-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

            }
        }
        return m3;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt;pomnozi(double x, const Matrica&lt;TipElemenata&gt;&amp;m){
    auto mx(StvoriMatricu&lt;TipElemenata&gt;(m.br_redova, m.br_kolona));
    for(int i=0; i&lt;m.br_redova; i++){
        for(int j=0; j&lt;m.br_kolona; j++) mx.elementi[i][j]=x*m.elementi[i][j];
    }
    return mx;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt;jedinicna(const Matrica&lt;TipElemenata&gt;&amp;m){
    auto x(StvoriMatricu&lt;TipElemenata&gt;(m.br_redova, m.br_kolona));
        for(int i=0; i&lt;m.br_redova; i++){
</font>            for(int j=0; j&lt;m.br_kolona; j++){
<a name="0"></a><font color="#FF0000"><a href="match136-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_30.gif"/></a>

                if(i==j) x.elementi[i][j]=1;
                else x.elementi[i][j]=0;
            }
        }
        return x;
}

template &lt;typename TipElemenata, typename PokTip&gt;
Matrica&lt;TipElemenata&gt;MatricniPolinom(const Matrica&lt;TipElemenata&gt;&amp;A, int n, PokTip p){
    if(n&lt;0) throw std::domain_error("Neispravan stepen polinoma");
    if(n==0){
        auto nula(StvoriMatricu&lt;TipElemenata&gt;(A.br_kolona,A.br_redova) );
        for(int j=0; j&lt;A.br_redova; j++) {
            for(int k=0; k&lt;A.br_kolona; k++) nula.elementi[j][k]=0;
        }
        return nula;
    }
    if(A.br_redova!=A.br_kolona) throw std::domain_error("Matrica mora biti kvadratna");
    
    std::vector&lt;Matrica&lt;TipElemenata&gt;&gt;vekmatrica;
    std::vector&lt;Matrica&lt;TipElemenata&gt;&gt;vekmatrica2;
    
    for(int i=0; i&lt;n+1; i++){
        if(i==0){
        auto jedm(jedinicna(A));
        vekmatrica.push_back(pomnozi(*(p),jedm));
        UnistiMatricu(jedm);
        
        }else if(i==1){
            vekmatrica2.push_back(A);
            vekmatrica.push_back(pomnozi(*(++p),A));
            
        }else{
            vekmatrica2.push_back(ProduktMatrica(A,vekmatrica2.at(i-2)));
            PokTip pozicija(p);
            for(int j=0; j&lt;i; j++) pozicija++;
            vekmatrica.push_back(pomnozi(*(--pozicija),vekmatrica2.at(i-1)));
        }
    }
        std::vector&lt;Matrica&lt;TipElemenata&gt;&gt;rez;
                for(int i=0; i&lt;vekmatrica.size()-1; i++){
                 if(i==0) rez.push_back(ZbirMatrica(vekmatrica.at(i), vekmatrica.at(i+1)));
                 else rez.push_back(ZbirMatrica(vekmatrica.at(i+1), rez.at(i-1)));
            }
    for(int i=0; i&lt;vekmatrica.size(); i++){
        UnistiMatricu(vekmatrica.at(i));
    }
    for(int i=1; i&lt;vekmatrica2.size(); i++){
        UnistiMatricu(vekmatrica2.at(i));
    }
    for(int i=0; i&lt;rez.size()-1; i++){
        UnistiMatricu(rez.at(i));
    }
    
    return rez.at(rez.size()-1);
}

template &lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt;&amp;m, int sirina, int preciznost=6, bool treba_brisati=false){
</font>        for(int i=0; i&lt;m.br_redova; i++){
            for(int j=0; j&lt;m.br_kolona; j++){
<a name="1"></a><font color="#00FF00"><a href="match136-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

                std::cout&lt;&lt;std::setw(sirina)&lt;&lt;std::setprecision(preciznost)&lt;&lt;m.elementi[i][j];
            }
            std::cout&lt;&lt;std::endl;
        }
        if(treba_brisati) UnistiMatricu(m);
}

int main ()
{
    int m(0);
    Matrica&lt;int&gt;x,y;
    std::cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    std::cin&gt;&gt;m;
    try{
        x=StvoriMatricu&lt;int&gt;(m,m);
        std::cout&lt;&lt;"Unesite elemente matrice A: "&lt;&lt;std::endl;
        UnesiMatricu('A',x);
        std::cout&lt;&lt;"Unesite red polinoma: ";
        int n(0);
        std::cin&gt;&gt;n;
        std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
        std::list&lt;int&gt;l;
            for(int i=0; i&lt;=n; i++){
                int k(0);
                std::cin&gt;&gt;k;
                l.push_back(k);
            }
        y=MatricniPolinom(x,n,l.begin());
        IspisiMatricu(y,10);
    }catch(std::bad_alloc){
        std::cout&lt;&lt;"Nema dovoljno memorije";
    }
    UnistiMatricu(x);
    UnistiMatricu(y);
</font>	return 0;
}
</pre>
</body>
</html>
