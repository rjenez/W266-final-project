<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student7795.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student8467.cpp<p></p><pre>
/B2017/2018: Zadaća 3, Zadatak 3
//RAZMISLI O UNOSU! 
//Postoji mogućnost da nestane memorije, razmisli o tome

#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;

template &lt;typename Tip&gt;
struct Matrica{
    int br_redova, br_kolona;
<a name="2"></a><font color="#0000FF"><a href="match652-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

    Tip **elementi = nullptr;
};

template &lt;typename Tip&gt;
void UnistiMatricu(Matrica&lt;Tip&gt; &amp;mat){
    if(!mat.elementi) return; //U slucaju double delete-a
    for(int i = 0; i &lt; mat.br_redova; i++) delete[] mat.elementi[i];
</font>    delete[] mat.elementi;
    mat.elementi = nullptr;
}

template &lt;typename Tip&gt;
Matrica&lt;Tip&gt; StvoriMatricu(int br_redova, int br_kolona){
    Matrica&lt;Tip&gt; mat;
    mat.br_redova = br_redova; 
    mat.br_kolona = br_kolona;
    
    try {
        mat.elementi = new Tip*[br_redova]; //Stvara niz pokazivača na dereferenciranom pokazivacu, poslije taj niz popunjava sa drugim nizovima
        for(int i = 0; i &lt; br_redova; i++)  mat.elementi[i] = nullptr; // Inicijalizacija pokazivača, radi sigurnosti(double delete)
    }
    catch (...) {
        UnistiMatricu(mat);
        throw;
    }
    
    try {
        for(int i = 0; i &lt; br_redova; i++)  mat.elementi[i] = new Tip[br_kolona]{};
    }
    catch (...) {
        UnistiMatricu(mat);
        throw;
    }
    return mat;
}

template &lt;typename Tip&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;Tip&gt; &amp;mat){
    for(int i = 0; i &lt; mat.br_kolona; i++){
        for(int j = 0; j &lt; mat.br_kolona; j++){
<a name="0"></a><font color="#FF0000"><a href="match652-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

            std::cout &lt;&lt; ime_matrice &lt;&lt;"(" &lt;&lt; (i + 1) &lt;&lt; "," &lt;&lt; (j + 1) &lt;&lt; ") = ";
            std::cin &gt;&gt; mat.elementi[i][j];
        }
    }
}

template &lt;typename Tip&gt;
void IspisiMatricu(Matrica&lt;Tip&gt; &amp;mat, int sirina, int preciznost = 6, bool treba_brisati = false){
    
    for(int i = 0; i &lt; mat.br_kolona; i++){
</font>        for(int j = 0; j &lt; mat.br_redova; j++){
<a name="1"></a><font color="#00FF00"><a href="match652-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

            std::cout &lt;&lt; std::setprecision(preciznost) &lt;&lt; std::setw(sirina) &lt;&lt; mat.elementi[i][j];
        }
        std::cout &lt;&lt; std::endl;
    }
    if(treba_brisati){
        UnistiMatricu(mat);
    }
    
}

template &lt;typename Tip, typename Tip1&gt;
auto ZbirMatrica(const Matrica&lt;Tip&gt; &amp;mat1, const Matrica&lt;Tip1&gt; &amp;mat2) -&gt; Matrica&lt;decltype(**mat1.elementi + **mat2.elementi)&gt;{
</font>    if(mat1.br_kolona != mat2.br_kolona || mat1.br_redova != mat2.br_redova) throw std::domain_error("Matrice nemaju jednake dimenzije");
    
    auto mat3(StvoriMatricu&lt;decltype(**mat1.elementi + **mat2.elementi)&gt;(mat1.br_redova, mat1.br_kolona));
    
    for(int i = 0; i &lt; mat1.br_redova; i++){
        for(int j = 0; j &lt; mat1.br_kolona; j++){
<a name="5"></a><font color="#FF0000"><a href="match652-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

            mat3.elementi[i][j] = mat1.elementi[i][j] + mat2.elementi[i][j];
            //std::cout &lt;&lt; mat3.elementi[i][j];
        }
    }
    
    return mat3;
}

template &lt;typename Tip, typename Mnozitelj&gt;
</font>void Skalarno(Matrica&lt;Tip&gt; &amp;mat, Mnozitelj broj){
    for(int i = 0; i &lt; mat.br_redova; i++){
        for(int j = 0; j &lt; mat.br_redova; j++){
            mat.elementi[i][j] = mat.elementi[i][j] * broj; //Manipulira matricu tako što množi svaki element sa nekim skalarom
        }
    }
}

template &lt;typename Tip&gt;
bool DaLiJeDealocirana(Matrica&lt;Tip&gt; mat){ // 1-Jeste dealocirana, 0-nije dealocirana
    return (!mat.elementi);
}

template &lt;typename Tip, typename Tip1&gt;
void PrekopirajMatrice(Matrica&lt;Tip&gt; &amp;mat1, Matrica&lt;Tip1&gt; &amp;mat2, bool da_li_brisati = false){
    for(int i = 0; i &lt; mat1.br_redova; i++){
        for(int j = 0; j &lt; mat1.br_kolona; j++){
            mat2.elementi[i][j] = mat1.elementi[i][j];
        }
    }
    if(da_li_brisati){
<a name="6"></a><font color="#00FF00"><a href="match652-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        UnistiMatricu(mat1);
    }
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
template &lt;typename Tip, typename Tip1&gt;
auto ProduktMatrica(const Matrica&lt;Tip&gt; &amp;mat1, const Matrica&lt;Tip1&gt; &amp;mat2) -&gt; Matrica&lt;decltype(**mat1.elementi * **mat2.elementi)&gt;{
</font>    if(mat1.br_kolona != mat2.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
    
    Matrica&lt;Tip&gt; rezultat(StvoriMatricu&lt;decltype(**mat1.elementi * **mat2.elementi)&gt;(mat1.br_redova, mat2.br_kolona));
    
    for(int i = 0; i &lt; mat1.br_redova; ++i){
        for(int j = 0; j &lt; mat2.br_kolona; ++j){
            for(int k = 0; k &lt; mat1.br_kolona; ++k){
                rezultat.elementi[i][j] += mat1.elementi[i][k] * mat2.elementi[k][j];
            }
        }
    }
    return rezultat;
}

template &lt;typename Tip&gt;
Matrica&lt;Tip&gt; Stepen(const Matrica&lt;Tip&gt; &amp;mat, int stepen){
    //if(stepen &lt; 0) return;
    Matrica&lt;Tip&gt; vrati(StvoriMatricu&lt;decltype(**mat.elementi * **mat.elementi)&gt;(mat.br_redova, mat.br_redova));
    //Stvaranje jedinične matrice(Moglo bi sa funkcijom)
    for(int i = 0; i &lt; vrati.br_kolona; i++){
        for(int j = 0; j &lt; vrati.br_redova; j++){
            if(i == j) vrati.elementi[i][j] = (Tip)1;
        }
    }
    //Proces samomnoženja, korištena je funkcija za kopiranje radi plitkog brisanja
    for(int i = 0; i &lt; stepen; i++){
        Matrica&lt;Tip&gt; temp(ProduktMatrica(vrati, mat));
        PrekopirajMatrice(temp, vrati, true);
        //UnistiMatricu(temp); Brisanje je riješeno funkcijom za kopiranje
    }
    //Vraćanje izmanipulirane dinamički alocirane matrice, početna matrica ostaje ista!
    return vrati;
}

template &lt;typename Tip, typename IterTip&gt;
<a name="3"></a><font color="#00FFFF"><a href="match652-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

auto MatricniPolinom(Matrica&lt;Tip&gt; &amp;mat, int n, IterTip it)-&gt; Matrica&lt;decltype(**mat.elementi * (*it))&gt;{
    // n - stepen polinoma, it - pokazivač na koeficiente
    if(n &lt; 0) throw std::domain_error("Neispravan stepen polinoma");
    if(mat.br_kolona != mat.br_redova) throw std::domain_error("Matrica mora biti kvadratna");
</font>    
    auto vrati(StvoriMatricu&lt;decltype(**mat.elementi * (*it))&gt;(mat.br_redova, mat.br_redova));
    //Postavi vrati na 0;
    for(int i = 0; i &lt; vrati.br_kolona; i++){
        for(int j = 0; j &lt; vrati.br_redova; j++){
            vrati.elementi[i][j] = (Tip)0;
        }
    }
    
    for(int i = 0; i &lt; n; i++){
        auto clan(Stepen(mat,i));
        Skalarno(clan,*it);
        
        //std::cout &lt;&lt; "Skalarno: ";
        //std::cout &lt;&lt; "Izmnozeni stepen: " &lt;&lt; std::endl;
        //IspisiMatricu(clan);
        //std::cout &lt;&lt; std::endl;
        
        auto zbir(ZbirMatrica(vrati, clan));
        
        //std::cout &lt;&lt; "Zbir: " &lt;&lt; zbir.elementi[0][0] &lt;&lt; std::endl;
        //std::cout &lt;&lt; "Zbir stepena i vrati: " &lt;&lt; std::endl;
        //IspisiMatricu(zbir);
        
        PrekopirajMatrice(zbir, vrati, true);
        
        //std::cout &lt;&lt; "Vrati: " &lt;&lt; vrati.elementi[0][0] &lt;&lt; std::endl;
        //IspisiMatricu(vrati);
        //std::cout &lt;&lt; std::endl;
        it++;
        UnistiMatricu(clan);
    }
    //IspisiMatricu(vrati);
    return vrati;
}


int main (){
    
    try {
        int dim;
<a name="4"></a><font color="#FF00FF"><a href="match652-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

        std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
        std::cin &gt;&gt; dim;
        
        auto a = StvoriMatricu&lt;double&gt;(dim, dim);
        std::cout &lt;&lt; "Unesite elemente matrice A:" &lt;&lt; std::endl;
        UnesiMatricu('A', a);
</font>        int red;
        std::cout &lt;&lt; "Unesite red polinoma: ";
        std::cin &gt;&gt; red;
        std::cout &lt;&lt; "Unesite koeficijente polinoma: ";
        
        std::vector&lt;int&gt; v(red + 1);
        std::for_each(v.begin(), v.end(), [](int &amp;x){ std::cin &gt;&gt; x;});
        
        auto stepen(MatricniPolinom(a, red + 1, v.begin()));
        IspisiMatricu(stepen, 10, 6, true);
        UnistiMatricu(a);
        
	
    }
    catch (std::exception &amp;e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        return 0;
    }
   
	return 0;
}
</pre>
</body>
</html>
