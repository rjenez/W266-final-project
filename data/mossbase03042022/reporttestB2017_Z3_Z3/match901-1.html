<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student2421.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student1845.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

using namespace std;

template &lt;typename TipElemenata&gt;
 struct Matrica {
 int br_redova, br_kolona;
 TipElemenata **elementi = nullptr; // VEOMA BITNA INICIJALIZACIJA!
 };

template &lt;typename TipElemenata&gt;
 void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat) {
 if(!mat.elementi) return;
 for(int i = 0; i &lt; mat.br_redova; i++) delete[] mat.elementi[i];
 delete[] mat.elementi;
 mat.elementi = nullptr;
 }
 
 

template &lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) {
 Matrica&lt;TipElemenata&gt; mat;
 mat.br_redova = br_redova; mat.br_kolona = br_kolona;
 mat.elementi = new TipElemenata*[br_redova];
 for(int i = 0; i &lt; br_redova; i++) mat.elementi[i] = nullptr;
 try {
 for(int i = 0; i &lt; br_redova; i++)
 mat.elementi[i] = new TipElemenata[br_kolona];
 }
 catch(...) {
 UnistiMatricu(mat);
 throw;
 }
 return mat;
 }

 template &lt;typename TipElemenata &gt;
 Matrica&lt;TipElemenata&gt; Skalarno(Matrica&lt;TipElemenata&gt; &amp;m1,int pls){
     int si=m1.br_kolona;
     auto m2(StvoriMatricu&lt;TipElemenata&gt;(si,si));
     for(int i=0;i&lt;m1.br_kolona;i++){
         for(int j=0;j&lt;m1.br_kolona;j++){
             m2.elementi[i][j]=m1.elementi[i][j]*pls;
         }
     }
     return m2;
 }



template &lt;typename TipElemenata&gt;
 void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; const &amp;mat) {
<a name="0"></a><font color="#FF0000"><a href="match901-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

 for(int i = 0; i &lt; mat.br_redova; i++)
 for(int j = 0; j &lt; mat.br_kolona; j++) {
 cout &lt;&lt; ime_matrice
 &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
 cin &gt;&gt; mat.elementi[i][j];
 }
 }

template &lt;typename TipElemenata&gt;
 void IspisiMatricu( Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa=10,int preciznost=6 ,bool treba_brisat=false) {
</font><a name="3"></a><font color="#00FFFF"><a href="match901-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

 for(int i = 0; i &lt; mat.br_redova; i++) {
 for(int j = 0; j &lt; mat.br_kolona; j++)
 cout&lt;&lt;setprecision(preciznost)&lt;&lt; setw(sirina_ispisa) &lt;&lt; mat.elementi[i][j];
 cout&lt;&lt;endl;
</font> }
 }

template &lt;typename TipElemenata&gt;
<a name="1"></a><font color="#00FF00"><a href="match901-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

 Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2) {
 
 if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
  throw domain_error("Matrice nemaju jednake dimenzije!");
 
 auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
 
 for(int i = 0; i &lt; m1.br_redova; i++)
</font>  for(int j = 0; j &lt; m1.br_kolona; j++)
   m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
 
 return m3;
 }
 
 template &lt;typename TipElemenata&gt;
<a name="2"></a><font color="#0000FF"><a href="match901-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

 Matrica&lt;TipElemenata&gt; ProduktMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1,const Matrica&lt;TipElemenata&gt; &amp;m2){
      if(m1.br_redova != m2.br_kolona)throw domain_error("Matrice nisu saglasne za mnozenje");
      auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona)); 
      for(int i=0;i&lt;m1.br_kolona;i++){
</font>          for(int j=0;j&lt;m1.br_kolona;j++){
           m3.elementi[i][j]=0;
          }
      }
      int koordx=0,koordy=0;
      for(int i=0;i&lt;m1.br_kolona;i++){
          koordy=0;
          for(int j=0;j&lt;m1.br_kolona;j++){
              for(int k=0;k&lt;m1.br_kolona;k++){
                  m3.elementi[koordx][koordy]+=m1.elementi[i][k]*m2.elementi[k][j];
              }
              koordy++;
          }
          koordx++;
      }
     return m3;
 }
 
 
 template &lt;typename TipElemenata, typename iter &gt;
 Matrica&lt;TipElemenata&gt;MatricniPolinom(Matrica&lt;TipElemenata&gt; &amp;m1,int stepen_polinoma, iter it){
     if(stepen_polinoma&lt;0)throw domain_error("Neispravan stepen polinoma");
     if(m1.br_redova != m1.br_kolona) throw domain_error("â€œMatrica mora biti kvadratna");
     auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
     for(int i=0;i&lt;m1.br_kolona;i++){
         for(int j=0;j&lt;m1.br_kolona;j++){
             m3.elementi[i][j]=m1.elementi[i][j];
         }
     }
     auto rez(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
     for(int kom=0;kom&lt;stepen_polinoma+1;kom++){
       
       
        for(int i=0;i&lt;m1.br_kolona;i++){
         for(int j=0;j&lt;m1.br_kolona;j++){
             m3.elementi[i][j]=m1.elementi[i][j];
         }
     }
       
        if(kom==0){
         for(int k=0;k&lt;m1.br_redova;k++){
             for(int l=0;l&lt;m1.br_kolona;l++)
                 if(k==l)m3.elementi[k][l]=1;
                 else m3.elementi[k][l]=0;
         }
        }
        if(kom==1){
         for(int i=0;i&lt;m1.br_kolona;i++){
         for(int j=0;j&lt;m1.br_kolona;j++){
<a name="4"></a><font color="#FF00FF"><a href="match901-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

             m3.elementi[i][j]=m1.elementi[i][j];
         }
     }
        }
         for(int j=1;j&lt;kom;j++){
             m3=ProduktMatrica(m3,m1);
</font>            
         }
       rez=ZbirMatrica(rez,Skalarno&lt;TipElemenata&gt;(m3,*it));
       
       it++;
     }
     

     return rez;
 }
 
int main(){
 
try{
 Matrica&lt;double&gt; a,c; // AUTOMATSKA INICIJALIZACIJA!!!
 int m;
 cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
 cin &gt;&gt; m;
 
 a = StvoriMatricu&lt;double&gt;(m, m);
 cout &lt;&lt; "Unesite elemente matrice A: "&lt;&lt;endl;
 UnesiMatricu&lt;double&gt;('A', a);
 cout &lt;&lt; "Unesite red polinoma: ";
 int red_polinoma;
 cin &gt;&gt; red_polinoma;
  cout &lt;&lt; "Unesite koeficijente polinoma: ";
  
 vector&lt;int&gt;v;
 for(int i=0;i&lt;red_polinoma+1;i++){
     int al;
     cin &gt;&gt; 
     
     al;
     v.push_back(al);
 }


c = MatricniPolinom&lt;double&gt;(a, red_polinoma, v.begin());
IspisiMatricu&lt;double&gt;(c);
     
     
 UnistiMatricu(a);  UnistiMatricu(c);
 }
 catch(bad_alloc) {
 cout &lt;&lt; "Nema dovoljno memorije!\n";
 }
 
 return 0;
}</pre>
</body>
</html>
