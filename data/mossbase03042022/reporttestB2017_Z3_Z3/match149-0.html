<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student5413.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student5413.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
#include &lt;list&gt;

template &lt;typename TipElemenata&gt;
struct Matrica {
    int br_redova, br_kolona;
<a name="2"></a><font color="#0000FF"><a href="match149-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

    TipElemenata **elementi=nullptr;
};

template &lt;typename TipElemenata&gt;
void UnistiMatricu (Matrica&lt;TipElemenata&gt; mat)
{
    if (!mat.elementi) return;
    for (int i(0); i&lt;mat.br_redova; i++) delete[] mat.elementi[i];
    delete[] mat.elementi;

    mat.elementi=nullptr;
</font>}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu (int br_redova, int br_kolona)
{
    Matrica&lt;TipElemenata&gt; mat;
    mat.br_redova=br_redova;
    mat.br_kolona=br_kolona;
    mat.elementi= new TipElemenata * [br_redova];
    for (int i=0; i&lt;br_redova; i++) mat.elementi[i]= nullptr;
    try {
        for (int i=0; i&lt; br_redova; i++)
<a name="1"></a><font color="#00FF00"><a href="match149-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_15.gif"/></a>

            mat.elementi [i]= new TipElemenata[br_kolona];
    } catch (...) {
        UnistiMatricu(mat);
        throw;
    }
    return mat;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriJedinicnuMatricu (int br_redova, int br_kolona)
{
    auto  mat=StvoriMatricu&lt;double&gt;(br_redova,br_kolona);
 
    for (int i=0; i&lt;br_redova; i++) {
        for (int j=0; j&lt;br_kolona; j++) {
            if (i==j) {
                mat.elementi[i][j]=1;
                continue;
            }
            mat.elementi[i][j]=0;
        }
    }
    return mat;
}

template &lt;typename TipElemenata&gt;
void SkalarM (Matrica&lt;TipElemenata&gt; &amp;mat, double skalar)
{
    for (int i=0; i&lt;mat.br_redova; i++) {
        for (int j=0; j&lt;mat.br_kolona; j++) {
            mat.elementi[i][j]*=skalar;
        }
    }

}

template &lt;typename TipElemenata&gt;
void UnesiMatricu (char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat)
{
    for (int i=0; i&lt;mat.br_redova; i++) {
</font>        for (int j=0; j&lt;mat.br_kolona; j++) {
            std::cout&lt;&lt; ime_matrice &lt;&lt;"("&lt;&lt;i+1 &lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            std::cin &gt;&gt; mat.elementi [i][j];
        }
    }
}

template &lt;typename TipElemenata&gt;
<a name="3"></a><font color="#00FFFF"><a href="match149-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

void IspisiMatricu (const Matrica&lt;TipElemenata&gt; &amp;a, int sirina_ispisa, int preciznost=6, bool treba_brisati=false)
{

    for (int i(0); i&lt;a.br_redova; i++) {
        for (int j=0; j&lt;a.br_redova; j++) {
            std::cout&lt;&lt; std::setw(sirina_ispisa)&lt;&lt;std::setprecision(preciznost)&lt;&lt; a.elementi[i][j];
</font>        }
        std::cout &lt;&lt; std::endl; 
    }
       if (treba_brisati) {
            UnistiMatricu (a);
        }  
     
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ZbirMatrica (const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2)
{
    if (m1.br_redova!= m2.br_redova || m1.br_kolona!= m2.br_kolona) {
        throw std::domain_error ("Matrice nemaju jednake dimenzije!");
    }
    auto m3 (StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
    for (int i(0); i&lt;m1.br_redova; i++) {
        for (int j(0); j&lt;m1.br_kolona; j++) {
            m3.elementi [i][j]= m1.elementi[i][j]+ m2.elementi [i][j];
        }
    }
    return m3;
}

template &lt;typename TipElemenata&gt;
Matrica &lt;TipElemenata&gt; ProduktMatrica (const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2)
{
    if (m1.br_redova!=m2.br_kolona ) throw std::domain_error ("Matrice nisu saglasne za mnozenje");

<a name="0"></a><font color="#FF0000"><a href="match149-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_42.gif"/></a>

    auto m3 (StvoriMatricu &lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona));
    for (int i(0); i&lt; m1.br_redova; i++) {
        for (int j(0); j&lt; m2.br_kolona; j++) {
            double suma(0);
            for (int k(0); k&lt;m2.br_redova; k++) suma+= m1.elementi[i][k]* m2.elementi[k][j];
            m3.elementi[i][j]=suma;
        }
    }
    return m3;
}
template &lt;typename TipElemenata&gt;
void  Prekopiraj ( Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2)
{
    for (int i(0); i&lt;m1.br_redova; i++) {
        for (int j(0); j&lt;m1.br_kolona; j++) {
            m1.elementi [i][j]= m2.elementi [i][j];
        }
    }
}


template &lt;typename TipElemenata, typename Iter&gt;
Matrica &lt;TipElemenata&gt; MatricniPolinom ( Matrica&lt;TipElemenata&gt; &amp;m1, int n, Iter it)
{

    if (m1.br_kolona != m1.br_redova) throw std::domain_error ("Matrica mora biti kvadratna.");
    if (n&lt;0) throw std::domain_error ("Neispravan stepen polinoma");
    
    auto SMatrica (StvoriMatricu &lt;TipElemenata&gt; (m1.br_redova, m1.br_kolona));
    auto JMatrica (StvoriJedinicnuMatricu &lt;TipElemenata&gt; (m1.br_redova, m1.br_kolona));
    auto Kopija (StvoriJedinicnuMatricu &lt;TipElemenata&gt; (m1.br_redova, m1.br_kolona));
    Prekopiraj &lt;TipElemenata&gt;(Kopija, m1 );
    Prekopiraj &lt;TipElemenata&gt; (SMatrica, m1 );

    for (int i(0); i&lt;=n; i++) {
        if (i==0) {
            double skalar= *it;
            SkalarM (JMatrica, skalar);
            auto pom(m1);
            m1=JMatrica;
            UnistiMatricu(pom);
            it++;
        }

       else {
            int vr=i-1;
            for (int j(0); j&lt;vr; j++) {
                auto Pomocni(SMatrica);
                SMatrica= ProduktMatrica  (SMatrica, Kopija);
                UnistiMatricu(Pomocni);
            }
            double skalar=*it;
            SkalarM  (SMatrica, skalar);
            auto NPomocni(m1);
            m1= ZbirMatrica  (m1, SMatrica);
            UnistiMatricu(NPomocni);
            it++;
            
            Prekopiraj (SMatrica, Kopija );
            }  
    }
    UnistiMatricu (Kopija);
    UnistiMatricu(SMatrica);

    return m1;
}



int main ()
{
    Matrica&lt;double&gt; a;
    int m,n;
    std::cout&lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    std::cin&gt;&gt; m;
    try {
        a=StvoriMatricu&lt;double&gt;(m,m);
        std::cout&lt;&lt;"Unesite elemente matrice A: \n";
        UnesiMatricu ('A', a);
        std::cout&lt;&lt; "Unesite red polinoma: ";
        std::cin&gt;&gt; n;
        std::list &lt;int&gt; v ;
        int size= n+1;
        std::cout&lt;&lt; "Unesite koeficijente polinoma: ";
        for (int i(0); i&lt;size; i++) {
            int unos;
            std::cin&gt;&gt;unos;
            v.push_back (unos);
        }
       
        MatricniPolinom (a,n,v.begin());
      IspisiMatricu (a,10,5,true);
        
    }

    catch (std::bad_alloc) {
        std::cout&lt;&lt; "Nema dovoljno memorije!\n";
    }
   
     if (!a.elementi) UnistiMatricu(a); 
      
    
    return 0;
</font>}
</pre>
</body>
</html>
