<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student5961.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student5961.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;new&gt;

#define BIGGERTYPE_MM(m1, m2)      decltype(**m1.elementi + **m2.elementi) 

/*   Matrix definition   */
<a name="1"></a><font color="#00FF00"><a href="match6-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_15.gif"/></a>

template &lt;typename TipElemenata&gt;
struct Matrica {
     int br_redova = 0, br_kolona = 0; // zbog petlje
     TipElemenata **elementi = nullptr;
};

/*   destroy matrix      */
template &lt;typename TipElemenata&gt;
void UnistiMatricu(Matrica&lt;TipElemenata&gt; &amp;mat) {
     if(!mat.elementi) return;
     for(int i = 0; i &lt; mat.br_redova; i++) 
          delete[] mat.elementi[i];
     delete[] mat.elementi;
     mat.elementi = nullptr;
}

// for a larger number to delete // CON!!! works only for same-type matrices
template &lt;typename ArgType&gt;
void cleanMess(std::vector&lt;std::reference_wrapper&lt;Matrica&lt;ArgType&gt;&gt;&gt; _toClean) {
     std::for_each(_toClean.begin(), _toClean.end(), [](Matrica&lt;ArgType&gt;&amp; mat) { UnistiMatricu(mat); });
}

/*   create matrix      */
template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) {
     Matrica&lt;TipElemenata&gt; mat;
     mat.br_redova = br_redova; mat.br_kolona = br_kolona;
     mat.elementi = new TipElemenata*[br_redova];
     for(int i (0); i &lt; br_redova; ++i) mat.elementi[i] = nullptr;
     try {
          for(int i = 0; i &lt; br_redova; i++)
          mat.elementi[i] = new TipElemenata[br_kolona]{};
</font>     }
     catch(...) {
          UnistiMatricu(mat);
          throw;
     }
     return mat;
}

/*   input matrix      */
template &lt;typename TipElemenata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) {
     for(int i = 0; i &lt; mat.br_redova; i++)
          for(int j = 0; j &lt; mat.br_kolona; j++) {
<a name="3"></a><font color="#00FFFF"><a href="match6-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

               std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
               std::cin &gt;&gt; mat.elementi[i][j];
          }
}

/*   print matrix      */
template &lt;typename TipElemenata&gt;
void IspisiMatricu(Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost = 6, bool treba_brisati = false) {
     for(int i = 0; i &lt; mat.br_redova; i++) {
</font>          for(int j = 0; j &lt; mat.br_kolona; j++)
<a name="2"></a><font color="#0000FF"><a href="match6-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

               std::cout &lt;&lt; std::setprecision(preciznost) &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; mat.elementi[i][j];
          std::cout &lt;&lt; std::endl;
     }
     if(treba_brisati) UnistiMatricu(mat);
}

/*   matrix sum      */
template &lt;typename TipElemenata1, typename TipElemenata2&gt;
auto ZbirMatrica(const Matrica&lt;TipElemenata1&gt; &amp;m1, const Matrica&lt;TipElemenata2&gt; &amp;m2) -&gt; Matrica&lt;BIGGERTYPE_MM(m1, m2)&gt; {
     if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
          throw std::domain_error("Matrice nemaju jednake dimenzije!");

     auto m3(StvoriMatricu&lt;BIGGERTYPE_MM(m1, m2)&gt;(m1.br_redova, m1.br_kolona));
     for(int i = 0; i &lt; m1.br_redova; i++)
          for(int j = 0; j &lt; m1.br_kolona; j++)
</font><a name="0"></a><font color="#FF0000"><a href="match6-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_59.gif"/></a>

               m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
     return m3;
}

/*   product of matrix and scalar    */
template &lt;typename TipElemenata, typename TipSkalara&gt;
auto ScalarProduct(const Matrica&lt;TipElemenata&gt;&amp; A, const TipSkalara&amp; p) -&gt; Matrica&lt;decltype(**A.elementi * p)&gt; {
     Matrica&lt;decltype(**A.elementi * p)&gt; R (StvoriMatricu&lt;decltype(**A.elementi * p)&gt;(A.br_kolona, A.br_redova));
     for(int i (0); i &lt; A.br_redova; ++i) 
          for(int j (0); j &lt; A.br_kolona; ++j) 
               R.elementi[i][j] = p * A.elementi[i][j];
               
     return R;
}

/*                                      */
/*   added functions to implement       */
/*                                      */
template &lt;typename TipElemenata1, typename TipElemenata2&gt;
auto ProduktMatrica(const Matrica&lt;TipElemenata1&gt;&amp; A, const Matrica&lt;TipElemenata2&gt;&amp; B) -&gt; Matrica&lt;BIGGERTYPE_MM(A, B)&gt; {
     if(A.br_kolona != B.br_redova)
          throw std::domain_error("Matrice nisu saglasne za mnozenje");
          
     using BiggerType = BIGGERTYPE_MM(A, B);
     Matrica&lt;BiggerType&gt; C (StvoriMatricu&lt;BiggerType&gt;(int(A.br_kolona), int(B.br_redova)));
     BiggerType _sum (0);
     
     for(int i (0); i &lt; A.br_redova; ++i) {
          for(int j (0); j &lt; B.br_kolona; ++j) {
               _sum = 0;
               for(int k (0); k &lt; A.br_kolona; ++k) 
                    _sum += A.elementi[i][k] * B.elementi[k][j];
               C.elementi[i][j] = _sum;
          }
     }
     return C;
}

/*   matrix polinomial   */
template &lt;typename TipElemenata, typename IterType&gt;
auto MatricniPolinom(const Matrica&lt;TipElemenata&gt;&amp; A, int n, IterType p) -&gt; Matrica&lt;decltype(**A.elementi * *p)&gt; {
     if(n &lt; 0) throw std::domain_error("Neispravan stepen polinoma");
     if(A.br_kolona &lt; 0 || A.br_redova &lt; 0 || A.br_kolona != A.br_redova)
          throw std::domain_error("Matrica mora biti kvadratna");

     using BiggerType = decltype(**A.elementi * *p);  // for example: TipElementa = int, *p = double, return matrix must be double
     int _size (A.br_kolona);
     Matrica&lt;BiggerType&gt; _clean[3], SP,
          _A (StvoriMatricu&lt;BiggerType&gt;(_size, _size)), 
          P  (StvoriMatricu&lt;BiggerType&gt;(_size, _size)), 
          M  (StvoriMatricu&lt;BiggerType&gt;(_size, _size));
               
     // convert matrix A from TipElemenata to BiggerType matrix _A
     for(int i (0); i &lt; _size; ++i) 
          for(int j (0); j &lt; _size; ++j)
               _A.elementi[i][j] = static_cast&lt;BiggerType&gt;(A.elementi[i][j]);
     
     // M = p[0] * I, A^0 = I = P
     for(int i (0); i &lt; _size; ++i) {
          M.elementi[i][i] = static_cast&lt;BiggerType&gt;(*p);
          P.elementi[i][i] = static_cast&lt;BiggerType&gt;(1);
     }
     
     // calculate matrix
     ++p;
     for(int i (1); i &lt;= n; ++i) {
          _clean[0] = M;
          _clean[1] = P;
          _clean[2] = SP;
          try {
               P  = ProduktMatrica(P, _A);
               SP = ScalarProduct(P, *p);
               M  = ZbirMatrica(M, SP);
               
               cleanMess&lt;BiggerType&gt;({_clean[0], _clean[1], _clean[2]});
               ++p;
          }
          catch (...) {
               cleanMess&lt;BiggerType&gt;({_clean[0], _clean[1], _clean[2], P, SP, M, _A});
               throw;
          }
     }
     cleanMess&lt;BiggerType&gt;({P, SP, _A});
     return M;
}

/*   main program logic    */
int main() {
     Matrica&lt;double&gt; A, M; 
     int dim, n;
     std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: "; std::cin &gt;&gt; dim;
     try {
          A = StvoriMatricu&lt;double&gt;(dim, dim);
          std::cout &lt;&lt; "Unesite elemente matrice A:" &lt;&lt; std::endl; UnesiMatricu('A', A);
     
          std::cout &lt;&lt; "Unesite red polinoma: ";  std::cin &gt;&gt; n;
          std::vector&lt;double&gt; p(n + 1, 0);
          
          std::cout &lt;&lt; "Unesite koeficijente polinoma: ";
          for(int i(0); i &lt;= n; ++i) 
               std::cin &gt;&gt; p.at(i);
          
          M = MatricniPolinom(A, n, std::begin(p));
          IspisiMatricu(M, 10, 6, true);
     }
     catch(std::bad_alloc) {
          std::cout &lt;&lt; "Nema dovoljno memorije!\n";
</font>     }
     UnistiMatricu(A);
     return 0;
}</pre>
</body>
</html>
