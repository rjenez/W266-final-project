<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student8288.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z3/Z3/student8288.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;

template&lt;typename NekiTip&gt;
struct Matrica {
    int br_redova,br_kolona;
    NekiTip **element=nullptr ;
};

template&lt;typename NekiTip&gt;
void UnistiMatricu (Matrica&lt;NekiTip&gt; m) {
    if(!m.element) return ;
    for(int i=0;i&lt;m.br_redova;i++)
        delete [] m.element[i];
        delete [] m.element ;
        m.element=nullptr;

}

template&lt;typename NekiTip&gt;
<a name="2"></a><font color="#0000FF"><a href="match113-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

Matrica &lt;NekiTip&gt; StvoriMatricu(int br_redova,int br_kolona) {

    Matrica&lt;NekiTip&gt; matrica ;
    matrica.br_redova=br_redova;
    matrica.br_kolona=br_kolona;
    try{
    matrica.element=new NekiTip *[br_redova];
    }  catch(...)  { 
    throw ; }
    for(int i=0;i&lt;br_redova;i++) matrica.element[i]=nullptr ;

    try {

        for(int i=0 ;i&lt;br_redova;i++)
</font>         matrica.element[i]=new NekiTip[br_kolona] ;

        }

    catch (...) {
        UnistiMatricu(matrica) ;
        throw ;
    }
    return matrica ;
}

template&lt;typename NekiTip&gt;
void UnesiMatricu (char ime_matrice,Matrica&lt;NekiTip&gt; &amp;mat) {

    for(int i=0;i&lt;mat.br_redova;i++) {
        for(int j=0;j&lt;mat.br_kolona;j++) {
<a name="4"></a><font color="#FF00FF"><a href="match113-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

            std::cout&lt;&lt;ime_matrice &lt;&lt;"("&lt;&lt; i+1 &lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            std::cin&gt;&gt;mat.element[i][j];

        }
    }

}

template&lt;typename NekiTip&gt;
Matrica&lt;NekiTip&gt; SaberiMatrice (const Matrica&lt;NekiTip&gt; &amp;mat1,const Matrica&lt;NekiTip&gt; &amp;mat2) {
</font>    if(mat1.br_redova!=mat2.br_redova || mat1.br_kolona!=mat2.br_kolona) throw std::domain_error("Matrice nemaju jednake dimenzije");
    auto m3 (StvoriMatricu&lt;NekiTip&gt;(mat1.br_redova,mat1.br_kolona)) ;
    for(int i=0 ;i&lt;mat1.br_redova;i++)
        for(int j=0; j&lt;mat1.br_kolona;j++)

<a name="3"></a><font color="#00FFFF"><a href="match113-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

        m3.element[i][j]=mat1.element[i][j]+mat2.element[i][j] ;

    return m3 ;
}

template&lt;typename NekiTip&gt;
void IspisiMatricu(Matrica&lt;NekiTip&gt; matrica,int sirina_ispisa,int s=6,bool n=false) {

    for(int i=0;i&lt;matrica.br_redova;i++) {
</font>        for(int j=0;j&lt;matrica.br_kolona;j++)
<a name="1"></a><font color="#00FF00"><a href="match113-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

            std::cout&lt;&lt;std::setw(sirina_ispisa)&lt;&lt;std::setprecision(s)&lt;&lt;matrica.element [i][j];

        std::cout&lt;&lt;std::endl ;
    }
    if(n) UnistiMatricu(matrica) ;
}

template&lt;typename NekiTip,typename NekiTip2&gt;
Matrica&lt;NekiTip&gt; PomnoziKIM(const Matrica&lt;NekiTip&gt; &amp;mat,NekiTip2 p) {
    Matrica&lt;NekiTip&gt; matrix (StvoriMatricu&lt;NekiTip&gt;(mat.br_redova,mat.br_kolona));
    for(int i=0;i&lt;mat.br_redova;i++)
        for(int j=0;j&lt;mat.br_kolona;j++)
            matrix.element[i][j]=p*mat.element[i][j] ;

return matrix ;
}


template&lt;typename NekiTip&gt;
Matrica&lt;NekiTip&gt; ProduktMatrica (Matrica&lt;NekiTip&gt; mat1,Matrica&lt;NekiTip&gt; mat2) {
    //if(mat1.br_redova!=mat2.br_kolona) return ;
    if(mat1.br_kolona!=mat2.br_redova) throw std::domain_error ("Matrice nisu saglasne za mnozenje") ;
    try {
    Matrica &lt;NekiTip&gt; m3 (StvoriMatricu&lt;NekiTip&gt;(mat1.br_redova,mat2.br_kolona)) ;


    for(int i=0;i&lt;mat1.br_redova;i++) {
</font>        for(int j=0;j&lt;mat2.br_kolona;j++) {

            NekiTip suma(0);
            for(int k=0;k&lt;mat2.br_redova;k++)
<a name="0"></a><font color="#FF0000"><a href="match113-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_40.gif"/></a>

            suma+=mat1.element[i][k]*mat2.element[k][j] ;
            m3.element[i][j]=suma ;
        }
      }

  
    return m3 ;
    }
    catch (...) {
        throw ;
    }
}

template&lt;typename NekiTip,typename NekiTip2&gt;

Matrica&lt;NekiTip&gt; MatricniPolinom(Matrica&lt;NekiTip&gt; mat,int n,NekiTip2 p) {

    if(n&lt;0) throw std::domain_error ("Neispravan stepen polinoma") ;
    if(mat.br_redova!=mat.br_kolona) throw std::domain_error("Matrice nisu saglasne za mnozenje");

    Matrica&lt;NekiTip&gt; Jedinicna_matrica;
    Jedinicna_matrica.br_redova=mat.br_redova;
    Jedinicna_matrica.br_kolona=mat.br_kolona;
    Jedinicna_matrica.element=(StvoriMatricu&lt;NekiTip&gt;(mat.br_redova,mat.br_kolona)).element;

    for(int i=0;i&lt;mat.br_redova;i++)
        for(int j=0;j&lt;mat.br_kolona;j++){
            if(i==j)
                Jedinicna_matrica.element[i][j]=1 ;
            else
                Jedinicna_matrica.element[i][j]= 0 ;
        }
    Matrica &lt;NekiTip&gt; produkt;
    produkt.br_redova=mat.br_redova;
    produkt.br_kolona=mat.br_kolona;
    produkt.element=(StvoriMatricu&lt;NekiTip&gt;(mat.br_redova,mat.br_kolona)).element;
    for(int i=0;i&lt;mat.br_redova;i++)
        for(int j=0;j&lt;mat.br_kolona;j++){
        
                produkt.element[i][j]=mat.element[i][j] ;
           
        }
    Matrica&lt;NekiTip&gt; matrica(PomnoziKIM(Jedinicna_matrica,*p)) ;
     UnistiMatricu(Jedinicna_matrica);//***
    p=p+1;
    for(int i=1;i&lt;=n ;i++) {
        
        if(i!=1) {
            Matrica&lt;NekiTip&gt; pom(produkt);
            produkt=ProduktMatrica(produkt,mat);
            UnistiMatricu(pom);
        }
       
        Matrica&lt;NekiTip&gt; pomocna (PomnoziKIM(produkt,*p));
        Matrica&lt;NekiTip&gt; pomocna2 (matrica);
        matrica= SaberiMatrice(matrica,pomocna);
        //matrica=pomocna1;//***
        UnistiMatricu(pomocna);
        UnistiMatricu(pomocna2);
        //UnistiMatricu(pomocna1);
     p=p+1 ;
    
    }
    UnistiMatricu(produkt);
   UnistiMatricu(mat);
    return matrica ;
}
int main ()
{
    std::vector&lt;int&gt; v;
    int n{0},k{0} ;
    std::cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    std::cin&gt;&gt;n ;

    try {

    Matrica&lt;int&gt; a =StvoriMatricu&lt;int&gt;(n,n) ;



  std::cout&lt;&lt;"Unesite elemente matrice A:\n";
  
  UnesiMatricu('A',a) ;

  std::cout&lt;&lt;"Unesite red polinoma: ";
  std::cin&gt;&gt;k;

  std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
  for(int i=0 ; i&lt;=k ; i++) {
      
      int temp{0} ;
      std::cin&gt;&gt;temp;
      v.push_back(temp) ;
  }

  try {
     a= MatricniPolinom(a,k,v.begin()) ;//***

IspisiMatricu(a,10) ;
     
  }
 
catch(std::domain_error s) {
    std::cout&lt;&lt;s.what() ;
    
 }
 UnistiMatricu(a);
}
catch(std::domain_error d) {
      std::cout&lt;&lt;d.what();
</font>  }
 
return 0 ;
}

</pre>
</body>
</html>
