<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z3/student5952.c</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/A2017/Z5/Z3/student1793.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
struct Oblik {
    char naziv[20];
    int br_stranica;
    double stranice[300];
};
void dodaj_oblik(struct Oblik novioblik) {
    unsigned short brojoblika;
    unsigned char brojstranica;
    struct Oblik oblici[100];
    int i, j;
<a name="3"></a><font color="#00FFFF"><a href="match135-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

    float stranica;
    FILE* dat=fopen("oblici.dat", "rb");
    if (dat==NULL) {
        printf("Greska");
        exit(1);
    }
    
    // Algoritam za citanje podataka iz ove binarne datoteke u niz struktura, koji ce se ponavljati vise puta kroz program
    fread(&amp;brojoblika, 2, 1, dat);
</font><a name="0"></a><font color="#FF0000"><a href="match135-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    for (i=0;i&lt;brojoblika;i++) {
        fread(oblici[i].naziv, 1, 20, dat);
        fread(&amp;brojstranica, 1, 1, dat);
        oblici[i].br_stranica=(int)brojstranica;
</font>        for (j=0;j&lt;brojstranica;j++) {
            fread(&amp;stranica, 4, 1, dat);
            oblici[i].stranice[j]=(double)stranica;
        }
    } 
    oblici[i]=novioblik;
    brojoblika++; // Jednostavno dodavanje oblika na kraj niza struktura;
    
    FILE* dat2=fopen("oblici.dat", "wb");
    if (dat2==NULL) {
        printf("Greska");
        exit(1);
    }
    // Algoritam za zapisivanje niza struktura nazad u binarnu datoteku
    fwrite(&amp;brojoblika, 2, 1, dat2);
    for (i=0;i&lt;brojoblika;i++) {
        fwrite(oblici[i].naziv, 1, 20, dat2);
        brojstranica=(unsigned char)oblici[i].br_stranica;
        fwrite(&amp;brojstranica, 1, 1, dat2);
        for (j=0;j&lt;brojstranica;j++) {
            stranica=(float)oblici[i].stranice[j];
            fwrite(&amp;stranica, 4, 1, dat2);
        }
    }
    fclose(dat);
    fclose(dat2);
}
void izbaci_duple() {
    int i, j, k;
    unsigned short brojoblika;
    unsigned char brojstranica;
    float stranica;
    struct Oblik oblici[100];
    FILE* dat=fopen("oblici.dat", "rb");
    if (dat==NULL) {
        printf("Greska");
        exit(1);
    }
    // Algoritam za citanje
    fread(&amp;brojoblika, 2, 1, dat);
<a name="1"></a><font color="#00FF00"><a href="match135-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

    for (i=0;i&lt;brojoblika;i++) {
        fread(oblici[i].naziv, 1, 20, dat);
        fread(&amp;brojstranica, 1, 1, dat);
        oblici[i].br_stranica=(int)brojstranica;
</font>        for (j=0;j&lt;brojstranica;j++) {
            fread(&amp;stranica, 4, 1, dat);
            oblici[i].stranice[j]=(double)stranica;
        }
    }
    // Ako strcmp vrati 0, tj. ako su stringovi jednaki, izbacuje drugog koji je pronadjen
    for (i=0;i&lt;brojoblika;i++) {
        for (j=i+1;j&lt;brojoblika;j++) {
            if (!strcmp(oblici[i].naziv, oblici[j].naziv)) {
                for(k=j;k&lt;brojoblika-1;k++) {
                    oblici[k]=oblici[k+1];
                }
                brojoblika--;
                j--;
            }
        }
    }
    
    FILE* dat2=fopen("oblici.dat","wb");
    if (dat2==NULL) {
        printf("Greska");
        exit(1);
    }
    // Algoritam za zapisivanje
    fwrite(&amp;brojoblika, 2, 1, dat2);
    for (i=0;i&lt;brojoblika;i++) {
        fwrite(oblici[i].naziv, 1, 20, dat2);
        brojstranica=(unsigned char)oblici[i].br_stranica;
        fwrite(&amp;brojstranica, 1, 1, dat2);
        for (j=0;j&lt;brojstranica;j++) {
            stranica=(float)oblici[i].stranice[j];
            fwrite(&amp;stranica, 4, 1, dat2);
        }
    }
    fclose(dat);
    fclose(dat2);
}
struct Oblik daj_najveci() {
    int i, j, brojoblika=0;
    float maxobim=0, obimoblika=0, stranica;
    struct Oblik maxoblik;
    struct Oblik oblici[100];
    unsigned char brojstranica;
    
    FILE* dat=fopen("oblici.dat","rb");
    if (dat==NULL) {
        printf("Greska");
        exit(1);
    }
    // Algoritam za citanje i pronalazanje strukture sa najvecim obimom
    fread(&amp;brojoblika, 2, 1, dat);
    for (i=0;i&lt;brojoblika;i++) {
        obimoblika=0;
<a name="2"></a><font color="#0000FF"><a href="match135-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

        fread(oblici[i].naziv, 1, 20, dat);
        fread(&amp;brojstranica, 1, 1, dat);
        oblici[i].br_stranica=(int)brojstranica;
</font>        for (j=0;j&lt;brojstranica;j++) {
            fread(&amp;stranica, 4, 1, dat);
            oblici[i].stranice[j]=(double)stranica;
            obimoblika+=oblici[i].stranice[j];
        }
        if (obimoblika&gt;maxobim) {
            maxobim=obimoblika;
            maxoblik=oblici[i];
        }
    }
    fclose(dat);
    return maxoblik;
}
int main() {
    int ucitano, i, j;
    unsigned short brojoblika;
    unsigned char brojstranica;
    float stranica;
    struct Oblik oblici[100];
    FILE* dat=fopen("oblici.dat", "rb");
    if (dat == NULL) {
        printf("Greska pri otvaranju datoteke");
        return 0;
    }
    i=0;
    /*do {
        ucitano=fread(&amp;brojoblika, 2, 1, dat);
        fread(oblici[i].naziv, 1, 20, dat);
        fread(&amp;brojstranica, 1, 1, dat);
        oblici[i].br_stranica=(int)brojstranica;
        for (j=0;j&lt;oblici[i].br_stranica;j++) {
            fread(&amp;stranica, 4, 1, dat);
            oblici[i].stranice[j]=(double)stranica;
        }
        i++;
    } while(ucitano);
    */
    printf("Uspjesno ucitani");
    fclose(dat);
    return 0;
}</pre>
</body>
</html>
