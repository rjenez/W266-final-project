<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z4/student9296.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z4/student3411.cpp<p></p><pre>
<a name="2"></a><font color="#0000FF"><a href="match394-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

/B2016/2017: ZadaÄ‡a 3, Zadatak 4
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;stdexcept&gt;
#include &lt;iterator&gt;
//pomocna funkcija koja broji kolika je velicina imena(u skladu s postavkom definisanim nacinom)
int Prebroji(std::string s){
    int br(0);
    for(int i=0; i&lt;s.length(); i++){
        if( (s[i]&gt;='a' &amp;&amp; s[i]&lt;='z') || (s[i]&gt;='A' &amp;&amp; s[i]&lt;='Z') || (s[i]&gt;='0' &amp;&amp; s[i]&lt;='9') ) br++;
</font>    }
    return br;
}
std::vector&lt;std::set&lt;std::string&gt;&gt; Razvrstavanje(std::vector&lt;std::string&gt; matrica, int broj_timova){
<a name="0"></a><font color="#FF0000"><a href="match394-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

    if(broj_timova&lt;1 || broj_timova&gt;matrica.size()) throw std::logic_error("Razvrstavanje nemoguce");
    std::vector&lt;std::set&lt;std::string&gt;&gt; skup(broj_timova);
    //kopiranje imena djece iz vektora primljenog u funkciji u listu
    std::list&lt;std::string&gt; lista;
    for(int i=0; i&lt;matrica.size(); i++){
        lista.push_back(matrica[i]);
</font>    }
    int broj_vecih(matrica.size()%broj_timova), broj_djece(matrica.size()),velicina_tima(broj_djece/broj_timova);
    int br(0),vel(0), i(0);
    //while-petlja u kojoj vrsimo formiranje timova
    auto it(lista.begin());
    while(broj_djece&gt;0){
        //blok naredbi koji se izvrsava ukoliko je u pitanju prvo dijete(od njega sve pocinje,stoga, poseban uslov)
        if(broj_djece==matrica.size()){
            skup[br].insert(*it);
            vel=Prebroji(*it)-1; //Prebroji je pomocna funkcija, broji slova u rijeci, "-1" zato sto erase pomjera iterator za jedno mjesto naprijed
            it = lista.erase(it); broj_djece--;
            i++;
            //pomjeranje iteratora za onoliko mjesta kolika je duzina imena izbacenog elementa iz liste
            while(vel&gt;0){
                //ako je iterator na poziciji posljednjeg clana u listi postavlja se da pokazuje na prvi clan liste
                if(it==--lista.end()) it=lista.begin();
                else it++;
                vel--;
            }    
        }
        else{
            //broj_vecih predstavlja broj timova koji trebaju imati n/k+1 element,dok br predstavlja poziciju skupa u vektoru skupova
            //i predstavlja svojevrsni brojac prolaza kroz glavnu petlju, a sluzi da predjemo na novi skup, kada se sadasnji popuni dovoljnim brojem elemenata(djece)
            if(broj_vecih&gt;0 &amp;&amp; i==velicina_tima+1) {broj_vecih--;br++; i=0; }//broj_vecih-- jer ako je if-uslov tacan, to znaci da je fomiran tim od n/k+1 elemenata, te se treba formirati novi tim
            else if(broj_vecih==0 &amp;&amp; i==velicina_tima) {br++; i=0;}
            bool zadnji(false);
            if( broj_djece&gt;1 &amp;&amp; it==--lista.end() ) zadnji=true; //ako se iterator nalazi na zadnjoj poziciji, erase bi ga pomjerio izvan opsega skupa
            skup[br].insert(*it);
            vel=Prebroji(*it)-1;
            if(zadnji){
                //blok naredbi kojim se element brise iz skupa ukoliko je rijec o elementu(tj. iteratoru na nj.) koji se nalazi na zadnjem mjestu
                //it1 je pomocni iterator koji nam sluzi samo za brisanje, dok se "glavni" iterator tj it stavlja na pocetak(kruzno kretanje)
                auto it1(it);
                it=lista.begin();
                it1=lista.erase(it1);
                broj_djece--;
            }
            if(!zadnji){
                //ukoliko nije rijec o iteratoru na posljednjoj poziciji, brisanje se odvija kao i inace
                it=lista.erase(it);
                broj_djece--;
            }
            i++;
            while(vel&gt;0){
                //blok naredbi u kojem se odvija pomjeranje iteratora za odgovarajuci broj mjesta, nacin rada ovog bloka je vec opisan
                if(it==--lista.end()) it=lista.begin();
                else it++;
                vel--;
            }
        }
        
    }
    return skup;
}
int main ()
{   int n;
    std::cout&lt;&lt;"Unesite broj djece: ";
    std::cin&gt;&gt;n;
    std::vector&lt;std::string&gt; matrica(n);
    std::cout&lt;&lt;"Unesite imena djece: "&lt;&lt;std::endl;
    std::cin.ignore(10000,'\n');
    for(int i=0; i&lt;n; i++) {
        std::getline(std::cin, matrica[i]);
    }
    std::cout&lt;&lt;"Unesite broj timova: ";
    int tim;
    std::cin&gt;&gt;tim;
    try{
    auto skup(Razvrstavanje(matrica, tim));
    for(int i=0; i&lt;skup.size(); i++){
        std::cout&lt;&lt;"Tim "&lt;&lt;i+1&lt;&lt;": ";
        for(auto it=skup[i].begin(); it!=skup[i].end(); it++){
<a name="1"></a><font color="#00FF00"><a href="match394-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

            if(it==--skup[i].end()) std::cout&lt;&lt;*it;
            else std::cout&lt;&lt;*it&lt;&lt;", ";
        }
        std::cout&lt;&lt;std::endl;
    }
    }
    catch(std::logic_error e){
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
</font>    }
	return 0;
}</pre>
</body>
</html>
