<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z4/student3871.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z4/student3871.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 4
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;

int BrojProstihFaktora(int a)
{
 int br(0);
 if(a&lt;0) a*=-1;
 if(a==1 || a==0) return 1;
 int k=a%2;
 while(k==0)
 {
  a/=2;
  br++;
  k=a%2;
 }
 for(int j(3);j&lt;=a;j+=2)
 {
  int k=a%j;
  while(k==0)
  {
   a/=j;
   br++;
   k=a%j;
  }
 }
 return br;
}

bool kriterij(int x,int y)
{
 int br1(BrojProstihFaktora(x));
 int br2(BrojProstihFaktora(y));
 if(br1==br2) return x&gt;y;
<a name="0"></a><font color="#FF0000"><a href="match968-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_14.gif"/></a>

 return br1&gt;br2;
}

int f(int x, int y)
{
 return (-2)*x+y;
}

template&lt;typename Pok1,typename Pok2,typename Pok3&gt;
void SortirajPodrucjeVrijednosti(Pok1 pocetak,Pok1 kraj,Pok2 pocetak2,Pok3 pocetak3,typename std::remove_reference&lt;decltype(*pocetak3)&gt;::type f(typename std::remove_reference&lt;decltype(*pocetak)&gt;::type,typename std::remove_reference&lt;decltype(*pocetak2)&gt;::type),bool kriterij(typename std::remove_reference&lt;decltype(*pocetak)&gt;::type,typename std::remove_reference&lt;decltype(*pocetak2)&gt;::type))
</font>{
 int brojac(0);
 int br2(0),pozicija(0);
 auto pomocni3(*pocetak3);
 typename std::remove_reference&lt;decltype(*pocetak3)&gt;::type br{};
 Pok1 pomocni(pocetak);
 while(pocetak!=kraj)
 {
  brojac++;
  pocetak++;
 }
 pocetak=pomocni;
 std::sort(pocetak,kraj,kriterij);
 std::sort(pocetak2,pocetak2+brojac,kriterij);
 for(int i(0);i&lt;brojac;i++)
 {
  pomocni3=*(pocetak3+i);
  br=f(*(pocetak+i),*(pocetak2+i));
  br2=0;
  pozicija=0;
  for(int j(0);j&lt;brojac;j++)
  {
   if(br==*(pocetak3+j)) 
   { 
    br2++;
    pozicija=j;
    break;
   }
  }
  if(br2==0) throw std::logic_error ("Vrijednost koja odgovara nekom od parova nije nadjena");
  *(pocetak3+i)=*(pocetak3+pozicija);
  *(pocetak3+pozicija)=pomocni3;
 }
}

int main ()
{
 try
 {
  int n,unos,brojac(0);
  std::cout &lt;&lt; "Unesite broj elemenata: ";
  std::cin &gt;&gt; n;
  std::vector&lt;int&gt; vek1;
  std::vector&lt;int&gt; vek2;
  std::vector&lt;int&gt; vek3;
  std::cout &lt;&lt; "Unesite elemente prvog vektora: ";
  for(int i(0); ;i++)
  {
   if(vek1.size()==n) break;
   std::cin &gt;&gt; unos;
   brojac=0;
   for(int j(0);j&lt;vek1.size();j++)
   {
    if(unos==vek1[j]) brojac++;
   }
   if(brojac&gt;=1) continue;
   vek1.push_back(unos);
  }
  std::cout &lt;&lt; "Unesite elemente drugog vektora: ";
  for(int i(0); ;i++)
  {
   if(vek2.size()==n) break;
   std::cin &gt;&gt; unos;
   brojac=0;
   for(int j(0);j&lt;vek2.size();j++)
   {
    if(unos==vek2[j]) brojac++;
   }
   if(brojac&gt;=1) continue;
   vek2.push_back(unos);
  }
  std::cout &lt;&lt; "Unesite elemente treceg vektora: ";
  for(int i(0); ;i++)
  {
   if(vek3.size()==n) break;
   std::cin &gt;&gt; unos;
   brojac=0;
   for(int j(0);j&lt;vek3.size();j++)
   {
    if(unos==vek3[j]) brojac++;
   }
   if(brojac&gt;=1) continue;
   vek3.push_back(unos);
  }
  std::cout &lt;&lt; std::endl;
  SortirajPodrucjeVrijednosti(vek1.begin(),vek1.end(),vek2.begin(),vek3.begin(),f,kriterij);
  std::cout &lt;&lt; "Nakon sortiranja podrucja vrijednosti imamo sljedece trojke:" &lt;&lt; std::endl;
  for(int i(0);i&lt;vek1.size();i++)
  {
   std::cout &lt;&lt; "f(" &lt;&lt; vek1[i] &lt;&lt; ", " &lt;&lt; vek2[i] &lt;&lt; ") = " &lt;&lt; f(vek1[i],vek2[i]) &lt;&lt;std::endl;
  }
 }
 catch(std::logic_error e)
 {
  std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what();
 }
 return 0;
}</pre>
</body>
</html>
