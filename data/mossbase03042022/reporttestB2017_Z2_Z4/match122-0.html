<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z4/student1916.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z4/student1916.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 4

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

<a name="0"></a><font color="#FF0000"><a href="match122-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

bool ProstBroj(int a)
{
	if(a&lt;=1) return false;
	for(int i(std::sqrt(a)); i&gt;1; i--) if(a%i==0) return false;
	return true;
}

int BrojProstihFaktora(int a)
{
	int broj(0);
	for(int i(std::sqrt(a)); i&gt;1; i--) {
		if(a%i==0 &amp;&amp; ProstBroj(i)) {
			broj++;
			a/=i;
			i=std::sqrt(a)+1;
		}
	}
	return broj;
}

int fun1( int a, int b)
{
	return b-2*a;
}

bool fun2(int a, int b)
{
	int br1(BrojProstihFaktora(a)), br2(BrojProstihFaktora(b));
	if(br1==br2) return a&gt;b;
	return br1&gt;br2;
}

template &lt;typename Tip1, typename Tip2, typename Tip3&gt;
void SortirajPodrucjeVrijednosti(Tip1 prvi, Tip1 kraj, Tip2 drugi, Tip3 treci,
                                 typename std::remove_reference&lt;decltype(treci[0])&gt;::type f(typename std::remove_reference&lt;decltype(prvi[0])&gt;::type x, typename std::remove_reference&lt;decltype(drugi[0])&gt;::type y),
                                 bool g(typename std::remove_reference&lt;decltype(prvi[0])&gt;::type x, typename std::remove_reference&lt;decltype(drugi[0])&gt;::type y))
{
	std::sort(prvi, kraj, g);
	Tip1 pom1(prvi);
	Tip2 kraj2(drugi);
	while(pom1!=kraj) {
		pom1++;
		kraj2++;
	}
	std::sort(drugi, kraj2, g);
	pom1=prvi;
	Tip2 pom2(drugi);
	Tip3 kraj3(treci);
	while(pom1!=kraj) {
		pom1++;
		kraj3++;
	}
	pom1=prvi;
	while(pom1!=kraj) {
		auto a(f(*pom1, *pom2));
		auto s(std::find(treci, kraj3, a));
		if(s==kraj3) throw std::logic_error("Vrijednost koja odgovara nekom od parova nije nadjena");
		s=std::copy_backward(treci, s, s+1);
		*treci=a;
		pom1++;
		pom2++;
	}
	std::reverse(treci, kraj3);
}

int main ()
{
	std::cout &lt;&lt; "Unesite broj elemenata: ";
	int n;
	std::cin &gt;&gt; n;
	try {
		std::vector&lt;int&gt; prvi(n), drugi(n), treci(n);
		std::cout &lt;&lt; "Unesite elemente prvog vektora: ";
		for(int i(0); i&lt;n; i++) {
			std::cin &gt;&gt; prvi.at(i);
			for(int j(0); j&lt;i; j++) if(prvi.at(i)==prvi.at(j)) i--;
		}
		std::cout &lt;&lt; "Unesite elemente drugog vektora: ";
		for(int i(0); i&lt;n; i++) {
			std::cin &gt;&gt; drugi.at(i);
			for(int j(0); j&lt;i; j++) if(drugi.at(i)==drugi.at(j)) i--;
		}
		std::cout &lt;&lt; "Unesite elemente treceg vektora: ";
		for(int i(0); i&lt;n; i++) {
			std::cin &gt;&gt; treci.at(i);
			for(int j(0); j&lt;i; j++) if(treci.at(i)==treci.at(j)) i--;
		}
		SortirajPodrucjeVrijednosti(prvi.begin(), prvi.end(), drugi.begin(), treci.begin(), fun1, fun2);
		std::cout &lt;&lt; "\nNakon sortiranja podrucja vrijednosti imamo sljedece trojke:";
		for(int i(0); i&lt;prvi.size(); i++) {
			std::cout &lt;&lt; "\nf(" &lt;&lt; prvi.at(i) &lt;&lt; ", " &lt;&lt; drugi.at(i) &lt;&lt; ") = " &lt;&lt; treci.at(i);
		}
	} catch(std::bad_alloc) {
		std::cout &lt;&lt; "\nIzuzetak: Nedovoljno memorije";
	} catch(std::logic_error p) {
		std::cout &lt;&lt; "\nIzuzetak: " &lt;&lt; p.what();
	}
	return 0;
</font>}</pre>
</body>
</html>
