<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z4/student3867.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z4/student3867.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;type_traits&gt;

<a name="0"></a><font color="#FF0000"><a href="match192-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_93.gif"/></a>

template &lt; typename T, typename U, typename F &gt;
void SortirajPodrucjeVrijednosti ( T slider_prvi, T end_prvi, T slider_drugi, U slider_treci, 
	F equation, bool ( *comp_func ) ( int, int ) )	
{
/*** uparuje elemente treceg skupa sa odgovarajucim pozicijama u druga dva skupa na osnovu uvjeta zadanim funkcijom ***/
	long size { end_prvi - slider_prvi }; // velicina niza
	std::sort ( slider_prvi, end_prvi, comp_func );
	std::sort ( slider_drugi, slider_drugi + size, comp_func );
	
	typedef typename std::remove_reference &lt; decltype ( *slider_treci ) &gt;::type UType;
	
	UType eval { 0 };
	U eval_pos { 0 };
	U begin_treci { slider_treci }; //za pretrazivanje treceg niza
	
	while ( slider_prvi != end_prvi )
	{
		eval = equation ( *slider_prvi, *slider_drugi );
	// pozicija trazenog elementa u trecem nizu
		eval_pos = std::find ( begin_treci, begin_treci + size, eval );
	// ako ne postoji, onda je pozicija iza kraja niza
		if ( eval_pos == begin_treci + size )
			throw std::logic_error ( "Vrijednost koja odgovara nekom od parova nije nadjena" );
		
		std::swap ( *slider_treci, *eval_pos ); // zamjena trenutne sa pozicijom na kojoj se nalazi element
	// sljedeca iteracija kroz nizove
		slider_prvi++; slider_drugi++; slider_treci++;
	}
}

namespace ab
{
	template &lt; typename T &gt;
	void InputUniqueVector ( std::vector &lt; T &gt; &amp;v, int n )
	{
	/*** unos elemenata u parametar 'v' do velicine n, bez ponavljanja elemenata ***/
		T temp;
		while ( n != v.size() and n &gt; 0 )
		{
		AGAIN: std::cin &gt;&gt; temp;
			for ( int i = 0; i &lt; v.size (); i++ )
				if ( v.at ( i ) == temp )
					goto AGAIN;
			v.push_back ( temp );
		}
	}
	
	template &lt; typename T &gt;
	int numOfPF ( T n )
	{
	/*** broj prostih faktora parametra 'n' ***/
		if ( n &lt; 2 )
			return 0;
			
		int pf { 0 };
		while ( n % 2 == 0 )
			pf++, ( n /= 2 );
		
		for ( int i = 3; i &lt;= int ( std::sqrt ( n ) ); i += 2 )
			while ( n % i == 0 )
				pf++, ( n /= i );
		
		return ( n &gt; 2 ) ? ++pf : pf;
	}
}

int main ( void )
{
	int n;
	std::cout &lt;&lt; "Unesite broj elemenata: ";
	std::cin &gt;&gt; n;
	
	std::vector &lt; int &gt; prvi;
	std::cout &lt;&lt; "Unesite elemente prvog vektora: ";
	ab::InputUniqueVector ( prvi, n );
	
	std::vector &lt; int &gt; drugi;
	std::cout &lt;&lt; "Unesite elemente drugog vektora: ";
	ab::InputUniqueVector ( drugi, n );
	
	std::vector &lt; int &gt; treci;
	std::cout &lt;&lt; "Unesite elemente treceg vektora: ";
	ab::InputUniqueVector ( treci, n );

	try
	{
		SortirajPodrucjeVrijednosti ( prvi.begin (), prvi.end (), drugi.begin (), treci.begin (), 
			[] ( int p1, int p2 ) { return -2 * p1 + p2; },
			[] ( int p1, int p2 ) -&gt; bool 
			{
				int npf1 { ab::numOfPF ( p1 ) }, npf2 { ab::numOfPF ( p2 ) }; 
				return ( npf1 == npf2 ) ? ( ( p1 &gt; p2 ) ? true : false ) : ( ( npf1 &gt; npf2 ) ? true : false );
			});
	}
	catch ( const std::exception &amp;exc )
	{
		std::cout &lt;&lt; "\nIzuzetak: " &lt;&lt; exc.what ();
		return 0;
	}
	
	std::cout &lt;&lt; "\nNakon sortiranja podrucja vrijednosti imamo sljedece trojke:\n";
	for ( int i = 0; i &lt; n; i++ )
		std::cout &lt;&lt; "f(" &lt;&lt; prvi.at ( i ) &lt;&lt; ", " &lt;&lt; drugi.at ( i ) &lt;&lt; ") = " &lt;&lt; treci.at ( i ) &lt;&lt; std::endl;
</font>	
	return 0;
}</pre>
</body>
</html>
