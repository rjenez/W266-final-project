<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student3872.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student3071.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

using namespace std;
const double  EPSILON = 1E-10;
typedef pair&lt;double, double&gt; Tacka;
double Distanca(Tacka tac1, Tacka tac2){ return sqrt(pow(tac1.first-tac2.first,2)+pow(tac1.second-tac2.second,2)); }
double Produkt(Tacka tac1, Tacka tac2, Tacka tac3){ return tac1.first*(tac2.second-tac3.second)-tac2.first*(tac1.second-tac3.second)+tac3.first*(tac1.second-tac2.second); }
bool Eq(double x,double y) { double infinitezimala {fabs(x-y)}; return infinitezimala&lt;EPSILON;  }
class Trougao{
  Tacka tac[3];
  public: 
  Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
       if(Eq(Produkt(t1,t2,t3),0)) throw domain_error("Nekorektne pozicije tjemena");
    tac[0]=t1; tac[1]=t2; tac[2]=t3;
  };
  void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
  void Postavi(int indeks, const Tacka &amp;t);
  static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
  Tacka DajTjeme(int indeks)const;
  double DajStranicu(int indeks)const;
  double DajUgao(int indeks) const;
  Tacka DajCentar()const {return { (tac[0].first+tac[1].first+tac[2].first)/3, (tac[0].second+tac[1].second+tac[2].second)/3 };}
  double DajObim()const{ return {Distanca(tac[0],tac[1])+Distanca(tac[1],tac[2])+Distanca(tac[2],tac[0])}; }
  double DajPovrsinu()const{ return fabs(Produkt(tac[0],tac[1],tac[2]))/2; }
  bool DaLiJePozitivnoOrijentiran()const{ if(Produkt(tac[0],tac[1],tac[2])&gt;0) return true; else return false; }
  bool DaLiJeUnutra(const Tacka &amp;t)const;
<a name="6"></a><font color="#00FF00"><a href="match545-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

  void Ispisi()const{ cout &lt;&lt; "(("&lt;&lt;tac[0].first&lt;&lt;","&lt;&lt;tac[0].second&lt;&lt;"),("&lt;&lt;tac[1].first&lt;&lt;","&lt;&lt;tac[1].second&lt;&lt;"),("&lt;&lt;tac[2].first&lt;&lt;","&lt;&lt;tac[2].second&lt;&lt;"))";}
  void Transliraj(double delta_x, double delta_y);
  void Centriraj(const Tacka &amp;t);
  void Rotiraj(const Tacka &amp;t, double ugao);
  void Skaliraj(const Tacka &amp;t, double faktor);
</font>  void Rotiraj(double ugao);
  void Skaliraj(double faktor);
  friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
  friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2);
  friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);
};

void Trougao::Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    if(Eq(Produkt(t1,t2,t3),0)) throw domain_error("Nekorektne pozicije tjemena");
    tac[0]=t1; tac[1]=t2; tac[2]=t3;
}
void Trougao::Postavi(int indeks, const Tacka &amp;t){
    if(indeks&gt;3 || indeks &lt; 1 ) throw range_error("Nekorektan indeks");
    tac[indeks-1]=t;
}
int Trougao::Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    if(Eq(Produkt(t1,t2,t3),0)) return 0;
    if(Produkt(t1,t2,t3)&gt;0) return 1; 
    return -1;
}
Tacka Trougao::DajTjeme(int indeks)const{
    if(indeks &gt;3 ||indeks&lt;1) throw range_error("Nekorektan indeks");
    return tac[indeks-1];
}
double Trougao::DajStranicu(int indeks)const{
    if(indeks&gt;3||indeks&lt;1) { throw range_error("Nekorektan indeks"); }
    
    if (indeks==1) return Distanca(tac[1],tac[2]); 
    if (indeks==2) return Distanca(tac[0],tac[2]); 
    if (indeks==3) return Distanca(tac[0],tac[1]);
}
double Trougao::DajUgao(int indeks)const{
    if(indeks&gt;3||indeks&lt;1) throw range_error("Nekorektan indeks");
    double a = Distanca(tac[1],tac[2]); double b = Distanca(tac[0],tac[2]); double c = Distanca(tac[0], tac[1]);
    if(indeks == 1) return acos((pow(b,2)+pow(c,2)-pow(a,2))/(2*b*c));
    if(indeks == 2) return acos((pow(a,2)+pow(c,2)-pow(b,2))/(2*b*c));
    if(indeks == 3) return acos((pow(a,2)+pow(b,2)-pow(c,2))/(2*a*b));
}
bool Trougao::DaLiJeUnutra(const Tacka &amp;t) const {
    if(Orijentacija(tac[0],tac[1],tac[2]))
        if(Orijentacija(tac[0],tac[1],t))
                if(Orijentacija(tac[1],tac[2],t))
                        if(Orijentacija(tac[2],tac[1],t)) return true;
                        return false;
}
void Trougao::Transliraj(double delta_x,double  delta_y){
    for(int i{0}; i&lt;3; i++) {tac[i].first+=delta_x; tac[i].second+=delta_y;}
}
void Trougao::Centriraj(const Tacka &amp;t){ Transliraj(t.first-DajCentar().first, t.second-DajCentar().second);  }
void Trougao::Rotiraj(const Tacka &amp;t, double ugao){
    Tacka a=tac[0];
    Tacka b=tac[1];
    Tacka c=tac[2];
    tac[0].first=t.first+(a.first-t.first)*cos(ugao)-(a.second-t.second)*sin(ugao);
    tac[1].first=t.first+(b.first-t.first)*cos(ugao)-(b.second-t.second)*sin(ugao);
    tac[2].first=t.first+(c.first-t.first)*cos(ugao)-(c.second-t.second)*sin(ugao);
    tac[0].second=t.second+(a.first-t.first)*sin(ugao)+(a.second-t.second)*cos(ugao);
    tac[1].second=t.second+(b.first-t.first)*sin(ugao)+(b.second-t.second)*cos(ugao);
    tac[2].second=t.second+(c.first-t.first)*sin(ugao)+(c.second-t.second)*cos(ugao);
}
void Trougao::Rotiraj(double ugao){
    Rotiraj(DajCentar(),ugao);
}
void Trougao::Skaliraj(const Tacka &amp;t, double k){
    if(Eq(k,0))throw domain_error("Nekorektan faktor skaliranja");
    for(int i{0}; i&lt;3; i++){
        tac[i].first = t.first+k*(tac[i].first-t.first);
        tac[i].second = t.second+k*(tac[i].second-t.second);
    }
}
void Trougao::Skaliraj(double k){
    Skaliraj(this-&gt;DajCentar(), k);
}
bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2){
    
    
    
    bool Yaa = Eq(t1.tac[0].second, t2.tac[0].second);
    bool Xaa = Eq(t1.tac[0].first, t2.tac[0].first);
    bool Xbb = Eq(t1.tac[1].first, t2.tac[1].first);
    bool Ybb = Eq(t1.tac[1].second, t2.tac[1].second);
    bool Xcc = Eq(t1.tac[2].first, t2.tac[2].first);
    bool Ycc = Eq(t1.tac[2].second,t2.tac[2].second);
    if(  ( Xaa &amp;&amp; Yaa &amp;&amp; Xbb &amp; Ybb &amp;&amp; Xcc &amp; Ycc ) || (Eq(t1.tac[0].first, t2.tac[1].first) &amp;&amp; Eq(t1.tac[0].second, t2.tac[1].second) &amp;&amp;  Eq(t1.tac[1].first,t2.tac[0].first) &amp;&amp; Eq(t1.tac[1].second, t2.tac[0].second) &amp;&amp; Eq(t1.tac[2].first,t2.tac[2].first) &amp;&amp; Eq(t1.tac[2].second,t2.tac[2].second))
    ||(Eq(t1.tac[0].first, t2.tac[2].first) &amp;&amp; Eq(t1.tac[0].second,t2.tac[2].second) &amp;&amp; Eq(t1.tac[1].first,t2.tac[1].first)&amp;&amp; Eq(t1.tac[1].second, t2.tac[2].second) &amp;&amp; Eq(t1.tac[2].first, t2.tac[2].first) &amp;&amp; Eq(t1.tac[2].second,t2.tac[2].second))
    ||( Eq(t1.tac[0].first, t2.tac[1].first) &amp;&amp; Eq(t1.tac[0].second,t2.tac[1].second) &amp;&amp; Eq(t1.tac[1].first, t2.tac[2].first) &amp;&amp; Eq(t1.tac[1].second, t2.tac[2].second) &amp;&amp; Eq(t1.tac[2].first, t2.tac[0].first) &amp;&amp; Eq(t1.tac[2].second, t2.tac[0].second) )
    || ( Eq(t1.tac[0].first, t2.tac[2].first) &amp;&amp; Eq(t1.tac[0].second, t2.tac[2].second) &amp;&amp; Eq(t1.tac[1].first, t2.tac[0].first) &amp;&amp; Eq(t1.tac[1].second, t2.tac[0].second) &amp;&amp; Eq(t1.tac[2].first, t2.tac[1].first) &amp;&amp; Eq(t1.tac[2].second, t2.tac[1].second))
    ||( Eq(t1.tac[0].first, t2.tac[0].first) &amp;&amp; Eq(t1.tac[0].second, t2.tac[0].second) &amp;&amp; Eq(t1.tac[1].first, t2.tac[2].first) &amp;&amp; Eq(t1.tac[1].second, t2.tac[2].second) &amp;&amp; Eq(t1.tac[2].first, t2.tac[1].first) &amp;&amp; Eq(t1.tac[2].second, t2.tac[1].second) )) return true;
    else return false;
    
    
}
  bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2){
      Tacka a1x,a2x,b1x,b2x,c1x,c2x;
      double c1=Distanca(t1.tac[0], t1.tac[1]),c1p,c2=Distanca(t2.tac[0],t2.tac[1]),c2p,a1=Distanca(t1.tac[1],t1.tac[2]),a1p,a2=Distanca(t2.tac[1],t2.tac[2]),a2p, b1=Distanca(t1.tac[0],t1.tac[2]),b1p,b2=Distanca(t2.tac[0],t2.tac[2]),b2p;
      //pronalazenje refernetnih a1p,a2p,b2p,b1p,c1p,c2p
      if(a1&gt;=b1 &amp;&amp; a1&gt;=c1){ a1p=a1; a1x=t1.tac[0];
          if(b1&gt;=c1) { b1p=b1; c1p=c1; b1x=t1.tac[1]; c1x=t1.tac[2];}
          else       { b1p=c1; c1p=b1; b1x=t1.tac[2]; c1x=t1.tac[1];}
      } if (b1&gt;=a1 &amp;&amp; b1&gt;=c1 ){ a1p=b1; a1x=t1.tac[1];
          if(a1&gt;=c1) { b1p=a1; c1p=c1; b1x=t1.tac[0]; c1x=t1.tac[2];}
          else       { b1p=c1; c1p=a1; b1x=t1.tac[2]; c1x=t1.tac[0];}
      } if (c1&gt;=a1 &amp;&amp; c1&gt;=b1) { a1p=c1; a1x=t1.tac[2];
          if(a1&gt;=b1) { b1p=a1; c1p=b1; b1x=t1.tac[0]; c1x=t1.tac[1];}
          else       { b1p=b1; c1p=a1; b1x=t1.tac[1]; c1x=t1.tac[0];}
      }
      if(a2&gt;=b2 &amp;&amp; a2&gt;=c2){ a2p=a2; a2x=t2.tac[0];
          if(b2&gt;=c2) { b2p=b2; c2p=c2; b2x=t2.tac[1]; c2x=t2.tac[2];}
          else       { b2p=c2; c2p=b2; b2x=t2.tac[2]; c2x=t2.tac[1];}
      }if (b2&gt;=a2 &amp;&amp; b2&gt;=c2 ){ a2p=b2; a2x=t2.tac[1];
          if(a2&gt;=c2) { b2p=a2; c2p=c2; b2x=t2.tac[0]; c2x=t2.tac[2];}
          else       { b2p=c2; c2p=a2; b2x=t2.tac[2]; c2x=t2.tac[0];}
      } if (c2&gt;=a2 &amp;&amp; c2&gt;=b2) { a2p=c2; a2x=t2.tac[2];
          if(a2&gt;=b2) { b2p=a2; c2p=b2; b2x=t2.tac[0]; c2x=t2.tac[1];}
          else       { b1p=b2; c1p=a2; b2x=t2.tac[1]; c2x=t2.tac[0];}
      }
      bool big = Eq(a1p,a2p),medium=Eq(b1p,b2p),small=Eq(c1p,c2p);
      bool Okrenutost(Trougao::Orijentacija(a1x,b1x,c1x)==Trougao::Orijentacija(a2x,b2x,c2x));
      if(Okrenutost &amp;&amp; big &amp;&amp; medium &amp;&amp; small )return true;
      return false;
  }
   bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2){
      Tacka a1x,a2x,b1x,b2x,c1x,c2x;
      double 
      c1=Distanca(t1.tac[0],t1.tac[1]),c1p=0,
      c2=Distanca(t2.tac[0],t2.tac[1]),c2p=0,
      a1=Distanca(t1.tac[1],t1.tac[2]),a1p=0,
      a2=Distanca(t2.tac[1],t2.tac[2]),a2p=0, 
      b1=Distanca(t1.tac[0],t1.tac[2]),b1p=0,
      b2=Distanca(t2.tac[0],t2.tac[2]),b2p=0;
      //pronalazenje refernetnih a1p,a2p,b2p,b1p,c1p,c2p
      if(a1&gt;=b1 &amp;&amp; a1&gt;=c1){ a1p=a1; a1x=t1.tac[0];
          if(b1&gt;=c1) { b1p=b1; c1p=c1; b1x=t1.tac[1]; c1x=t1.tac[2];}
          else       { b1p=c1; c1p=b1; b1x=t1.tac[2]; c1x=t1.tac[1];}
      }else if (b1&gt;=a1 &amp;&amp; b1&gt;=c1 ){ a1p=b1; a1x=t1.tac[1];
          if(a1&gt;=c1) { b1p=a1; c1p=c1; b1x=t1.tac[0]; c1x=t1.tac[2];}
          else       { b1p=c1; c1p=a1; b1x=t1.tac[2]; c1x=t1.tac[0];}
      }else if (c1&gt;=a1 &amp;&amp; c1&gt;=b1) { a1p=c1; a1x=t1.tac[2];
          if(a1&gt;=b1) { b1p=a1; c1p=b1; b1x=t1.tac[0]; c1x=t1.tac[1];}
          else       { b1p=b1; c1p=a1; b1x=t1.tac[1]; c1x=t1.tac[0];}
      }
      if(a2&gt;=b2 &amp;&amp; a2&gt;=c2){ a2p=a2; a2x=t2.tac[0];
          if(b2&gt;=c2) { b2p=b2; c2p=c2; b2x=t2.tac[1]; c2x=t2.tac[2];}
          else       { b2p=c2; c2p=b2; b2x=t2.tac[2]; c2x=t2.tac[1];}
      }else if (b2&gt;=a2 &amp;&amp; b2&gt;=c2 ){ a2p=b2; a2x=t2.tac[1];
          if(a2&gt;=c2) { b2p=a2; c2p=c2; b2x=t2.tac[0]; c2x=t2.tac[2];}
          else       { b2p=c2; c2p=a2; b2x=t2.tac[2]; c2x=t2.tac[0];}
      }else if (c2&gt;=a2 &amp;&amp; c2&gt;=b2) { a2p=c2; a2x=t2.tac[2];
          if(a2&gt;=b2) { b2p=a2; c2p=b2; b2x=t2.tac[0]; c2x=t2.tac[1];}
          else       { b1p=b2; c1p=a2; b2x=t2.tac[1]; c2x=t2.tac[0];}
      }
      double k = a1p/a2p, l=b1p/b2p, m=c1p/c2p;
      //Proporcionalnost stranica uz urbi
      bool big = Eq(k,l),medium=Eq(l,m),small=Eq(k,m);
      bool Okrenutost(Trougao::Orijentacija(a1x,b1x,c1x)==Trougao::Orijentacija(a2x,b2x,c2x));
      if(Okrenutost &amp;&amp; big &amp;&amp; medium &amp;&amp; small )return true;
      return false;
  }
int main (){
    
    int broj_trouglova;
    cout &lt;&lt; "Koliko zelite kreirati trouglova: ";
    cin &gt;&gt; broj_trouglova;
  vector&lt;shared_ptr&lt;Trougao&gt;&gt; vektor_pokova(broj_trouglova,nullptr);
    for(int i{0}; i&lt;broj_trouglova; i++){
        try{Tacka pomocna1, pomocna2, pomocna3; cout &lt;&lt; "Unesite podatke za "&lt;&lt;i+1&lt;&lt;". trougao (x1 y1 x2 y2 x3 y3): ";
        cin &gt;&gt; pomocna1.first&gt;&gt;pomocna1.second;
        cin &gt;&gt;pomocna2.first&gt;&gt;pomocna2.second;
        cin &gt;&gt; pomocna3.first &gt;&gt; pomocna3.second;
        auto pok (make_shared&lt;Trougao&gt;(pomocna1,pomocna2,pomocna3));
        vektor_pokova[i]=pok;
        } catch(domain_error gre){
            cout &lt;&lt; gre.what()&lt;&lt;", ponovite unos!"&lt;&lt;endl;
<a name="4"></a><font color="#FF00FF"><a href="match545-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

            i--;
        }
    }
    double dx, dy, ugao, koef;
    cout &lt;&lt; "Unesite vektor translacije (dx dy): ";
    cin &gt;&gt; dx &gt;&gt;dy;
    cout &lt;&lt; "Unesite ugao rotacije: ";
    cin &gt;&gt; ugao;
    cout &lt;&lt; "Unesite faktor skaliranja: ";
    cin &gt;&gt; koef;
    transform(vektor_pokova.begin(), vektor_pokova.end(), vektor_pokova.begin(), [dx,dy,ugao,koef](shared_ptr&lt;Trougao&gt;p1){
</font><a name="5"></a><font color="#FF0000"><a href="match545-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

       p1-&gt;Transliraj(dx,dy);p1-&gt;Rotiraj(ugao);p1-&gt;Skaliraj(p1-&gt;DajTjeme(1), koef); return p1;
    });
    sort(vektor_pokova.begin(), vektor_pokova.end(), [](shared_ptr&lt;Trougao&gt; pt1, shared_ptr&lt;Trougao&gt; pt2){return pt1-&gt;DajPovrsinu()&lt;pt2-&gt;DajPovrsinu(); });
    vector&lt;pair&lt;Trougao, Trougao&gt;&gt; parovi;
</font><a name="7"></a><font color="#0000FF"><a href="match545-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    for(int i{0}; i&lt;broj_trouglova-1; i++) for(int k{i+1}; k&lt;broj_trouglova; k++) if(DaLiSuIdenticni(*vektor_pokova[i], *vektor_pokova[k]))  parovi.push_back(make_pair(*vektor_pokova[i],*vektor_pokova[k]));
</font><a name="0"></a><font color="#FF0000"><a href="match545-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    cout &lt;&lt; "Trouglovi nakon obavljenih transformacija:"&lt;&lt;endl;
    for_each(vektor_pokova.begin(), vektor_pokova.end(), [](shared_ptr&lt;Trougao&gt;pt1){pt1-&gt;Ispisi(); cout &lt;&lt;endl;});
    cout &lt;&lt; "Trougao sa najmanjim obimom: ";
     (*(min_element(vektor_pokova.begin(), vektor_pokova.end(), [](shared_ptr&lt;Trougao&gt; pt1, shared_ptr&lt;Trougao&gt; pt2){ return pt1-&gt;DajObim()&lt;pt2-&gt;DajObim(); })))-&gt;Ispisi();
    cout &lt;&lt;endl; if (parovi.size()==0) cout &lt;&lt; "Nema identicnih trouglova!"&lt;&lt;endl;
</font>    else {
<a name="1"></a><font color="#00FF00"><a href="match545-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        cout &lt;&lt;"Parovi identicnih trouglova:"&lt;&lt;endl;
        for_each(parovi.begin(), parovi.end(), [](pair&lt;Trougao, Trougao&gt; p1){ p1.first.Ispisi(); 
        cout &lt;&lt; " i ";
        p1.second.Ispisi(); cout &lt;&lt;endl;
</font>            
        });
    }
        vector&lt;pair&lt;Trougao,Trougao&gt;&gt; parovi2;
<a name="8"></a><font color="#00FFFF"><a href="match545-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

        for(int i{0}; i&lt;broj_trouglova-1; i++) for(int k{i+1}; k&lt;broj_trouglova; k++) if(DaLiSuPodudarni(*vektor_pokova[i], *vektor_pokova[k])) parovi2.push_back(make_pair(*vektor_pokova[i],*vektor_pokova[k]));
</font>    if (parovi2.size()==0) cout &lt;&lt; "Nema podudarnih trouglova!"&lt;&lt;endl;
    else {
<a name="2"></a><font color="#0000FF"><a href="match545-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        cout &lt;&lt;"Parovi podudarnih trouglova:"&lt;&lt;endl;
        for_each(parovi2.begin(), parovi2.end(), [](pair&lt;Trougao, Trougao&gt; p1){ p1.first.Ispisi(); 
        cout &lt;&lt; " i ";
        p1.second.Ispisi(); cout &lt;&lt;endl;
</font>            
        });}
        vector&lt;pair&lt;Trougao,Trougao&gt;&gt; parovi3;
<a name="9"></a><font color="#FF00FF"><a href="match545-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

        for(int i{0}; i&lt;broj_trouglova-1; i++) for(int k{i+1}; k&lt;broj_trouglova; k++) if (DaLiSuSlicni(*vektor_pokova[i], *vektor_pokova[k])) parovi3.push_back(make_pair(*vektor_pokova[i], *vektor_pokova[k]));
</font>	    if (parovi3.size()==0 )cout &lt;&lt; "Nema slicnih trouglova!"&lt;&lt;endl;
    else {
<a name="3"></a><font color="#00FFFF"><a href="match545-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        cout &lt;&lt;"Parovi slicnih trouglova:"&lt;&lt;endl;
        for_each(parovi3.begin(), parovi3.end(), [](pair&lt;Trougao, Trougao&gt; p1){ p1.first.Ispisi(); 
        cout &lt;&lt; " i ";
        p1.second.Ispisi(); cout &lt;&lt;endl;
</font>            
        });
    }
	return 0;
}</pre>
</body>
</html>
