<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student2675.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student4377.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;memory&gt;

typedef std::pair&lt;double, double&gt; Tacka;
const double eps (10e-10);

class Trougao 
{
    std::vector&lt;Tacka&gt; tacka;
    
    static double Izraz(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) { return t1.first*(t2.second - t3.second) - t2.first*(t1.second - t3.second) + t3.first*(t1.second - t2.second); }
    static void ProvjeriIndex(int i) { if(i &lt;0 || i&gt;3) throw std::range_error("Nekorektan indeks"); }
    static void OdrediOstaleIndexe(int indeks, int &amp;a, int &amp;b) 
    { 
        if(indeks == 1) { a = 2; b = 3; }
        if(indeks == 2) { a = 1; b = 3; }
        if(indeks == 3) { a = 1; b = 2; }
    }
    static bool PD(double d1, double d2) { return fabs(d1-d2) &lt; eps; }
    static double Modul(const Tacka &amp;t) { return sqrt(t.first*t.first + t.second*t.second); }
    static double Produkt(const Tacka &amp;t1, const Tacka &amp;t2) { return t1.first * t2.first + t1.second * t2.second; }
    static bool ProvjeriTrougao(const Trougao &amp;t1, const Trougao &amp;t2)
<a name="8"></a><font color="#00FFFF"><a href="match770-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    { if( PD(t1.DajUgao(1),t2.DajUgao(1)) &amp;&amp; PD(t1.DajUgao(2),t2.DajUgao(2)) &amp;&amp; PD(t1.DajUgao(3),t2.DajUgao(3))) return true; return false; }
</font>    static void NasteliTrougao(const Trougao &amp;t1,const Trougao &amp;t2, Trougao &amp;T)
    {
        for(int i=0;i&lt;6;i++)
        {
            if(Trougao::ProvjeriTrougao(t1, T)) break;
            if(i==0) T.Postavi(t2.tacka[0], t2.tacka[1], t2.tacka[2]);
            if(i==1) T.Postavi(t2.tacka[0], t2.tacka[2], t2.tacka[1]);
            if(i==2) T.Postavi(t2.tacka[2], t2.tacka[1], t2.tacka[0]);
            if(i==3) T.Postavi(t2.tacka[1], t2.tacka[0], t2.tacka[2]);
            if(i==4) T.Postavi(t2.tacka[1], t2.tacka[2], t2.tacka[0]);
            if(i==5) T.Postavi(t2.tacka[2], t2.tacka[0], t2.tacka[1]);
        }
    }
    static bool ProvjeriTrougao(std::vector&lt;double&gt; &amp;tr1, std::vector&lt;double&gt; &amp;tr2)
    { 
        std::sort(tr1.begin(), tr1.end()); std::sort(tr2.begin(), tr2.end());
        for(int i=0,j=0; i&lt;3; i++, j++) if(!Trougao::PD(tr1[i], tr2[j])) return false;
        return true;
    }
    
    public:
    Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    void Postavi(int indeks, const Tacka &amp;t);
    static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    Tacka DajTjeme(int indeks) const;
    double DajStranicu(int indeks) const;
    double DajUgao(int indeks) const;
    Tacka DajCentar() const;
    double DajObim() const;
    double DajPovrsinu() const;
    bool DaLiJePozitivnoOrijentiran() const;
    bool DaLiJeUnutra(const Tacka &amp;t) const;
    void Ispisi() const;
    void Transliraj(double delta_x, double delta_y);
    void Centriraj(const Tacka &amp;t);
    void Rotiraj(const Tacka &amp;t, double ugao);
    void Skaliraj(const Tacka &amp;t, double faktor);
    void Rotiraj(double ugao);
    void Skaliraj(double faktor);
    friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);
};

Trougao::Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3)
{
    tacka.resize(3);
    Postavi(t1,t2,t3);
}

<a name="6"></a><font color="#00FF00"><a href="match770-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

void Trougao::Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3)
{
    if(!Orijentacija(t1,t2,t3)) throw std::domain_error("Nekorektne pozicije tjemena");
    tacka[0] = t1; tacka[1] = t2; tacka[2] = t3;
</font>}

void Trougao::Postavi(int indeks, const Tacka &amp;t)
{
    ProvjeriIndex(indeks);
    if(indeks==1) Postavi(t,tacka[1],tacka[2]);
    else if(indeks==2) Postavi(tacka[0],t,tacka[2]);
    else if(indeks==3) Postavi(tacka[0],tacka[1],t);
}

int Trougao::Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3)
{
    double x(Izraz(t1,t2,t3));
    if(PD(x, 0)) return 0; else if(x&lt;0) return -1; else return 1;
}

Tacka Trougao::DajTjeme(int indeks) const
{
    ProvjeriIndex(indeks);
    return tacka[indeks-1];
}

double Trougao::DajStranicu(int indeks) const
{
    ProvjeriIndex(indeks);
    int a,b;
    OdrediOstaleIndexe(indeks, a, b);
    return sqrt( ((tacka[a-1].first - tacka[b-1].first) * (tacka[a-1].first - tacka[b-1].first)) + ((tacka[a-1].second - tacka[b-1].second) * (tacka[a-1].second - tacka[b-1].second)) );
}

double Trougao::DajUgao(int indeks) const
{
    ProvjeriIndex(indeks);
    int A,B;
    OdrediOstaleIndexe(indeks, A, B);
    double a(DajStranicu(A)), b(DajStranicu(B)), c(DajStranicu(indeks));
    return acos( (a*a + b*b -c*c) / (2*a*b) );
}

Tacka Trougao::DajCentar() const
{
    double x(0),y(0);
    for(int i=0; i&lt;tacka.size(); i++) { x += tacka[i].first; y += tacka[i].second; }
    x/=3; y/=3;
    return Tacka(x,y);
}

double Trougao::DajObim() const
{
    double obim(0);
    for(int i=1; i&lt;=tacka.size(); i++) obim += DajStranicu(i);
    return obim;
}

double Trougao::DajPovrsinu() const
{
    return fabs(Izraz(tacka[0],tacka[1],tacka[2])/2);
}

bool Trougao::DaLiJePozitivnoOrijentiran() const
{
    return Orijentacija(tacka[0], tacka[1], tacka[2]) == 1;
}

bool Trougao::DaLiJeUnutra(const Tacka &amp;t) const
{
    bool smjer(DaLiJePozitivnoOrijentiran());
    for(int i=3; i!= 0; i--) 
    {
        int a,b;
        OdrediOstaleIndexe(i, a, b);
        if(Orijentacija(tacka[a-1], tacka[b-1], t) != smjer) return false;
    }
    return true;
}

void Trougao::Ispisi() const
{
    std::cout &lt;&lt; "((" &lt;&lt; tacka[0].first &lt;&lt; "," &lt;&lt; tacka[0].second &lt;&lt; "),(" &lt;&lt; tacka[1].first &lt;&lt; "," &lt;&lt; tacka[1].second &lt;&lt; "),(" &lt;&lt; tacka[2].first &lt;&lt; "," &lt;&lt; tacka[2].second &lt;&lt; "))";
}

<a name="0"></a><font color="#FF0000"><a href="match770-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

void Trougao::Transliraj(double delta_x, double delta_y)
{
    tacka[0].first += delta_x; tacka[0].second += delta_y;
    tacka[1].first += delta_x; tacka[1].second += delta_y;
    tacka[2].first += delta_x; tacka[2].second += delta_y;
}

void Trougao::Centriraj(const Tacka &amp;t)
</font>{
    Tacka ts (DajCentar());
    double dx(t.first - ts.first), dy(t.second - ts.second);
    Transliraj(dx,dy);
}

void Trougao::Rotiraj(const Tacka &amp;t, double ugao)
{
    std::vector&lt;Tacka&gt; a{ DajTjeme(1), DajTjeme(2), DajTjeme(3) };
    std::vector&lt;Tacka&gt; n(3);
    for(int i=0; i&lt;3; i++)
    {
        n[i].first = t.first + (a[i].first-t.first)*cos(ugao)-(a[i].second-t.second)*sin(ugao);
        n[i].second = t.second + (a[i].first-t.first)*sin(ugao)+(a[i].second-t.second)*cos(ugao);
    }
    Postavi(n[0], n[1], n[2]);
}

void Trougao::Skaliraj(const Tacka &amp;t, double faktor)
{
    if(PD(faktor, 0.)) throw std::domain_error("Nekorektan faktor skaliranja");
    std::vector&lt;Tacka&gt; a{ DajTjeme(1), DajTjeme(2), DajTjeme(3) };
    std::vector&lt;Tacka&gt; n(3);
    for(int i=0; i&lt;3; i++)
    {
        n[i].first = t.first + (a[i].first-t.first)*faktor;
        n[i].second = t.second + (a[i].second-t.second)*faktor;
    }
    Postavi(n[0], n[1], n[2]);
}

void Trougao::Rotiraj(double ugao)
{
    Rotiraj(DajCentar(), ugao);
}

void Trougao::Skaliraj(double faktor)
{
    Skaliraj(DajCentar(), faktor);
}

bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2)
{
    if(Trougao::PD(t1.tacka[0].first, t2.tacka[0].first) &amp;&amp; Trougao::PD(t1.tacka[1].first, t2.tacka[1].first) &amp;&amp; Trougao::PD(t1.tacka[2].first, t2.tacka[2].first) &amp;&amp; Trougao::PD(t1.tacka[0].second, t2.tacka[0].second) &amp;&amp; Trougao::PD(t1.tacka[1].second, t2.tacka[1].second) &amp;&amp; Trougao::PD(t1.tacka[2].second, t2.tacka[2].second)) return true;
    if(Trougao::PD(t1.tacka[0].first, t2.tacka[0].first) &amp;&amp; Trougao::PD(t1.tacka[1].first, t2.tacka[2].first) &amp;&amp; Trougao::PD(t1.tacka[2].first, t2.tacka[1].first) &amp;&amp; Trougao::PD(t1.tacka[0].second, t2.tacka[0].second) &amp;&amp; Trougao::PD(t1.tacka[1].second, t2.tacka[2].second) &amp;&amp; Trougao::PD(t1.tacka[2].second, t2.tacka[1].second)) return true;
    if(Trougao::PD(t1.tacka[1].first, t2.tacka[1].first) &amp;&amp; Trougao::PD(t1.tacka[0].first, t2.tacka[2].first) &amp;&amp; Trougao::PD(t1.tacka[2].first, t2.tacka[0].first) &amp;&amp; Trougao::PD(t1.tacka[1].second, t2.tacka[1].second) &amp;&amp; Trougao::PD(t1.tacka[0].second, t2.tacka[2].second) &amp;&amp; Trougao::PD(t1.tacka[2].second, t2.tacka[0].second)) return true;
    if(Trougao::PD(t1.tacka[2].first, t2.tacka[2].first) &amp;&amp; Trougao::PD(t1.tacka[0].first, t2.tacka[1].first) &amp;&amp; Trougao::PD(t1.tacka[1].first, t2.tacka[0].first) &amp;&amp; Trougao::PD(t1.tacka[2].second, t2.tacka[2].second) &amp;&amp; Trougao::PD(t1.tacka[0].second, t2.tacka[1].second) &amp;&amp; Trougao::PD(t1.tacka[1].second, t2.tacka[0].second)) return true;
    
    for(int i=1; i&lt;=3; i++)
    {
        int a,b;
        Trougao::OdrediOstaleIndexe(i, a, b);
        if(Trougao::PD(t1.tacka[0].first, t2.tacka[i-1].first) &amp;&amp; Trougao::PD(t1.tacka[1].first, t2.tacka[a-1].first) &amp;&amp; Trougao::PD(t1.tacka[2].first, t2.tacka[b-1].first)       &amp;&amp;        Trougao::PD(t1.tacka[0].second, t2.tacka[i-1].second) &amp;&amp; Trougao::PD(t1.tacka[1].second, t2.tacka[a-1].second) &amp;&amp; Trougao::PD(t1.tacka[2].second, t2.tacka[b-1].second) ) return true;
    }
    return false;
}

bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2)
{
    if(DaLiSuIdenticni(t1,t2)) return true;
    std::vector&lt;double&gt; tr1{t1.DajStranicu(1),t1.DajStranicu(2),t1.DajStranicu(3)};
    std::vector&lt;double&gt; tr2{t2.DajStranicu(1),t2.DajStranicu(2),t2.DajStranicu(3)};
    if(!Trougao::ProvjeriTrougao(tr1, tr2)) return false;
    if(Trougao::PD(tr1[0], tr1[1]) || Trougao::PD(tr1[0], tr1[2]) || Trougao::PD(tr1[1], tr1[2])) return true;
    Trougao T(t2); Trougao::NasteliTrougao(t1, t2, T);
<a name="1"></a><font color="#00FF00"><a href="match770-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    return (Trougao::Orijentacija(t1.tacka[0], t1.tacka[1], t1.tacka[2]) == Trougao::Orijentacija(T.tacka[0], T.tacka[1], T.tacka[2]));
}

bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2)
</font>{
    if(DaLiSuIdenticni(t1,t2)) return true;
    std::vector&lt;double&gt; tr1{t1.DajUgao(1),t1.DajUgao(2),t1.DajUgao(3)};
    std::vector&lt;double&gt; tr2{t2.DajUgao(1),t2.DajUgao(2),t2.DajUgao(3)};
    if(!Trougao::ProvjeriTrougao(tr1, tr2)) return false;
    if(Trougao::PD(tr1[0], tr1[1]) || Trougao::PD(tr1[0], tr1[2]) || Trougao::PD(tr1[1], tr1[2])) return true;
    Trougao T(t2); Trougao::NasteliTrougao(t1, t2, T);
<a name="2"></a><font color="#0000FF"><a href="match770-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    return (Trougao::Orijentacija(t1.tacka[0], t1.tacka[1],t1.tacka[2]) == Trougao::Orijentacija(T.tacka[0], T.tacka[1],T.tacka[2]));
</font>}

int main ()
{
    int n;
    std::cout &lt;&lt; "Koliko zelite kreirati trouglova: ";
    std::cin &gt;&gt; n;
    std::vector&lt;std::shared_ptr&lt;Trougao&gt;&gt; pok_v(n);
    std::vector&lt;std::pair&lt;double, double&gt;&gt; tjemena(3);
    for(int i=0; i&lt;n; i++)
    {
        std::cout &lt;&lt; "Unesite podatke za "&lt;&lt; i+1 &lt;&lt; ". trougao (x1 y1 x2 y2 x3 y3): "; 
        for(int j=0; j&lt;3; j++)
        {
            std::cin &gt;&gt; tjemena[j].first &gt;&gt;  tjemena[j].second; 
        }
        try { pok_v[i] = std::make_shared&lt;Trougao&gt;(tjemena[0], tjemena[1], tjemena[2]); }
        catch (std::bad_alloc) {std::cout &lt;&lt; "Problemi sa memorijom."; return 0; }
        catch (std::domain_error a) {std::cout &lt;&lt; a.what() &lt;&lt; ", ponovite unos!" &lt;&lt; std::endl; i--; }
    }
    
    double dx(0), dy(0);
    std::cout &lt;&lt; "Unesite vektor translacije (dx dy): ";
    std::cin &gt;&gt; dx &gt;&gt; dy;
    std::transform(pok_v.begin(), pok_v.end(), pok_v.begin(), [dx,dy] (std::shared_ptr&lt;Trougao&gt; &amp;p_t) { p_t-&gt;Transliraj(dx,dy); return p_t;});
    std::cout &lt;&lt; "Unesite ugao rotacije: ";
    std::cin &gt;&gt; dx;
    std::transform(pok_v.begin(), pok_v.end(), pok_v.begin(), [dx] (std::shared_ptr&lt;Trougao&gt; &amp;p_t) { p_t-&gt;Rotiraj(dx); return p_t;});
    
    double faktor(0);
    std::cout &lt;&lt; "Unesite faktor skaliranja: ";
    std::cin &gt;&gt; faktor;
    std::transform(pok_v.begin(), pok_v.end(), pok_v.begin(), [faktor] (std::shared_ptr&lt;Trougao&gt; &amp;p_t) { p_t-&gt;Skaliraj(p_t-&gt;DajTjeme(1), faktor); return p_t;});
    
<a name="7"></a><font color="#0000FF"><a href="match770-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    std::cout &lt;&lt; "Trouglovi nakon obavljenih transformacija: \n";
    std::sort(pok_v.begin(), pok_v.end(), [](std::shared_ptr&lt;Trougao&gt; t1, std::shared_ptr&lt;Trougao&gt; t2) {
</font>    return t1-&gt;DajPovrsinu() &lt; t2-&gt;DajPovrsinu(); });
   
    std::for_each(pok_v.begin(), pok_v.end(), [](std::shared_ptr&lt;Trougao&gt; t) { t-&gt;Ispisi(); std::cout &lt;&lt; std::endl; });
    std::cout &lt;&lt; "Trougao sa najmanjim obimom: ";
    auto a (*std::min_element(pok_v.begin(), pok_v.end(), [] (std::shared_ptr&lt;Trougao&gt; t1 , std::shared_ptr&lt;Trougao&gt; t2) { return t1-&gt;DajObim() &lt; t2-&gt;DajObim() ;}));
    a-&gt;Ispisi(); std::cout &lt;&lt; std::endl;
    {
    std::vector&lt;bool&gt; bul(pok_v.size(), false);
    bool poruka(false);
    for(int i=0; i&lt;pok_v.size(); i++)
    for(int j=0; j&lt;pok_v.size(); j++)
    {
        bool ima(false); 
        if(bul[j] != true &amp;&amp; i!=j &amp;&amp; DaLiSuIdenticni(*pok_v[i], *pok_v[j]))
        {
<a name="3"></a><font color="#00FFFF"><a href="match770-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

            if(poruka == false) { std::cout &lt;&lt; "Parovi identicnih trouglova: \n"; poruka = true; } 
            pok_v[i]-&gt;Ispisi(); std::cout &lt;&lt; " i "; pok_v[j]-&gt;Ispisi(); std::cout &lt;&lt; std::endl;
</font>            ima = true;
        }
        if(ima) bul[i] = true;
    }
    if(!poruka) std::cout &lt;&lt; "Nema identicnih trouglova!" &lt;&lt; std::endl;
    }
    
    {
    bool poruka(false);
    std::vector&lt;bool&gt; bul(pok_v.size(), false);
    for(int i=0; i&lt;pok_v.size(); i++)
    for(int j=0; j&lt;pok_v.size(); j++)
    {
        bool ima(false);
        if(bul[j] != true &amp;&amp; i!=j &amp;&amp; DaLiSuPodudarni(*pok_v[i], *pok_v[j]))
        {
<a name="4"></a><font color="#FF00FF"><a href="match770-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

            if(poruka == false) { std::cout &lt;&lt; "Parovi podudarnih trouglova: \n"; poruka = true; } 
            pok_v[i]-&gt;Ispisi(); std::cout &lt;&lt; " i "; pok_v[j]-&gt;Ispisi(); std::cout &lt;&lt; std::endl;
</font>            ima = true;
        }
        if(ima) bul[i] = true;
    }
    if(!poruka) std::cout &lt;&lt; "Nema podudarnih trouglova!" &lt;&lt; std::endl;
    }
    
    {
    bool poruka(false);
    std::vector&lt;bool&gt; bul(pok_v.size(), false);
    for(int i=0; i&lt;pok_v.size(); i++)
    for(int j=0; j&lt;pok_v.size(); j++)
    {
        bool ima(false);
        if(bul[j] != true &amp;&amp; i!=j &amp;&amp; DaLiSuSlicni(*pok_v[i], *pok_v[j]))
        {
<a name="5"></a><font color="#FF0000"><a href="match770-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

            if(poruka == false) { std::cout &lt;&lt; "Parovi slicnih trouglova: \n"; poruka = true; } 
            pok_v[i]-&gt;Ispisi(); std::cout &lt;&lt; " i "; pok_v[j]-&gt;Ispisi(); std::cout &lt;&lt; std::endl;
</font>            ima = true;
        }
        if(ima) bul[i] = true;
    }
    if(!poruka) std::cout &lt;&lt; "Nema slicnih trouglova!" &lt;&lt; std::endl;
    }
	return 0;
}</pre>
</body>
</html>
