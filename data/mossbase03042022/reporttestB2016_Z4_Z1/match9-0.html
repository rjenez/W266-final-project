<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student9557.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student9557.cpp<p></p><pre>
<a name="5"></a><font color="#FF0000"><a href="match9-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;
#include &lt;cmath&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;limits&gt;

typedef std::pair&lt;double, double&gt; Tacka;
const double PI{4 * std::atan(1)};
const double EPS{0.0000001};

class Trougao {
    Tacka a, b, c; //tri tacke
    public:
    Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) { Postavi(t1, t2, t3); }
    void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    void Postavi(int indeks, const Tacka &amp;t);
    static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
        int n = t1.first*(t2.second-t3.second) - t2.first*(t1.second-t3.second) + t3.first*(t1.second-t2.second);
        if(n &gt; 0) return 1;
        if(n &lt; 0) return -1;
        if(n == 0) return 0;
        return 2; 
    }
    Tacka DajTjeme(int indeks) const;
    double DajStranicu(int indeks) const;
    double DajUgao(int indeks) const;
    Tacka DajCentar() const;
    double DajObim() const;
</font>    double DajPovrsinu() const;
    bool DaLiJePozitivnoOrijentiran() const;
    bool DaLiJeUnutra(const Tacka &amp;t) const;
    void Ispisi() const;
    void Transliraj(double delta_x, double delta_y);
    void Centriraj(const Tacka &amp;t);
    void Rotiraj(const Tacka &amp;t, double ugao); 
    void Skaliraj(const Tacka &amp;t, double faktor);
    void Rotiraj(double ugao);
    void Skaliraj(double faktor);
    friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
<a name="2"></a><font color="#0000FF"><a href="match9-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_14.gif"/></a>

    friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);
};

    void Trougao::Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
        if(Orijentacija(t1, t2, t3) == 0) throw std::domain_error("Nekorektne pozicije tjemena");
        
        a.first=t1.first;
        a.second=t1.second;
        
        b.first=t2.first;
        b.second=t2.second;
        
        c.first=t3.first;
        c.second=t3.second;
    }
    void Trougao::Postavi(int indeks, const Tacka &amp;t){
        if(indeks==1){
            if(Orijentacija(t, b, c) ==0) throw std::domain_error("Nekorektne pozicije tjemena");
            a.first=t.first;
            a.second=t.second;
        }
        else if(indeks==2){
            if(Orijentacija(a, t, c)==0) throw std::domain_error("Nekorektne pozicije tjemena");
            b.first=t.first;
            b.second=t.second;
        }
        else if(indeks==3){
            if(Orijentacija(a, b, t)==0) throw std::domain_error("Nekorektne pozicije tjemena");
            c.first=t.first;
            c.second=t.second;
        }
        else throw std::range_error("Nekorektan indeks");
    }
    Tacka Trougao::DajTjeme(int indeks) const{
        if(indeks==1) return a;
        if(indeks==2) return b;
        if(indeks==3) return c;
        
        throw std::range_error("Nekorektan indeks");
    }
    double Trougao::DajStranicu(int indeks) const{
        if(indeks==1){
            return std::sqrt((c.first-b.first)*(c.first-b.first) + (c.second-b.second)*(c.second-b.second));
        }
        else if (indeks==2){
            return std::sqrt((a.first-c.first)*(a.first-c.first) + (a.second-c.second)*(a.second-c.second));
        }
        else if (indeks==3){
            return std::sqrt((b.first-a.first)*(b.first-a.first) + (b.second-a.second)*(b.second-a.second));
        }
        throw std::range_error("Nekorektan indeks");
    }
    double Trougao::DajUgao(int indeks) const{
        double str_a=DajStranicu(1);
        double str_b=DajStranicu(2);
        double str_c=DajStranicu(3);
        if(indeks&gt;3) throw std::range_error("Nekorektan indeks");
        if(indeks==1){
            double cosA= (double)(str_b*str_b + str_c*str_c - str_a*str_a) / (2*str_b*str_c);
            return acos(cosA);
        }
        if(indeks==2){
            double cosB= (double)(str_c*str_c + str_a*str_a - str_b*str_b) / (2*str_c*str_a);
            return acos(cosB);
        }
        if(indeks==3){
            double cosC=(double)(str_a*str_a + str_b*str_b - str_c*str_c) / (2*str_a*str_b);
            return acos(cosC);
        }
        
        return 0;
    }
    Tacka Trougao::DajCentar() const{
        double x, y;
        x=(double)((a.first+b.first+c.first)/3);
        y=(double)((a.second+b.second+c.second)/3);
        Tacka t(x,y);
        return t;
    }
    double Trougao::DajObim() const{
        double str_a=DajStranicu(1);
        double str_b=DajStranicu(2);
        double str_c=DajStranicu(3);
        return str_a+str_b+str_c;
    }
    void Trougao::Ispisi() const{
        std::cout &lt;&lt; "((" &lt;&lt; a.first &lt;&lt; "," &lt;&lt; a.second &lt;&lt; "),(" &lt;&lt; b.first &lt;&lt; "," &lt;&lt; b.second &lt;&lt; "),(" &lt;&lt; c.first &lt;&lt; "," &lt;&lt; c.second &lt;&lt; "))";
</font><a name="1"></a><font color="#00FF00"><a href="match9-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_19.gif"/></a>

        //std::cout &lt;&lt; std::endl &lt;&lt; DajPovrsinu();
    }
    double Trougao::DajPovrsinu() const{
        return 0.5*(abs(a.first*(b.second-c.second) - b.first*(a.second-c.second) + c.first*(a.second-b.second)));
    }
    bool Trougao::DaLiJePozitivnoOrijentiran() const{
        if(Orijentacija(a, b, c)==1) return true;
        return false;
    }
    bool Trougao::DaLiJeUnutra(const Tacka &amp;t) const{
        
        if(t==a) return true;
        if(t==b) return true;
        if(t==c) return true;
        // baricentricne koordinate
        double prva=((b.second - c.second)*(t.first - c.first) + (c.first- b.first)*(t.second - c.second)) / ((b.second - c.second)*(a.first - c.first) + (c.first - b.first)*(a.second - c.second));
        double druga=((c.second - a.second)*(t.first -c.first) + (a.first - c.first)*(t.second - c.second)) / ((b.second - c.second)*(a.first - c.first) + (c.first - b.first)*(a.second - c.second));
        double treca=1.0-prva-druga;
        
        if(prva&gt;0 &amp;&amp; druga&gt;0 &amp;&amp; treca&gt;0) return true;
        return false;
        
    }
    void Trougao::Transliraj(double delta_x, double delta_y){
        Tacka a1(a.first+delta_x, a.second+delta_y);
        Tacka b1(b.first+delta_x, b.second+delta_y);
        Tacka c1(c.first+delta_x, c.second+delta_y);
        Postavi(a1, b1, c1);
    }
    void Trougao::Centriraj(const Tacka &amp;t){
        Tacka centar=DajCentar();
        double x, y;
        x=t.first-centar.first;
        y=t.second-centar.second;
        Transliraj(x,y);
    }
    void Trougao::Rotiraj(const Tacka &amp;t, double ugao){
        double ax, ay;
        long double cosA(cos(ugao));
        long double sinA(sin(ugao));

        ax = t.first + (a.first-t.first)*cosA - (a.second-t.second)*sinA;
        ay = t.second + (a.first-t.first)*sinA + (a.second-t.second)*cosA;
        Tacka a_prim(ax,ay);
                        
        double bx, by;
        bx = t.first + (b.first-t.first)*cosA - (b.second-t.second)*sinA;
        by = t.second + (b.first - t.first)*sinA + (b.second-t.second)*cosA;
        Tacka b_prim(bx,by);
                        
        double cx, cy;
        cx = t.first + (c.first-t.first)*cosA - (c.second-t.second)*sinA;
        cy = t.second + (c.first-t.first)*sinA + (c.second-t.second)*cosA;
        Tacka c_prim(cx,cy);
        
        Postavi(a_prim, b_prim, c_prim);
    }
    void Trougao::Skaliraj(const Tacka &amp;t, double faktor){
        if(faktor&lt;=0) throw std::domain_error("Nekorektan faktor skaliranja");
        double ax, ay;
        ax=t.first+faktor*(a.first-t.first);
        ay=t.second+faktor*(a.second-t.second);
        Tacka a_prim(ax,ay);
        
        double bx, by;
        bx=t.first+faktor*(b.first-t.first);
        by=t.second+faktor*(b.second-t.second);
        Tacka b_prim(bx,by);
        
        double cx, cy;
        cx=t.first+faktor*(c.first-t.first);
        cy=t.second+faktor*(c.second-t.second);
        Tacka c_prim(cx,cy);
        
        Postavi(a_prim, b_prim, c_prim);
        
    }
    void Trougao::Rotiraj(double ugao) { Rotiraj(DajCentar(), ugao); }
    void Trougao::Skaliraj(double faktor){
        if(faktor&lt;=0) throw std::domain_error("Nekorektan faktor skaliranja");
        Skaliraj(DajCentar(), faktor);
    }
    bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2){
        if((abs(t1.a.first-t2.a.first)&lt;=EPS &amp;&amp; abs(t1.a.second-t2.a.second)&lt;=EPS) &amp;&amp; (abs(t1.b.first-t2.b.first)&lt;=EPS &amp;&amp; abs(t1.b.second-t2.b.second)&lt;=EPS) &amp;&amp; (abs(t1.c.first-t2.c.first)&lt;=EPS &amp;&amp; abs(t1.c.second-t2.c.second)&lt;=EPS)) return true;
</font><a name="7"></a><font color="#0000FF"><a href="match9-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        if((abs(t1.a.first-t2.a.first)&lt;=EPS &amp;&amp; abs(t1.a.second-t2.a.second)&lt;=EPS) &amp;&amp; (abs(t1.b.first-t2.c.first)&lt;=EPS &amp;&amp; abs(t1.b.second-t2.c.second)&lt;=EPS) &amp;&amp; (abs(t1.c.first-t2.b.first)&lt;=EPS &amp;&amp; abs(t1.c.second-t2.b.second)&lt;=EPS)) return true;
</font><a name="8"></a><font color="#00FFFF"><a href="match9-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        if((abs(t1.a.first-t2.c.first)&lt;=EPS &amp;&amp; abs(t1.a.second-t2.c.second)&lt;=EPS) &amp;&amp; (abs(t1.b.first-t2.b.first)&lt;=EPS &amp;&amp; abs(t1.b.second-t2.b.second)&lt;=EPS) &amp;&amp; (abs(t1.c.first-t2.a.first)&lt;=EPS &amp;&amp; abs(t1.c.second-t2.a.second)&lt;=EPS)) return true;
</font><a name="9"></a><font color="#FF00FF"><a href="match9-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        if((abs(t1.a.first-t2.b.first)&lt;=EPS &amp;&amp; abs(t1.a.second-t2.b.second)&lt;=EPS) &amp;&amp; (abs(t1.b.first-t2.a.first)&lt;=EPS &amp;&amp; abs(t1.b.second-t2.a.second)&lt;=EPS) &amp;&amp; (abs(t1.c.first-t2.c.first)&lt;=EPS &amp;&amp; abs(t1.c.second-t2.c.second)&lt;=EPS)) return true;
</font><a name="10"></a><font color="#FF0000"><a href="match9-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        if((abs(t1.a.first-t2.b.first)&lt;=EPS &amp;&amp; abs(t1.a.second-t2.b.second)&lt;=EPS) &amp;&amp; (abs(t1.b.first-t2.c.first)&lt;=EPS &amp;&amp; abs(t1.b.second-t2.c.second)&lt;=EPS) &amp;&amp; (abs(t1.c.first-t2.a.first)&lt;=EPS &amp;&amp; abs(t1.c.second-t2.a.second)&lt;=EPS)) return true;
</font><a name="11"></a><font color="#00FF00"><a href="match9-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        if((abs(t1.a.first-t2.b.first)&lt;=EPS &amp;&amp; abs(t1.a.second-t2.b.second)&lt;=EPS) &amp;&amp; (abs(t1.b.first-t2.a.first)&lt;=EPS &amp;&amp; abs(t1.b.second-t2.a.second)&lt;=EPS) &amp;&amp; (abs(t1.c.first-t2.b.first)&lt;=EPS &amp;&amp; abs(t1.c.second-t2.b.second)&lt;=EPS)) return true;
</font><a name="6"></a><font color="#00FF00"><a href="match9-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        return false;
    }
    bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2){
        // Dva trougla su slicna ukoliko su im sva tri ugla jednaka
        
        double alfa_1 = t1.DajUgao(1);
        double str_b1 = t1.DajStranicu(2);
        double str_c1 = t1.DajStranicu(3);
        
        double alfa_2 = t2.DajUgao(1);
</font>        double beta_2 = t2.DajUgao(2);
<a name="4"></a><font color="#FF00FF"><a href="match9-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

        double gama_2 = t2.DajUgao(3);
        double str_a2 = t2.DajStranicu(1);
        double str_b2 = t2.DajStranicu(2);
        double str_c2 = t2.DajStranicu(3);
        
        //odnosi b:c moraju biti jednaki
        if(fabs(alfa_1-alfa_2)&lt;std::numeric_limits&lt;double&gt;::epsilon()){ 
            if(fabs(str_b1/str_b2 - str_c1/str_c2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
            if(fabs(str_b1/str_c2 - str_c1/str_b2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
        }
        
        if(fabs(alfa_1-beta_2)&lt;std::numeric_limits&lt;double&gt;::epsilon()){ 
            if(fabs(str_b1/str_a2 - str_c1/str_c2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
            if(fabs(str_b1/str_c2 - str_c1/str_a2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
        }
        
         if(fabs(alfa_1-gama_2) &lt; std::numeric_limits&lt;double&gt;::epsilon()){ 
            if(fabs(str_b1/str_a2 - str_c1/str_b2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
            if(fabs(str_b1/str_b2 - str_c1/str_a2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
        }
        
        return false;
    }
    bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2){
        // Dva trougla su slicna ukoliko su im sva tri ugla jednaka
        
        double alfa_1 = t1.DajUgao(1);
        double beta_1 = t1.DajUgao(2);
        double gama_1 = t1.DajUgao(3);
        double str_a1 = t2.DajStranicu(1);
</font>        double str_b1 = t1.DajStranicu(2);
        double str_c1 = t1.DajStranicu(3);
        
        double alfa_2 = t2.DajUgao(1);
        double beta_2 = t2.DajUgao(2);
<a name="0"></a><font color="#FF0000"><a href="match9-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_25.gif"/></a>

        double gama_2 = t2.DajUgao(3);
        double str_a2 = t2.DajStranicu(1);
        double str_b2 = t2.DajStranicu(2);
        double str_c2 = t2.DajStranicu(3);
        
        if(fabs(alfa_1-alfa_2)&lt;std::numeric_limits&lt;double&gt;::epsilon()){ //b i c moraju biti jednaki b i c
            if(fabs(str_b1-str_b2)&lt;std::numeric_limits&lt;double&gt;::epsilon() &amp;&amp; fabs(str_c1-str_c2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
            if(fabs(str_b1-str_c2)&lt;std::numeric_limits&lt;double&gt;::epsilon() &amp;&amp; fabs(str_c1-str_b2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
        }
        
        if(fabs(beta_1-beta_2)&lt;std::numeric_limits&lt;double&gt;::epsilon()){ //a i c
            if(fabs(str_a1-str_c2)&lt;std::numeric_limits&lt;double&gt;::epsilon() &amp;&amp; fabs(str_c1-str_c2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
            if(fabs(str_c1-str_a2)&lt;std::numeric_limits&lt;double&gt;::epsilon() &amp;&amp; fabs(str_c1-str_b2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
        }
        
        if(fabs(gama_1-gama_2)&lt;std::numeric_limits&lt;double&gt;::epsilon()){ // 
            if(fabs(str_b1-str_b2)&lt;std::numeric_limits&lt;double&gt;::epsilon() &amp;&amp; fabs(str_c1-str_c2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
            if(fabs(str_b1-str_c2)&lt;std::numeric_limits&lt;double&gt;::epsilon() &amp;&amp; fabs(str_c1-str_b2)&lt;std::numeric_limits&lt;double&gt;::epsilon()) return true;
        }
        return false;
    }
    
int main ()
{
    
    std::cout &lt;&lt; "Koliko zelite kreirati trouglova: ";
    int n;
    std::cin&gt;&gt;n; 
    std::cin.ignore(100, '\n');
    std::vector&lt;std::shared_ptr&lt;Trougao&gt;&gt; trouglovi;
    
    for(int i =0; i &lt;n; i++){
        std::cout &lt;&lt; "Unesite podatke za " &lt;&lt; i+1 &lt;&lt; ". trougao (x1 y1 x2 y2 x3 y3): ";
        try{
            double x1,y1, x2, y2, x3, y3;
            std::cin &gt;&gt; x1&gt;&gt; y1&gt;&gt; x2&gt;&gt; y2&gt;&gt; x3&gt;&gt; y3;
            //std::cin.ignore(100, '\n');
            Tacka a(x1,y1), b(x2,y2), c(x3,y3);
            std::shared_ptr&lt;Trougao&gt; trougao = std::make_shared&lt;Trougao&gt;(a,b,c); 
            trouglovi.push_back(trougao);
        } catch(std::domain_error e){
            std::cout &lt;&lt; e.what() &lt;&lt; ", ponovite unos!" &lt;&lt; std::endl;
            i--;
            std::cin.clear();
        }
    }
    
    //Translacija radi
    double dx, dy;
    std::cout &lt;&lt; "Unesite vektor translacije (dx dy): ";
    std::cin &gt;&gt; dx &gt;&gt; dy;
    std::cin.ignore(100, '\n');
    std::transform(trouglovi.begin(), trouglovi.end(), trouglovi.begin(), 
                   [dx, dy] (std::shared_ptr&lt;Trougao&gt; t1) {
                        Tacka a=t1-&gt;DajTjeme(1);
                        Tacka b=t1-&gt;DajTjeme(2);
                        Tacka c=t1-&gt;DajTjeme(3);
                       Tacka a1(a.first + dx, a.second + dy);
                       Tacka b1(b.first + dx, b.second + dy);
                       Tacka c1(c.first + dx, c.second + dy);
                       return std::make_shared&lt;Trougao&gt;(a1,b1,c1);
                       }); 


    //Rotacija radi
    long double ugao;
    std::cout &lt;&lt; "Unesite ugao rotacije: ";
    std::cin&gt;&gt;ugao;
    std::cin.ignore(100, '\n');
    std::transform(trouglovi.begin(), trouglovi.end(), trouglovi.begin(), 
                  [ugao] (std::shared_ptr&lt;Trougao&gt; t1){
                        double ax, ay;
                        long double cosA(cos(ugao));
                        long double sinA(sin(ugao));
                        
                        Tacka a=t1-&gt;DajTjeme(1);
                        Tacka b=t1-&gt;DajTjeme(2);
                        Tacka c=t1-&gt;DajTjeme(3);
                        Tacka t=t1-&gt;DajCentar();
                        
                        
                        ax = t.first + (a.first-t.first)*cosA - (a.second-t.second)*sinA;
                        ay = t.second + (a.first-t.first)*sinA + (a.second-t.second)*cosA;
                        Tacka a_prim(ax,ay);
                        
                        double bx, by;
                        bx = t.first + (b.first-t.first)*cosA - (b.second-t.second)*sinA;
                        by = t.second + (b.first - t.first)*sinA + (b.second-t.second)*cosA;
                        Tacka b_prim(bx,by);
                        
                        double cx, cy;
                        cx = t.first + (c.first-t.first)*cosA - (c.second-t.second)*sinA;
                        cy = t.second + (c.first-t.first)*sinA + (c.second-t.second)*cosA;
                        Tacka c_prim(cx,cy);
                        
                        return std::make_shared&lt;Trougao&gt;(a_prim,b_prim,c_prim);
                  }); 

    //Skalirati uzimajuci prvo tjeme!!!
    double faktor;
    std::cout &lt;&lt; "Unesite faktor skaliranja: ";
    std::cin&gt;&gt;faktor;
    std::cin.ignore(100, '\n');
    std::transform(trouglovi.begin(), trouglovi.end(), trouglovi.begin(), 
                  [faktor] (std::shared_ptr&lt;Trougao&gt; t1) { 
                    Tacka a=t1-&gt;DajTjeme(1);
                    Tacka b=t1-&gt;DajTjeme(2);
                    Tacka c=t1-&gt;DajTjeme(3);
                    Tacka t=t1-&gt;DajTjeme(1);
                    
                    if(faktor &lt;= EPS) throw std::domain_error("Nekorektan faktor skaliranja");
                    
                    double ax, ay;
                    ax = t.first + faktor*(a.first-t.first);
                    ay = t.second + faktor*(a.second-t.second);
                    Tacka a_prim(ax,ay);
                    
                    double bx, by;
                    bx = t.first + faktor*(b.first-t.first);
                    by = t.second + faktor*(b.second-t.second);
                    Tacka b_prim(bx,by);
                    
                    double cx, cy;
                    cx = t.first + faktor*(c.first-t.first);
                    cy = t.second + faktor*(c.second-t.second);
                    Tacka c_prim(cx,cy);
                    return std::make_shared&lt;Trougao&gt;(a_prim,b_prim,c_prim);
                  });
    
    std::sort(trouglovi.begin(), trouglovi.end(),
              [] (std::shared_ptr&lt;Trougao&gt; t1, std::shared_ptr&lt;Trougao&gt; t2){
</font>                  return t1-&gt;DajPovrsinu() &lt; t2-&gt;DajPovrsinu();
              });
 
    std::cout &lt;&lt; "Trouglovi nakon obavljenih transformacija:"&lt;&lt;std::endl;
    std::for_each(trouglovi.begin(), trouglovi.end(), 
<a name="3"></a><font color="#00FFFF"><a href="match9-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_11.gif"/></a>

                  [] (std::shared_ptr&lt;Trougao&gt; t1) { t1-&gt;Ispisi(); std::cout &lt;&lt; std::endl; });
                  
    std::cout &lt;&lt; "Trougao sa najmanjim obimom: ";
    auto najmanjiObim = *(std::min_element(trouglovi.begin(), trouglovi.end(),
                     [] (std::shared_ptr&lt;Trougao&gt; t1, std::shared_ptr&lt;Trougao&gt; t2){
                         return t1-&gt;DajObim() &lt; t2-&gt;DajObim();
                     }));
    najmanjiObim-&gt;Ispisi();
    std::cout&lt;&lt;std::endl; 
    
    bool biliIdenticni=false;
    bool biliPodudarni=false;
    bool biliSlicni=false;
    
    typedef std::pair&lt;int, int&gt; IdenticniTrouglovi;
     std::vector&lt;IdenticniTrouglovi&gt; paroviIdenticni;
     
    typedef std::pair&lt;int, int&gt; SlicniTrouglovi;
    std::vector&lt;SlicniTrouglovi&gt; paroviSlicni;
    
    typedef std::pair&lt;int, int&gt; PodudarniTrouglovi;
    std::vector&lt;PodudarniTrouglovi&gt; paroviPodudarni;
    
    for(int i=0; i &lt; trouglovi.size()-1; i++){
        for(int j=i+1; j &lt; trouglovi.size(); j++){
            if(DaLiSuIdenticni(*trouglovi[i], *trouglovi[j])){
                biliIdenticni=true;
                IdenticniTrouglovi identicni(i, j);
                paroviIdenticni.push_back(identicni);
                continue;
            }
            if(DaLiSuPodudarni(*trouglovi[i], *trouglovi[j])){
                biliPodudarni=true;
                PodudarniTrouglovi podudarni(i, j);
                paroviPodudarni.push_back(podudarni);
                continue;
            }
            if(DaLiSuSlicni(*trouglovi[i], *trouglovi[j])){
                biliSlicni=true;
                SlicniTrouglovi slicni(i, j);
                paroviSlicni.push_back(slicni);
                continue;
            }
        }
    }
    
    if(!biliIdenticni) std::cout &lt;&lt; "Nema identicnih trouglova!\n";
    else{
        std::cout &lt;&lt; "Parovi identicnih trouglova:" &lt;&lt; std::endl;
        for(int i=0; i &lt; paroviIdenticni.size(); i++){
            trouglovi[paroviIdenticni[i].first]-&gt;Ispisi(); std::cout &lt;&lt;" i "; trouglovi[paroviIdenticni[i].second]-&gt;Ispisi();
            std::cout &lt;&lt; std::endl;
        }
    }
    if(!biliPodudarni) std::cout &lt;&lt; "Nema podudarnih trouglova!\n";
    else{
        std::cout &lt;&lt; "Parovi podudarnih trouglova:" &lt;&lt; std::endl;
        for(int i=0; i &lt; paroviPodudarni.size(); i++){
            trouglovi[paroviPodudarni[i].first]-&gt;Ispisi(); std::cout &lt;&lt;" i "; trouglovi[paroviPodudarni[i].second]-&gt;Ispisi();
            std::cout &lt;&lt; std::endl;
        }
    }
    if(!biliSlicni) std::cout &lt;&lt; "Nema slicnih trouglova!\n";
        else{
        std::cout &lt;&lt; "Parovi slicnih trouglova:" &lt;&lt; std::endl;
        for(int i=0; i &lt; paroviSlicni.size(); i++){
            trouglovi[paroviSlicni[i].first]-&gt;Ispisi(); std::cout &lt;&lt;" i "; trouglovi[paroviSlicni[i].second]-&gt;Ispisi();
            std::cout &lt;&lt; std::endl;
        }
    }
    
	return 0;
</font>}</pre>
</body>
</html>
