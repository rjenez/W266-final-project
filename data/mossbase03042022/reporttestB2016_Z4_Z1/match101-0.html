<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student5904.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student5904.cpp<p></p><pre>
<a name="1"></a><font color="#00FF00"><a href="match101-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_27.gif"/></a>

/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#define epsilon 0.00000000001
typedef std::pair&lt;double,double&gt; Tacka;
Tacka skaliranje(const Tacka t,double faktor,Tacka tacka_skaliranja){//provjerit da li sam fino sve 
/*tacka_skaliranja.first=(tacka_skaliranja.first+faktor*(t.first-tacka_skaliranja.first));
tacka_skaliranja.second=(tacka_skaliranja.second+faktor*(t.second-tacka_skaliranja.second));*/
    tacka_skaliranja.first=(t.first+faktor*(tacka_skaliranja.first-t.first));
    tacka_skaliranja.second=(t.second+faktor*(tacka_skaliranja.second-t.second));
    return tacka_skaliranja;
}


double povrsina(Tacka t1,Tacka t2,Tacka t3){
    return (std::abs(t1.first*(t2.second-t3.second)-t2.first*(t1.second-t3.second)+t3.first*(t1.second-t2.second)))/2;
}
double udaljenost(Tacka t1,Tacka t2)
{
    return std::sqrt((t1.first-t2.first)*(t1.first-t2.first)+ (t2.second-t1.second)*(t2.second-t1.second));
}
Tacka centar(Tacka t1,Tacka t2,Tacka t3){
    Tacka t;
    t.first=(t1.first+t2.first+t3.first)/3;
    t.second=(t1.second+t2.second+t3.second)/3;
    return t;
}
class Trougao{
    Tacka t1,t2,t3;
   /* Tacka Trougao::tjeme(Trougao t, int br){
    return DajTjeme(br);
}*/
  public:
  Trougao(const Tacka &amp;t1,const Tacka &amp;t2, const Tacka &amp;t3){
     if(Orijentacija(t1,t2,t3)==0) throw std::domain_error("Nekorektne pozicije tjemena");
      Trougao::t1.first=t1.first; Trougao::t1.second=t1.second;
      Trougao::t2.first=t2.first; Trougao::t2.second=t2.second;
      Trougao::t3.first=t3.first; Trougao::t3.second=t3.second;
  }
  void Postavi(const Tacka &amp;t1, const Tacka &amp;t2,const Tacka &amp;t3){
      if(Orijentacija(t1,t2,t3)==0) throw std::domain_error("Nekorektne pozicije tjemena");
      Trougao::t1.first=t1.first; Trougao::t1.second=t1.second;
      Trougao::t2.first=t2.first; Trougao::t2.second=t2.second;
      Trougao::t3.first=t3.first; Trougao::t3.second=t3.second;
  }
  void Postavi(int indeks,const Tacka &amp;t){
      if(indeks&lt;1 || indeks&gt;3) throw std::range_error("Nekorektan indeks");
      if(indeks==1){
          Trougao::t1.first=t.first;
          Trougao::t1.second=t.second;
      }
      else if(indeks==2){
          Trougao::t2.first=t.first;
          Trougao::t2.second=t.second;
      }
      else if(indeks==3){
          Trougao::t3.first=t.first;
          Trougao::t3.second=t.second;
      }
  }
  static int Orijentacija(const Tacka &amp;t1,const Tacka &amp;t2,const Tacka &amp;t3);
  Tacka DajTjeme(int indeks)const{
      if(indeks&lt;1 || indeks&gt;3) throw std::range_error("Nekorektan indeks");
      if(indeks==1) return t1;
      else if(indeks==2) return t2;
      else if(indeks==3) return t3;
  }
  double DajStranicu(int indeks)const{
      if(indeks&lt;1 || indeks&gt;3) throw std::range_error("Nekorektan indeks");
      if(indeks==1) return udaljenost(t2,t3);
      else if(indeks==2) return udaljenost(t1,t3);
      else if(indeks==3) return udaljenost(t1,t2);
  }
  double DajUgao(int indeks)const{
      if(indeks&lt;1 || indeks&gt;3) throw std::range_error("Nekorektan indeks");
      if(indeks==1) return acos((DajStranicu(2)*DajStranicu(2)+DajStranicu(3)*DajStranicu(3)-DajStranicu(1)*DajStranicu(1))/(2*DajStranicu(2)*DajStranicu(3)));
      if(indeks==2) return acos((DajStranicu(1)*DajStranicu(1)+DajStranicu(3)*DajStranicu(3)-DajStranicu(2)*DajStranicu(2))/(2*DajStranicu(1)*DajStranicu(3)));
      if(indeks==3) return acos((DajStranicu(1)*DajStranicu(1)+DajStranicu(2)*DajStranicu(2)-DajStranicu(3)*DajStranicu(3))/(2*DajStranicu(1)*DajStranicu(3)));
  }
  Tacka DajCentar()const{
      return centar(t1,t2,t3);
  }
  double DajObim()const
  {
      return DajStranicu(1)+DajStranicu(2)+DajStranicu(3);
  }
  double DajPovrsinu() const{
      return povrsina(t1,t2,t3);
  }
  bool DaLiJePozitivnoOrijentiran()const{
      if(Orijentacija(t1,t2,t3)==1) return true;
      else return false;
  }
  bool DaLiJeUnutra(const Tacka &amp;t)const;
  void Ispisi()const{
      std::cout&lt;&lt;"(("&lt;&lt;t1.first&lt;&lt;","&lt;&lt;t1.second&lt;&lt;"),("&lt;&lt;t2.first&lt;&lt;","&lt;&lt;t2.second&lt;&lt;"),("&lt;&lt;t3.first&lt;&lt;","&lt;&lt;t3.second&lt;&lt;"))";
</font><a name="2"></a><font color="#0000FF"><a href="match101-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

  }
  void Transliraj(double delta_x,double delta_y){
      t1.first=t1.first+delta_x;
      t2.first=t2.first+delta_x;
      t3.first=t3.first+delta_x;
      t1.second=t1.second+delta_y;
      t2.second=t2.second+delta_y;
      t3.second=t3.second+delta_y;
  }
  void Centriraj(const Tacka &amp;t){
      double delta_x(std::abs(DajCentar().first-t.first));
      double delta_y(std::abs(DajCentar().second-t.second));
      Transliraj(delta_x,delta_y);
  }
  void Rotiraj(const Tacka &amp;t,double ugao){
      t1.first=(t.first+(t1.first-t.first)*std::cos(ugao)-(t1.second-t.second)*std::sin(ugao));
</font>      t2.first=(t.first+(t2.first-t.first)*std::cos(ugao)-(t2.second-t.second)*std::sin(ugao));
      t3.first=(t.first+(t3.first-t.first)*std::cos(ugao)-(t3.second-t.second)*std::sin(ugao));
      t1.second=(t.second+(t1.first-t.first)*std::sin(ugao)+(t1.second-t.second)*std::cos(ugao));
      t2.second=(t.second+(t2.first-t.first)*std::sin(ugao)+(t2.second-t.second)*std::cos(ugao));
<a name="0"></a><font color="#FF0000"><a href="match101-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_60.gif"/></a>

      t3.second=(t.second+(t3.first-t.first)*std::sin(ugao)+(t3.second-t.second)*std::cos(ugao));
  }
  void Skaliraj(const Tacka &amp;t,double faktor){
      if(faktor&lt;epsilon) throw std::domain_error("Nekorektan faktor skaliranja");
     t1=skaliranje(t,faktor,t1);
     t2=skaliranje(t,faktor,t2);
     t3=skaliranje(t,faktor,t3);
  }
  void Rotiraj(double ugao){
      Rotiraj(centar(t1,t2,t3),ugao);
  }
  void Skaliraj(double faktor){
      Skaliraj(centar(t1,t2,t3),faktor);
  }
  friend bool DaLiSuIdenticni(const Trougao &amp;t1,const Trougao &amp;t2);
  
  friend bool DaLiSuPodudarni(const Trougao &amp;t1,const Trougao &amp;t2);
  friend bool DaLiSuSlicni(const Trougao &amp;t1,const Trougao &amp;t2);

};

int Trougao::Orijentacija(const Tacka &amp;t1,const Tacka &amp;t2,const Tacka &amp;t3){

    if(std::fabs(t1.first*(t2.second-t3.second)-t2.first*(t1.second-t3.second)+t3.first*(t1.second-t2.second))&gt;epsilon)
    {
        if((t1.first*(t2.second-t3.second)-t2.first*(t1.second-t3.second)+t3.first*(t1.second-t2.second))&lt;-epsilon) return -1;
         else if((t1.first*(t2.second-t3.second)-t2.first*(t1.second-t3.second)+t3.first*(t1.second-t2.second))&gt;epsilon) return 1;
 
    }
    else return 0;
}
bool Jednakost(Tacka t1,Tacka t2)
{
if(std::fabs(t1.first-t2.first)&lt;epsilon &amp;&amp; std::fabs(t1.second-t2.second)&lt;epsilon) return true;
else return false;
}
bool DaLiSuIdenticni(const Trougao &amp;t1,const Trougao &amp;t2){
   if(
   (Jednakost(t1.DajTjeme(1),t2.DajTjeme(1)) || Jednakost(t1.DajTjeme(1),t2.DajTjeme(2)) || Jednakost(t1.DajTjeme(1),t2.DajTjeme(3))) &amp;&amp; 
   (Jednakost(t1.DajTjeme(2),t2.DajTjeme(1)) || Jednakost(t1.DajTjeme(2),t2.DajTjeme(2)) || Jednakost(t1.DajTjeme(2),t2.DajTjeme(3))) &amp;&amp;
   (Jednakost(t1.DajTjeme(3),t2.DajTjeme(1)) || Jednakost(t1.DajTjeme(3),t2.DajTjeme(2)) || Jednakost(t1.DajTjeme(3),t2.DajTjeme(3))) 
   ) return true;
   else return false;
}

bool JednakostDouble(double x,double y)
{
    return std::fabs(x-y)&lt;epsilon;
}

bool DaLiSuPodudarni(const Trougao &amp;t1,const Trougao &amp;t2)
{

    if(t1.DaLiJePozitivnoOrijentiran()!=t2.DaLiJePozitivnoOrijentiran())
    {
           return false;
    }
    
    std::vector&lt;double&gt; stranicea;
    std::vector&lt;double&gt; straniceb;
    for(int i=0;i&lt;3;i++)
    {
        stranicea.push_back(t1.DajStranicu(i+1));
        straniceb.push_back(t2.DajStranicu(i+1));
    }
    std::sort(stranicea.begin(),stranicea.end());
    std::sort(straniceb.begin(),straniceb.end());
    std::vector&lt;double&gt; sve_stranice;
    for(int i=0;i&lt;3;i++)
    {
        sve_stranice.push_back(stranicea[i]);
    }
    
    for(int i=0;i&lt;3;i++)
    {
        sve_stranice.push_back(straniceb[i]);
    }
    for(int i=1;i&lt;3;i++)
    {
        if(std::fabs(sve_stranice[i]-sve_stranice[i+3])&gt;epsilon) return false;
    }
    return true;
}

bool DaLiSuSlicni(const Trougao &amp;t1,const Trougao &amp;t2)
{
    if(t1.DaLiJePozitivnoOrijentiran()!=t2.DaLiJePozitivnoOrijentiran()) return false;
    std::vector&lt;double&gt; stranicea;
    std::vector&lt;double&gt; straniceb;
    for(int i=0;i&lt;3;i++)
    {
        stranicea.push_back(t1.DajStranicu(i+1));
        straniceb.push_back(t2.DajStranicu(i+1));
    }
    std::sort(stranicea.begin(),stranicea.end());
    std::sort(straniceb.begin(),straniceb.end());
    std::vector&lt;double&gt; sve_stranice;
    for(int i=0;i&lt;3;i++)
    {
        sve_stranice.push_back(stranicea[i]);
    }
    
    for(int i=0;i&lt;3;i++)
    {
        sve_stranice.push_back(straniceb[i]);
    }
    for(int i=1;i&lt;3;i++)
    {
        if(std::fabs(sve_stranice[i]/sve_stranice[i+3]-sve_stranice[i-1]/sve_stranice[i+2])&gt;epsilon) return false;
    }
    return true;
    /*double faktor=stranicea[0]/straniceb[0];
    Tacka t=t2.DajTjeme(1);
    Trougao tr=t2;
    tr.Skaliraj(t,faktor);
    if(DaLiSuPodudarni(tr,t1)) return true;
    else return false;*/
}

bool DaLiSeNalaziUVektoru(std::vector&lt;std::pair&lt;Trougao,Trougao&gt;&gt; trouglovi, std::pair&lt;Trougao,Trougao&gt; par)
{
    for(int i=0;i&lt;(int)trouglovi.size();i++)
    {
        if((DaLiSuIdenticni(trouglovi[i].first,par.first) &amp;&amp; DaLiSuIdenticni(trouglovi[i].second,par.second)) || (DaLiSuIdenticni(trouglovi[i].first,par.second) &amp;&amp; DaLiSuIdenticni(trouglovi[i].second,par.first)) ) return true;
    }
    return false;
}


int main ()
{
   Tacka t1,t2,t3;
   double x1,y1,x2,y2,x3,y3;
    int n;
    std::vector&lt;std::shared_ptr&lt;Trougao&gt;&gt; vektor;
    std::cout&lt;&lt;"Koliko zelite kreirati trouglova: ";
    std::cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++){
        std::cout&lt;&lt;"Unesite podatke za "&lt;&lt;i+1&lt;&lt;". trougao (x1 y1 x2 y2 x3 y3): ";
       std::cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3;
       t1=std::make_pair(x1,y1);
       t2=std::make_pair(x2,y2);
       t3=std::make_pair(x3,y3);
       try{
           vektor.emplace_back(std::make_shared&lt;Trougao&gt;(Trougao(t1,t2,t3)));
       }
       catch(std::domain_error){
           std::cout&lt;&lt;"Nekorektne pozicije tjemena, ponovite unos";
           --i;
       }
    }
    double dx,dy,ugao,fakt;
    std::cout&lt;&lt;"Unesite vektor translacije (dx dy): ";
    std::cin&gt;&gt;dx&gt;&gt;dy;
    std::cout&lt;&lt;"Unesite ugao rotacije: ";
    std::cin&gt;&gt;ugao;
    std::cout&lt;&lt;"Unesite faktor skaliranja: ";
    std::cin&gt;&gt;fakt;
    
    std::cout&lt;&lt;"Trouglovi nakon obavljenih transformacija: ";
    std::vector&lt;std::shared_ptr&lt;Trougao&gt;&gt; vektor2(n),vektor3(n),vektor4(n);
    std::transform(vektor.begin(),vektor.end(),vektor2.begin(),[dx,dy](std::shared_ptr&lt;Trougao&gt; vektor)/*-&gt;(std::shared_ptr&lt;Trougao&gt; )*/{ (*vektor).Transliraj(dx,dy); return vektor;});
    std::transform(vektor2.begin(),vektor2.end(),vektor3.begin(),[ugao](std::shared_ptr&lt;Trougao&gt; vektor2){(*vektor2).Rotiraj((*vektor2).DajCentar(),ugao);return vektor2;});
    std::transform(vektor3.begin(),vektor3.end(),vektor4.begin(),[fakt](std::shared_ptr&lt;Trougao&gt; vektor3){(*vektor3).Skaliraj((*vektor3).DajTjeme(1),fakt); return vektor3;});
    std::sort(vektor4.begin(),vektor4.end(),[](std::shared_ptr&lt;Trougao&gt; t1,std::shared_ptr&lt;Trougao&gt; t2){return t1-&gt;DajPovrsinu()&lt;t2-&gt;DajPovrsinu();});
    std::cout&lt;&lt;std::endl;
    std::for_each(vektor4.begin(),vektor4.end(),[](std::shared_ptr&lt;Trougao&gt;t){t-&gt;Ispisi(); std::cout&lt;&lt;"\n";});
    
    
    std::cout&lt;&lt;"Trougao sa najmanjim obimom: ";
    (*std::min_element(vektor4.begin(),vektor4.end(),[](std::shared_ptr&lt;Trougao&gt; t1,std::shared_ptr&lt;Trougao&gt; t2){
        return t1-&gt;DajObim()&lt;t2-&gt;DajObim();}))-&gt;Ispisi();
        std::vector&lt;std::pair&lt;Trougao,Trougao&gt;&gt; identicni,podudarni,slicni;
        std::cout&lt;&lt;std::endl;
        for(int i=0;i&lt;n;i++)
        {
            for(int j=0;j&lt;n;j++)
            {
                if(i!=j)
                {
                    if(DaLiSuIdenticni(*vektor4[i],*vektor4[j]))
                    {
                        if(!DaLiSeNalaziUVektoru(identicni,std::make_pair(*vektor4[i],*vektor4[j])))
                            {
                                identicni.push_back(std::make_pair(*vektor4[j],*vektor4[i]));
                            }
                    }
                    if(DaLiSuPodudarni(*vektor4[i],*vektor4[j]))
                    {
                        if(!DaLiSeNalaziUVektoru(podudarni,std::make_pair(*vektor4[i],*vektor4[j])))
                            {
                                podudarni.push_back(std::make_pair(*vektor4[j],*vektor4[i]));
                            }
                    }
                     if(DaLiSuSlicni(*vektor4[i],*vektor4[j]))
                    {
                        if(!DaLiSeNalaziUVektoru(slicni,std::make_pair(*vektor4[i],*vektor4[j])))
                            {
                                slicni.push_back(std::make_pair(*vektor4[j],*vektor4[i]));
                            }
                    }
                }
            }
        }
        if((int)identicni.size()==0)
        {
            std::cout&lt;&lt;"Nema identicnih trouglova!\n";
        }
        else
        {
            std::cout&lt;&lt;"Parovi identicnih trouglova: \n";
            std::for_each(identicni.begin(),identicni.end(),[](std::pair&lt;Trougao,Trougao&gt; p)
            {
               p.second.Ispisi();
               std::cout&lt;&lt;" i ";
               p.first.Ispisi();
               std::cout&lt;&lt;"\n";
                
            });
        }
        if((int)podudarni.size()==0)
        {
            std::cout&lt;&lt;"Nema podudarnih trouglova!\n";
        }
        else
        {
            std::cout&lt;&lt;"Parovi podudarnih trouglova: \n";
            std::for_each(podudarni.begin(),podudarni.end(),[](std::pair&lt;Trougao,Trougao&gt; p)
            {
               p.second.Ispisi();
               std::cout&lt;&lt;" i ";
               p.first.Ispisi();
               std::cout&lt;&lt;"\n";
                
            });
        }
        if((int)slicni.size()==0)
        {
            std::cout&lt;&lt;"Nema slicnih trouglova!\n";
        }
        else
        {
            std::cout&lt;&lt;"Parovi slicnih trouglova: \n";
            std::for_each(slicni.begin(),slicni.end(),[](std::pair&lt;Trougao,Trougao&gt; p)
            {
               p.second.Ispisi();
               std::cout&lt;&lt;" i ";
               p.first.Ispisi();
               std::cout&lt;&lt;"\n";
                
            });
        }
    
        /*
        for(int i=0;i&lt;n;i++)
            for(int j=i+1;j&lt;n;j++)
                if(DaLiSuIdenticni(*vektor4[i],*vektor4[j]))
                    identicni.push_back(std::make_pair(i+1,j+1));
                    if(identicni.size()==0) std::cout&lt;&lt;"Nema identicnih trouglova";
                    else {
                        std::cout&lt;&lt;"Parovi identicnih trouglova: ";
                        for(auto &amp;par:identicni){
                           // std::cout&lt;&lt;par.Ispisi();
                        }
                        for(int i=0;i&lt;identicni.size();i++){
                            std::cout&lt;&lt;"("&lt;&lt;identicni[i].first&lt;&lt;","&lt;&lt;identicni[i].second&lt;&lt;")";
                             std::cout&lt;&lt;" i ";
                        }
                   
          //  }*/
        
	return 0;
</font>}</pre>
</body>
</html>
