<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student7678.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student7678.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;cmath&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;

using std::cin;
using std::cout;
using std::endl;
using std::pair;
using std::range_error;
using std::domain_error;
using std::sqrt;
using std::acos;
using std::abs;
using std::cos;
using std::sin;
using std::fabs;
using std::vector;
using std::make_pair;
using std::shared_ptr;
using std::make_shared;
using std::transform;
using std::sort;
using std::for_each;
using std::min_element;

typedef std::pair&lt;double, double&gt; Tacka;

double TestOrijentacije  (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
        return (t1.first*(t2.second - t3.second) - t2.first*(t1.second - t3.second) + t3.first*(t1.second - t2.second));
        
    }
    
    void TestIndeksa(int indeks)  {
        if(indeks &lt; 1 || indeks &gt; 3)
        throw range_error("Nekorektan indeks!");
    }
    
    double DuzinaStranice (const Tacka &amp;t1, const Tacka &amp;t2){
        return sqrt((t1.first-t2.first)*(t1.first-t2.first)+(t1.second-t2.second)*(t1.second-t2.second));
    }
    
    Tacka Teziste (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
        
        Tacka centar;
        centar.first = (t1.first + t2.first + t3.first)/3;
        centar.second = (t1.second + t2.second + t3.second)/3;
        
        return centar;
        
    }
    
bool UporediRealne(double x, double y){
    const double eps(1e-10);
    if(fabs(x-y) &lt;= eps*(fabs(x)+fabs(y)))return 1;
    return 0;
}

class Trougao{
    Tacka m[3];
    
    
    
   
    public:
    Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
        
        int tmp;
        tmp = TestOrijentacije(t1,t2,t3);
        if(UporediRealne(tmp,0))throw domain_error("Nekorektne pozicije tjemena");
        
        m[0] = t1; 
        m[1] = t2;
        m[2] = t3;
        
    }
    
    void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
        int tmp;
        tmp = TestOrijentacije(t1,t2,t3);
        if(UporediRealne(tmp,0))throw domain_error("Nekorektne pozicije tjemena");
        
        m[0] = t1; 
        m[1] = t2;
        m[2] = t3;
        
    }
    
    void Postavi(int indeks, const Tacka &amp;t){
        TestIndeksa(indeks);
        const double eps(1e-10);

        if(fabs(indeks)&lt;=eps*fabs(indeks)){
            double x = TestOrijentacije(m[1],m[2],t);
            if(fabs(x) &lt;= eps*fabs(x))throw domain_error("Nekorektne pozicije tjemena");
        }
        //fabs(x-y) &lt;= eps*(fabs(x)+fabs(y))
         if(fabs(indeks-1) &lt;= eps*(fabs(indeks)+fabs(1))){
             double x = TestOrijentacije(m[0],m[2],t);
            if(fabs(x) &lt;= eps*fabs(x))throw domain_error("Nekorektne pozicije tjemena");
        }
        
         if(fabs(indeks-2) &lt;= eps*(fabs(indeks)+fabs(2))){
             double x = TestOrijentacije(m[1],m[0],t);
            if(fabs(x) &lt;= eps*fabs(x))throw domain_error("Nekorektne pozicije tjemena");
        }
        
        
        m[indeks-1] = t;
        
    }
    
    static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
         double tmp;
         tmp = TestOrijentacije(t1,t2,t3);
        if(tmp&gt;0)return 1;
        else if(tmp&lt;0)return -1;
        else if(UporediRealne(tmp,0))return 0;
    }
    
    Tacka DajTjeme(int indeks) const{ return m[indeks-1];}
    
    double DajStranicu(int indeks) const{
        TestIndeksa(indeks);
        if(indeks-1 == 0)return DuzinaStranice(m[1],m[2]);
        else if(indeks-1 == 1) return DuzinaStranice(m[0],m[2]);
        else if(indeks-1==2)return DuzinaStranice(m[0],m[1]);
    }
    
    double DajUgao(int indeks) const{
        TestIndeksa(indeks);
        double a = DuzinaStranice(m[1],m[2]);
        double b = DuzinaStranice(m[0],m[2]);
        double c = DuzinaStranice(m[0],m[1]);
        
        if(indeks-1 == 0) return acos((b*b+c*c-a*a)/(2*c*b));
        else if(indeks-1 == 1) return acos((a*a+c*c-b*b)/(2*a*c));
        else if(indeks-1 == 2) return acos((a*a+b*b-c*c)/(2*a*b));
    }
    
    Tacka DajCentar() const{
        return Teziste(m[0],m[1],m[2]);
    }
    
    double DajObim() const{
        double a = DuzinaStranice(m[1],m[2]);
        double b = DuzinaStranice(m[0],m[2]);
        double c = DuzinaStranice(m[0],m[1]);
        
        return a+b+c;
    }
    
    double DajPovrsinu() const{
        double tmp = TestOrijentacije(m[0],m[1],m[2]);
        return (1./2)*abs(tmp);
    }
    
    bool DaLiJePozitivnoOrijentiran() const{
        double tmp = TestOrijentacije(m[0],m[1],m[2]);
        if(tmp&gt;0)return 1;
        return 0;
    }
    
    bool DaLiJeUnutra(const Tacka &amp;t) const{
        double uslov1 = TestOrijentacije(m[0], m[1], m[2]);
        double uslov2 = TestOrijentacije(m[0], m[1], t);
        double uslov3 = TestOrijentacije(m[1], m[2], t);
        double uslov4 = TestOrijentacije(m[2], m[0], t);
        
        if((uslov1&gt;0 &amp;&amp; uslov2&gt;0 &amp;&amp; uslov3&gt;0 &amp;&amp; uslov4&gt;0)||(uslov1&lt;0 &amp;&amp; uslov2&lt;0 &amp;&amp; uslov3&lt;0 &amp;&amp; uslov4&lt;0))return true;
        return false;
    }


<a name="1"></a><font color="#00FF00"><a href="match855-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    void Ispisi() const{
        cout&lt;&lt;"(("&lt;&lt;m[0].first&lt;&lt;","&lt;&lt;m[0].second&lt;&lt;"),("&lt;&lt;m[1].first&lt;&lt;","&lt;&lt;m[1].second&lt;&lt;"),("&lt;&lt;m[2].first&lt;&lt;","&lt;&lt;m[2].second&lt;&lt;"))";
</font>    }
    
    void Transliraj(double delta_x, double delta_y){
        m[0].first = m[0].first+delta_x;
        m[1].first = m[1].first+delta_x;
        m[2].first = m[2].first+delta_x;
        
        m[0].second = m[0].second+delta_y;
        m[1].second = m[1].second+delta_y;
        m[2].second = m[2].second+delta_y;
        
    }
    
    void Centriraj(const Tacka &amp;t){
        Tacka centar;
        centar = Teziste(m[0],m[1],m[2]);
        double delta_x = t.first - centar.first;
        double delta_y = t.second - centar.second;
        
        m[0].first = m[0].first+delta_x;
        m[1].first = m[1].first+delta_x;
        m[2].first = m[2].first+delta_x;
        
        m[0].second = m[0].second+delta_y;
        m[1].second = m[1].second+delta_y;
        m[2].second = m[2].second+delta_y;
        
    }
    
<a name="0"></a><font color="#FF0000"><a href="match855-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

    void Rotiraj(const Tacka &amp;t, double ugao){
        
        m[0].first =  t.first + (m[0].first - t.first)*cos(ugao) - (m[0].second - t.second)*sin(ugao);
        m[0].second = t.second + (m[0].first - t.first)*sin(ugao) + (m[0].second - t.second)*cos(ugao);
        
        m[1].first =  t.first + (m[1].first - t.first)*cos(ugao) - (m[1].second - t.second)*sin(ugao);
        m[1].second = t.second + (m[1].first - t.first)*sin(ugao) + (m[1].second - t.second)*cos(ugao);
        
        m[2].first =  t.first + (m[2].first - t.first)*cos(ugao) - (m[2].second - t.second)*sin(ugao);
        m[2].second = t.second + (m[2].first - t.first)*sin(ugao) + (m[2].second - t.second)*cos(ugao);
    
    }
    
    void Skaliraj(const Tacka &amp;t, double faktor){
</font>        

        if(UporediRealne(faktor,0))throw domain_error("Nekorektan faktor skaliranja");
        
<a name="2"></a><font color="#0000FF"><a href="match855-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

        m[0].first = t.first + faktor*(m[0].first - t.first);
        m[0].second = t.second + faktor*(m[0].second - t.second);
</font>        
        m[1].first = t.first + faktor*(m[1].first - t.first);
        m[1].second = t.second + faktor*(m[1].second - t.second);
        
<a name="3"></a><font color="#00FFFF"><a href="match855-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

        m[2].first = t.first + faktor*(m[2].first - t.first);
        m[2].second = t.second + faktor*(m[2].second - t.second);
        
    }
    
    void Rotiraj(double ugao){
</font>        
        Tacka t = DajCentar();
        Tacka d1,d2,d3;
        d1.first = m[0].first;
        d1.second = m[0].second;
        m[0].first =  t.first + (d1.first - t.first)*cos(ugao) - (d1.second - t.second)*sin(ugao);
        m[0].second = t.second + (d1.first - t.first)*sin(ugao) + (d1.second - t.second)*cos(ugao);
        
        d2.first = m[1].first;
        d2.second = m[1].second;
        m[1].first =  t.first + (d2.first - t.first)*cos(ugao) - (d2.second - t.second)*sin(ugao);
        m[1].second = t.second + (d2.first - t.first)*sin(ugao) + (d2.second - t.second)*cos(ugao);
        
         d3.first = m[2].first;
        d3.second = m[2].second;
        m[2].first =  t.first + (d3.first - t.first)*cos(ugao) - (d3.second - t.second)*sin(ugao);
        m[2].second = t.second + (d3.first - t.first)*sin(ugao) + (d3.second - t.second)*cos(ugao);
    
    }
    
    void Skaliraj(double faktor){
        
        Tacka t = DajCentar();
        
        m[0].first = t.first + faktor*(m[0].first - t.first);
        m[0].second = t.second + faktor*(m[0].second - t.second);
        
        m[1].first = t.first + faktor*(m[1].first - t.first);
        m[1].second = t.second + faktor*(m[1].second - t.second);
        
        m[2].first = t.first + faktor*(m[2].first - t.first);
        m[2].second = t.second + faktor*(m[2].second - t.second);
        
    }
    
    friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2){
        int brojac = 0;
        for(int i=0; i&lt;3; i++){
            for(int j=0; j&lt;3; j++){
               
                if((UporediRealne(t1.m[i].first, t2.m[j].first))&amp;&amp;(UporediRealne(t1.m[i].second, t2.m[j].second)))brojac++;
        }
        
        
    }
    
    if(brojac == 3)return true;
        return false;
    }
    
    friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2){
        vector&lt;pair&lt;double,double&gt;&gt; ugstr1(3),ugstr2(3);//par ugao stranica, podudarni isti im ugl i str
        
        if(DaLiSuIdenticni(t1,t2))return 1;
        
        for(int i=0; i&lt;3; i++){
            ugstr1[i] = make_pair(t1.DajStranicu(i+1),t1.DajUgao(i+1));
            ugstr2[i] = make_pair(t2.DajStranicu(i+1),t2.DajUgao(i+1));
        }
        //Provjera da li je trougao jkk ili jdstr
        bool jkk = 0;
        for(int i=0; i&lt;3; i++){
            int brojac = 0;
            for(int j=0; j&lt;3; j++){
                if((UporediRealne(ugstr1[i].first,ugstr2[j].first))&amp;&amp;(UporediRealne(ugstr1[i].second,ugstr2[j].second)))brojac++;
            }
            if(brojac&gt;=2){jkk = 1;break;}
            else continue;
        }
        
        if(jkk){
            
            int brojac = 0;
        for(int i=0; i&lt;3; i++){
            for(int j=0; j&lt;ugstr2.size(); j++){
                
                if((UporediRealne(ugstr1[i].first,ugstr2[j].first))&amp;&amp;(UporediRealne(ugstr1[i].second,ugstr2[j].second))){
                    brojac++;
                    
                    ugstr2.erase(ugstr2.begin()+j);
                    j--;
                }
            }
        }
        
        if(brojac == 3)return true;
        else return false;
            
        }
        else if(!jkk){
        
        //Pamcenje indeksa
        vector&lt;int&gt; zapamti;
        for(int i=0; i&lt;3; i++){
            for(int j=0; j&lt;3; j++){
                if((UporediRealne(ugstr1[i].first,ugstr2[j].first))&amp;&amp;(UporediRealne(ugstr1[i].second,ugstr2[j].second))){
                    zapamti.push_back(j);
                }
            }
        }
        
        int brojac = 0;
        for(int i=0; i&lt;3; i++){
            for(int j=0; j&lt;ugstr2.size(); j++){
                
                if((UporediRealne(ugstr1[i].first,ugstr2[j].first))&amp;&amp;(UporediRealne(ugstr1[i].second,ugstr2[j].second))){
                    brojac++;
                    
                    ugstr2.erase(ugstr2.begin()+j);
                    j--;
                }
            }
        }
        
        if(brojac == 3){
            int x = Orijentacija(t1.m[0],t1.m[1],t1.m[2]);
            int y = Orijentacija(t2.m[zapamti[0]], t2.m[zapamti[1]], t2.m[zapamti[2]]);
            if(x==y)return true;
            else return false;
        }
        else return false;
        
        }
    }
    
    friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2){
        //slicni isti im ugl
        
            if(DaLiSuIdenticni(t1,t2))return 1;
            vector&lt;double&gt; uglovi1(3),uglovi2(3);
            
            for(int i=0; i&lt;3; i++){
                uglovi1[i] = t1.DajUgao(i+1);
                uglovi2[i] = t2.DajUgao(i+1);
            }
            
            bool jkk = 0;
        for(int i=0; i&lt;3; i++){
            int brojac = 0;
            for(int j=0; j&lt;3; j++){
                if((UporediRealne(uglovi1[i],uglovi2[j])))brojac++;
            }
            if(brojac&gt;=2){jkk = 1;break;}
            else continue;
        }
        
        if(jkk){
            
            int brojac = 0;
            for(int i=0; i&lt;3; i++){
                for(int j=0; j&lt;uglovi2.size(); j++){
                    
                    if(UporediRealne(uglovi1[i],uglovi2[j])){
                        brojac++;
                        
                        uglovi2.erase(uglovi2.begin()+j);
                        
                        j--;
                    }
                }
            }
            
            
        
        if(brojac == 3)return true;
        else return false;
            
            
        }
        else{
            
            vector&lt;int&gt; zapamti;
        for(int i=0; i&lt;3; i++){
            for(int j=0; j&lt;3; j++){
                if((UporediRealne(uglovi1[i],uglovi2[j]))){
                    zapamti.push_back(j);
                }
            }
        }
            
            int brojac =0;
            for(int i=0; i&lt;3; i++){
                for(int j=0; j&lt;uglovi2.size(); j++){
                    
                    if(UporediRealne(uglovi1[i],uglovi2[j])){
                        brojac++;
                        
                        uglovi2.erase(uglovi2.begin()+j);
                        
                        j--;
                    }
                }
            }
            
            if(brojac == 3){
                int x = Orijentacija(t1.m[0],t1.m[1],t1.m[2]);
            int y = Orijentacija(t2.m[zapamti[0]], t2.m[zapamti[1]], t2.m[zapamti[2]]);
            if(x==y)return true;
            else return false;
            }
            else return false;
        
        }
        
    }

    

    
};
int main ()
{
     try{   
        cout&lt;&lt;"Koliko zelite kreirati trouglova: ";
        int n;
        cin&gt;&gt;n;
        
        vector&lt;shared_ptr&lt;Trougao&gt;&gt; v;
        
        for(int i=0; i&lt;n; i++){
            cout&lt;&lt;"Unesite podatke za "&lt;&lt;i+1&lt;&lt;". trougao (x1 y1 x2 y2 x3 y3): ";
            double x1, y1, x2, y2, x3, y3;
            cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3;
            Tacka t1 = make_pair(x1,y1);
            Tacka t2 = make_pair(x2,y2);
            Tacka t3 = make_pair(x3,y3);
            shared_ptr&lt;Trougao&gt; p;
            try{
                p = make_shared&lt;Trougao&gt;(t1,t2,t3);
                
            }
            catch(domain_error e){
                cout&lt;&lt;e.what()&lt;&lt; ", ponovite unos!" &lt;&lt;endl;
                i--;
                continue;
            }
            v.push_back(p);
            
        }
        
        cout&lt;&lt;"Unesite vektor translacije (dx dy): ";
        double dx, dy; cin&gt;&gt;dx&gt;&gt;dy;
        
        transform(v.begin(), v.begin()+n, v.begin(), [dx,dy](shared_ptr&lt;Trougao&gt; a){ (*a).Transliraj(dx,dy); return a;});
        
        cout&lt;&lt;"Unesite ugao rotacije: ";
        double ugao; cin&gt;&gt;ugao; 
        
        transform(v.begin(), v.begin()+n,v.begin(), [ugao](shared_ptr&lt;Trougao&gt; a){ (*a).Rotiraj(ugao);return a;});
       
        
        cout&lt;&lt;"Unesite faktor skaliranja: ";
        double faktor; cin&gt;&gt;faktor;
         transform(v.begin(), v.begin()+n,v.begin(), [faktor](shared_ptr&lt;Trougao&gt; a){(*a).Skaliraj((*a).DajTjeme(1),faktor);return a;});
         
         sort(v.begin(), v.begin()+n, [](shared_ptr&lt;Trougao&gt; a, shared_ptr&lt;Trougao&gt; b){
             if((*a).DajPovrsinu()&lt;(*b).DajPovrsinu())return 1; else return 0;});
             
             cout&lt;&lt;"Trouglovi nakon obavljenih transformacija: "&lt;&lt;endl;
        for_each(v.begin(), v.begin()+n, [](shared_ptr&lt;Trougao&gt; a){(*a).Ispisi(); cout&lt;&lt;endl;});
        
        
        cout&lt;&lt;"Trougao sa najmanjim obimom: ";
       auto p =  min_element(v.begin(), v.begin()+n, [](shared_ptr&lt;Trougao&gt; a,shared_ptr&lt;Trougao&gt; b){return (*a).DajObim()&lt;(*b).DajObim();});
        
        (*p)-&gt;Ispisi();
        
        cout&lt;&lt;endl;
        int brojac =0;
        for(int i=0; i&lt;n-1; i++){
            for(int j=i+1; j&lt;n; j++){
                if(DaLiSuIdenticni(*v[i],*v[j])){ brojac++;}
            }
        }
        
        
        if(brojac==0)cout&lt;&lt;"Nema identicnih trouglova!"&lt;&lt;endl;
        else{
            cout&lt;&lt;"Parovi identicnih trouglova: "&lt;&lt;endl;
        
        brojac=0;
         for(int i=0; i&lt;n-1; i++){
            for(int j=i+1; j&lt;n; j++){
                if(DaLiSuIdenticni(*v[i],*v[j])){(*v[i]).Ispisi(); cout&lt;&lt;" i "; (*v[j]).Ispisi();cout&lt;&lt;endl; brojac++;}
            }
        }
            
        }
        
        brojac=0;
         for(int i=0; i&lt;n-1; i++){
            for(int j=i+1; j&lt;n; j++){
                if(DaLiSuPodudarni(*v[i],*v[j])){brojac++;}
            }
        }
        
        if(brojac==0)cout&lt;&lt;"Nema podudarnih trouglova!"&lt;&lt;endl;
        else{
            cout&lt;&lt;"Parovi podudarnih trouglova: "&lt;&lt;endl;
         brojac=0;
         for(int i=0; i&lt;n-1; i++){
            for(int j=i+1; j&lt;n; j++){
                if(DaLiSuPodudarni(*v[i],*v[j])){(*v[i]).Ispisi(); cout&lt;&lt;" i "; (*v[j]).Ispisi();cout&lt;&lt;endl; brojac++;}
            }
        }
            
        }
        
        
        brojac=0;
         for(int i=0; i&lt;n-1; i++){
            for(int j=i+1; j&lt;n; j++){
                if(DaLiSuSlicni(*v[i],*v[j])){brojac++;}
            }
        }
        
        if(brojac==0)cout&lt;&lt;"Nema slicnih trouglova!"&lt;&lt;endl;
        else{
            cout&lt;&lt;"Parovi slicnih trouglova: "&lt;&lt;endl;
         brojac=0;
         for(int i=0; i&lt;n-1; i++){
            for(int j=i+1; j&lt;n; j++){
                if(DaLiSuSlicni(*v[i],*v[j])){(*v[i]).Ispisi(); cout&lt;&lt;" i "; (*v[j]).Ispisi();cout&lt;&lt;endl; brojac++;}
            }
        }
            
        }
     }
     catch(domain_error e){
         cout&lt;&lt;e.what();
         
     }
     catch(range_error t){
         cout&lt;&lt;t.what();
     } 
    
    
    
	return 0;
}</pre>
</body>
</html>
