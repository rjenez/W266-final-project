<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student4770.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student4770.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;
const double Eps(1e-10);
typedef std::pair&lt;double, double&gt; Tacka;
bool epsilon(double x, double y);
class Trougao {
    Tacka t1, t2, t3;
    static void PozicijaTjemena(Tacka t1, Tacka t2, Tacka t3) {
        if(Orijentacija(t1, t2, t3) == 0) throw std::domain_error("Nekorektne pozicije tjemena");
    }
    void KakavJeIndeks(int indeks) const {
        if(indeks != 1 &amp;&amp; indeks &amp;&amp; 2 &amp;&amp; indeks != 3) throw std::range_error("Nekorektan indeks");
    }
    static double DuzinaStranice(Tacka t1, Tacka t2)  {
        int a = std::sqrt(std::pow((t1.first - t2.first), 2) + std::pow((t1.second - t2.second), 2));
        return a;
    }
    static double Ugao(Tacka trazena, Tacka prva, Tacka druga)  {
        double a = DuzinaStranice(trazena, prva);
        double b = DuzinaStranice(trazena, druga);
        double c = DuzinaStranice(prva, druga);
        return std::acos((a*a + b*b - c*c)/(2*a*b));
    }
    static bool Jednakokraki(const Trougao &amp;t1);
    static double Izraz(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
        return t1.first*(t2.second - t3.second) - t2.first*(t1.second - t3.second) + t3.first*(t1.second - t2.second);
    }
    Tacka Teziste() {
        Tacka t;
        t.first = (t1.first + t2.first + t3.first)/3.;
        t.second = (t1.second + t2.second + t3.second)/3.;
        return t;
    }
    Tacka rotacija(Tacka &amp;t, Tacka x, double ugao) {
        Tacka a;
        a.first = x.first + (t.first - x.first)*std::cos(ugao) - (t.second - x.second)*std::sin(ugao);
        a.second = x.second + (t.first - x.first)*std::sin(ugao) + (t.second - x.second)*std::cos(ugao);
        return a;
    }
    void skaliranje(Tacka &amp;t, Tacka T, double k) {
        t.first = T.first + k*(t.first - T.first);
        t.second = T.second + k*(t.second - T.second);
    }
    public:
    Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
        PozicijaTjemena(t1, t2, t3);
        this-&gt;t1 = t1; this-&gt;t2 = t2; this-&gt;t3 = t3;
    }
    void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
        PozicijaTjemena(t1, t2, t3);
        this-&gt;t1 = t1; this-&gt;t2 = t2; this-&gt;t3 = t3;
    }
    void Postavi(int indeks, const Tacka &amp;t) {
        KakavJeIndeks(indeks);
        switch(indeks) {
            case 1: this-&gt;t1 = t; break;
            case 2: this-&gt;t2 = t; break;
            case 3: this-&gt;t3 = t; break;
        }
        PozicijaTjemena(t1, t2, t3);
    }
    static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
        double x = Izraz(t1, t2, t3);
        if(x &lt; -Eps) return -1;
        if(x &gt; Eps) return 1;
        return 0;
    }
    Tacka DajTjeme(int indeks) const {
        KakavJeIndeks(indeks);
        switch(indeks) {
            case 1: return t1; 
            case 2: return t2; 
            case 3: return t3;
        }
    }
    double DajStranicu(int indeks) const {
        KakavJeIndeks(indeks);
        switch(indeks) {
            case 1: return DuzinaStranice(t2, t3);
            case 2: return DuzinaStranice(t1, t3);
            case 3: return DuzinaStranice(t1, t2);
        }
    }
    double DajUgao(int indeks) const {
        KakavJeIndeks(indeks);
        switch(indeks) {
            case 1: return Ugao(t1, t2, t3); 
            case 2: return Ugao(t2, t1, t3);
            case 3: return Ugao(t3, t1, t2);
        }
    }
    Tacka DajCentar() const {
        return { (t1.first + t2.first + t3.first) / 3., (t1.second + t2.second + t3.second)/3. };
    }
    double DajObim() const {
        return DuzinaStranice(t1, t2) + DuzinaStranice(t1, t3) + DuzinaStranice(t2, t3);
    }
    double DajPovrsinu() const {
        return std::abs(Izraz(t1, t2, t3))/2.;
    }
    bool DaLiJePozitivnoOrijentiran() const {
        return Orijentacija(t1, t2, t3);
    }
    bool DaLiJeUnutra(const Tacka &amp;t) const {
<a name="7"></a><font color="#0000FF"><a href="match502-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

        if(Orijentacija(t1, t2, t3) == Orijentacija(t1, t2, t) == Orijentacija(t2, t3, t) == Orijentacija(t3, t1, t)) return true;
        return false;
    }
    void Ispisi() const {
        std::cout&lt;&lt;"(("&lt;&lt;t1.first&lt;&lt;","&lt;&lt;t1.second&lt;&lt;"),("&lt;&lt;t2.first&lt;&lt;","&lt;&lt;t2.second&lt;&lt;"),("&lt;&lt;t3.first&lt;&lt;","&lt;&lt;t3.second&lt;&lt;"))";
</font>    }
    void Transliraj(double delta_x, double delta_y) {
        t1.first += delta_x; t1.second += delta_y;
        t2.first += delta_x; t2.second += delta_y;
        t3.first += delta_x; t3.second += delta_y;
    }
    void Centriraj(const Tacka &amp;t);
    void Rotiraj(const Tacka &amp;t, double ugao);
    void Skaliraj(const Tacka &amp;t, double faktor);
    void Rotiraj(double ugao);
    void Skaliraj(double faktor);
    friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);

};
void Trougao::Centriraj(const Tacka &amp;t)
{
    Tacka staroT(this-&gt;Teziste());
    double x, y;
    x = t.first - staroT.first; y = t.second - staroT.second;
    t1.first += x; t1.second += y;
    t2.first += x; t2.second += y;
    t3.first += x; t3.second += y;
}
<a name="8"></a><font color="#00FFFF"><a href="match502-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

void Trougao::Rotiraj(const Tacka &amp;t, double ugao)
{
    t1 = rotacija(t1, t, ugao);
    t2 = rotacija(t2, t, ugao);
    t3 = rotacija(t3, t, ugao);
</font>}
void Trougao::Skaliraj(const Tacka&amp;t, double faktor)
{
    if(epsilon(faktor, 0)) throw std::domain_error("Nekorektan faktor skaliranja");
    skaliranje(t1, t, faktor);
    skaliranje(t2, t, faktor);
    skaliranje(t3, t, faktor);
}
void Trougao::Rotiraj(double ugao)
{
    Tacka t(Teziste());
    Rotiraj(t, ugao);
}
void Trougao::Skaliraj(double faktor)
{
    if(epsilon(faktor, 0)) throw std::domain_error("Nekorektan faktor skaliranja");
    Tacka t(this-&gt;Teziste());
    skaliranje(t1, t, faktor);
    skaliranje(t2, t, faktor);
    skaliranje(t3, t, faktor);
}
bool Jednakost (std::vector&lt;Tacka&gt; niz, std::vector&lt;Tacka&gt; drugi)
{
    int a(-1), b(-1), c(-1);
    for(int i = 0; i &lt; 3; i++)
    {
        for(int j = 0; j &lt; 3; j++)
        {
            if(j == a) continue;
            if(j == b) continue;
            if(j == c) continue;
            if(std::abs(niz[0].first - drugi[j].first) &lt;= Eps &amp;&amp; std::abs(niz[0].second - drugi[j].second) &lt;= Eps)  { a = j; continue; }
            else if(std::abs(niz[1].first - drugi[j].first) &lt;= Eps &amp;&amp; std::abs(niz[1].second - drugi[j].second) &lt;= Eps) { b = j; continue; }
            else if(std::abs(niz[2].first - drugi[j].first) &lt;= Eps &amp;&amp; std::abs(niz[2].second - drugi[j].second) &lt;= Eps) { c = j; continue; }
        }
    }
    if(a &gt;= 0  &amp;&amp; b &gt;= 0 &amp;&amp; c &gt;= 0) return true;
    return false;
}
template &lt;typename Tip&gt;
bool Jednakost2 (std::vector&lt;Tip&gt; niz, std::vector&lt;Tip&gt;drugi)
{
    int a(-1), b(-1), c(-1);
    for(int i = 0; i &lt; 3; i++)
    {
        for(int j = 0; j &lt; 3; j++)
        {
            if(j == a) continue;
            if(j == b) continue;
            if(j == c) continue;
            if(std::abs(niz[0] - drugi[j]) &lt;= Eps) { a = j; continue; }
            else if(std::abs(niz[1] - drugi[j]) &lt;= Eps) { b = j; continue; }
            else if(std::abs(niz[2] - drugi[j]) &lt;= Eps) { c = j; continue; }
        }
    } if(a &gt;= 0 &amp;&amp; b &gt;= 0 &amp;&amp; c &gt;= 0) return true;
    return false;
}
bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2)
{
    std::vector&lt;Tacka&gt;prvi { t1.t1, t1.t2, t1.t3 };
    std::vector&lt;Tacka&gt; drugi { t2.t1, t2.t2, t2.t3 };
    return Jednakost(prvi, drugi);
}
bool epsilon(double x, double y)
{
    return std::abs(x - y) &lt; Eps;
}
bool Trougao::Jednakokraki(const Trougao &amp;t1)
{
    std::vector&lt;double&gt;v { t1.DuzinaStranice(t1.t1, t1.t2), t1.DuzinaStranice(t1.t1, t1.t3), t1.DuzinaStranice(t1.t2, t1.t3) };
    bool jednakokrako = false;
    if(epsilon(v[0], v[1]) || epsilon(v[0], v[2]) || epsilon(v[1], v[2])) jednakokrako = true;
    return jednakokrako;
    
}
bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2)
{
    std::vector&lt;double&gt; prvi { t1.DuzinaStranice(t1.t1, t1.t2), t1.DuzinaStranice(t1.t1, t1.t3), t1.DuzinaStranice(t1.t2, t1.t3) };
    std::vector&lt;double&gt; drugi { t2.DuzinaStranice(t2.t1, t2.t2), t2.DuzinaStranice(t2.t1, t2.t3), t2.DuzinaStranice(t2.t2, t2.t3) };
    if(!Jednakost2(prvi, drugi)) return false;
    if(epsilon(prvi[0], prvi[1]) &amp;&amp; epsilon(prvi[1], prvi[2]) &amp;&amp; epsilon(prvi[2], drugi[0]) &amp;&amp; epsilon(drugi[0], drugi[1]) &amp;&amp; epsilon(drugi[1], drugi[2])) return true;
    if(Trougao::Jednakokraki(t1)) return true;
    auto pok = max_element(prvi.begin(), prvi.end());
    double stranica1 = *pok;
    std::vector&lt;Tacka&gt; najnoviji;
    std::vector&lt;Tacka&gt; korektor;
    if(epsilon(Trougao::DuzinaStranice(t1.t1, t1.t2), stranica1)) najnoviji.push_back(t1.t3);
    else if(epsilon(Trougao::DuzinaStranice(t1.t2, t1.t3), stranica1)) najnoviji.push_back(t1.t1);
    else  najnoviji.push_back(t1.t2);
    if(epsilon(Trougao::DuzinaStranice(t2.t1, t2.t2), stranica1)) korektor.push_back(t2.t3);
    else if(epsilon(Trougao::DuzinaStranice(t2.t2, t2.t3), stranica1)) korektor.push_back(t2.t1);
    else korektor.push_back(t2.t2);
    prvi.erase(pok);
    pok = max_element(prvi.begin(), prvi.end());
    stranica1 = *pok;
    if(epsilon(Trougao::DuzinaStranice(t1.t1, t1.t2), stranica1)) najnoviji.push_back(t1.t3);
    else if(epsilon(Trougao::DuzinaStranice(t1.t2, t1.t3), stranica1)) najnoviji.push_back(t1.t1);
    else najnoviji.push_back(t1.t2);
    if(epsilon(Trougao::DuzinaStranice(t2.t1, t2.t2), stranica1)) korektor.push_back(t2.t3);
    else if(epsilon(Trougao::DuzinaStranice(t2.t2, t2.t3), stranica1)) korektor.push_back(t2.t1);
    else korektor.push_back(t2.t2);
    prvi.erase(pok);
    stranica1 = prvi[0];
    if(epsilon(Trougao::DuzinaStranice(t1.t1, t1.t2), stranica1)) najnoviji.push_back(t1.t3);
    else if(epsilon(Trougao::DuzinaStranice(t1.t2, t1.t3), stranica1)) najnoviji.push_back(t1.t1);
    else najnoviji.push_back(t1.t2);
    if(epsilon(Trougao::DuzinaStranice(t2.t1, t2.t2), stranica1)) korektor.push_back(t2.t3);
    else if(epsilon(Trougao::DuzinaStranice(t2.t2, t2.t3), stranica1)) korektor.push_back(t2.t1);
    else korektor.push_back(t2.t2);
    if(Trougao::Orijentacija(najnoviji[0], najnoviji[1], najnoviji[2]) == Trougao::Orijentacija(korektor[0], korektor[1], korektor[2])) return true;
    return false;
}
bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2)
{
    std::vector&lt;double&gt; prvi { Trougao::Ugao(t1.t1, t1.t2, t1.t3), Trougao::Ugao(t1.t2, t1.t3, t1.t1), Trougao::Ugao(t1.t3, t1.t2, t1.t1) };
    std::vector&lt;double&gt; drugi { Trougao::Ugao(t2.t1, t2.t2, t2.t3), Trougao::Ugao(t2.t2, t2.t3, t2.t1), Trougao::Ugao(t2.t3, t2.t2, t2.t1) };
    Tacka a(t1.t1), b(t1.t2), c(t1.t3), A(t2.t1), B(t2.t2), C(t2.t3);
    if(epsilon(Trougao::DuzinaStranice(a, b), Trougao::DuzinaStranice(b, c)) &amp;&amp; epsilon(Trougao::DuzinaStranice(a, c), Trougao::DuzinaStranice(a, b)) &amp;&amp; epsilon(Trougao::DuzinaStranice(A, B), Trougao::DuzinaStranice(A, C))
        &amp;&amp; epsilon(Trougao::DuzinaStranice(A, B), Trougao::DuzinaStranice(B, C))) return true;
    std::sort(prvi.begin(), prvi.end());
    std::sort(drugi.begin(), drugi.end());
    if((epsilon(prvi[0], prvi[1]) &amp;&amp; epsilon(drugi[0], drugi[1]) &amp;&amp; epsilon(prvi[0], drugi[0])) || (epsilon(prvi[1], prvi[2]) &amp;&amp; epsilon(drugi[1], drugi[2]) &amp;&amp; epsilon(prvi[1], drugi[1]))
        || (epsilon(prvi[2], prvi[0]) &amp;&amp; epsilon(drugi[2], drugi[0]) &amp;&amp; epsilon(prvi[2], drugi[2]))) return true;
    if(!Jednakost2(prvi, drugi)) return false;
    std::vector&lt;Tacka&gt;najnoviji;
    std::vector&lt;Tacka&gt;korektor;
    for(int i = 0; i &lt; 3; i++)
    {
        if(epsilon(Trougao::Ugao(a, b, c), prvi[i])) najnoviji.push_back(a);
        else if(epsilon(Trougao::Ugao(c, a, b), prvi[i])) najnoviji.push_back(c);
        else najnoviji.push_back(b);
    }
    for(int i = 0; i &lt; 3; i++)
    {
        if(epsilon(Trougao::Ugao(A, B, C), drugi[i])) korektor.push_back(A);
        else if(epsilon(Trougao::Ugao(B, C, A), drugi[i])) korektor.push_back(B);
        else korektor.push_back(C);
    }
    if(Trougao::Orijentacija(najnoviji[0], najnoviji[1], najnoviji[2]) == Trougao::Orijentacija(korektor[0], korektor[1], korektor[2])) return true;
    return false;
}
int main ()
{
    int n;
    std::cout&lt;&lt;"Koliko zelite kreirati trouglova: ";
    std::cin&gt;&gt;n;
    std::vector&lt;std::shared_ptr&lt;Trougao&gt;&gt; trouglovi(n);
    for(int i = 0; i &lt; n; i++)
    {
        try {
<a name="3"></a><font color="#00FFFF"><a href="match502-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

            std::cout&lt;&lt;"Unesite podatke za "&lt;&lt;i+1&lt;&lt;". trougao (x1 y1 x2 y2 x3 y3): ";
            Tacka t1, t2, t3;
            std::cin&gt;&gt;t1.first&gt;&gt;t1.second&gt;&gt;t2.first&gt;&gt;t2.second&gt;&gt;t3.first&gt;&gt;t3.second;
</font><a name="6"></a><font color="#00FF00"><a href="match502-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

            trouglovi[i] = std::make_shared&lt;Trougao&gt; (t1, t2, t3);
        }
        catch(std::domain_error e) {
            std::cout&lt;&lt;e.what()&lt;&lt;", ponovite unos!"&lt;&lt;std::endl;
</font>            std::cout&lt;&lt;"Unesite podatke za "&lt;&lt;i+1&lt;&lt;". trougao (x1 y1 x2 y2 x3 y3): ";
            std::cin.clear(); std::cin.ignore(100000, '\n');
            Tacka t1, t2, t3;
            std::cin&gt;&gt;t1.first&gt;&gt;t1.second&gt;&gt;t2.first&gt;&gt;t2.second&gt;&gt;t3.first&gt;&gt;t3.second;
            trouglovi[i] = std::make_shared&lt;Trougao&gt;(t1, t2, t3);
        }
    }
    double dx, dy;
    std::cout&lt;&lt;"Unesite vektor translacije (dx dy): ";
    std::cin&gt;&gt;dx&gt;&gt;dy;
    std::cout&lt;&lt;"Unesite ugao rotacije: ";
    double ugao;
    std::cin&gt;&gt;ugao;
    std::cout&lt;&lt;"Unesite faktor skaliranja: ";
    double faktor;
    std::cin&gt;&gt;faktor;
    std::cout&lt;&lt;"Trouglovi nakon obavljenih transformacija:\n";
    std::transform(trouglovi.begin(), trouglovi.end(), trouglovi.begin(), [dx, dy, ugao, faktor](std::shared_ptr&lt;Trougao&gt; p) { 
        p-&gt;Trougao::Transliraj(dx, dy); p-&gt;Trougao::Rotiraj(ugao); p-&gt;Trougao::Skaliraj(p-&gt;DajTjeme(1), faktor); return p; });
    std::sort(trouglovi.begin(), trouglovi.end(), [](std::shared_ptr&lt;Trougao&gt; p, std::shared_ptr&lt;Trougao&gt; q) {
        return p-&gt;Trougao::DajPovrsinu() &lt; q-&gt;Trougao::DajPovrsinu();});
    for_each(trouglovi.begin(), trouglovi.end(), [](std::shared_ptr&lt;Trougao&gt; p) { p-&gt;Trougao::Ispisi(); std::cout&lt;&lt;std::endl;});
    std::cout&lt;&lt;"Trougao sa najmanjim obimom: ";
    (*std::min_element(trouglovi.begin(), trouglovi.end(), [](std::shared_ptr&lt;Trougao&gt; p, std::shared_ptr&lt;Trougao&gt; q){ 
        return p-&gt;Trougao::DajObim() &lt; q-&gt;Trougao::DajObim();}))-&gt;Ispisi();
    std::cout&lt;&lt;std::endl;
    std::vector&lt;std::pair&lt;Trougao, Trougao&gt;&gt; v;
    for(int i = 0; i &lt; n; i++)
    {
<a name="0"></a><font color="#FF0000"><a href="match502-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        for(int j = i + 1; j &lt; n; j++)
        {
            if(DaLiSuIdenticni(*trouglovi[i], *trouglovi[j]))
                v.push_back(std::make_pair(*trouglovi[i], *trouglovi[j]));
        }
    }
    if(v.size() == 0) std::cout&lt;&lt;"Nema identicnih trouglova!\n";
    else {
        std::cout&lt;&lt;"Parovi identicnih trouglova:\n";
        for(int i = 0; i &lt; v.size(); i++)
</font>        {
<a name="4"></a><font color="#FF00FF"><a href="match502-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

           v[i].first.Ispisi(); std::cout&lt;&lt;" i "; v[i].second.Ispisi();
           std::cout&lt;&lt;std::endl;
        } 
    }
    std::vector&lt;std::pair&lt;Trougao, Trougao&gt;&gt; podudarni;
    for(int i = 0; i &lt; n; i++)
</font>    {
<a name="1"></a><font color="#00FF00"><a href="match502-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        for(int j = i + 1; j &lt; n; j++)
        {
            if(DaLiSuPodudarni(*trouglovi[i], *trouglovi[j]))
                podudarni.push_back(std::make_pair(*trouglovi[i], *trouglovi[j]));
                
        }
    }
    if(podudarni.size() == 0) std::cout&lt;&lt;"Nema podudarnih trouglova!\n";
    else {
        std::cout&lt;&lt;"Parovi podudarnih trouglova:\n";
        for(int i = 0; i &lt; podudarni.size(); i++)
</font>        {
<a name="5"></a><font color="#FF0000"><a href="match502-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

            podudarni[i].first.Ispisi(); std::cout&lt;&lt;" i "; podudarni[i].second.Ispisi();
            std::cout&lt;&lt;std::endl;
        }
    }
    std::vector&lt;std::pair&lt;Trougao, Trougao&gt;&gt; slicni;
    for(int i = 0; i &lt; n; i++)
</font>    {
<a name="2"></a><font color="#0000FF"><a href="match502-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        for(int j = i + 1; j &lt; n; j++)
            if(DaLiSuSlicni(*trouglovi[i], *trouglovi[j]))
                slicni.push_back(std::make_pair(*trouglovi[i], *trouglovi[j]));
    }
    if(slicni.size() == 0) std::cout&lt;&lt;"Nema slicnih trouglova!\n";
    else {
        std::cout&lt;&lt;"Parovi slicnih trouglova:\n";
        for(int i = 0; i &lt; slicni.size(); i++)
</font>        {
            slicni[i].first.Ispisi(); std::cout&lt;&lt;" i "; slicni[i].second.Ispisi();
            std::cout&lt;&lt;std::endl;
        }
    }
	return 0;
}</pre>
</body>
</html>
