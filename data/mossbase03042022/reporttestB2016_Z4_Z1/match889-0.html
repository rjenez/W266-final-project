<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student7948.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student7948.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;
const double eps = 1E-10;

typedef pair&lt;double, double&gt; Tacka;

class Trougao {
		Tacka tacke[3];
		static double Izraz(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
			return t1.first*(t2.second-t3.second) - t2.first*(t1.second-t3.second) + t3.first*(t1.second-t2.second);
		}

	public:
		Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
			if(Orijentacija(t1,t2,t3)==0) throw domain_error("Nekorektne pozicije tjemena");
<a name="5"></a><font color="#FF0000"><a href="match889-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

			tacke[0]=t1; tacke[1]=t2; tacke[2]=t3;
		}
		void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
</font>			if(Orijentacija(t1,t2,t3)==0) throw domain_error("Nekorektne pozicije tjemena");
			tacke[0].first=t1.first; tacke[1].first=t2.first; tacke[2].first=t3.first;
			tacke[0].second=t1.second; tacke[1].second=t2.second; tacke[2].second=t3.second;
		}
		void Postavi(int indeks, const Tacka &amp;t) {
			if(indeks!=0 &amp;&amp; indeks!=1 &amp;&amp; indeks!=2) throw range_error("Nekorektan indeks");
			tacke[indeks]=t;
			if(Orijentacija(tacke[0],tacke[1],tacke[2])==0) throw domain_error("Nekorektne pozicije tjemena");
		}
		static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
			int izraz(Izraz(t1, t2, t3));
			if(izraz&gt;0) return 1;
			else if(izraz&lt;0) return -1;
			return 0;
		}
		Tacka DajTjeme(int indeks) const {
			if(indeks!=0 &amp;&amp; indeks!=1 &amp;&amp; indeks!=2) throw range_error("Nekorektan indeks");
			return tacke[indeks];
		}
		double DajStranicu(int indeks) const {
			if(indeks!=0 &amp;&amp; indeks!=1 &amp;&amp; indeks!=2) throw range_error("Nekorektan indeks");
			if(indeks==0) return sqrt((tacke[1].first-tacke[2].first)*(tacke[1].first-tacke[2].first)
				+ (tacke[1].second-tacke[2].second)*(tacke[1].second-tacke[2].second));
			else if(indeks==1) return sqrt((tacke[0].first-tacke[2].first)*(tacke[0].first-tacke[2].first)
				+ (tacke[0].second-tacke[2].second)*(tacke[0].second-tacke[2].second));
			return  sqrt((tacke[0].first-tacke[1].first)*(tacke[0].first-tacke[1].first)
				+ (tacke[0].second-tacke[1].second)*(tacke[0].second-tacke[1].second));
		}
		double DajUgao(int indeks) const {
			if(indeks!=0 &amp;&amp; indeks!=1 &amp;&amp; indeks!=2) throw range_error("Nekorektan indeks");
			double a, b, c;
			if(indeks==0) {
				a=DajStranicu(0); b=DajStranicu(1); c=DajStranicu(2);
			}
			else if(indeks==1) {
				a=DajStranicu(1); b=DajStranicu(0); c=DajStranicu(2);
			}
			else {
				a=DajStranicu(2); b=DajStranicu(1); c=DajStranicu(0);
			}
			return acos( (b*b+c*c-a*a) / (2*b*c) );
		}
<a name="1"></a><font color="#00FF00"><a href="match889-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		Tacka DajCentar() const {
			Tacka centar;
			centar.first=(tacke[0].first+tacke[1].first+tacke[2].first)/3;
			centar.second=(tacke[0].second+tacke[1].second+tacke[2].second)/3;
			return centar;
		}
		double DajObim() const {
</font>			return DajStranicu(0)+DajStranicu(1)+DajStranicu(2);
		}
		double DajPovrsinu() const {
			return abs(Izraz(tacke[0], tacke[1], tacke[2]))/2;
		}
		bool DaLiJePozitivnoOrijentiran() const {
			if((Orijentacija(tacke[0], tacke[1], tacke[2]))==1) return true;
			return false;
		}
		bool DaLiJeUnutra(const Tacka &amp;t) const {
			if( (Orijentacija(tacke[0],t ,tacke[2])==0) || (Orijentacija(tacke[0], t, tacke[1])==0) || (Orijentacija(t, tacke[1], tacke[2])==0))
				return false;
			double p1=abs(Izraz(tacke[0], tacke[1], t))/2, p2=abs(Izraz(tacke[0], t, tacke[2]))/2,
				p3=abs(Izraz(t, tacke[1], tacke[2]))/2, p=DajPovrsinu();
			if((p1+p2+p3)-p&lt;eps) return true;
			return false;
		}
		void Ispisi() {
			cout &lt;&lt; "((" &lt;&lt; tacke[0].first &lt;&lt; "," &lt;&lt; tacke[0].second &lt;&lt; "),("
				&lt;&lt; tacke[1].first &lt;&lt; "," &lt;&lt; tacke[1].second &lt;&lt; "),("
<a name="0"></a><font color="#FF0000"><a href="match889-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

				&lt;&lt; tacke[2].first &lt;&lt; "," &lt;&lt; tacke[2].second &lt;&lt; "))";
		}
		void Transliraj(double delta_x, double delta_y) {
			tacke[0].first+=delta_x; tacke[0].second+=delta_y;
			tacke[1].first+=delta_x; tacke[1].second+=delta_y;
			tacke[2].first+=delta_x; tacke[2].second+=delta_y;
		}
		void Centriraj(const Tacka &amp;t) {
</font>			int delta_x=t.first, delta_y=t.second;
			tacke[0].first+=delta_x; tacke[0].second+=delta_y;
			tacke[1].first+=delta_x; tacke[1].second+=delta_y;
			tacke[2].first+=delta_x; tacke[2].second+=delta_y;
		}
		void Rotiraj(const Tacka &amp;t, double ugao) {
<a name="2"></a><font color="#0000FF"><a href="match889-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

			double stari_x=tacke[0].first, stari_y=tacke[0].second;
			tacke[0].first = t.first + (stari_x - t.first) * cos(ugao) - (stari_y - t.second) * sin(ugao);
			tacke[0].second = t.second + (stari_x - t.first) * sin(ugao) + (stari_y - t.second) * cos(ugao);
</font>			
			stari_x=tacke[1].first, stari_y=tacke[1].second;
<a name="4"></a><font color="#FF00FF"><a href="match889-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

			tacke[1].first = t.first + (stari_x - t.first) * cos(ugao) - (stari_y - t.second) * sin(ugao);
			tacke[1].second = t.second + (stari_x - t.first) * sin(ugao) + (stari_y - t.second) * cos(ugao);
</font>			
			stari_x=tacke[2].first, stari_y=tacke[2].second;
<a name="3"></a><font color="#00FFFF"><a href="match889-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			tacke[2].first = t.first + (stari_x - t.first) * cos(ugao) - (stari_y - t.second) * sin(ugao);
			tacke[2].second = t.second + (stari_x - t.first) * sin(ugao) + (stari_y - t.second) * cos(ugao);
</font>		}
		void Rotiraj(double ugao) {
			(*this).Rotiraj((*this).DajCentar(), ugao);
		}
		void Skaliraj(const Tacka &amp;t, double faktor) {
			if(abs(faktor)&lt;eps) throw domain_error("Nekorektan faktor skaliranja");
			if(faktor&lt;0) (*this).Rotiraj(4*atan(1));
			if(tacke[0]!=t) {
				tacke[0].first=t.first+faktor*(tacke[0].first-t.first);
				tacke[0].second=t.second+faktor*(tacke[0].second-t.second);
			}
			if(tacke[1]!=t) {
				tacke[1].first=t.first+faktor*(tacke[1].first-t.first);
				tacke[1].second=t.second+faktor*(tacke[1].second-t.second);
			}
			if(tacke[2]!=t) {
				tacke[2].first=t.first+faktor*(tacke[2].first-t.first);
				tacke[2].second=t.second+faktor*(tacke[2].second-t.second);
			}
		}
		void Skaliraj(double faktor) {
			(*this).Skaliraj((*this).DajCentar(), faktor);
		}
		friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
		friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2);
		friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);
};

double Funkcija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
			return t1.first*(t2.second-t3.second) - t2.first*(t1.second-t3.second) + t3.first*(t1.second-t2.second);
		}

bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2) {
	int brojac(0);
	for(int i=0; i&lt;3; i++) {
		for(int j=0; j&lt;3; j++) {
			if(t1.tacke[i]==t2.tacke[j]) {
				brojac++;
				break;
			}
		}
	}
	if(brojac==3) return true;
	return false;
}

bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2){
	if(DaLiSuIdenticni(t1,t2)==true) return true;
	int indeks(-1);
	for(int i=0; i&lt;3; i++) {
		if(abs(t1.DajUgao(0)-t2.DajUgao(i))&lt;eps) {
			indeks=i;
			break;
		}
	} 
	if(indeks==-1) return false;
	
	if(indeks==0) {
		if(t1.DaLiJePozitivnoOrijentiran()==true) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(1), b=t2.DajStranicu(2);
				if(abs(a-x)&lt;eps &amp;&amp; abs(b-y)&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(1), b=t2.DajStranicu(2);
				if(abs(b-x)&lt;eps &amp;&amp; abs(a-y)&lt;eps) return true;
				return false;
			}
		}
		if(t1.DaLiJePozitivnoOrijentiran()==false) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(1), b=t2.DajStranicu(2);
				if(abs(a-y)&lt;eps &amp;&amp; abs(b-x)&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(1), b=t2.DajStranicu(2);
				if(abs(b-y)&lt;eps &amp;&amp; abs(a-x)&lt;eps) return true;
				return false;
			}
		}
	}
	
	if(indeks==1) {
		if(t1.DaLiJePozitivnoOrijentiran()==true) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(2), b=t2.DajStranicu(0);
				if(abs(a-x)&lt;eps &amp;&amp; abs(b-y)&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(2), b=t2.DajStranicu(0);
				if(abs(b-x)&lt;eps &amp;&amp; abs(a-y)&lt;eps) return true;
				return false;
			}
		}
		if(t1.DaLiJePozitivnoOrijentiran()==false) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(2), b=t2.DajStranicu(0);
				if(abs(a-y)&lt;eps &amp;&amp; abs(b-x)&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(2), b=t2.DajStranicu(0);
				if(abs(b-y)&lt;eps &amp;&amp; abs(a-x)&lt;eps) return true;
				return false;
			}
		}
	}
	if(indeks==2) {
		if(t1.DaLiJePozitivnoOrijentiran()==true) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(0), b=t2.DajStranicu(1);
				if(abs(a-x)&lt;eps &amp;&amp; abs(b-y)&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(0), b=t2.DajStranicu(1);
				if(abs(b-x)&lt;eps &amp;&amp; abs(a-y)&lt;eps) return true;
				return false;
			}
		}
		if(t1.DaLiJePozitivnoOrijentiran()==false) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(0), b=t2.DajStranicu(1);
				if(abs(a-y)&lt;eps &amp;&amp; abs(b-x)&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(0), b=t2.DajStranicu(1);
				if(abs(b-y)&lt;eps &amp;&amp; abs(a-x)&lt;eps) return true;
				return false;
			}
		}
	}
	return false;
}

bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2) {
	int indeks(-1);
	for(int i=0; i&lt;3; i++) {
		if(abs(t1.DajUgao(0)-t2.DajUgao(i))&lt;eps) {
			indeks=i;
			break;
		}
	} 
	if(indeks==-1) return false;
	
	if(indeks==0) {
		if(t1.DaLiJePozitivnoOrijentiran()==true) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(1), b=t2.DajStranicu(2);
				if(abs(abs(a/x)-abs(b/y))&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(1), b=t2.DajStranicu(2);
				if(abs(abs(b/x)-abs(a/y))&lt;eps) return true;
				return false;
			}
		}
		if(t1.DaLiJePozitivnoOrijentiran()==false) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(1), b=t2.DajStranicu(2);
				if(abs(abs(a/y)-abs(b/x))&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(1), b=t2.DajStranicu(2);
				if(abs(abs(b/y)-abs(a/x))&lt;eps) return true;
				return false;
			}
		}
	}
	
	if(indeks==1) {
		if(t1.DaLiJePozitivnoOrijentiran()==true) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(2), b=t2.DajStranicu(0);
				if(abs(abs(a/x)-abs(b/y))&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(2), b=t2.DajStranicu(0);
				if(abs(abs(b/x)-abs(a/y))&lt;eps) return true;
				return false;
			}
		}
		if(t1.DaLiJePozitivnoOrijentiran()==false) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(2), b=t2.DajStranicu(0);
				if(abs(abs(a/y)-abs(b/x))&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(2), b=t2.DajStranicu(0);
				if(abs(abs(b/y)-abs(a/x))&lt;eps) return true;
				return false;
			}
		}
	}
	if(indeks==2) {
		if(t1.DaLiJePozitivnoOrijentiran()==true) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(0), b=t2.DajStranicu(1);
				if(abs(abs(a/x)-abs(b/y))&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(0), b=t2.DajStranicu(1);
				if(abs(abs(b/x)-abs(a/y))&lt;eps) return true;
				return false;
			}
		}
		if(t1.DaLiJePozitivnoOrijentiran()==false) {
			double x=t1.DajStranicu(1), y=t1.DajStranicu(2);
			if(t2.DaLiJePozitivnoOrijentiran()==true) {
				double a=t2.DajStranicu(0), b=t2.DajStranicu(1);
				if(abs(abs(a/y)-abs(b/x))&lt;eps) return true;
				return false;
			}
			else if(t2.DaLiJePozitivnoOrijentiran()==false) {
				double a=t2.DajStranicu(0), b=t2.DajStranicu(1);
				if(abs(abs(b/y)-abs(a/x))&lt;eps) return true;
				return false;
			}
		}
	}
	return false;
}



int main ()
{ 
	try { 
	cout &lt;&lt; "Koliko zelite kreirati trouglova: ";
	int n;
	cin &gt;&gt; n;
	vector&lt;shared_ptr&lt;Trougao&gt;&gt; vec(n);
	double x1,y1,x2,y2,x3,y3;
	for(int i=1; i&lt;=n; i++) { 
		ponovo:
		cout &lt;&lt; "Unesite podatke za " &lt;&lt; i &lt;&lt; ". trougao (x1 y1 x2 y2 x3 y3): ";
		try {
			cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3;
			Trougao pomocni=Trougao(make_pair(x1,y1),make_pair(x2,y2),make_pair(x3,y3));
			vec[i-1]=make_shared&lt;Trougao&gt;(pomocni);
		}
		catch(domain_error) {
			cout &lt;&lt; "Nekorektne pozicije tjemena, ponovite unos! \n";
			goto ponovo;
		}
	}
	cout &lt;&lt; "Unesite vektor translacije (dx dy): ";
	double dx, dy;
	cin &gt;&gt; dx &gt;&gt; dy;
	cout &lt;&lt; "Unesite ugao rotacije: ";
	double ugao;
	cin &gt;&gt; ugao;
	cout &lt;&lt; "Unesite faktor skaliranja: ";
	double faktor;
	cin &gt;&gt; faktor;
	transform(vec.begin(), vec.end(), vec.begin(), [dx,dy,ugao,faktor](shared_ptr&lt;Trougao&gt; trokutic) -&gt;shared_ptr&lt;Trougao&gt; {
		trokutic-&gt;Transliraj(dx,dy);
		trokutic-&gt;Rotiraj(ugao);
		trokutic-&gt;Skaliraj((*trokutic).DajTjeme(0), faktor);
		return trokutic;
	});
	sort(vec.begin(), vec.end(), [](shared_ptr&lt;Trougao&gt; trokutic_1, shared_ptr&lt;Trougao&gt; trokutic_2) {
		return trokutic_1-&gt;DajPovrsinu() &lt; trokutic_2-&gt;DajPovrsinu();
	});
	cout &lt;&lt; "Trouglovi nakon obavljenih transformacija: " &lt;&lt; endl;
	for_each(vec.begin(), vec.end(), [](shared_ptr&lt;Trougao&gt; trokutic) {
		trokutic-&gt;Ispisi();
		cout &lt;&lt; endl;
	});
	auto min = min_element(vec.begin(), vec.end(), [](shared_ptr&lt;Trougao&gt; trokutic_1, shared_ptr&lt;Trougao&gt; trokutic_2) {
		return trokutic_1-&gt;DajObim() &lt; trokutic_2-&gt;DajObim();
	});
	cout &lt;&lt; "Trougao sa najmanjim obimom: ";
	if(!vec.empty()) 5(*min)-&gt;Ispisi();
	vector&lt;pair&lt;Trougao,Trougao&gt;&gt; identicni, podudarni, slicni;
	for(int i=0; i&lt;n; i++) {
		for(int j=i+1; j&lt;n; j++) {
			if(DaLiSuIdenticni(*vec[i], *vec[j])==true) identicni.push_back(make_pair(*vec[i],*vec[j]));
			if(DaLiSuPodudarni(*vec[i], *vec[j])==true) podudarni.push_back(make_pair(*vec[i],*vec[j]));
			if(DaLiSuSlicni(*vec[i], *vec[j])==true) slicni.push_back(make_pair(*vec[i],*vec[j]));
		}
	}
	if(identicni.empty()) cout &lt;&lt; "\nNema identicnih trouglova!" &lt;&lt; endl;
	else {
		cout &lt;&lt; "\nParovi identicnih trouglova: " &lt;&lt; endl;
		for(int i=0; i&lt;identicni.size(); i++) {
			identicni[i].first.Ispisi();
			cout &lt;&lt; " i ";
			identicni[i].second.Ispisi();
			cout &lt;&lt; endl;
		}
	}
	if(podudarni.empty()) cout &lt;&lt; "Nema podudarnih trouglova!" &lt;&lt; endl;
	else {
		cout &lt;&lt; "Parovi podudarnih trouglova: " &lt;&lt; endl;
		for(int i=0; i&lt;podudarni.size(); i++) {
			podudarni[i].first.Ispisi();
			cout &lt;&lt; " i ";
			podudarni[i].second.Ispisi();
			cout &lt;&lt; endl;
		}
	}
	if(podudarni.empty()) cout &lt;&lt; "Nema slicnih trouglova!" &lt;&lt; endl;
	else {
		cout &lt;&lt; "Parovi slicnih trouglova: " &lt;&lt; endl;
		for(int i=0; i&lt;slicni.size(); i++) {
			slicni[i].first.Ispisi();
			cout &lt;&lt; " i ";
			slicni[i].second.Ispisi();
			cout &lt;&lt; endl;
		}
	}
	}
	catch(range_error re) {
		cout &lt;&lt; re.what();
	}
	catch(domain_error de) {
		cout &lt;&lt; de.what();
	}
	return 0;
}</pre>
</body>
</html>
