<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student3320.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student3320.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
/B2016/2017: ZSR 7, Zadatak 1
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt; 
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

const double PI = 1E-10;

typedef std::pair&lt;double, double&gt; Tacka;

class Trokut {
Tacka t1, t2, t3;
public:
Trokut(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3); //
void Postavi(int indeks, const Tacka &amp;t); //
static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3); //
Tacka DajTjeme(int indeks) const; //
double DajStranicu(int indeks) const; //
double DajUgao(int indeks) const; //
Tacka DajCentar() const; //
double DajObim() const; //
double DajPovrsinu() const; //
bool DaLiJePozitivnoOrijentiran() const; //
bool DaLiJeUnutra(const Tacka &amp;t) const; //
void Ispisi() const { 
    std::cout &lt;&lt; "((" &lt;&lt; Trokut::t1.first &lt;&lt; "," &lt;&lt; Trokut::t1.second &lt;&lt; "),(" &lt;&lt; Trokut::t2.first &lt;&lt; "," &lt;&lt; Trokut::t2.second &lt;&lt; "),(" &lt;&lt; Trokut::t3.first &lt;&lt; "," &lt;&lt; Trokut::t3.second &lt;&lt; "))";
} //
void Transliraj(double delta_x, double delta_y); //
void Centriraj(const Tacka &amp;t); //
void Rotiraj(const Tacka &amp;t, double ugao); //
void Skaliraj(const Tacka &amp;t, double faktor); //
void Rotiraj(double ugao); //
void Skaliraj(double faktor); //
friend bool DaLiSuIdenticni(const Trokut &amp;t1, const Trokut &amp;t2); //
friend bool DaLiSuPodudarni(const Trokut &amp;t1, const Trokut &amp;t2);
<a name="2"></a><font color="#0000FF"><a href="match577-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

friend bool DaLiSuSlicni(const Trokut &amp;t1, const Trokut &amp;t2); //
};

Trokut::Trokut(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    if(Orijentacija(t1, t2, t3)==0) throw std::domain_error("Nekorektne pozicije tjemena");
</font>    this-&gt;t1.first=t1.first;
    this-&gt;t1.second=t1.second;
    this-&gt;t2.first=t2.first;
    this-&gt;t2.second=t2.second;
    this-&gt;t3.first=t3.first;
    this-&gt;t3.second=t3.second;
}

void Trokut::Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
    if(Orijentacija(t1, t2, t3)==0) throw std::domain_error("Nekorektne pozicije tjemena");
    this-&gt;t1.first=t1.first;
    this-&gt;t1.second=t1.second;
    this-&gt;t2.first=t2.first;
    this-&gt;t2.second=t2.second;
    this-&gt;t3.first=t3.first;
    this-&gt;t3.second=t3.second;
}

int Trokut::Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
    int test;
    test=(((t1.first)*((t2.second)-(t3.second)))-((t2.first)*((t1.second)-(t3.second)))+((t3.first)*((t1.second)-(t2.second))));
    if(test&gt;0) return 1;
    else if(test&lt;0) return -1;
    else return 0;
}

void Trokut::Postavi(int indeks, const Tacka &amp;t) {
    if(indeks&lt;1 || indeks&gt;3) throw std::range_error("Nekorektan indeks");
    
    if(indeks==1) {
        if(Orijentacija(t, t2, t3)==0) throw std::domain_error("Nekorektne pozicije tjemena");
        this-&gt;t1.first=t.first;
        this-&gt;t1.second=t.second;
    } else if(indeks==2) {
        if(Orijentacija(t1, t, t3)==0) throw std::domain_error("Nekorektne pozicije tjemena");
        this-&gt;t2.first=t.first;
        this-&gt;t2.second=t.second;
    } else if(indeks==3) {
        if(Orijentacija(t1, t2, t)==0) throw std::domain_error("Nekorektne pozicije tjemena");
        this-&gt;t3.first=t.first;
        this-&gt;t3.second=t.second;
    }
}

Tacka Trokut::DajTjeme(int indeks) const {
    if(indeks&lt;1 || indeks&gt;3) throw std::range_error("Nekorektan indeks");
    if(indeks==1) { return this-&gt;t1; }
    else if(indeks==2) { return this-&gt;t2; }
    else { return this-&gt;t3; }
}

double Trokut::DajStranicu(int indeks) const { //DORADITI
    if(indeks&lt;1 || indeks&gt;3) throw std::range_error("Nekorektan indeks");
    if(indeks==1) return sqrt(((t2.first-t3.first)*(t2.first-t3.first))+((t2.second-t3.second)*(t2.second-t3.second)));
    else if(indeks==2) return sqrt(((t1.first-t3.first)*(t1.first-t3.first))+((t1.second-t3.second)*(t1.second-t3.second)));
    else return sqrt(((t1.first-t2.first)*(t1.first-t2.first))+((t1.second-t2.second)*(t1.second-t2.second)));
}

double Trokut::DajUgao(int indeks) const { //DORADITI
    if(indeks&lt;1 || indeks&gt;3) throw std::range_error("Nekorektan indeks");
    double ugao=0;
    double PI1=3*atan(1);
    double AREA=abs((((t1.first)*((t2.second)-(t3.second)))-((t2.first)*((t1.second)-(t3.second)))+((t3.first)*((t1.second)-(t2.second))))/2.0);
    if(indeks==1) {
        double stranica1=this-&gt;DajStranicu(2);
        double stranica2=this-&gt;DajStranicu(3);
        ugao=asin((2*AREA)/(stranica1*stranica2));
    } else if(indeks==2) { 
        double stranica1=this-&gt;DajStranicu(1);
        double stranica2=this-&gt;DajStranicu(3);
        ugao=asin((2*AREA)/(stranica1*stranica2));
    } else if(indeks==3) {
        double stranica1=this-&gt;DajStranicu(1);
        double stranica2=this-&gt;DajStranicu(2);
        ugao=asin((2*AREA)/(stranica1*stranica2));
    }
    ugao=(ugao*PI1)/180;
    return ugao;
}

double Trokut::DajPovrsinu() const {
    return abs((t1.first*((t2.second)-(t3.second)))-(t2.first*((t1.second)-(t3.second)))+(t3.first*((t1.second)-(t2.second))))/2.0;
}

double Trokut::DajObim() const {
    double stranica1;
    double stranica2;
    double stranica3;
    
    stranica1=this-&gt;DajStranicu(1);
    stranica2=this-&gt;DajStranicu(2);
    stranica3=this-&gt;DajStranicu(3);
    
    return stranica1+stranica2+stranica3;
}

Tacka Trokut::DajCentar() const {
    Tacka Centar;
    double Gx, Gy;
    
    Gx=(t1.first+t2.first+t3.first)/3;
    Gy=(t1.second+t2.second+t3.second)/3;
    
    Centar=std::make_pair(Gx,Gy);
    
    return Centar;
}

bool Trokut::DaLiJePozitivnoOrijentiran() const {
    if(this-&gt;Orijentacija(this-&gt;t1, this-&gt;t2, this-&gt;t3)&gt;0) return true;
    else return false;
}

bool Trokut::DaLiJeUnutra(const Tacka &amp;t) const {
    double Area=abs((((t1.first)*((t2.second)-(t3.second)))-((t2.first)*((t1.second)-(t3.second)))+((t3.first)*((t1.second)-(t2.second))))/2.0);
    double AreaA=abs((((t.first)*((t2.second)-(t3.second)))-((t2.first)*((t.second)-(t3.second)))+((t3.first)*((t.second)-(t2.second))))/2.0);
    double AreaB=abs((((t1.first)*((t.second)-(t3.second)))-((t.first)*((t1.second)-(t3.second)))+((t3.first)*((t1.second)-(t.second))))/2.0);
    double AreaC=abs((((t1.first)*((t2.second)-(t.second)))-((t2.first)*((t1.second)-(t.second)))+((t.first)*((t1.second)-(t2.second))))/2.0);
    
    if ((((AreaA+AreaB+AreaC)-Area)&lt;PI) || (((AreaA+AreaB+AreaC)-Area)&gt;PI)) return false;
    else return true;
}

void Trokut::Transliraj(double delta_x, double delta_y) {
    this-&gt;t1.first+=delta_x;
    this-&gt;t1.second+=delta_y;
    this-&gt;t2.first+=delta_x;
    this-&gt;t2.second+=delta_y;
    this-&gt;t3.first+=delta_x;
    this-&gt;t3.second+=delta_y;
}

void Trokut::Centriraj(const Tacka &amp;t) {
    this-&gt;t1.first+=t.first;
    this-&gt;t1.second+=t.second;
    this-&gt;t2.first+=t.first;
    this-&gt;t2.second+=t.second;
    this-&gt;t3.first+=t.first;
    this-&gt;t3.second+=t.second;
}

void Trokut::Rotiraj(const Tacka &amp;t, double ugao) {
    if(!DaLiJeUnutra(t)) throw std::domain_error("Nekorektna tacka");
    t1.first=t.first+(t1.first-t.first)*cos(ugao)-(t1.second-t.second)*sin(ugao);
    t1.second=t.second+(t1.first-t.first)*sin(ugao)+(t1.second-t.second)*cos(ugao);
    t2.first=t.first+(t2.first-t.first)*cos(ugao)-(t2.second-t.second)*sin(ugao);
    t2.second=t.second+(t2.first-t.first)*sin(ugao)+(t2.second-t.second)*cos(ugao);
    t3.first=t.first+(t3.first-t.first)*cos(ugao)-(t3.second-t.second)*sin(ugao);
    t3.second=t.second+(t3.first-t.first)*sin(ugao)+(t3.second-t.second)*cos(ugao);
}

void Trokut::Skaliraj(const Tacka &amp;t, double faktor) {
    if(faktor&gt;0) {
        t1.first=t.first+faktor*(t1.first-t.first);
        t1.second=t.second+faktor*(t1.second-t.second);
        t2.first=t.first+faktor*(t1.first-t.first);
        t2.second=t.second+faktor*(t1.second-t.second);
        t3.first=t.first+faktor*(t1.first-t.first);
        t3.second=t.second+faktor*(t1.second-t.second);
    } else if(faktor&lt;0) {
        t1.first=t.first+faktor*(t1.first-t.first);
        t1.second=t.second+faktor*(t1.second-t.second);
        t2.first=t.first+faktor*(t1.first-t.first);
        t2.second=t.second+faktor*(t1.second-t.second);
        t3.first=t.first+faktor*(t1.first-t.first);
        t3.second=t.second+faktor*(t1.second-t.second);
        
        this-&gt;Rotiraj(t, 180.0);
    } else {
        throw std::domain_error("Nekorektan faktor skaliranja");
    }
}

void Trokut::Rotiraj(double ugao) {
    Tacka Centar=this-&gt;DajCentar();
    t1.first=Centar.first+(t1.first-Centar.first)*cos(ugao)-(t1.second-Centar.second)*sin(ugao);
    t1.second=Centar.second+(t1.first-Centar.first)*sin(ugao)+(t1.second-Centar.second)*cos(ugao);
    t2.first=Centar.first+(t2.first-Centar.first)*cos(ugao)-(t2.second-Centar.second)*sin(ugao);
    t2.second=Centar.second+(t2.first-Centar.first)*sin(ugao)+(t2.second-Centar.second)*cos(ugao);
    t3.first=Centar.first+(t3.first-Centar.first)*cos(ugao)-(t3.second-Centar.second)*sin(ugao);
    t3.second=Centar.second+(t3.first-Centar.first)*sin(ugao)+(t3.second-Centar.second)*cos(ugao);
}

void Trokut::Skaliraj(double faktor) {
    if(faktor&gt;0 || faktor&lt;0) {
        Tacka Centar=Trokut::DajCentar();
        t1.first=Centar.first+(faktor*(t1.first-Centar.first));
        t2.second=Centar.second+(faktor*(t1.second-Centar.second));
        t2.first=Centar.first+(faktor*(t2.first-Centar.first));
        t2.second=Centar.second+(faktor*(t2.second-Centar.second));
        t3.first=Centar.first+(faktor*(t3.first-Centar.first));
        t3.second=Centar.second+(faktor*(t3.second-Centar.second));
        if(faktor&lt;0) {
            this-&gt;Rotiraj(180.);
        }
        } else {
            throw std::domain_error("Nekorektan faktor skaliranja");
    }
}

bool DaLiSuIdenticni(const Trokut &amp;t1, const Trokut &amp;t2) {
    int i=0, j=0, k=0;
    int x=0, y=0, z=0;
    //PRVA
    if(t1.t1.first-t2.t1.first&lt;0 || t1.t1.first-t2.t1.first&gt;0) {
        i=1;
        if(t1.t1.first-t2.t2.first&lt;0 || t1.t1.first-t2.t2.first&gt;0) {
            i=1;
            if(t1.t1.first-t2.t3.first&lt;0 || t1.t1.first-t2.t3.first&gt;0) {
                i=1;
            } else {
                if(t1.t1.second-t2.t3.second&lt;0 || t1.t1.second-t2.t3.second&gt;0) {
                    i=1;
                } else {
                    x=1;
                    i=0;
                }
            }
        } else {
            if(t1.t1.second-t2.t2.second&lt;0 || t1.t1.second-t2.t2.second&gt;0) {
                i=1;
            } else {
                x=1;
                i=0;
            }
        }
    } else {
        if(t1.t1.second-t2.t1.second&lt;0 || t1.t1.second-t2.t1.second&gt;0) {
            i=1;
        } else {
            x=1;
            i=0;
        }
    }
    //DRUGA
    if(t1.t2.first-t2.t1.first&lt;0 || t1.t2.first-t2.t1.first&gt;0) {
        j=1;
        if(t1.t2.first-t2.t2.first&lt;0 || t1.t2.first-t2.t2.first&gt;0) {
            j=1;
            if(t1.t2.first-t2.t3.first&lt;0 || t1.t2.first-t2.t3.first&gt;0) {
                j=1;
            } else {
                if(t1.t2.second-t2.t3.second&lt;0 || t1.t2.second-t2.t3.second&gt;0) {
                    j=1;
                } else {
                    y=1;
                    j=0;
                }
            }
        } else {
            if(t1.t2.second-t2.t2.second&lt;0 || t1.t2.second-t2.t2.second&gt;0) {
                j=1;
            } else {
                y=1;
                j=0;
            }
        }
    } else {
        if(t1.t2.second-t2.t1.second&lt;0 || t1.t2.second-t2.t1.second&gt;0) {
            j=1;
        } else {
            y=1;
            j=0;
        }
    }
    //TRECA
    if(t1.t3.first-t2.t1.first&lt;0 || t1.t3.first-t2.t1.first&gt;0) {
        k=1;
        if(t1.t3.first-t2.t2.first&lt;0 || t1.t3.first-t2.t2.first&gt;0) {
            k=1;
            if(t1.t3.first-t2.t3.first&lt;0 || t1.t3.first-t2.t3.first&gt;0) {
                k=1;
            } else {
                if(t1.t3.second-t2.t3.second&lt;0 || t1.t3.second-t2.t3.second&gt;0) {
                    k=1;
                } else {
                    z=1;
                    k=0;
                }
            }
        } else {
            if(t1.t3.second-t2.t2.second&lt;0 || t1.t3.second-t2.t2.second&gt;0) {
                k=1;
            } else {
                z=1;
                k=0;
            }
        }
    } else {
        if(t1.t3.second-t2.t1.second&lt;0 || t1.t3.second-t2.t1.second&gt;0) {
            k=1;
        } else {
            z=1;
            k=0;
        }
    }
    if(x==1 &amp;&amp; y==1 &amp;&amp; z==1) {
        if(i==0 &amp;&amp; j==0 &amp;&amp; k==0) {
            return true;
        }
    }
    return false;
}


bool DaLiSuPodudarni(const Trokut &amp;t1, const Trokut &amp;t2) {
    double povrsina1;
    double povrsina2;
    
    povrsina1=t1.Trokut::DajPovrsinu(); 
    povrsina2=t2.Trokut::DajPovrsinu();
    
    if((povrsina1-povrsina2)&lt;PI) return false;
    if((povrsina1-povrsina2)&gt;PI) return false;

    for(double i=1; i&lt;=360; i++) {
        
        for(double j=-10; j&lt;10; j++) {
            for(double k=-10; k&lt;10; k++) {
            
                if(DaLiSuIdenticni(t1, t2)) return true;
                else continue;
            }
        }
    }
    return false;
}

bool DaLiSuSlicni(const Trokut &amp;t1, const Trokut &amp;t2){
    if(DaLiSuPodudarni(t1, t2)) {
        double ugao1=0, ugao2=0;
        for(int i=1; i&lt;=3; i++) {
            ugao1+=t1.DajUgao(i);
            ugao2+=t2.DajUgao(i);
        }
        if((ugao1-ugao2)&lt;PI) return false;
        if((ugao1-ugao2)&gt;PI) return false;
        return true;
    }
    return false;
}

int main () {
    try {
        std::cout &lt;&lt; "Koliko zelite kreirati trouglova: ";
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;std::shared_ptr&lt;Trokut&gt;&gt; trouglovi;
<a name="3"></a><font color="#00FFFF"><a href="match577-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

        trouglovi.resize(n);
        for(int i=0; i&lt;n; i++) {
            std::cout &lt;&lt; "Unesite podatke za "&lt;&lt; i+1 &lt;&lt;". trougao (x1 y1 x2 y2 x3 y3): ";
</font>            Tacka a1;
            Tacka b1;
            Tacka c1;
            double a,b,c,aa,bb,cc;
            std::cin &gt;&gt; a &gt;&gt; aa;
            std::cin &gt;&gt; b &gt;&gt; bb;
<a name="0"></a><font color="#FF0000"><a href="match577-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

            std::cin &gt;&gt; c &gt;&gt; cc;
            try {
                trouglovi[i]=std::make_shared&lt;Trokut&gt;(Trokut({a, aa}, {b, bb}, {c, cc}));
            } catch (std::domain_error Prvi) {
                std::cout &lt;&lt; Prvi.what() &lt;&lt; std::endl;
                i--;
            }
        }
        std::cout &lt;&lt; "Unesite vector translacije (dx dy): ";
        double x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        std::transform(trouglovi.begin(),trouglovi.end(), trouglovi.begin(), [x, y](std::shared_ptr&lt;Trokut&gt; temp) {
            temp-&gt;Transliraj(x, y);
            return temp;
        });
        
        std::cout &lt;&lt; "Unesite ugao rotacije: ";
        double ugao;
        std::cin &gt;&gt; ugao;
        std::transform(trouglovi.begin(), trouglovi.end(), trouglovi.begin(), [ugao](std::shared_ptr&lt;Trokut&gt; temp) {
            temp-&gt;Rotiraj(ugao);
            return temp;
        });
        std::cout &lt;&lt; "Unesite faktor skaliranja: ";
        double fac;
        std::cin &gt;&gt; fac;
        std::transform(trouglovi.begin(), trouglovi.end(), trouglovi.begin(), [fac](std::shared_ptr&lt;Trokut&gt; temp) {
           temp-&gt;Skaliraj(temp-&gt;DajTjeme(1),fac);
           return temp;
        });
        std::sort(trouglovi.begin(), trouglovi.end(), [](std::shared_ptr&lt;Trokut&gt; temp, std::shared_ptr&lt;Trokut&gt; temp1) {
</font>            return temp-&gt;DajPovrsinu()&lt;temp1-&gt;DajPovrsinu();
        });
        std::cout &lt;&lt; "Trouglovi nakon obavljenih transformacija: ";
<a name="1"></a><font color="#00FF00"><a href="match577-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        std::for_each(trouglovi.begin(), trouglovi.end(), [](std::shared_ptr&lt;Trokut&gt; temp) {
            temp-&gt;Ispisi();
            std::cout &lt;&lt; std::endl;
        });

	    std::cout &lt;&lt; "Trougao sa najmanjim obimom: ";
	    auto obim=std::min_element(trouglovi.begin(), trouglovi.end(), [](std::shared_ptr&lt;Trokut&gt; temp, std::shared_ptr&lt;Trokut&gt; temp1) {
	       return temp-&gt;DajObim()&lt;temp1-&gt;DajObim(); 
	    });
	    (*obim)-&gt;Ispisi();
	    std::cout &lt;&lt; std::endl;
	    
	    int test=0;
	    for(int i=0; i&lt;n-1; i++) {
	        for(int j=1; j&lt;n; j++) {
</font>	            test++;
	            if(test==1) std::cout &lt;&lt; "Parovi identicnih trouglova: ";
	            if(DaLiSuIdenticni(*trouglovi[i], *trouglovi[j])) {
	                trouglovi[i]-&gt;Ispisi();
	                std::cout &lt;&lt; " i ";
	                trouglovi[j]-&gt;Ispisi();
	                std::cout &lt;&lt; std::endl;
	            }
	        }
	    }
	    if(!test) std::cout &lt;&lt; "nema identicnih trouglova!" &lt;&lt; std::endl;
	
	    test=0;
	    for(int i=0; i&lt;n-1; i++) {
	        for(int j=1; j&lt;n; j++) {
	            test++;
	            if(test==1) std::cout &lt;&lt; "Parovi podudarnih trouglova: ";
	            if(DaLiSuPodudarni(*trouglovi[i], *trouglovi[j])) {
	               trouglovi[i]-&gt;Ispisi();
	                std::cout &lt;&lt; " i ";
	                trouglovi[j]-&gt;Ispisi();
	                std::cout &lt;&lt; std::endl;
	            }
	        }
	    }
	    if(!test) std::cout &lt;&lt; "nema podudarnih trouglova!" &lt;&lt; std::endl;
	
	    test=0;
	    for(int i=0; i&lt;n-1; i++) {
	        for(int j=1; j&lt;n; j++) {
	            test++;
	            if(test==1) std::cout &lt;&lt; "Parovi slicnih trouglova: ";
	            if(DaLiSuSlicni(*trouglovi[i], *trouglovi[j])) {
	                trouglovi[i]-&gt;Ispisi();
	                std::cout &lt;&lt; " i ";
	                trouglovi[j]-&gt;Ispisi();
	                std::cout &lt;&lt; std::endl;
	            }
	        }
	    }
	    if(!test) std::cout &lt;&lt; "nema slicnih trouglova!" &lt;&lt; std::endl;
	    
    } catch (std::domain_error Prvi) {
        std::cout &lt;&lt; Prvi.what() &lt;&lt; ", ponovite unos!" &lt;&lt; std::endl;
    } catch (std::range_error Prvi) {
        std::cout &lt;&lt; Prvi.what() &lt;&lt; ", ponovite unos!" &lt;&lt; std::endl;
    }
	return 0;
}
</pre>
</body>
</html>
