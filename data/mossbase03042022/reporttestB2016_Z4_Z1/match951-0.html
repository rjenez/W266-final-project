<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student4863.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student4863.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!

#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;

typedef std::pair&lt;double, double&gt; Tacka;

class Trougao {
     Tacka tacke[3];
    void ProvjeraIndeksa(int i) const {
        if(i &lt; 1 || i &gt; 3) throw std::range_error("Nekorektan indeks");
    }
    static double Izraz(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
        return t1.first * (t2.second - t3.second) - t2.first * (t1.second - t3.second) + t3.first * (t1.second - t2.second);
    }
    static bool EpsJednakost(double x, double y) {
        const double Eps (1E-10);
        return std::fabs(x-y) &lt;= Eps * (std::fabs(x) + std::fabs(y));
    }
public:
    Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
        if(!Orijentacija(t1, t2, t3)) throw std::domain_error("Nekorektne pozicije tjemena");
        tacke[0] = t1; tacke[1] = t2; tacke[2] = t3;
    }
    void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
        if(!Orijentacija(t1, t2, t3)) throw std::domain_error("Nekorektne pozicije tjemena");
        tacke[0] = t1; tacke[1] = t2; tacke[2] = t3;  
    }
    void Postavi(int indeks, const Tacka &amp;t) {
        ProvjeraIndeksa(indeks);
        auto tmp(tacke[indeks-1]);
        tacke[indeks-1] = t;
        if(!Orijentacija(tacke[0], tacke[1], tacke[2])) {
            tacke[indeks-1] = tmp;
            throw std::domain_error("Nekorektne pozicije tjemena");
        }
    }
    static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    Tacka DajTjeme(int indeks) { ProvjeraIndeksa(indeks); return tacke[indeks-1]; }
    double DajStranicu(int indeks) const;
    double DajUgao(int indeks) const;
    Tacka DajCentar() const;
    double DajObim() const;
    double DajPovrsinu() const;
    bool DaLiJePozitivnoOrijentiran() const;
    bool DaLiJeUnutra (const Tacka &amp;t) const;
    void Ispisi() const;
    void Transliraj(double delta_x, double delta_y);
    void Centriraj (const Tacka &amp;t);
    void Rotiraj (const Tacka &amp;t, double ugao);
    void Rotiraj (double ugao);
    void Skaliraj (const Tacka &amp;t, double faktor);
    void Skaliraj (double faktor);
    friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);
    
};

int Trougao::Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
    auto a = Izraz(t1, t2, t3);
    if(a &lt; 0) return -1;
    if(a &gt; 0) return 1;
    else return 0;
}

double Trougao::DajStranicu(int indeks) const {
    ProvjeraIndeksa(indeks);
    double d = sqrt(pow(tacke[indeks%3].first - tacke[(indeks+1)%3].first, 2) + pow(tacke[indeks%3].second - tacke[(indeks+1)%3].second, 2));
    //double d = sqrt((tacke[indeks%3].first - tacke[(indeks+1)%3].first))*(tacke[indeks%3].first -
    return d;
}

double Trougao::DajUgao(int indeks) const {
    ProvjeraIndeksa(indeks);
    double a = DajStranicu(indeks%3), b = DajStranicu((indeks+1)%3), c = DajStranicu(indeks-1);
    return std::acos((a*a+b*b-c*c)/(2*a*b));
}

Tacka Trougao::DajCentar() const {
    Tacka t;
    t.first = 0; t.second = 0;
    for(int i = 0; i &lt; 3; i++) {
        t.first += tacke[i].first;
        t.second += tacke[i].second;
    }
    t.first /= 3;
    t.second /= 3;
    return t;
}

double Trougao::DajObim() const {
    double O(0);
    for(int i = 0; i &lt; 3; i++)
        O += DajStranicu(i+1);
    return O;
}

double Trougao::DajPovrsinu() const {
    return 0.5 * std::abs(Izraz(tacke[0], tacke[1], tacke[2]));
}

bool Trougao::DaLiJePozitivnoOrijentiran() const {
    auto a = Orijentacija(tacke[0], tacke[1], tacke[2]);
    return a == 1;
}

bool Trougao::DaLiJeUnutra(const Tacka &amp;t) const {
    auto orj(Orijentacija(tacke[0], tacke[1], tacke[2]));
    return Orijentacija(tacke[0], tacke[1], t) == orj &amp;&amp; Orijentacija(tacke[1], tacke[2], t) == orj &amp;&amp; Orijentacija(tacke[2], tacke[0], t) == orj;
}

void Trougao::Ispisi() const {
    std::cout &lt;&lt; "(";
    for(int i = 0; i &lt; 3; i++) {
        std::cout &lt;&lt; "(" &lt;&lt; tacke[i].first &lt;&lt; "," &lt;&lt; tacke[i].second &lt;&lt; ")";
        if(i != 2) std::cout &lt;&lt; ",";
    }
<a name="3"></a><font color="#00FFFF"><a href="match951-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    std::cout &lt;&lt; ")";
}

void Trougao::Transliraj (double delta_x, double delta_y) {
    for(int i = 0; i &lt; 3; i++) {
        tacke[i].first += delta_x;
        tacke[i].second += delta_y;   
    }
}

void Trougao::Centriraj (const Tacka &amp;t) {
</font>    Tacka t2 = DajCentar();
    Transliraj(t.first - t2.first, t.second - t2.second);
}

void Trougao::Rotiraj (const Tacka &amp;t, double ugao) {
    for(int i = 0; i &lt; 3; i++) {
        double x = t.first + (tacke[i].first - t.first) * std::cos(ugao) - (tacke[i].second - t.second) * std::sin(ugao);
        double y = t.second + (tacke[i].first - t.first) * std::sin(ugao) + (tacke[i].second - t.second) * std::cos(ugao);
        tacke[i] = {x,y};
    }
}

void Trougao::Rotiraj (double ugao) {
    Rotiraj(DajCentar(), ugao);
}

void Trougao::Skaliraj (const Tacka &amp;t, double faktor) {
<a name="1"></a><font color="#00FF00"><a href="match951-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    if (!faktor) throw std::domain_error("Nekorektan faktor skaliranja");
    for(int i = 0; i &lt; 3; i++) {
        tacke[i].first = t.first + faktor * (tacke[i].first - t.first);
        tacke[i].second = t.second + faktor * (tacke[i].second - t.second); 
    }
}

void Trougao::Skaliraj (double faktor) {
    Skaliraj(DajCentar(), faktor);
</font>}

bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2) {
    for(int i = 0; i &lt; 3; i++) {
        int brojac(0);
<a name="2"></a><font color="#0000FF"><a href="match951-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        for(int j = 0; j &lt; 3; j++)
            if(Trougao::EpsJednakost(t1.tacke[i].first, t2.tacke[j].first) &amp;&amp; Trougao::EpsJednakost(t1.tacke[i].second, t2.tacke[j].second))
</font>            //if(t1.tacke[i].first == t2.tacke[j].first &amp;&amp; t1.tacke[i].second == t2.tacke[j].second)
                brojac++;
        if(brojac != 1)
            return false;
    }
    return true;
}

bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2) {
    for(int i = 0; i &lt; 3; i++) {
        int brojac(0);
        for(int j = 0; j &lt; 3; j++)
            if(Trougao::EpsJednakost(t1.DajStranicu(i+1), t2.DajStranicu(j+1)))
            //if(t1.DajStranicu(i+1) == t2.DajStranicu(j+1))
                brojac++;
        if(brojac &lt; 1) return false;
    }
    int br(1);
    for(int i = 1; i &lt; 3; i++)
        if(Trougao::EpsJednakost(t1.DajStranicu(i+1), t1.DajStranicu(1)))
        //if(t1.DajStranicu(i+1) == t1.DajStranicu(1)) br++;
    if(br == 3) return true;
    auto t(t1);
    for(int i = 0; i &lt; 3; i++)
        for(int j = 1; j &lt; 2; j++)
            if(t.DajStranicu(i+1) &lt; t.DajStranicu(j+1))
                std::swap(t.tacke[i], t.tacke[j]);
    auto tp(t2);
    for(int i =  0; i &lt; 3; i++)
        for(int j = 1; j &lt; 2; j++)
            if(tp.DajStranicu(i+1) &lt; tp.DajStranicu(j+1))
                std::swap(tp.tacke[i], tp.tacke[j]);
    if(Trougao::Orijentacija(t.tacke[0], t.tacke[1], t.tacke[2]) == Trougao::Orijentacija(tp.tacke[0], tp.tacke[1], tp.tacke[2]))
        return true;
    return false;
}

bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2) {
    int br1(0), br2(0), br3(0);
    double k1(t1.DajStranicu(1)/t2.DajStranicu(1)), k2(t1.DajStranicu(1)/t2.DajStranicu(2)), k3(t1.DajStranicu(1)/t2.DajStranicu(3));
    for(int i = 0; i &lt; 3; i++) 
        for(int j = 0; j &lt; 3; j++) {
            double x = t1.DajStranicu(i+1) / t2.DajStranicu(j+1);
            if(Trougao::EpsJednakost(x, k1)) br1++;
            if(Trougao::EpsJednakost(x, k2)) br2++;
            if(Trougao::EpsJednakost(x, k3)) br3++;
        }
    if(br1 != 3 &amp;&amp; br2 != 3 &amp;&amp; br3 != 3) return false;
    if(br1 == 3 &amp;&amp; br2 == 3 &amp;&amp; br3 == 3) return true;
    auto t(t1);
    for(int i = 0; i &lt; 3; i++)
        for(int j = 1; j &lt;2; j++)
            if(t.DajStranicu(i+1) &lt; t.DajStranicu(j+1))
                std::swap(t.tacke[i], t.tacke[j]);
    auto tp(t2);
    for(int i = 0; i &lt; 3; i++)
        for(int j = 1; j &lt; 2; j++)
            if(tp.DajStranicu(i+1) &lt; tp.DajStranicu(j+1))
                std::swap(tp.tacke[i], tp.tacke[j]);
                
    if(Trougao::Orijentacija(t.tacke[0], t.tacke[1], t.tacke[2]) == Trougao::Orijentacija(tp.tacke[0], tp.tacke[1], tp.tacke[2]))
        return true;
    return false;
}

bool Provjera(const std::vector&lt;std::shared_ptr&lt;Trougao&gt;&gt; &amp;v, std::function&lt;bool(Trougao, Trougao)&gt; f, int x) {
    bool uslov(false);
    for(int i = 0; i &lt; v.size(); i++)
        for(int j = i; j &lt; v.size(); j++) 
            if(i != j &amp;&amp; f(*v[i], *v[j])) {
                if(!uslov) {
                    if(x == 0) std::cout &lt;&lt; "\nParovi identicnih trouglova:\n";
                    if(x == 1) std::cout &lt;&lt; "Parovi podudarnih trouglova:\n";
                    if(x == 2) std::cout &lt;&lt; "Parovi slicnih trouglova:\n";
                }
                uslov = true;
                v[i] -&gt; Ispisi();
                std::cout &lt;&lt; " i ";
                v[j] -&gt; Ispisi();
                std::cout &lt;&lt; std::endl;
            }
    return uslov;
}
int main ()
{  
    try{
    int n;
    std::cout &lt;&lt; "Koliko zelite kreirati trouglova: ";
    std::cin &gt;&gt; n;
    std::vector&lt;std::shared_ptr&lt;Trougao&gt;&gt; v(n);
    for(int i = 0; i &lt; n; i++) {
        double x1, y1, x2, y2, x3, y3;
        std::cout &lt;&lt; "Unesite podatke za " &lt;&lt; i+1 &lt;&lt; ". trougao (x1 y1 x2 y2 x3 y3): ";
        std::cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3;
        try {
            v[i] = std::make_shared&lt;Trougao&gt; (Trougao({x1, y1}, {x2, y2}, {x3, y3}));
        }
        catch(std::domain_error e) {
            std::cout &lt;&lt; e.what() &lt;&lt;", ponovite unos!" &lt;&lt; std::endl;
            i--;
        }
        catch(std::bad_alloc) {
            std::cout &lt;&lt;"Problemi sa memorijom";
        }
    }
<a name="0"></a><font color="#FF0000"><a href="match951-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    std::cout &lt;&lt; "Unesite vektor translacije (dx dy): ";
    double dx, dy;
    std::cin &gt;&gt; dx &gt;&gt; dy;
    std::transform(v.begin(), v.end(), v.begin(),  [dx, dy] (std::shared_ptr&lt;Trougao&gt; t) {t-&gt;Transliraj(dx, dy); return t;});
    std::cout &lt;&lt; "Unesite ugao rotacije: ";
    double ugao;
    std::cin &gt;&gt; ugao;
    std::transform(v.begin(), v.end(), v.begin(), [ugao] (std::shared_ptr&lt;Trougao&gt; t) {t-&gt;Rotiraj(ugao); return t;});
    std::cout &lt;&lt; "Unesite faktor skaliranja: ";
    double faktor;
    std::cin &gt;&gt; faktor;
    std::transform(v.begin(), v.end(), v.begin(), [faktor] (std::shared_ptr&lt;Trougao&gt;t) {t-&gt;Skaliraj(t-&gt;DajTjeme(1), faktor); return t;});
</font><a name="4"></a><font color="#FF00FF"><a href="match951-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    std::sort(v.begin(), v.end(), [] (std::shared_ptr&lt;Trougao&gt; t1, std::shared_ptr&lt;Trougao&gt; t2) { return t1-&gt;DajPovrsinu() &lt; t2-&gt;DajPovrsinu();});
    std::cout &lt;&lt; "Trouglovi nakon obavljenih transformacija:\n";
    std::for_each(v.begin(), v.end(), [](std::shared_ptr&lt;Trougao&gt; t) { t-&gt;Ispisi(); std::cout &lt;&lt; std::endl;});    
</font>    auto min_obim (std::min_element(v.begin(), v.end(), [] (std::shared_ptr&lt;Trougao&gt; t1, std::shared_ptr&lt;Trougao&gt; t2) {return t1-&gt;DajObim() &lt; t2-&gt;DajObim();}));
    std::cout &lt;&lt; "Trougao sa najmanjim obimom: ";
    if(min_obim != v.end()) (*min_obim)-&gt;Ispisi();
    if(!(Provjera(v, DaLiSuIdenticni, 0))) std::cout &lt;&lt; "\nNema identicnih trouglova!\n";
    if(!(Provjera(v, DaLiSuPodudarni, 1))) std::cout &lt;&lt; "Nema podudarnih trouglova!\n";
    if(!(Provjera(v, DaLiSuSlicni, 2))) std::cout &lt;&lt; "Nema slicnih trouglova!\n";
    }
    catch(std::bad_alloc) {
        std::cout &lt;&lt; "Nema memorije";
    }
    
	return 0;
}</pre>
</body>
</html>
