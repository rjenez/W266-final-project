<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student6040.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student6040.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;memory&gt;
#define PI 3.14159265358979323846

typedef std::pair&lt;double, double&gt; Tacka;

class Trougao{
    Tacka T1, T2, T3;
    static bool JesuLiJednaki(double x, double y, double Eps=1e-10){
        return std::fabs(x-y)&lt;=Eps*(std::fabs(x)+std::fabs(y));
    }
    
    public:
        Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
        void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
        void Postavi(int indeks, const Tacka &amp;t);
        static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
        Tacka DajTjeme(int indeks) const;
        double DajStranicu(int indeks) const;
        double DajUgao(int indeks) const;
        Tacka DajCentar() const;
        double DajObim() const;
        double DajPovrsinu() const;
        bool DaLiJePozitivnoOrijentiran() const;
        bool DaLiJeUnutra(const Tacka &amp;t) const;
        void Ispisi() const;
        void Transliraj(double delta_x, double delta_y);
        void Centriraj(const Tacka &amp;t);
        void Rotiraj(const Tacka &amp;t, double ugao);
        void Skaliraj(const Tacka &amp;t, double faktor);
        void Rotiraj(double ugao);
        void Skaliraj(double faktor);
        friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
<a name="3"></a><font color="#00FFFF"><a href="match305-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

        friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2);
        friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);
};
//pomocna fija koja ispituje kolinearnost tacaka
double UslovKolinearnosti(Tacka t1, Tacka t2, Tacka t3){
</font><a name="1"></a><font color="#00FF00"><a href="match305-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    return t1.first*(t2.second-t3.second)-t2.first*(t1.second-t3.second)+t3.first*(t1.second-t2.second);
}
//implementacija kontruktora-isto tijelo kao i metoda Postavi
Trougao::Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    Postavi(t1, t2, t3);
}
//prva verzija metode Postavi
void Trougao::Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    if(JesuLiJednaki(UslovKolinearnosti(t1, t2, t3), 0))throw std::domain_error("Nekorektne pozicije tjemena");
    T1=t1;
    T2=t2;
    T3=t3;
}
//druga verzija metode Postavi
void Trougao::Postavi(int indeks, const Tacka &amp;t){
    if(indeks!=1 &amp;&amp; indeks!=2 &amp;&amp; indeks!=3) throw std::range_error("Nekorektan indeks");
</font>    DajTjeme(indeks)=t;
    if(JesuLiJednaki(UslovKolinearnosti(T1, T2, T3), 0)) throw std::domain_error("Nekorektne pozicije tjemena");
}

//pozitivna return 1;/ negativna return -1;/ tacke kolinearne return 0;
int Trougao::Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    if(JesuLiJednaki(UslovKolinearnosti(t1, t2, t3), 0)) return 0;
    if(UslovKolinearnosti(t1, t2, t3)&gt;0) return 1;
    return -1;
}

<a name="0"></a><font color="#FF0000"><a href="match305-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

Tacka Trougao::DajTjeme(int indeks) const{
    if(indeks!=1 &amp;&amp; indeks!=2 &amp;&amp; indeks!=3) throw std::range_error("Nekorektan indeks");
    if(indeks==1) return T1;
    else if(indeks==2) return T2;
    else return T3;
}

double Trougao::DajStranicu(int indeks) const{
     if(indeks!=1 &amp;&amp; indeks!=2 &amp;&amp; indeks!=3) throw std::range_error("Nekorektan indeks");
     if(indeks==1){
         return std::sqrt((T3.first-T2.first)*(T3.first-T2.first)+(T3.second-T2.second)*(T3.second-T2.second));
     }
     else if(indeks==2){
         return std::sqrt((T3.first-T1.first)*(T3.first-T1.first)+(T3.second-T1.second)*(T3.second-T1.second));
     }
     else{
         return std::sqrt((T2.first-T1.first)*(T2.first-T1.first)+(T2.second-T1.second)*(T2.second-T1.second));
     }
}

double Trougao::DajUgao(int indeks) const{
    if(indeks!=1 &amp;&amp; indeks!=2 &amp;&amp; indeks!=3) throw std::range_error("Nekorektan indeks");
</font>    double ugao;
    if(indeks==1){
        ugao=acos((DajStranicu(3)*DajStranicu(3)+DajStranicu(2)*DajStranicu(2)-DajStranicu(1)*DajStranicu(1))/(2*DajStranicu(3)*DajStranicu(2)))*PI/180;
    }
    else if(indeks==2){
         ugao=acos((DajStranicu(3)*DajStranicu(3)+DajStranicu(1)*DajStranicu(1)-DajStranicu(2)*DajStranicu(2))/(2*DajStranicu(3)*DajStranicu(1)))*PI/180;
    }
    else {
         ugao=acos((DajStranicu(1)*DajStranicu(1)+DajStranicu(2)*DajStranicu(2)-DajStranicu(3)*DajStranicu(3))/(2*DajStranicu(1)*DajStranicu(2)))*PI/180;
    }
    return ugao;
}

<a name="2"></a><font color="#0000FF"><a href="match305-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

Tacka Trougao::DajCentar() const{
    Tacka teziste;
    teziste.first=(T1.first+T2.first+T3.first)/3;
    teziste.second=(T1.second+T2.second+T3.second)/3;
    return teziste;
}

double Trougao::DajObim() const{
    return DajStranicu(1)+DajStranicu(2)+DajStranicu(3);
}

double Trougao::DajPovrsinu() const{
</font>    return (1./2)*std::fabs(UslovKolinearnosti(T1, T2, T3));
}

bool Trougao::DaLiJePozitivnoOrijentiran() const{
    if(Orijentacija(T1, T2, T3)==1) return true;
    else return false;
}

bool Trougao::DaLiJeUnutra(const Tacka &amp;t) const{
    if(Orijentacija(T1, T2, T3)==-1 &amp;&amp; Orijentacija(T1, T2, t)==1 &amp;&amp; Orijentacija(T2, T3, t)==1 &amp;&amp; Orijentacija(T3, T1, t)==1){
        return true;
    }
<a name="4"></a><font color="#FF00FF"><a href="match305-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

    if(Orijentacija(T1, T2, T3)==-1 &amp;&amp; Orijentacija(T1, T2, t)==-1 &amp;&amp; Orijentacija(T2, T3, t)==-1 &amp;&amp; Orijentacija(T3, T1, t)==-1){
        return true;
</font><a name="5"></a><font color="#FF0000"><a href="match305-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    }
    return false;
}

void Trougao::Ispisi() const{
    std::cout&lt;&lt;"(("&lt;&lt;T1.first&lt;&lt;","&lt;&lt;T1.second&lt;&lt;"),("&lt;&lt;T2.first&lt;&lt;","&lt;&lt;T2.second&lt;&lt;"),("&lt;&lt;T3.first&lt;&lt;","&lt;&lt;T3.second&lt;&lt;"))";
</font>}

void Trougao::Transliraj(double delta_x, double delta_y){
    T1.first+=delta_x;
    T1.second+=delta_y;
    
    T2.first+=delta_x;
    T2.second+=delta_y;
    
    T3.first+=delta_x;
    T3.second+=delta_y;
}

//specijalan slucaj translacije
void Trougao::Centriraj(const Tacka &amp;t){
    T1.first+=t.first-DajCentar().first;
    T1.second+=t.second-DajCentar().second;
    
    T2.first+=t.first-DajCentar().first;
    T2.second+=t.second-DajCentar().second;
    
    T3.first+=t.first-DajCentar().first;
    T3.second+=t.second-DajCentar().second;
}

void Trougao::Rotiraj(const Tacka &amp;t, double ugao){
    double temp1, temp2, temp3;
    
    temp1=T1.first;
    temp2=T2.first;
    temp3=T3.first;
    
    T1.first=t.first+(T1.first-t.first)*cos(ugao)-(T1.second-t.second)*sin(ugao);
    T1.second=t.second+(temp1-t.first)*sin(ugao)+(T1.second-t.second)*cos(ugao);
    
    T2.first=t.first+(T2.first-t.first)*cos(ugao)-(T2.second-t.second)*sin(ugao);
    T2.second=t.second+(temp2-t.first)*sin(ugao)+(T2.second-t.second)*cos(ugao);
    
    T3.first=t.first+(T3.first-t.first)*cos(ugao)-(T3.second-t.second)*sin(ugao);
    T3.second=t.second+(temp3-t.first)*sin(ugao)+(T3.second-t.second)*cos(ugao);
    
}

void Trougao::Skaliraj(const Tacka &amp;t, double faktor){
    if(JesuLiJednaki(faktor, 0)) throw std::domain_error("Nekorektan faktor skaliranja");
    
    T1.first=t.first+faktor*(T1.first-t.first);
    T1.second=t.second+faktor*(T1.second-t.second);
    
    T2.first=t.first+faktor*(T2.first-t.first);
    T2.second=t.second+faktor*(T2.second-t.second);
    
    T3.first=t.first+faktor*(T3.first-t.first);
    T3.second=t.second+faktor*(T3.second-t.second);
    
    if(faktor&lt;0) Rotiraj(180);
}

void Trougao::Rotiraj(double ugao){
    Rotiraj(DajCentar(), ugao);
}

void Trougao::Skaliraj(double faktor){
    Skaliraj(DajCentar(), faktor);
}
bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2){
    std::vector&lt;std::pair&lt;double, double&gt;&gt; v{t1.T1, t1.T2, t1.T3};
    std::vector&lt;std::pair&lt;double, double&gt;&gt; k{t2.T1, t2.T2, t2. T3};
    int n(0);
    std::vector&lt;std::pair&lt;double, double&gt;&gt; p;
    for(int i=0;i&lt;3;i++){
       for(int j=0;j&lt;3;j++){
           if(Trougao::JesuLiJednaki(v[i].first, k[j].first) &amp;&amp; Trougao::JesuLiJednaki(v[i].second, k[j].second)){
               n++;
           }
       }
    }
    if(n==3) return true;
    return false;
}

bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2){
    std::vector&lt;Tacka&gt; p, d;
    bool podudarni(false);
       int stranice(0), uglovi(0);
            for(int i=1;i&lt;=3;i++){
                for(int j=1;j&lt;=3;j++){
                    if(Trougao::JesuLiJednaki(t1.DajStranicu(i), t2.DajStranicu(j))){ stranice++;}
                    if(Trougao::JesuLiJednaki(t1.DajUgao(i), t2.DajUgao(j))) { uglovi++; p.push_back(t1.DajTjeme(i)); d.push_back(t2.DajTjeme(j));}
                }
            }
            if(uglovi&gt;=3 &amp;&amp; stranice&gt;=3 &amp;&amp; Trougao::JesuLiJednaki(t1.Orijentacija(p[0], p[1], p[2]), t2.Orijentacija(d[0], d[1], d[2]))){
               podudarni=true;
            }
        
    return podudarni;
}

bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2){
    
    bool slicni(false);
    std::vector&lt;Tacka&gt; p, d;
    int uglovi(0);
            for(int i=1;i&lt;=3;i++){
                for(int j=1;j&lt;=3;j++){
                    if(Trougao::JesuLiJednaki(t1.DajUgao(i), t2.DajUgao(j))) { uglovi++; p.push_back(t1.DajTjeme(i)); d.push_back(t2.DajTjeme(j));}
                }
            }
            if(uglovi&gt;=3 &amp;&amp; Trougao::JesuLiJednaki(t1.Orijentacija(p[0], p[1], p[2]), t2.Orijentacija(d[0], d[1], d[2]))){
               slicni=true;
            }
    return slicni;
}
//pomocna fija koja racuna udaljenost izmedju dvije tacke
double dd(Tacka A, Tacka B){
    double dx=A.first-B.first;
    double dy=A.second-B.second;
    return std::sqrt(dx*dx+dy*dy);
}

int main ()
{
    int n;
    std::cout&lt;&lt;"Koliko zelite kreirati trouglova: ";
    std::cin&gt;&gt;n;
    if(n&gt;0) 
    {
    std::vector&lt;std::shared_ptr&lt;Trougao&gt;&gt; v(n);
    for(int i=0;i&lt;n;i++){
        Tacka A, B, C;
        std::cout&lt;&lt;"Unesite podatke za "&lt;&lt;i+1&lt;&lt;". trougao (x1 y1 x2 y2 x3 y3): ";
        std::cin&gt;&gt;A.first&gt;&gt;A.second&gt;&gt;B.first&gt;&gt;B.second&gt;&gt;C.first&gt;&gt;C.second;
        try{
            v[i]=std::make_shared&lt;Trougao&gt;(Trougao(A, B, C));
        }
        catch(std::domain_error e){
            std::cout&lt;&lt;e.what()&lt;&lt;", ponovite unos!"&lt;&lt;std::endl;
            i--;
        }
    }
    std::cout&lt;&lt;"Unesite vektor translacije (dx dy): ";
    double dx, dy;
    std::cin&gt;&gt;dx&gt;&gt;dy;
    
    std::cout&lt;&lt;"Unesite ugao rotacije: ";
    double ugao;
    std::cin&gt;&gt;ugao;
    
    std::cout&lt;&lt;"Unesite faktor skaliranja: ";
    double f;
    std::cin&gt;&gt;f;
   
<a name="6"></a><font color="#00FF00"><a href="match305-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    std::transform(v.begin(), v.end(), v.begin(), [dx, dy](std::shared_ptr&lt;Trougao&gt; t){ t-&gt;Transliraj(dx, dy); return t; });
    std::transform(v.begin(), v.end(), v.begin(), [ugao](std::shared_ptr&lt;Trougao&gt; t){ t-&gt;Rotiraj(ugao); return t; });
</font><a name="7"></a><font color="#0000FF"><a href="match305-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    std::transform(v.begin(), v.end(), v.begin(), [f](std::shared_ptr&lt;Trougao&gt; t){ t-&gt;Skaliraj(t-&gt;DajTjeme(1),f); return t;});
</font><a name="8"></a><font color="#00FFFF"><a href="match305-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

    
    
    
    std::sort(v.begin(), v.end(), [](std::shared_ptr&lt;Trougao&gt; prvi, std::shared_ptr&lt;Trougao&gt; drugi){return prvi-&gt;DajPovrsinu()&lt;drugi-&gt;DajPovrsinu();});
</font>    
    std::cout&lt;&lt;"Trouglovi nakon obavljenih transformacija:"&lt;&lt;std::endl;
    std::for_each(v.begin(), v.end(), [](std::shared_ptr&lt;Trougao&gt; t){t-&gt;Ispisi();std::cout&lt;&lt;std::endl;});
    
    std::cout&lt;&lt;"Trougao sa najmanjim obimom: ";
    (*std::min_element(v.begin(), v.end(),[](std::shared_ptr&lt;Trougao&gt; prvi, std::shared_ptr&lt;Trougao&gt; drugi){return prvi-&gt;DajObim()&lt;drugi-&gt;DajObim();}))-&gt;Ispisi();
    std::cout&lt;&lt;std::endl;
    
        bool k(false);
        for(int i=0;i&lt;n;i++){
            for(int j=i+1;j&lt;n;j++){
                if(DaLiSuIdenticni(*v[i], *v[j])){
                    k=true;
                }
            }
        }
        if(!k) std::cout&lt;&lt;"Nema identicnih trouglova!"&lt;&lt;std::endl;
        else{
            std::cout&lt;&lt;"Parovi identicnih trouglova:"&lt;&lt;std::endl;
            for(int i=0;i&lt;n;i++){
                for(int j=i+1;j&lt;n;j++){
                    if(DaLiSuIdenticni(*v[i], *v[j])){
                        v[i]-&gt;Ispisi();
                        std::cout&lt;&lt;" i ";
                        v[j]-&gt;Ispisi();
                        std::cout&lt;&lt;std::endl;
                    }
                }
            }
        }
        bool b(false);
        for(int i=0;i&lt;n;i++){
            for(int j=i+1;j&lt;n;j++){
                if(DaLiSuPodudarni(*v[i], *v[j])){
                    b=true;
                }
            }
        }
        if(!b) std::cout&lt;&lt;"Nema podudarnih trouglova!"&lt;&lt;std::endl;
        else{
            std::cout&lt;&lt;"Parovi podudarnih trouglova:"&lt;&lt;std::endl;
            for(int i=0;i&lt;n;i++){
                for(int j=i+1;j&lt;n;j++){
                    if(DaLiSuPodudarni(*v[i], *v[j])){
                        v[i]-&gt;Ispisi();
                        std::cout&lt;&lt;" i ";
                        v[j]-&gt;Ispisi();
                        std::cout&lt;&lt;std::endl;
                    }
                }
            }
            
        }
   
        bool g(false);
        for(int i=0;i&lt;n;i++){
            for(int j=i+1;j&lt;n;j++){
                if(DaLiSuSlicni(*v[i], *v[j])){
                   g=true;
                }
            }
        }
        if(!g) std::cout&lt;&lt;"Nema slicnih trouglova!"&lt;&lt;std::endl;
        else{
             std::cout&lt;&lt;"Parovi slicnih trouglova:"&lt;&lt;std::endl;
            for(int i=0;i&lt;n;i++){
                for(int j=i+1;j&lt;n;j++){
                    if(DaLiSuSlicni(*v[i], *v[j])){
                        v[i]-&gt;Ispisi();
                        std::cout&lt;&lt;" i ";
                        v[j]-&gt;Ispisi();
                        std::cout&lt;&lt;std::endl;
                    }
                }
            }
        }
        
    }
    
	return 0;
}</pre>
</body>
</html>
