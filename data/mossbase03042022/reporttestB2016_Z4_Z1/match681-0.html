<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student8957.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student8957.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

typedef std::pair&lt;double,double&gt; Tacka;

double Povrsina (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    return (t1.first*(t2.second-t3.second)-t2.first*(t1.second-t3.second)+t3.first*(t1.second-t2.second));
}

double DuzinaStranice (const Tacka &amp;t1, const Tacka &amp;t2){
    return (std::sqrt((t2.first-t1.first)*(t2.first-t1.first)+(t2.second-t2.second)*(t2.second-t1.second)));
}

bool DaLiSuIdenticni (const Trougao &amp;t1, const Trougao &amp;t2){
    int brojac(0);
    for (int i=0,i&lt;3;i++){
        for (int j=0;j&lt;3;j++){
            if (tacke[i]==tacke[j]){
                brojac++;
                break;
            }
        }
    }
    if (brojac==3) return true;
    return false;
}

bool DaLiSuPodudarni (const Trougao &amp;t1, const Trougao &amp;t2){
    int a[3],b[3];
    a[0]=DuzinaStranice(tacke[1],tacke[2]);
    a[1]=DuzinaStranice(tacke[0],tacke[2]);
    a[2]=DuzinaStranice(tacke[0],tacke[1]);
    b[0]=DuzinaStranice(tacke[1],tacke[2]);
    b[1]=DuzinaStranice(tacke[0],tacke[2]);
    b[2]=DuzinaStranice(tacke[0],tacke[1]);
    int brojac(0);
    for (int i=0,i&lt;3;i++){
        for (int j=0;j&lt;3;j++){
            if (tacke[i]==tacke[j]){
                brojac++;
                break;
            }
        }
    }
    if (brojac==3) return true;
    return false;
}
    
bool DaLiSuSlicni (const Trougao &amp;t1, const Trougao &amp;t2){
    int a1,b1,c1,a2,b2,c2;
    a1=DuzinaStranice(tacke[1],tacke[2]);
    b1=DuzinaStranice(tacke[0],tacke[2]);
    c1=DuzinaStranice(tacke[0],tacke[1]);
    a2=DuzinaStranice(tacke[1],tacke[2]);
    b2=DuzinaStranice(tacke[0],tacke[2]);
    c2=DuzinaStranice(tacke[0],tacke[1]);
    int s1(a1/a2),s2(b1/b2),s3(c1/c2);
    if (s1==s2 &amp;&amp; s2==s3) return true;
    return false;
}

class Trougao {
    Tacka tacke[3];
    public:
    Trougao (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
        if (Povrsina(t1,t2,t3)==0)
            throw std::domain_error ("Nekorektne pozicije tjemena");
        tacke[0]=t1; tacke[1]=t2; tacke[2]=t3; 
    }
    void Postavi (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    void Postavi (int indeks, const Tacka &amp;t);
    static int Orijentacija (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    Tacka DajTjeme (int indeks) const { return tacke[indeks-1]; } ;
    double DajStranicu (int indeks) const;
    double DajUgao (int indeks ) const;
    Tacka DajCentar () const ;
    double DajObim () const;
    double DajPovrsinu () const { return Povrsina(tacke[0],tacke[1],tacke[2]); };
    bool DaLiJePozitivnoOrijentiran () const { return Povrsina(tacke[0],tacke[1],tacke[2])&gt;0; };
    bool DaLiJeUnutra (const Tacka &amp;t);
    void Ispisi () const;
    void Transliraj (double delta_x, double delta_y);
    void Centriraj (const Tacka &amp;t);
    void Rotiraj (const Tacka &amp;t, double ugao);
    void Skaliraj (const Tacka &amp;t, double faktor);
    void Rotiraj (double ugao);
    void Skaliraj (double faktor);
    friend bool DaLiSuIdenticni (const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuPodudarni (const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuSlicni (const Trougao &amp;t1, const Trougao &amp;t2);
    friend double Povrsina (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3 );
    friend double DuzinaStranice (const Tacka &amp;t1, const Tacka &amp;t2);
};

int main ()
{
    int n;
    std::cout&lt;&lt;"Koliko zelite kreirati trouglova: ";
    std::cin&gt;&gt;n;
    return 0;
}

void Trougao::Postavi (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    if (Povrsina(t1,t2,t3)==0)
<a name="3"></a><font color="#00FFFF"><a href="match681-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

        throw std::domain_error ("Nekorektne pozicije tjemena");
        tacke[0]=t1; tacke[1]=t2; tacke[2]=t3;
}

void Trougao::Postavi (int indeks, const Tacka &amp;t){
    if (indeks&lt;0 || indeks&gt;3)
        throw std::range_error ("Nekorektan indeks");
    tacke[indeks-1]=t;
</font>    if (Povrsina(tacke[0],tacke[1],tacke[2])==0)
        throw std::domain_error ("Nekorektne pozicije tjemena");
}

int Trougao::Orijentacija (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    if (Povrsina(t1,t2,t3)==0) return 0;
    if (Povrsina(t1,t2,t3)&gt;0) return 1;
    if (Povrsina(t1,t2,t3)&lt;0) return -1;
}

double Trougao::DajUgao (int indeks) const {
    double a,b,c;
    a=DuzinaStranice(tacke[1],tacke[2]);
    b=DuzinaStranice(tacke[0],tacke[2]);
    c=DuzinaStranice(tacke[0],tacke[1]);
    if (indeks==1) return std::acos(((b*b+c*c-a*a)/(2*b*c)));
    if (indeks==2) return std::acos(((a*a+c*c-b*b)/(2*a*c)));
    if (indeks==3) return std::acos(((a*a+b*b-c*c)/(2*a*b)));
}

<a name="2"></a><font color="#0000FF"><a href="match681-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

Tacka Trougao::DajCentar() const {
    Tacka t;
    t.first=(tacke[0].first+tacke[1].first+tacke[2].first)/3;
    t.second=(tacke[0].second+tacke[1].second+tacke[2].second)/3;
    return t;
}

double Trougao::DajObim() const {
</font>    double a,b,c;
    a=DuzinaStranice(tacke[1],tacke[2]);
    b=DuzinaStranice(tacke[0],tacke[2]);
    c=DuzinaStranice(tacke[0],tacke[1]);
    return a+b+c;
}

bool Trougao::DaLiJeUnutra (const Tacka &amp;t){
    double p(Povrsina(tacke[0],tacke[1],tacke[2]));
    double p1(Povrsina(t,tacke[1],tacke[2]));
    double p2(Povrsina(tacke[0],t,tacke[2]));
    double p3(Povrsina(tacke[0],tacke[1],t));
    if (p&lt;p1+p2+p3) return true;
    return false;
}

<a name="1"></a><font color="#00FF00"><a href="match681-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

void Trougao::Transliraj (double delta_x, double delta_y){
    tacke[0].first+=delta_x;tacke[0].second+=delta_y;
    tacke[1].first+=delta_x;tacke[1].second+=delta_y;
    tacke[2].first+=delta_x;tacke[2].second+=delta_y;
}

void Trougao::Centriraj (const Tacka &amp;t){
    double xt((tacke[0].first+tacke[1].first+tacke[2].first)/3);
</font>    double yt((tacke[0].second+tacke[1].second+tacke[2].second)/3);
    Tacka te;
    te=std::make_pair(xt,yt);
    double d(DuzinaStranice(te,t));
    Transliraj(d,d);
}
 
void Trougao::Rotiraj (const Tacka &amp;t, double ugao){
<a name="0"></a><font color="#FF0000"><a href="match681-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

    tacke[0].first=t.first+(tacke[0].first-t.first)*std::cos(ugao)-(tacke[0].second-t.second)*std::sin(ugao);
    tacke[0].second=t.second+(tacke[0].first-t.first)*std::sin(ugao)+(tacke[0].second-t.second)*std::cos(ugao);
    tacke[1].first=t.first+(tacke[1].first-t.first)*std::cos(ugao)-(tacke[1].second-t.second)*std::sin(ugao);
</font>    tacke[1].second=t.second+(tacke[1].first-t.first)*std::sin(ugao)+(tacke[1].second-t.second)*std::cos(ugao);
<a name="4"></a><font color="#FF00FF"><a href="match681-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    tacke[2].first=t.first+(tacke[2].first-t.first)*std::cos(ugao)-(tacke[2].second-t.second)*std::sin(ugao);
</font>    tacke[2].second=t.second+(tacke[2].first-t.first)*std::sin(ugao)+(tacke[2].second-t.second)*std::cos(ugao);
}

void Trougao::Skaliraj(const Tacka &amp;t, double faktor){
    if (faktor==0) throw std::domain_error ("Nekorektan faktor skaliranja");
    tacke[0].first=t.first+faktor*(tacke[0].first-t.first);
    tacke[0].second=t.second+faktor*(tacke[0].second-t.second);
    tacke[1].first=t.first+faktor*(tacke[1].first-t.first);
    tacke[1].second=t.second+faktor*(tacke[1].second-t.second);
    tacke[2].first=t.first+faktor*(tacke[2].first-t.first);
    tacke[2].second=t.second+faktor*(tacke[2].second-t.second);
    
    if (faktor&lt;0){
        Rotiraj(t,180);
    }
}

void Trougao::Rotiraj (double ugao){
    double xt((tacke[0].first+tacke[1].first+tacke[2].first)/3);
    double yt((tacke[0].second+tacke[1].second+tacke[2].second)/3);
    Tacka t;
    t=std::make_pair(xt,yt);
    tacke[0].first=t.first+(tacke[0].first-t.first)*std::cos(ugao)-(tacke[0].second-t.second)*std::sin(ugao);
<a name="5"></a><font color="#FF0000"><a href="match681-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    tacke[0].second=t.second+(tacke[0].first-t.first)*std::sin(ugao)+(tacke[0].second-t.second)*std::cos(ugao);
    tacke[1].first=t.first+(tacke[1].first-t.first)*std::cos(ugao)-(tacke[1].second-t.second)*std::sin(ugao);
</font>    tacke[1].second=t.second+(tacke[1].first-t.first)*std::sin(ugao)+(tacke[1].second-t.second)*std::cos(ugao);
    tacke[2].first=t.first+(tacke[2].first-t.first)*std::cos(ugao)-(tacke[2].second-t.second)*std::sin(ugao);
    tacke[2].second=t.second+(tacke[2].first-t.first)*std::sin(ugao)+(tacke[2].second-t.second)*std::cos(ugao);
}

void Trougao::Skaliraj(double faktor){
    if (faktor==0) throw std::domain_error ("Nekorektan faktor skaliranja");
    double xt((tacke[0].first+tacke[1].first+tacke[2].first)/3);
    double yt((tacke[0].second+tacke[1].second+tacke[2].second)/3);
    Tacka t;
    tacke[0].first=t.first+faktor*(tacke[0].first-t.first);
    tacke[0].second=t.second+faktor*(tacke[0].second-t.second);
    tacke[1].first=t.first+faktor*(tacke[1].first-t.first);
    tacke[1].second=t.second+faktor*(tacke[1].second-t.second);
    tacke[2].first=t.first+faktor*(tacke[2].first-t.first);
    tacke[2].second=t.second+faktor*(tacke[2].second-t.second);
    
    if (faktor&lt;0){
        Rotiraj(t,180);
    }
}</pre>
</body>
</html>
