<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student6822.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student6822.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

<a name="1"></a><font color="#00FF00"><a href="match74-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_17.gif"/></a>

using namespace std;

typedef std::pair&lt;double, double&gt; Tacka;

class Trougao
{
    Tacka t1, t2, t3;
public:
 bool Jednako(double a, double b, double eps=1e-10) {
        if(abs(a-b) &lt; eps) return true;
        return false;
    }
    bool Jednakokraki_Jednakostranicni(const Trougao &amp;t) {
        const double eps=1e-10;
        if((abs(t.DajStranicu(1) - t.DajStranicu(2)) &lt; eps) &amp;&amp; (abs(t.DajStranicu(1) - t.DajStranicu(3)) &lt; eps)) return true;
        else if(abs(t.DajStranicu(1) - t.DajStranicu(2)) &lt; eps || abs(t.DajStranicu(1) - t.DajStranicu(2)) &lt; eps || abs(t.DajStranicu(2) - t.DajStranicu(3) &lt; eps)) return true;
        else return false;
    }
bool Ispitaj(const Trougao &amp;t) {
        double a=t.DajStranicu(1), b=DajStranicu(2), c=DajStranicu(3);
        vector&lt;double&gt; v{a,b,c};
        sort(v.begin(), v.end());
        if(Jednako(v[2], a)) {
            if(Jednako(v[1],b)) {
                if(t.t2.first &gt; t.t3.first) return true;
                else if(t.t3.first &gt; t.t2.first) return false;
                else if(Jednako(t.t2.first, t.t3.first)) {
                    if(t.t1.first &gt; t.t2.first) return false;
                    else return true;
                }
            }
            else {
                if(t.t3.first &gt; t.t2.first) return true;
                else if(t.t2.first &gt; t.t3.first) return false;
                else if(Jednako(t.t2.first, t.t3.first)) {
                    if(t.t1.first &gt; t.t2.first) return false;
                    else return true;
            }
        }
    }
        else if(Jednako(v[2], b)) {
            if(Jednako(v[1],a)) {
                if(t.t1.first &gt; t.t3.first) return true;
                else if(t.t3.first &gt; t.t1.first) return false;
                else if(Jednako(t.t1.first, t.t3.first)) {
                    if(t.t2.first &gt; t.t1.first) return false;
                    else return true;
                }
            }
            else {
                if(t.t3.first &gt; t.t1.first) return true;
                else if(t.t1.first &gt; t.t3.first) return false;
                else if(Jednako(t.t1.first, t.t3.first)) {
                    if(t.t2.first &gt; t.t1.first) return false;
                    else return true;
            }
        }
    }
    else{
            if(Jednako(v[1],a)) {
                if(t.t1.first &gt; t.t2.first) return true;
                else if(t.t2.first &gt; t.t1.first) return false;
                else if(Jednako(t.t2.first, t.t1.first)) {
                    if(t.t3.first &gt; t.t2.first) return false;
                    else return true;
                }
            }
            else {
                if(t.t2.first &gt; t.t1.first) return true;
                else if(t.t1.first &gt; t.t2.first) return false;
                else if(Jednako(t.t2.first, t.t1.first)) {
                    if(t.t3.first &gt; t.t2.first) return false;
                    else return true;
            }
        }
    }
}
    Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
</font><a name="4"></a><font color="#FF00FF"><a href="match74-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_8.gif"/></a>

    void Postavi(int indeks, const Tacka &amp;t);
    static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
    static int a;
    if((t1.first*(t2.second - t3.second) - t2.first*(t1.second - t3.second) + t3.first*(t1.second - t2.second)) &gt; 0) a=1;
    else if((t1.first*(t2.second - t3.second) - t2.first*(t1.second - t3.second) + t3.first*(t1.second - t2.second)) &lt; 0) a=-1;
    else a=0;
    return a;
    }
    Tacka DajTjeme(int indeks) const;
    double DajStranicu(int indeks) const;
    double DajUgao(int indeks) const;
    Tacka DajCentar() const;
    double DajObim() const;
    double DajPovrsinu() const {
        return 1./2*abs(t1.first*(t2.second - t3.second) - t2.first*(t1.second - t3.second) + t3.first*(t1.second - t2.second));
    }
    bool DaLiJePozitivnoOrijentiran() const { 
        if(Orijentacija(t1,t2,t3) &gt; 0) return true; 
        else return false; 
    }
    bool DaLiJeUnutra(const Tacka &amp;t) const;
    void Ispisi() const { cout&lt;&lt;"(("&lt;&lt;t1.first&lt;&lt;","&lt;&lt;t1.second&lt;&lt;"),("&lt;&lt;t2.first&lt;&lt;","&lt;&lt;t2.second&lt;&lt;"),("&lt;&lt;t3.first&lt;&lt;","&lt;&lt;t3.second&lt;&lt;"))"; }
    void Transliraj(double delta_x, double delta_y);
    void Centriraj(const Tacka &amp;t);
    void Rotiraj(const Tacka &amp;t, double ugao);
    void Skaliraj(const Tacka &amp;t, double faktor);
</font>    void Rotiraj(double ugao);
    void Skaliraj(double faktor);
<a name="2"></a><font color="#0000FF"><a href="match74-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_14.gif"/></a>

    friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2) {
    double a,b,c,e,f,g;
    const double eps=1e-10;
    a=t1.DajStranicu(1);
    b=t1.DajStranicu(2);
    c=t1.DajStranicu(3);
    e=t2.DajStranicu(1);
    f=t2.DajStranicu(2);
    g=t2.DajStranicu(3);
    if((abs(a-e)&lt;eps || abs(a-f)&lt;eps || abs(a-g)&lt;eps) &amp;&amp; (abs(b-e)&lt;eps || abs(b-f)&lt;eps || abs(b-g)&lt;eps) &amp;&amp; 
    (abs(c-e)&lt;eps || abs(c-f)&lt;eps || abs(c-g)&lt;eps) &amp;&amp; (Ispitaj(thisdwqdqd-&gt;t1dwdq) == Ispitaj(this-&gt;t2))) return true;
    return false;
    }
    friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);
    
};
Trougao::Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
    if(Orijentacija(t1,t2,t3)==0) throw domain_error("Nekorektne pozicije tjemena");
    Trougao::t1.first = t1.first;
    Trougao::t1.second = t1.second;
    Trougao::t2.first = t2.first;
    Trougao::t2.second = t2.second;
    Trougao::t3.first = t3.first;
    Trougao::t3.second = t3.second;
}
void Trougao::Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
    if(Orijentacija(t1,t2,t3)==0) throw domain_error("Nekorektne pozicije tjemena");
    Trougao::t1.first = t1.first;
    Trougao::t1.second = t1.second;
    Trougao::t2.first = t2.first;
    Trougao::t2.second = t2.second;
    Trougao::t3.first = t3.first;
    Trougao::t3.second = t3.second;
}
void Trougao::Postavi(int indeks, const Tacka &amp;t) {
    if(indeks &gt; 3 || indeks &lt; 1) throw range_error("Nekorektan indeks");
    if(indeks == 1) {
        if(Orijentacija(t,t2,t3)==0) throw domain_error("Nekorektne pozicije tjemena");
        t1.first=t.first;
        t1.second = t.second;
    }
    else if(indeks == 2) { 
        if(Orijentacija(t1,t,t3)==0) throw domain_error("Nekorektne pozicije tjemena");
        t2.first=t.first;
        t2.second = t.second;
    }
    else{ 
        if(Orijentacija(t1,t2,t)==0) throw domain_error("Nekorektne pozicije tjemena");
        t3.first=t.first; 
        t3.second = t.second; 
    }
}
Tacka Trougao::DajTjeme(int indeks) const {
     if(indeks == 1) return t1;
     else if(indeks == 2) return t2;
     else return t3;
}
double Trougao::DajStranicu(int indeks) const {
    if(indeks == 1) return sqrt((t2.first - t3.first)*(t2.first - t3.first) + (t2.second - t3.second)*(t2.second - t3.second)); 
</font><a name="5"></a><font color="#FF0000"><a href="match74-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    else if(indeks == 2) return sqrt((t1.first - t3.first)*(t1.first - t3.first) + (t1.second - t3.second)*(t1.second - t3.second));
    else return sqrt((t1.first - t2.first)*(t1.first - t2.first) + (t1.second - t2.second)*(t1.second - t2.second));
}
double Trougao::DajUgao(int indeks) const {
    double alfa, beta, gama;
    double a=sqrt((t2.first - t3.first)*(t2.first - t3.first) + (t2.second - t3.second)*(t2.second - t3.second)); 
</font>    double b=sqrt((t1.first - t3.first)*(t1.first - t3.first) + (t1.second - t3.second)*(t1.second - t3.second));
<a name="3"></a><font color="#00FFFF"><a href="match74-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_9.gif"/></a>

    double c=sqrt((t1.first - t2.first)*(t1.first - t2.first) + (t1.second - t2.second)*(t1.second - t2.second));
    alfa=acos((b*b + c*c - a*a)/(2*b*c));
    beta=acos((a*a + c*c - b*b)/(2*a*c));
    gama=acos((a*a + b*b - c*c)/(2*a*b));
    if(indeks == 1) return alfa;
    else if(indeks == 2) return beta;
    else return gama;
}
Tacka Trougao::DajCentar() const {
    Tacka centar;
    centar.first=(t1.first+t2.first+t3.first)/3;
    centar.second=(t1.second+t2.second+t3.second)/3;
    return centar;
}
double Trougao::DajObim() const {
    return (DajStranicu(1) + DajStranicu(2) + DajStranicu(3));
}
bool Trougao::DaLiJeUnutra(const Tacka &amp;t) const {
    if(Orijentacija(t1,t2,t3)==Orijentacija(t1,t2,t) &amp;&amp; Orijentacija(t1,t2,t3)==Orijentacija(t2,t3,t) &amp;&amp; Orijentacija(t1,t2,t3)==Orijentacija(t3,t1,t))
    return true;
    else return false;
}
void Trougao::Transliraj(double delta_x, double delta_y) {
    t1.first+=delta_x;
    t1.second+=delta_y;
    t2.first+=delta_x;
    t2.second+=delta_y;
    t3.first+=delta_x;
    t3.second+=delta_y;
}
void Trougao::Centriraj(const Tacka &amp;t) {
    Tacka A=DajCentar();
    double deltaX=t.first - A.first;
    double deltaY=t.second - A.second;
    Transliraj(deltaX, deltaY);
    
}
void Trougao::Rotiraj(const Tacka &amp;t, double ugao) {
    t1.first=(t.first + (t1.first - t.first)*cos(ugao) - (t1.second - t.second)*sin(ugao));
</font>    t2.first=(t.first + (t2.first - t.first)*cos(ugao) - (t2.second - t.second)*sin(ugao));
    t3.first=(t.first + (t3.first - t.first)*cos(ugao) - (t3.second - t.second)*sin(ugao));
    t1.second=(t.second + (t1.first - t.first)*sin(ugao) + (t1.second - t.second)*cos(ugao));
    t2.second=(t.second + (t2.first - t.first)*sin(ugao) + (t2.second - t.second)*cos(ugao));
<a name="7"></a><font color="#0000FF"><a href="match74-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    t3.second=(t.second + (t3.first - t.first)*sin(ugao) + (t3.second - t.second)*cos(ugao));
}
void Trougao::Skaliraj(const Tacka &amp;t, double faktor) {
    double k=faktor;
    if(abs(faktor)&lt;0.0001) throw domain_error("Nekorektan faktor skaliranja");
    t1.first=(t.first + k*(t1.first - t.first));
    t2.first=(t.first + k*(t2.first - t.first));
</font>    t3.first=(t.first + k*(t3.first - t.first));
    t1.second=(t.second + k*(t1.second - t.second));
    t2.second=(t.second + k*(t2.second - t.second));
<a name="8"></a><font color="#00FFFF"><a href="match74-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    t3.second=(t.second + k*(t3.second - t.second));
}
void Trougao::Rotiraj(double ugao) {
    Tacka A = DajCentar();
    t1.first=(A.first + (t1.first - A.first)*cos(ugao) - (t1.second - A.second)*sin(ugao));
</font>    t2.first=(A.first + (t2.first - A.first)*cos(ugao) - (t2.second - A.second)*sin(ugao));
    t3.first=(A.first + (t3.first - A.first)*cos(ugao) - (t3.second - A.second)*sin(ugao));
    t1.second=(A.second + (t1.first - A.first)*sin(ugao) + (t1.second - A.second)*cos(ugao));
    t2.second=(A.second + (t2.first - A.first)*sin(ugao) + (t2.second - A.second)*cos(ugao));
<a name="6"></a><font color="#00FF00"><a href="match74-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    t3.second=(A.second + (t3.first - A.first)*sin(ugao) + (t3.second - A.second)*cos(ugao));
}
void Trougao::Skaliraj(double faktor) {
    double k=faktor;
    if(abs(faktor)&lt;0.0001) throw domain_error("Nekorektan faktor skaliranja");
    Tacka A = DajCentar();
    t1.first=(A.first + k*(t1.first - A.first));
    t2.first=(A.first + k*(t2.first - A.first));
</font>    t3.first=(A.first + k*(t3.first - A.first));
    t1.second=(A.second + k*(t1.second - A.second));
<a name="0"></a><font color="#FF0000"><a href="match74-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_25.gif"/></a>

    t2.second=(A.second + k*(t2.second - A.second));
    t3.second=(A.second + k*(t3.second - A.second));
}
bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2) {
    Tacka x1=t1.t1, y1=t1.t2, z1=t1.t3, x2=t2.t1, y2=t2.t2, z2=t2.t3;
    if((x1==x2 || x1==y2 || x1==z2) &amp;&amp; (y1==x2 || y1==y2 || y1==z2) &amp;&amp; (z1==x2 || z1==y2 || z1==z2))
    return true;
    return false;
}
bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2) {
    if(Trougao::Jednako(3,4)) return true;
    double a,b,c,e,f,g;
    a=t1.DajStranicu(1);
    b=t1.DajStranicu(2);
    c=t1.DajStranicu(3);
    e=t2.DajStranicu(1);
    f=t2.DajStranicu(2);
    g=t2.DajStranicu(3);
    vector&lt;double&gt; v1{a,b,c}, v2{e,f,g};
    sort(v1.begin(), v1.end());
    sort(v2.begin(), v2.end());
    const double epsilon=(1e-10);
    double x(v1[0]/v2[0]), y(v1[1]/v2[1]), z(v1[2]/v2[2]);
    return (x&gt;=(y-epsilon) &amp;&amp;x&lt;=(y+epsilon) &amp;&amp; y&gt;=(z-epsilon) &amp;&amp; y&lt;=(z+epsilon));
}
int main ()
{
    cout&lt;&lt;"Koliko zelite kreirati trouglova: ";
    int n;
    cin&gt;&gt;n;
    vector&lt;shared_ptr&lt;Trougao&gt;&gt; vec;
    for(int i = 0 ; i &lt; n ; i++)
    {
        ponovo:
        cout&lt;&lt;"Unesite podatke za "&lt;&lt;i+1&lt;&lt;". trougao (x1 y1 x2 y2 z1 z2): ";
        double x,y,z,a,b,c;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        Tacka x1=make_pair(x,y), y1=make_pair(z,a), z1=make_pair(b,c);
        try {
            shared_ptr&lt;Trougao&gt; pok(new Trougao(x1,y1,z1));
            vec.push_back(pok);
        }
        catch(bad_alloc izuzetak1)
        {
            cout&lt;&lt;"Nema dovoljno memorije";
        }
        catch(domain_error izuzetak)
        {
            cout&lt;&lt;izuzetak.what()&lt;&lt;", ponovite unos!"&lt;&lt;endl;
            goto ponovo;
        }
    }
    cout&lt;&lt;"Unesite vektor translacije (dx dy): ";
    double d1,d2;
    cin&gt;&gt;d1&gt;&gt;d2;
    cout&lt;&lt;"Unesite ugao rotacije: ";
    double ugao;
    cin&gt;&gt;ugao;
    cout&lt;&lt;"Unesite faktor skaliranja: ";
    double f;
    cin&gt;&gt;f;
    transform(vec.begin(), vec.end(), vec.begin(), [d1,d2,ugao,f] (shared_ptr&lt;Trougao&gt; pok) {
        pok-&gt;Transliraj(d1,d2);
        pok-&gt;Rotiraj(ugao);
        pok-&gt;Skaliraj(pok-&gt;DajTjeme(1), f);
        return pok;
    });
    sort(vec.begin(), vec.end(), [] (shared_ptr&lt;Trougao&gt; pok1, shared_ptr&lt;Trougao&gt; pok2) {
        return pok1-&gt;DajPovrsinu()&lt;pok2-&gt;DajPovrsinu();
    });
    cout&lt;&lt;"Trouglovi nakon obavljenih transformacija: "&lt;&lt;endl;
    for_each(vec.begin(), vec.end(), [](shared_ptr&lt;Trougao&gt; pok) {
        pok-&gt;Ispisi(); 
        cout&lt;&lt;endl;
    });
    auto min=min_element(vec.begin(), vec.end(), [] (shared_ptr&lt;Trougao&gt; pok1, shared_ptr&lt;Trougao&gt; pok2) {
        return pok1-&gt;DajObim() &lt; pok2-&gt;DajObim();
    });
    cout&lt;&lt;"Trougao sa najmanjin obimom";
    (*min)-&gt;Ispisi();
    cout&lt;&lt;endl;
    int br=0;
    cout&lt;&lt;"Parovi identicnih trouglova: "&lt;&lt;endl;
    for(int i = 0 ; i &lt; n ; i++)
    {
        for(int j = i + 1 ; j &lt; n ; j++)
        {
            if(DaLiSuIdenticni(*vec[i], *vec[j]) == true) {
                br++;
                if(br &gt; 0) {
                vec[i]-&gt;Ispisi(); 
                cout&lt;&lt;" i "; 
                vec[j]-&gt;Ispisi(); cout&lt;&lt;endl;
                }
            }
        }
    }
    if(br==0) cout&lt;&lt;"Nema identicnih trouglova!"&lt;&lt;endl;
    int br1=0;
    cout&lt;&lt;"Parovi podudarnih trouglova: "&lt;&lt;endl;
    for(int i = 0 ; i &lt; n ; i++)
    {
        for(int j = i + 1 ; j &lt; n ; j++)
        {
            if(DaLiSuPodudarni(*vec[i], *vec[j]) == true) {
                br1++;
                if(br1 &gt; 0) {
                vec[i]-&gt;Ispisi(); 
                cout&lt;&lt;" i "; 
                vec[j]-&gt;Ispisi(); cout&lt;&lt;endl;
                }
            }
        }
    }
    if(br1==0) cout&lt;&lt;"Nema podudarnih trouglova!"&lt;&lt;endl;
    int br2=0;
    cout&lt;&lt;"Parovi slicnih trouglova: "&lt;&lt;endl;
    for(int i = 0 ; i &lt; n ; i++)
    {
        for(int j = i + 1 ; j &lt; n ; j++)
        {
            if(DaLiSuSlicni(*vec[i], *vec[j]) == true) {
                br2++;
                if(br2 &gt; 0) {
                vec[i]-&gt;Ispisi(); 
                cout&lt;&lt;" i "; 
                vec[j]-&gt;Ispisi(); cout&lt;&lt;endl;
                }
            }
        }
    }
    if(br2==0) cout&lt;&lt;"Nema slicnih trouglova!"&lt;&lt;endl;
    return 0;
</font>}</pre>
</body>
</html>
