<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student6956.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student6956.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

#define EPS 0.001

using namespace std;

typedef pair&lt;double, double&gt; Tacka;

bool IstiDouble(const double a, const double b){
    return fabs(a - b) &lt; EPS;
}

class Trougao {
private:
    Tacka t1, t2, t3;
    void ProvjeriIndex(int n) const { if(n &lt; 1 || n &gt; 3) throw range_error("Nekorektan indeks"); }
    double DajStranicu(Tacka t1, Tacka t2) const;
public:
    Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    void Postavi(int indeks, const Tacka &amp;t);
    static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
    Tacka DajTjeme(int indeks) const;
    double DajStranicu(int indeks) const;
    double DajUgao(int indeks) const;
    Tacka DajCentar() const;
    double DajObim() const;
    double DajPovrsinu() const;
    bool DaLiJePozitivnoOrijentiran() const;
    bool DaLiJeUnutra(const Tacka &amp;t) const;
    void Ispisi() const;
    void Transliraj(double delta_x, double delta_y);
    void Centriraj(const Tacka &amp;t);
    void Rotiraj(const Tacka &amp;t, double ugao);
    void Skaliraj(const Tacka &amp;t, double faktor);
    void Rotiraj(double ugao);
    void Skaliraj(double faktor);
    friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2);
    friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);
};

Trougao::Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    if(Orijentacija(t1, t2, t3) == 0) throw domain_error("Nekorektne pozicije tjemena");
    this-&gt;t1 = t1; this-&gt;t2 = t2; this-&gt;t3 = t3;
}

void Trougao::Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    if(Orijentacija(t1, t2, t3) == 0) throw domain_error("Nekorektne pozicije tjemena");
    this-&gt;t1 = t1; this-&gt;t2 = t2; this-&gt;t3 = t3;
}

void Trougao::Postavi(int index, const Tacka &amp;t){
    ProvjeriIndex(index);
    if(index == 1) Orijentacija(t, t2, t3), t1 = t;
    else if(index == 2) Orijentacija(t1, t, t3), t2 = t;
    else if(index == 3) Orijentacija(t1, t2, t), t3 = t;
}

int Trougao::Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    double rez = t1.first * (t2.second - t3.second) - t2.first * (t1.second - t3.second) + t3.first * (t1.second - t2.second);
    return rez &lt; 0 ? -1 : rez &gt; 0 ? 1 : 0;
}

void Trougao::Ispisi() const {
    cout &lt;&lt; "((" &lt;&lt; t1.first &lt;&lt; "," &lt;&lt; t1.second &lt;&lt; "),(" &lt;&lt; t2.first &lt;&lt; "," &lt;&lt; t2.second &lt;&lt; "),(" &lt;&lt; t3.first &lt;&lt; "," &lt;&lt; t3.second &lt;&lt; "))";
}

Tacka Trougao::DajTjeme(int indeks) const {
    ProvjeriIndex(indeks);
    return indeks == 1 ? t1 : indeks == 2 ? t2 : t3;
}

double Trougao::DajStranicu(Tacka t1, Tacka t2) const {
    return sqrt((t1.first - t2.first) * (t1.first - t2.first) + (t1.second - t2.second) * (t1.second - t2.second));
}

double Trougao::DajStranicu(int indeks) const {
    ProvjeriIndex(indeks);
    return indeks == 1 ? DajStranicu(t2, t3) : indeks == 2 ? DajStranicu(t1, t3) : DajStranicu(t1, t2);
}

double Trougao::DajUgao(int indeks) const {
    ProvjeriIndex(indeks);
    double a = DajStranicu(1);
    double b = DajStranicu(2);
    double c = DajStranicu(3);
    return indeks == 1 ? acos((b * b + c * c - a * a) / (2 * b * c)) : indeks == 2 ? acos((a * a + c * c - b * b) / (2 * a * c)) : acos((b * b + a * a - c * c) / (2 * b * a));
}

Tacka Trougao::DajCentar() const {
    return Tacka((t1.first + t2.first + t3.first) / 3, (t1.second + t2.second + t3.second) / 3);
}

void Trougao::Transliraj(double delta_x, double delta_y){
    t1 = {t1.first + delta_x, t1.second + delta_y};
    t2 = {t2.first + delta_x, t2.second + delta_y};
    t3 = {t3.first + delta_x, t3.second + delta_y};
}

void Trougao::Centriraj(const Tacka &amp;t){
    Transliraj(t.first - DajCentar().first, t.second - DajCentar().second);
}

void Trougao::Rotiraj(const Tacka &amp;t, double ugao){
<a name="0"></a><font color="#FF0000"><a href="match935-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    t1 = { t.first + (t1.first - t.first) * cos(ugao) - (t1.second - t.second) * sin(ugao), t.second + (t1.first - t.first) * sin(ugao) + (t1.second - t.second) * cos(ugao) };
    t2 = { t.first + (t2.first - t.first) * cos(ugao) - (t2.second - t.second) * sin(ugao), t.second + (t2.first - t.first) * sin(ugao) + (t2.second - t.second) * cos(ugao) };
</font><a name="1"></a><font color="#00FF00"><a href="match935-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    t3 = { t.first + (t3.first - t.first) * cos(ugao) - (t3.second - t.second) * sin(ugao), t.second + (t3.first - t.first) * sin(ugao) + (t3.second - t.second) * cos(ugao) };
</font><a name="2"></a><font color="#0000FF"><a href="match935-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    
</font>}

void Trougao::Skaliraj(const Tacka &amp;t, double faktor){
    if(IstiDouble(faktor, 0)) throw domain_error("Nekorektan faktor skaliranja");
<a name="6"></a><font color="#00FF00"><a href="match935-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    t1 = { t.first + faktor * (t1.first - t.first), t.second + faktor * (t1.second - t.second) };
    t2 = { t.first + faktor * (t2.first - t.first), t.second + faktor * (t2.second - t.second) };
</font><a name="7"></a><font color="#0000FF"><a href="match935-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

    t3 = { t.first + faktor * (t3.first - t.first), t.second + faktor * (t3.second - t.second) };
</font>}

void Trougao::Rotiraj(double ugao){
    Rotiraj(DajCentar(), ugao); 
}

void Trougao::Skaliraj(double faktor){
    Skaliraj(DajCentar(), faktor);
}

bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2){
    for(int i(1); i &lt;= 3; i++){
        bool isteTacke(false);
        for(int j(1); j &lt;=3; j++)
            if(IstiDouble(t1.DajTjeme(i).first, t2.DajTjeme(j).first) &amp;&amp; IstiDouble(t1.DajTjeme(i).second, t2.DajTjeme(j).second))
                isteTacke = true;
        if(!isteTacke) return false;
    }
    return true;
}

bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2){
    list&lt;string&gt; prviTip { "vvm", "vmv", "mvv" }; //prvi tip trougla; v = veca, m = manja
    list&lt;string&gt; drugiTip { "vmm", "mmv", "mvm" }; //drugi tip trougla
    string prvi, drugi; //u "prvi" smjestamo odnose od prvog trougla, objasnjenje za "drugi" je logicno
    for(int i(1); i &lt;= 3; i++){
        int j = i == 3 ? 1 : i + 1;
        if(t1.Orijentacija(t1.DajTjeme(1), t1.DajTjeme(2), t1.DajTjeme(3)) == 1)
            //ako nije pozitivna orijentacija moramo obrnuti logiku (mjenja se znak poredjenja)
            prvi += t1.DajStranicu(i) &gt; t1.DajStranicu(j) || IstiDouble(t1.DajStranicu(i), t1.DajStranicu(j)) ? "v" : "m";
        else prvi += t1.DajStranicu(i) &lt; t1.DajStranicu(j) || IstiDouble(t1.DajStranicu(i), t1.DajStranicu(j)) ? "v" : "m";
        if(t2.Orijentacija(t2.DajTjeme(1), t2.DajTjeme(2), t2.DajTjeme(3)) == 1)
            drugi += t2.DajStranicu(i) &gt; t2.DajStranicu(j) || IstiDouble(t2.DajStranicu(i), t2.DajStranicu(j)) ? "v" : "m";
        drugi += t2.DajStranicu(i) &lt; t2.DajStranicu(j) || IstiDouble(t2.DajStranicu(i), t2.DajStranicu(j)) ? "v" : "m";
    }
    auto it1 = find(prviTip.begin(), prviTip.end(), prvi); // gledamo kojeg je tipa trougao
    auto it2 = find(prviTip.begin(), prviTip.end(), drugi);
    if((it1 != prviTip.end() &amp;&amp; it2 == prviTip.end()) || (it1 == prviTip.end() &amp;&amp; it2 != prviTip.end())) return false;
    //dakle, ako oba trougla nisu istog tipa nisu podudarni
    //ako su istog tipa onda provjeravamo da li imaju iste duzine stranica
    list&lt;double&gt; str1 { t1.DajStranicu(1), t1.DajStranicu(2), t1.DajStranicu(3) }, str2 { t2.DajStranicu(1), t2.DajStranicu(2), t2.DajStranicu(3) };
    for(auto it3 = str1.begin(); it3 != str1.end(); it3++){
        auto it4 = find_if(str2.begin(), str2.end(), [it3](double n){
            return IstiDouble(*it3, n);
        });
        if(it4 == str2.end()) return false;
        str2.erase(it4); //ukoliko smo nasli istu stranicu u oba trougla, izbrisacemo jednu(od drugog trougla) iz liste jer jbg
    }
    return true;
}
bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2){
    list&lt;string&gt; prviTip { "vvm", "vmv", "mvv" }; //prvi tip trougla; v = veca, m = manja
    list&lt;string&gt; drugiTip { "vmm", "mmv", "mvm" }; //drugi tip trougla
    string prvi, drugi; //u "prvi" smjestamo odnose od prvog trougla, objasnjenje za "drugi" je logicno
    for(int i(1); i &lt;= 3; i++){
        int j = i == 3 ? 1 : i + 1;
        if(t1.Orijentacija(t1.DajTjeme(1), t1.DajTjeme(2), t1.DajTjeme(3)) == 1)
            //ako nije pozitivna orijentacija moramo obrnuti logiku (mjenja se znak poredjenja)
            prvi += t1.DajStranicu(i) &gt; t1.DajStranicu(j) || IstiDouble(t1.DajStranicu(i), t1.DajStranicu(j)) ? "v" : "m";
        else prvi += t1.DajStranicu(i) &lt; t1.DajStranicu(j) || IstiDouble(t1.DajStranicu(i), t1.DajStranicu(j)) ? "v" : "m";
        if(t2.Orijentacija(t2.DajTjeme(1), t2.DajTjeme(2), t2.DajTjeme(3)) == 1)
            drugi += t2.DajStranicu(i) &gt; t2.DajStranicu(j) || IstiDouble(t2.DajStranicu(i), t2.DajStranicu(j)) ? "v" : "m";
        drugi += t2.DajStranicu(i) &lt; t2.DajStranicu(j) || IstiDouble(t2.DajStranicu(i), t2.DajStranicu(j)) ? "v" : "m";
    }
    auto it1 = find(prviTip.begin(), prviTip.end(), prvi); // gledamo kojeg je tipa trougao
    auto it2 = find(prviTip.begin(), prviTip.end(), drugi);
    if((it1 != prviTip.end() &amp;&amp; it2 == prviTip.end()) || (it1 == prviTip.end() &amp;&amp; it2 != prviTip.end())) return false;
    //dakle, ako oba trougla nisu istog tipa nisu podudarni
    //ako su istog tipa onda provjeravamo da li imaju iste uglove
    list&lt;double&gt; uglovi1 { t1.DajUgao(1), t1.DajUgao(2), t1.DajUgao(3) }, uglovi2 { t2.DajUgao(1), t2.DajUgao(2), t2.DajUgao(3) };
    for(auto it3 = uglovi1.begin(); it3 != uglovi1.end(); it3++){
        auto it4 = find_if(uglovi2.begin(), uglovi2.end(), [it3](double n){
           return IstiDouble(*it3, n); 
        });
        if(it4 == uglovi2.end()) return false;
        uglovi2.erase(it4);
    }
    return true;
}

double Trougao::DajObim() const {
    return DajStranicu(1) + DajStranicu(2) + DajStranicu(3);
}

double Trougao::DajPovrsinu() const {
    return 0.5 * fabs(t1.first * (t2.second - t3.second) - t2.first * (t1.second - t3.second) + t3.first * (t1.second - t2.second));
}

bool Trougao::DaLiJePozitivnoOrijentiran() const {
    return Orijentacija(t1, t2, t3) == 1 ? true : false;
}

bool Trougao::DaLiJeUnutra(const Tacka &amp;t) const {
    int temp(Orijentacija(t1, t2, t3));
    return temp == Orijentacija(t1, t2, t) &amp;&amp; temp == Orijentacija(t2, t3, t3) &amp;&amp; temp == Orijentacija(t3, t2, t);
}

int main(){
    try{
        int n;
        cout &lt;&lt; "Koliko zelite kreirati trouglova: ";
        cin &gt;&gt; n;
        vector&lt;shared_ptr&lt;Trougao&gt;&gt; v(n);
        for(int i(1); i &lt;= n;){
            cout &lt;&lt; "Unesite podatke za " &lt;&lt; i &lt;&lt; ". trougao (x1 y1 x2 y2 x3 y3): ";
            vector&lt;Tacka&gt; tacke;
            for(int j(1); j &lt;= 3; j++){
                double x, y;
                cin &gt;&gt; x &gt;&gt; y;
                tacke.push_back({x, y});
            }
            Trougao* t;
            try{
                t = new Trougao(tacke[0], tacke[1], tacke[2]);
                v[i - 1] = make_shared&lt;Trougao&gt; (*t);
                i++;
                t = nullptr;
            }catch(exception &amp;e){
                cout &lt;&lt; e.what() &lt;&lt; ", ponovite unos!" &lt;&lt; endl;
                delete t;
            }
        }
        double delta_x, delta_y;
        cout &lt;&lt; "Unesite vektor translacije(dx i dy): ";
        cin &gt;&gt; delta_x &gt;&gt; delta_y;
        double ugaoRotacije, faktorSkaliranja;
        cout &lt;&lt; "Unesite ugao rotacije: ";
        cin &gt;&gt; ugaoRotacije;
        cout &lt;&lt; "Unesite faktor skaliranja: ";
        cin &gt;&gt; faktorSkaliranja;
        
        transform(v.begin(), v.end(), v.begin(), [=](shared_ptr&lt;Trougao&gt; t){
           t-&gt;Transliraj(delta_x, delta_y);
           t-&gt;Rotiraj(ugaoRotacije);
           t-&gt;Skaliraj(t-&gt;DajTjeme(1), faktorSkaliranja);
           return t;
        });
        
        sort(v.begin(), v.end(), [](shared_ptr&lt;Trougao&gt; t1, shared_ptr&lt;Trougao&gt; t2){
            return t1-&gt;DajPovrsinu() &lt; t2-&gt;DajPovrsinu();
        });
        cout &lt;&lt; "Trouglovi nakon obavljenih transformacija: " &lt;&lt; endl;
        for_each(v.begin(), v.end(), [](shared_ptr&lt;Trougao&gt; t) {
           t-&gt;Ispisi(); cout &lt;&lt; endl;
        });
        cout &lt;&lt; "Trougao sa najmanjim obimom: ";
        (**max_element(v.begin(), v.end(), [](shared_ptr&lt;Trougao&gt; t1, shared_ptr&lt;Trougao&gt; t2){
            return t1-&gt;DajObim() &gt; t2-&gt;DajObim();
        })).Ispisi();
        cout &lt;&lt; endl;
        bool postoji(false);
        for(int i(0); i &lt; (int)v.size(); i++){
            for(int j(i + 1); j &lt; (int)v.size(); j++){
                if(DaLiSuIdenticni(*v[i], *v[j])){
                    postoji = true; 
                    break;
                }
            }
        }
        if(!postoji) cout &lt;&lt; "Nema identicnih trouglova!" &lt;&lt; endl;
        else{
            cout &lt;&lt; "Parovi identicnih trouglova:" &lt;&lt; endl;
            for(int i(0); i &lt; (int)v.size(); i++){
<a name="3"></a><font color="#00FFFF"><a href="match935-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

                for(int j(i + 1); j &lt; (int)v.size(); j++){
                    if(DaLiSuIdenticni(*v[i], *v[j])){
                        v[i]-&gt;Ispisi(); cout &lt;&lt; " i "; v[j]-&gt;Ispisi(); cout &lt;&lt; endl;
</font>                    }
                }
            }
        }
        postoji = false;
        
        for(int i(0); i &lt; (int)v.size(); i++){
            for(int j(i + 1); j &lt; (int)v.size(); j++){
                if(DaLiSuPodudarni(*v[i], *v[j])){
                    postoji = true; 
                    break;
                }
            }
        }
        if(!postoji) cout &lt;&lt; "Nema podudarnih trouglova!" &lt;&lt; endl;
        else{
            cout &lt;&lt; "Parovi podudarnih trouglova:" &lt;&lt; endl;
            for(int i(0); i &lt; (int)v.size(); i++){
<a name="4"></a><font color="#FF00FF"><a href="match935-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

                for(int j(i + 1); j &lt; (int)v.size(); j++){
                    if(DaLiSuPodudarni(*v[i], *v[j])){
                        v[i]-&gt;Ispisi(); cout &lt;&lt; " i "; v[j]-&gt;Ispisi(); cout &lt;&lt; endl;
</font>                    }
                }
            }
        }
        postoji = false;
        for(int i(0); i &lt; (int)v.size(); i++){
            for(int j(i + 1); j &lt; (int)v.size(); j++){
                if(DaLiSuSlicni(*v[i], *v[j])){
                    postoji = true; 
                    break;
                }
            }
        }
        if(!postoji) cout &lt;&lt; "Nema slicnih trouglova!" &lt;&lt; endl;
        else{
            cout &lt;&lt; "Parovi slicnih trouglova:" &lt;&lt; endl;
            for(int i(0); i &lt; (int)v.size(); i++){
<a name="5"></a><font color="#FF0000"><a href="match935-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

                for(int j(i + 1); j &lt; (int)v.size(); j++){
                    if(DaLiSuSlicni(*v[i], *v[j])){
                        v[i]-&gt;Ispisi(); cout &lt;&lt; " i "; v[j]-&gt;Ispisi(); cout &lt;&lt; endl;
</font>                    }
                }
            }
        }
        
    }catch(exception &amp;e){
        cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what() &lt;&lt; endl;
    }
    return 0;
}</pre>
</body>
</html>
