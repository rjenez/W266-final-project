<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student7970.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student5713.cpp<p></p><pre>
/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include&lt;iomanip&gt;
#include &lt;utility&gt;
const double epsilon (1e-10);

using namespace std;

typedef pair&lt;double, double&gt; Tacka;
const double PI=atan(1)*4;

class Trougao{
    Tacka A, B, C;
    double UdaljenostIzmedju2Tacke(const Tacka &amp;t1, const Tacka &amp;t2)const{
        return sqrt((t2.first-t1.first)*(t2.first-t1.first)+(t2.second-t1.second)*(t2.second-t1.second));
    }
    
    
    double  a=UdaljenostIzmedju2Tacke(B, C);
    double  b=UdaljenostIzmedju2Tacke(A, C);
    double  c=UdaljenostIzmedju2Tacke(A, B);
    void TestirajIndeks(int n){
        if(n&lt;1 || n&gt;3) throw range_error("Nekorektan indeks");
    }
    void TestirajIndeks(int n)const{
        if(n&lt;1 || n&gt;3) throw range_error("Nekorektan indeks");
    }
/*
    
    double Izraz ( Tacka t1,  Tacka t2,  Tacka t3){
        return (t1.first*(t2.second-t3.second)-t2.first*(t1.second-t3.second)+t3.first*(t1.second-t2.second));
    }
    */
    double Izraz (const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3)const{
       return (t1.first*(t2.second-t3.second)-t2.first*(t1.second-t3.second)+t3.first*(t1.second-t2.second));
    }
    
    double Kosinusna_Teroema(int indeks)const{
        TestirajIndeks(indeks);
      
        double prva, druga, treca;
        if(indeks==1)   { prva=b; druga=c; treca=a;}
        else if(indeks==2)  { prva=a; druga=c; treca=b;}
        else {prva=a; druga=b; treca=c;}
        return acos((prva*prva+druga*druga-treca*treca)/(2*prva*druga));
    }
    
public:
Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
   // if(((t2.first-t1.first)*(t3.second-t1.second)-(t2.second-t1.second)*(t3.first -t1.first))&lt;epsilon)
   if(Orijentacija(t1, t2, t3)==0)
    throw domain_error("Nekorektne pozicije tjemena");
    A=t1;
    B=t2;
    C=t3;
    
}

void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
     if((t2.first-t1.first)*(t3.second-t1.second)-(t2.second-t1.second)*(t3.first -t1.first)&lt;epsilon)
    throw domain_error("Nekorektne pozicije tjemena");
    A=t1;
    B=t2;
    B=t3;
}

void Postavi(int indeks, const Tacka &amp;t){
    TestirajIndeks(indeks);
    if(indeks==1) A=t;
    else if(indeks==2) B=t;
    else C=t;
       if((B.first-A.first)*(C.second-A.second)-(B.second-A.second)*(C.first -A.first)&lt;epsilon)
    throw domain_error("Nekorektne pozicije tjemena");
}

static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3){
    double povratna(0);
    //povratna=Izraz(t1,t2,t3); sto mi ovo nije radiloo
    povratna=t1.first*(t2.second-t3.second)-t2.first*(t1.second-t3.second)+t3.first*(t1.second-t2.second);
    if(povratna ==0) return 0;
    else if(povratna&gt;0) return 1;
    return -1;
}

Tacka DajTjeme(int indeks) const{
    TestirajIndeks(indeks);
    if(indeks==1) return A;
    else if(indeks==2) return B;
    else return C;
}

double DajStranicu(int indeks) const{
    TestirajIndeks(indeks);
    double duzina;
    if(indeks==1) duzina=UdaljenostIzmedju2Tacke(B, C);
    else if(indeks==2) duzina=UdaljenostIzmedju2Tacke(C, A);
    else duzina=UdaljenostIzmedju2Tacke(A, B);
    return duzina;
}

double DajUgao(int indeks) const{
    TestirajIndeks(indeks);
    double ugao=Kosinusna_Teroema(indeks);
    ugao=ugao*PI/180;
    return ugao;
}

Tacka DajCentar() const{
    Tacka nova;
    nova.first=A.first+B.first+C.first;
    nova.first/=3;
    nova.second=A.second+B.second+C.second;
    nova.second/=3;
    return nova;
}

Tacka DajPrvu ()const{
    return A;
}
Tacka DajDrugu()const {
    return B;
}
double DajObim() const{
    return a+b+c;
}
double DajPovrsinu() const{
    double vr_izraza=Izraz(A, B, C);
    if(vr_izraza&lt;0) vr_izraza=-vr_izraza;
    return vr_izraza/2;
}

bool DaLiJePozitivnoOrijentiran() const{
    if(Orijentacija((*this).A, (*this).B, (*this).C)==1) return 1;
    return 0;

}
bool DaLiJeUnutra(const Tacka &amp;t) const;

void Ispisi() const{
    cout&lt;&lt;"(("&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;A.first&lt;&lt;","&lt;&lt;A.second&lt;&lt;")"&lt;&lt;",("&lt;&lt;B.first&lt;&lt;","&lt;&lt;B.second&lt;&lt;")"&lt;&lt;",("&lt;&lt;C.first&lt;&lt;","&lt;&lt;C.second&lt;&lt;"))"; 
}

void Transliraj(double delta_x, double delta_y){
    A.first+=delta_x; B.first+=delta_x; C.first+=delta_x;
    A.second+=delta_y; B.second+=delta_y; C.second+=delta_y;
}

void Centriraj(const Tacka &amp;t){
    Tacka teziste=DajCentar();
    double udaljenost=teziste.first- t.first;
    if(udaljenost&lt;0) udaljenost=-udaljenost;
    double udaljenost2=teziste.second-t.second;
    if(udaljenost2&lt;0) udaljenost2=-udaljenost2;
    Transliraj(udaljenost, udaljenost2 );
}

void Rotiraj(const Tacka &amp;t, double ugao){
   // if(ugao==0) return;
<a name="6"></a><font color="#00FF00"><a href="match988-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_0.gif"/></a>

    double temp=A.first;
    A.first=t.first+(A.first-t.first)*cos(ugao)-(A.second-t.second)*sin(ugao);
</font>    //je li ovdje treba sad ova stara vr. A.first
    A.second=t.second+(temp-t.first)*sin(ugao)+(A.second-t.second)*cos(ugao);
    
    temp=B.first;
    B.first=t.first+(B.first-t.first)*cos(ugao)-(B.second-t.second)*sin(ugao);
    B.second=t.second+(temp-t.first)*sin(ugao)+(B.second-t.second)*cos(ugao);
    
    temp=C.first;
    C.first=t.first+(C.first-t.first)*cos(ugao)-(C.second-t.second)*sin(ugao);
<a name="5"></a><font color="#FF0000"><a href="match988-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_0.gif"/></a>

    C.second=t.second+(temp-t.first)*sin(ugao)+(C.second-t.second)*cos(ugao);
    
}

void Skaliraj(const Tacka &amp;t, double faktor){
    if(faktor-0&lt;epsilon) throw domain_error("Nekorektan faktor skaliranja");
</font>    
    A.first=t.first+faktor*(A.first-t.first);
    A.second=t.second+faktor*(A.second-t.second);
    
    B.first=t.first+faktor*(B.first-t.first);
    B.second=t.second+faktor*(B.second-t.second);
    
    C.first=t.first+faktor*(C.first-t.first);
    C.second=t.second+faktor*(C.second-t.second);
    
    if(faktor&lt;0) Rotiraj(180);
}



void Rotiraj(double ugao){
  //  if(ugao-0&lt;epsilon) return;
    Tacka t=DajCentar();
    Rotiraj(t, ugao);
    
}
void Skaliraj(double faktor){
     if(faktor-0&lt;epsilon) throw domain_error("Nekorektan faktor skaliranja");
    Tacka t=DajCentar();
   Skaliraj(t, faktor);
}

friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2){
<a name="7"></a><font color="#0000FF"><a href="match988-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_0.gif"/></a>

if((t1.A==t2.A &amp;&amp; t1.B==t2.B &amp;&amp; t1.C==t2.C)
|| (t1.A==t2.A &amp;&amp; t1.B==t2.C &amp;&amp; t1.C==t2.B)
</font><a name="8"></a><font color="#00FFFF"><a href="match988-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_0.gif"/></a>

|| (t1.A==t2.B &amp;&amp; t1.B==t2.A &amp;&amp; t1.C==t2.C)
|| (t1.A==t2.B &amp;&amp; t1.B==t2.C &amp;&amp; t1.C==t2.A)
</font><a name="9"></a><font color="#FF00FF"><a href="match988-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_0.gif"/></a>

|| (t1.A==t2.C &amp;&amp; t1.B==t2.A &amp;&amp; t1.C==t2.B)
|| (t1.A==t2.C &amp;&amp; t1.B==t2.B &amp;&amp; t1.C==t2.A))return 1;
</font>return 0;
}

friend bool DaLiSuPodudarni( const Trougao &amp;t1,const Trougao &amp;t2){
double prvi=t1.DajUgao(1);
double drugi=t1.DajUgao(2);
double treci=t1.DajUgao(3);
double prviprim=t2.DajUgao(1);
double drugiprim=t2.DajUgao(2);
double treciprim=t2.DajUgao(3);
double a1=t1.UdaljenostIzmedju2Tacke(t1.DajTjeme(1), t1.DajTjeme(2));
double a2=t1.UdaljenostIzmedju2Tacke(t1.DajTjeme(2), t1.DajTjeme(3));
double a3=t1.UdaljenostIzmedju2Tacke(t1.DajTjeme(3), t1.DajTjeme(1));

double a10=t2.UdaljenostIzmedju2Tacke(t2.DajTjeme(1), t2.DajTjeme(2));
double a20=t2.UdaljenostIzmedju2Tacke(t2.DajTjeme(2), t2.DajTjeme(3));
double a30=t2.UdaljenostIzmedju2Tacke(t2.DajTjeme(3), t2.DajTjeme(1));

if((a1==a10 || a1==a20 || a1==a30) &amp;&amp; (a2==a10 || a2==a20 || a2==a30) &amp;&amp; (a3==a10 || a3==a20 || a3==a30)){
vector&lt;pair&lt;double, Tacka&gt;&gt; vek, vek2;
vek.push_back(make_pair(prvi, t1.DajTjeme(1)));
vek.push_back(make_pair(drugi, t1.DajTjeme(2)));
vek.push_back(make_pair(treci, t1.DajTjeme(3)));
<a name="0"></a><font color="#FF0000"><a href="match988-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

sort(vek.begin(), vek.end(), [](pair&lt;double, Tacka&gt; x, pair&lt;double, Tacka&gt; y){
    return x.first&lt;y.first;
});

vek2.push_back(make_pair(prviprim, t2.DajTjeme(1)));
</font>vek2.push_back(make_pair(drugiprim, t2.DajTjeme(2)));
vek2.push_back(make_pair(treciprim, t2.DajTjeme(3)));
<a name="1"></a><font color="#00FF00"><a href="match988-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

sort(vek2.begin(), vek2.end(), [](pair&lt;double, Tacka&gt; x, pair&lt;double, Tacka&gt; y){
    return x.first&lt;y.first;
});

return t1.Orijentacija(vek[0].second, vek[1].second, vek[2].second)==t2.Orijentacija(vek2[0].second, vek2[1].second, vek2[2].second);
</font>}

 return 0;
 
 
  //  sort(v1.begin(), v1.end());
    //sort(v2.begin(), v2.end()); v1==v2
   // return testna &amp;&amp; !(Orijentacija(t1.A, t1.B, t1.C)==Orijentacija(t2.A, t2.B,t2.C));
}

friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2){
 double prvi=t1.DajUgao(1);
double drugi=t1.DajUgao(2);
double treci=t1.DajUgao(3);
double prviprim=t2.DajUgao(1);
double drugiprim=t2.DajUgao(2);
double treciprim=t2.DajUgao(3); 

vector&lt;pair&lt;double, Tacka&gt;&gt; vek, vek2;
vek.push_back(make_pair(prvi, t1.DajTjeme(1)));
vek.push_back(make_pair(drugi, t1.DajTjeme(2)));
vek.push_back(make_pair(treci, t1.DajTjeme(3)));
<a name="2"></a><font color="#0000FF"><a href="match988-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

sort(vek.begin(), vek.end(), [](pair&lt;double, Tacka&gt; x, pair&lt;double, Tacka&gt; y){
    return x.first&lt;y.first;
});

vek2.push_back(make_pair(prviprim, t2.DajTjeme(1)));
</font>vek2.push_back(make_pair(drugiprim, t2.DajTjeme(2)));
vek2.push_back(make_pair(treciprim, t2.DajTjeme(3)));
<a name="3"></a><font color="#00FFFF"><a href="match988-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

sort(vek2.begin(), vek2.end(), [](pair&lt;double, Tacka&gt; x, pair&lt;double, Tacka&gt; y){
    return x.first&lt;y.first;
});

return t1.Orijentacija(vek[0].second, vek[1].second, vek[2].second)==t2.Orijentacija(vek2[0].second, vek2[1].second, vek2[2].second);
</font>}


bool ImajuLiDvaJednakaUgla(const Trougao &amp;t1,const Trougao &amp;t2)const{
    if ((t1.DajUgao(1)==t2.DajUgao(1) &amp;&amp; (t1.DajUgao(2)==t2.DajUgao(2) || t1.DajUgao(2)==t2.DajUgao(3)))
    || (t1.DajUgao(1)==t2.DajUgao(2) &amp;&amp; (t1.DajUgao(2)==t2.DajUgao(1) || t1.DajUgao(2)==t2.DajUgao(3)))
    || (t1.DajUgao(1)==t2.DajUgao(3) &amp;&amp; (t1.DajUgao(2)==t2.DajUgao(1) || t1.DajUgao(2)==t2.DajUgao(3)) ))return 1;
    return 0;
}
};

double UdaljenostIzmedju2Tackee( Tacka &amp;t1,  Tacka &amp;t2){
        return sqrt((t2.first-t1.first)*(t2.first-t1.first)+(t2.second-t1.second)*(t2.second-t1.second));
    }


int main ()
{
    cout&lt;&lt;"Koliko zelite kreirati trouglova: ";
    int n;
    cin&gt;&gt;n;
    try{
    vector&lt;shared_ptr&lt;Trougao&gt;&gt; vek;
    double a0, a1, b0, b1, c0, c1;
    shared_ptr&lt;Trougao&gt; pok;
    for(int i=0; i&lt;n; i++){
        cout&lt;&lt;"Unesite podatke za "&lt;&lt;i+1&lt;&lt;" trougao (x1 y1 x2 y2 x3 y3): ";
        cin&gt;&gt;a0&gt;&gt;a1&gt;&gt;b0&gt;&gt;b1&gt;&gt;c0&gt;&gt;c1;
        
        Tacka prva, druga, treca;
        prva.first=a0; prva.second=a1;
        druga.first=b0; druga.second=b1;
        treca.first=c0; treca.second=c1;
        //Trougao novi(prva, druga, treca);
        try{Trougao novi(prva, druga, treca);
          
        
        pok=make_shared&lt;Trougao&gt;(novi);
        vek.push_back(pok);
        
        }
        catch(...){
            cout&lt;&lt;"Nekorektne pozicije tjemena, ponovite unos!\n"; i--; 
        }
   
       
    }
    cout&lt;&lt;"Unesite vektor translacije (dx dy): ";
    double dx, dy;
    cin&gt;&gt;dx&gt;&gt; dy;
    
    cout&lt;&lt;"Unesite ugao rotacije: ";
    double ugao;
    cin&gt;&gt;ugao;
    
    cout&lt;&lt;"Unesite faktor skaliranja: ";
    double faktor;
    cin&gt;&gt;faktor;
    

    transform(vek.begin(), vek.end(), vek.begin(), [dx, dy, ugao, faktor](shared_ptr&lt;Trougao&gt;&amp;a){
        a-&gt;Transliraj(dx, dy);
      //  a-&gt;Rotiraj(ugao);
    //    a-&gt;Skaliraj(faktor);
        return a;
    }
    );
    /*
      cout&lt;&lt;"\n\nprije rotacije\n";
     for_each(vek.begin(), vek.end(), []( shared_ptr&lt;Trougao&gt; &amp;a){
        a-&gt;Ispisi();
        cout&lt;&lt;endl;
    });*/
    
     transform(vek.begin(), vek.end(), vek.begin(), [dx, dy, ugao, faktor](shared_ptr&lt;Trougao&gt;&amp;a){
        a-&gt;Rotiraj(ugao);
        return a;
         
     });      
     /*
          cout&lt;&lt;"\n\nprije translacije\n";
     for_each(vek.begin(), vek.end(), []( shared_ptr&lt;Trougao&gt; &amp;a){
        a-&gt;Ispisi();
        cout&lt;&lt;endl;
    }); 
    */
    transform(vek.begin(), vek.end(), vek.begin(), [dx, dy, ugao, faktor](shared_ptr&lt;Trougao&gt;&amp;a){
        a-&gt;Skaliraj(a-&gt;DajPrvu(), faktor); 
<a name="4"></a><font color="#FF00FF"><a href="match988-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        return a;}
    );
    /*
    cout&lt;&lt;"\n\nprije sort\n";
     for_each(vek.begin(), vek.end(), []( shared_ptr&lt;Trougao&gt; &amp;a){
        a-&gt;Ispisi();
        cout&lt;&lt;endl;
    });*/
    sort(vek.begin(), vek.end(), [](shared_ptr&lt;Trougao&gt; a, shared_ptr&lt;Trougao&gt; b){
        return a-&gt;DajPovrsinu()&lt;b-&gt;DajPovrsinu();
        
        
    });
    
    cout&lt;&lt;"\nTrouglovi nakon obavljenih transformacija: \n";
</font>    for_each(vek.begin(), vek.end(), []( shared_ptr&lt;Trougao&gt; &amp;a){
        a-&gt;Ispisi();
        cout&lt;&lt;endl;
    });
    
    vector&lt;shared_ptr&lt;Trougao&gt;&gt; temp=vek, novi;
    auto poki=min_element(vek.begin(), vek.end(), [](const shared_ptr&lt;Trougao&gt; &amp;a, const shared_ptr&lt;Trougao&gt; &amp;b){
        if(a-&gt;DajObim()&lt;b-&gt;DajObim()) return true;
        return false;
    });
    shared_ptr&lt;Trougao&gt; pokili=vek[0];
    for(int i=0; i&lt;vek.size(); i++){
        if(vek[i]-&gt;DajObim()&lt;pokili-&gt;DajObim()) 
        pokili=vek[i];
    }
    cout&lt;&lt;"Trougao sa najmanjim obimom: ";
    pokili-&gt;Ispisi();
    //pokii-&gt;Ispisi();
    
    vek=temp;
    cout&lt;&lt;"\nParovi identicnih trouglova: \n";
    vector&lt;shared_ptr&lt;Trougao&gt;&gt; novi2;
    for(int i=0; i&lt;vek.size(); i++){
        for(int j=i+1; j&lt;vek.size(); j++){
            if(DaLiSuIdenticni(*vek[i], *vek[j])) {
                novi.push_back(vek[i]);
                novi2.push_back(vek[j]);
        }
    }}
    
    for(int i=0; i&lt;novi.size(); i++) {novi[i]-&gt;Ispisi(); cout&lt;&lt;" i "; novi2[i]-&gt;Ispisi();if(i!=novi.size()-1) cout&lt;&lt;endl;}

    vek=temp;
    novi.resize(0);
    novi2.resize(0);
    cout&lt;&lt;"\nParovi podudarnih trouglova: \n";
      for(int i=0; i&lt;vek.size(); i++){
        for(int j=i+1; j&lt;vek.size(); j++){
            if(DaLiSuPodudarni(*vek[i], *vek[j])) {
                novi.push_back(vek[i]);
                novi2.push_back(vek[j]);
        }
    }}
    
    for(int i=0; i&lt;novi.size(); i++) {
        novi[i]-&gt;Ispisi(); cout&lt;&lt;" i "; novi2[i]-&gt;Ispisi(); cout&lt;&lt;endl;}
 
    vek=temp;
    cout&lt;&lt;"\nParovi slicnih trouglova: \n";
     vek=temp;
    novi.resize(0);
    
      for(int i=0; i&lt;vek.size(); i++){
        for(int j=i+1; j&lt;vek.size(); j++){
            if(DaLiSuSlicni(*vek[i], *vek[j])) novi.push_back(vek[i]);
        }
    }
    
    for(int i=0; i&lt;novi.size(); i++) {novi[i]-&gt;Ispisi(); cout&lt;&lt;endl;}

    
    }
    catch(...){
        cout&lt;&lt;"greska";
    }
    
  //:( Ich bin ziemlich traurig... It s not the point to know math for programming, it s not a part of tp.
  
  // we are losing our time on searching some teorems... we should concentrate on implementation of this 'gradivo'...
    
	return 0;
}</pre>
</body>
</html>
