<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student5370.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z4/Z1/student7173.cpp<p></p><pre>
<a name="3"></a><font color="#00FFFF"><a href="match129-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

/B 2016/2017, ZadaÄ‡a 4, Zadatak 1
//Napomena: testovi ce biti dostupni dan pred rok!

#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

using std::cout;
using std::cin;
using std::pair;
using std::domain_error;
using std::range_error;
using std::abs;
</font>using std::make_pair;
using std::endl;
using std::sort;
<a name="2"></a><font color="#0000FF"><a href="match129-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

using std::vector;
using std::shared_ptr;
using std::make_shared;
using std::transform;
using std::for_each;
using std::min_element;

const double Eps = 1E-10;

typedef pair&lt;double, double&gt; Tacka;

class Trougao {
    Tacka t1, t2, t3;
    
    public :
        Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
        void Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
</font>        void Postavi(int indeks, const Tacka &amp;t);
        
        static int Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3);
        
        Tacka DajTjeme(int indeks) const;
        double DajStranicu(int indeks) const;
        double DajUgao(int indeks) const;
        Tacka DajCentar() const;
        double DajObim() const;
        double DajPovrsinu() const;
        
        bool DaLiJePozitivnoOrijentiran() const;
        bool DaLiJeUnutra(const Tacka &amp;t) const;
        
        void Ispisi() const;
        void Transliraj(double delta_x, double delta_y);
        void Centriraj(const Tacka &amp;t);
        void Rotiraj(const Tacka &amp;t, double faktor);
        void Skaliraj(const Tacka &amp;t, double ugao);
        void Rotiraj(double ugao);
        void Skaliraj(double faktor);
        
        friend bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2);
<a name="1"></a><font color="#00FF00"><a href="match129-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_26.gif"/></a>

        friend bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2);
        friend bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2);
};

// JesuLiJednaki
bool JLJ(double x, double y) {
    if ((x &lt; 0 &amp;&amp; y &gt; 0) || (x &gt; 0 &amp;&amp; y &lt; 0))
        return false;
    return (abs(x - y) &lt;= Eps * (abs(x) + abs(y)));
}

bool Jednake(const Tacka &amp;t1, const Tacka &amp;t2)
{
    return (JLJ(t1.first, t2.first) &amp;&amp; JLJ(t1.second, t2.second));
}

Trougao::Trougao(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3)
{
    Postavi(t1, t2, t3);
}

void Trougao::Postavi(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3)
{
    if (!Orijentacija(t1, t2, t3))
        throw domain_error("Nekorektne pozicije tjemena");
    Trougao::t1 = t1; Trougao::t2 = t2; Trougao::t3 = t3;
}

void Trougao::Postavi(int indeks, const Tacka &amp;t)
{
    if (indeks == 1)
        Postavi(t, t2, t3);
    else if(indeks == 2)
        Postavi(t1, t, t3);
    else if(indeks == 3)
        Postavi(t1, t2, t);
    else
        throw range_error("Nekorektan indeks");
}

// TODO: zapisati da smo DetVrhova morali implementirati iznad Orijentacija?
double DetVrhova(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3) {
    return t1.first*(t2.second - t3.second) + t2.first*(t3.second - t1.second) +
        t3.first*(t1.second - t2.second);
}

int Trougao::Orijentacija(const Tacka &amp;t1, const Tacka &amp;t2, const Tacka &amp;t3)
{
    double determinanta(DetVrhova(t1, t2, t3));
    return (determinanta &gt; 0) - (determinanta &lt; 0);
}

Tacka Trougao::DajTjeme(int indeks) const
{
    if (indeks == 1)
        return t1;
    else if(indeks == 2)
        return t2;
    else if(indeks == 3)
        return t3;
    else
        throw range_error("Nekorektan indeks");
}

// Racuna duzinu (neusmjerene) duzi t1-t2
double Duzina(const Tacka &amp;t1, const Tacka &amp;t2) {
    return sqrt(pow(t1.first - t2.first, 2) + pow(t1.second - t2.second, 2));
}

double Trougao::DajStranicu(int indeks) const
{
    if (indeks == 1)
        return Duzina(t2, t3);
    else if(indeks == 2)
        return Duzina(t1, t3);
    else if(indeks == 3)
        return Duzina(t1, t2);
    else
        throw range_error("Nekorektan indeks");
}

// Racuna ugao bac
double Ugao(const Tacka &amp;a, const Tacka &amp;b, const Tacka &amp;c)
{
    Tacka ab = make_pair(b.first - a.first, b.second - a.second);
    Tacka ac = make_pair(c.first - a.first, c.second - a.second);
    double duz_b = Duzina(ab, make_pair&lt;double, double&gt;(0, 0));
    double duz_c = Duzina(ac,  make_pair&lt;double, double&gt;(0, 0));
    
    return acos((ab.first*ac.first + ab.second*ac.second) / (duz_b * duz_c)); // (ab1/duzb)*(ac1/duzc) + (ab2...
}

double Trougao::DajUgao(int indeks) const
{
    if (indeks == 1)
        return Ugao(t1, t2, t3);
    else if(indeks == 2)
        return Ugao(t2, t1, t3);
    else if(indeks == 3)
        return Ugao(t3, t1, t2);
    else
        throw range_error("Nekorektan indeks");
}

// TODO: upisati u predavanje 8b ako ne moramo eksplicitno specificirati tipove para
Tacka Trougao::DajCentar() const {
    return make_pair((t1.first + t2.first + t3.first) / 3,
        (t1.second + t2.second + t3.second) / 3);
}

double Trougao::DajObim() const {
    return DajStranicu(1) + DajStranicu(2) + DajStranicu(3);
}

double Trougao::DajPovrsinu() const {
    return abs(DetVrhova(t1, t2, t3) / 2);
}

bool Trougao::DaLiJePozitivnoOrijentiran() const {
    return Orijentacija(t1, t2, t3) &gt; 0;
}

bool Trougao::DaLiJeUnutra(const Tacka &amp;t) const
{
    int broj(Orijentacija(t1, t2, t));
    return (broj != 0 &amp;&amp; broj == Orijentacija(t2, t3, t) &amp;&amp; 
        broj == Orijentacija(t3, t1, t));
}

void Trougao::Ispisi() const {
    cout &lt;&lt; "((" &lt;&lt; t1.first &lt;&lt; "," &lt;&lt; t1.second &lt;&lt; "),(" &lt;&lt; t2.first &lt;&lt; "," &lt;&lt;
</font>        t2.second &lt;&lt; "),(" &lt;&lt; t3.first &lt;&lt; "," &lt;&lt; t3.second &lt;&lt; "))";
}

void Trougao::Transliraj(double delta_x, double delta_y)
{
    t1.first += delta_x; t2.first += delta_x; t3.first += delta_x;
<a name="0"></a><font color="#FF0000"><a href="match129-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_61.gif"/></a>

    t1.second += delta_y; t2.second += delta_y; t3.second += delta_y;
}

void Trougao::Centriraj(const Tacka &amp;t)
{
    Tacka centar(DajCentar());
    Transliraj(t.first - centar.first, t.second - centar.second);
}

void Trougao::Rotiraj(const Tacka &amp;t, double ugao)
{
    double x(t.first), y(t.second);
    t1.first = (x + (t1.first - x)*cos(ugao) - (t1.second - y)*sin(ugao));
    t1.second = (y + (t1.second - y)*cos(ugao) + (t1.first - x)*sin(ugao));
    t2.first = (x + (t2.first - x)*cos(ugao) - (t2.second - y)*sin(ugao));
    t2.second = (y + (t2.second - y)*cos(ugao) + (t2.first - x)*sin(ugao));
    t3.first = (x + (t3.first - x)*cos(ugao) - (t3.second - y)*sin(ugao));
    t3.second = (y + (t3.second - y)*cos(ugao) + (t3.first - x)*sin(ugao));
}

void Trougao::Rotiraj(double ugao) {
    Rotiraj(DajCentar(), ugao);
}

void Trougao::Skaliraj(const Tacka &amp;t, double faktor)
{
    if (!faktor)
        throw domain_error("Nekorektan faktor skaliranja");
    t1 = make_pair(t.first + faktor*(t1.first - t.first), 
        t.second + faktor*(t1.second - t.second));
    t2 = make_pair(t.first + faktor*(t2.first - t.first), 
        t.second + faktor*(t2.second - t.second));
    t3 = make_pair(t.first + faktor*(t3.first - t.first), 
        t.second + faktor*(t3.second - t.second));
}

void Trougao::Skaliraj(double faktor)
{
    if (!faktor)
        throw domain_error("Nekorektan faktor skaliranja");
    Skaliraj(DajCentar(), faktor);
}

bool DaLiSuIdenticni(const Trougao &amp;t1, const Trougao &amp;t2)
{
    if (Jednake(t1.t1, t2.t1)) {
        if (Jednake(t1.t2, t2.t2)) {
            if (Jednake(t1.t3, t2.t3)) {
                return true;
            }
        } else if (Jednake(t1.t2, t2.t3)) {
            if (Jednake(t1.t3, t2.t2)) {
                return true;
            }
        }
    } else if (Jednake(t1.t1, t2.t2)) {
        if (Jednake(t1.t2, t2.t1)) {
            if (Jednake(t1.t3, t2.t3)) {
                return true;
            }
        } else if (Jednake(t1.t2, t2.t3)) {
            if (Jednake(t1.t3, t2.t1)) {
                return true;
            }
        }
    } else if (Jednake(t1.t1, t2.t3)) {
        if (Jednake(t1.t2, t2.t1)) {
            if (Jednake(t1.t3, t2.t2)) {
                return true;
            }
        } else if (Jednake(t1.t2, t2.t2)) {
            if (Jednake(t1.t3, t2.t1)) {
                return true;
            }
        }
    }

    return false;
}

bool DaLiSuPodudarni(const Trougao &amp;t1, const Trougao &amp;t2)
{
    double duzine1[3] = {Duzina(t1.t1, t1.t2), Duzina(t1.t2, t1.t3), 
        Duzina(t1.t3, t1.t1)};
    double duzine2[3] = {Duzina(t2.t1, t2.t2), Duzina(t2.t2, t2.t3),
        Duzina(t2.t3, t2.t1)};
    sort(duzine1, duzine1 + 3);
    sort(duzine2, duzine2 + 3);
    
    if (JLJ(duzine1[0], duzine2[0]) &amp;&amp; JLJ(duzine1[1], duzine2[1]) &amp;&amp;
        JLJ(duzine1[2], duzine1[2])) {
        if (JLJ(duzine1[0], duzine1[1]) || JLJ(duzine1[0], duzine1[2]) ||
            JLJ(duzine1[1], duzine1[2]))
                return true;
        else {
            double duz1 = Duzina(t1.t1, t1.t2), duz2 = Duzina(t1.t2, t1.t3);
            bool cond = (Trougao::Orijentacija(t1.t1, t1.t2, t1.t3) == 
                Trougao::Orijentacija(t2.t1, t2.t2, t2.t3));
            duzine2[0] = Duzina(t2.t1, t2.t2);
            duzine2[1] = Duzina(t2.t2, t2.t3);
            duzine2[2] = Duzina(t2.t3, t2.t1);
            
         
            if (JLJ(duz1, duzine2[0])) {
                if (JLJ(duz2, duzine2[1])) {
                    return cond;
                } else if (JLJ(duz2, duzine2[2])) {
                    return !cond;
                }
            } else if(JLJ(duz1, duzine2[1])) {
                if (JLJ(duz2, duzine2[2])) {
                    return cond;
                } else if(JLJ(duz2, duzine2[0])) {
                    return !cond ;
                }
            } else if (JLJ(duz1, duzine2[2])) {
                if (JLJ(duz2, duzine2[0])) {
                    return cond;
                } else {
                    return !cond;
                }
            }
        }
    }
    
    return false;
}

bool DaLiSuSlicni(const Trougao &amp;t1, const Trougao &amp;t2)
{
    double duzine1[3] = {Duzina(t1.t1, t1.t2), Duzina(t1.t2, t1.t3), 
        Duzina(t1.t3, t1.t1)};
    double duzine2[3] = {Duzina(t2.t1, t2.t2), Duzina(t2.t2, t2.t3),
        Duzina(t2.t3, t2.t1)};
    sort(duzine1, duzine1 + 3);
    sort(duzine2, duzine2 + 3);
    
    double prop(duzine1[0] / duzine2[0]);
    if (JLJ(prop, duzine1[1] / duzine2[1]) &amp;&amp; JLJ(prop, duzine1[2] / duzine2[2])) {
        Tacka druga1(t2.t1), druga2(t2.t2), druga3(t2.t3);
        return DaLiSuPodudarni(t1, {make_pair(druga1.first * prop, druga1.second * prop),
            make_pair(druga2.first * prop, druga2.second * prop), 
            make_pair(druga3.first * prop, druga3.second * prop)});
    }
    
    return false;
}

int main ()
{
    int n;
    cout &lt;&lt; "Koliko zelite kreirati trouglova: ";
    cin &gt;&gt; n;
    vector&lt;shared_ptr&lt;Trougao&gt;&gt; trouglovi(n);
    
    for(int i = 0; i &lt; n; i++) {
        bool cond(true);
        double x1, y1, x2, y2, x3, y3;
        while (cond) {
            cout &lt;&lt; "Unesite podatke za " &lt;&lt; i + 1 &lt;&lt;". trougao (x1 y1 x2 y2 x3 y3): ";
            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3;
            try {
                trouglovi[i] = make_shared&lt;Trougao&gt;(Trougao(make_pair(x1, y1), 
                    make_pair(x2, y2), make_pair(x3, y3)));
                cond = false;
            } catch(domain_error &amp;e) {
                cout &lt;&lt; e.what() &lt;&lt; ", ponovite unos!" &lt;&lt; std::endl;
            }
        }
    }
    
    double dx, dy, ugao, faktor; 
    cout &lt;&lt; "Unesite vektor translacije (dx dy): ";
    cin &gt;&gt; dx &gt;&gt; dy;
    cout &lt;&lt; "Unesite ugao rotacije: ";
    cin &gt;&gt; ugao;
    cout &lt;&lt; "Unesite faktor skaliranja: ";
    cin &gt;&gt; faktor;
    
    try {    
        transform(trouglovi.begin(), trouglovi.end(), trouglovi.begin(), [dx, dy, ugao, faktor](shared_ptr&lt;Trougao&gt; p) {
            p-&gt;Transliraj(dx, dy);
            p-&gt;Rotiraj(p-&gt;DajCentar(), ugao);
            p-&gt;Skaliraj(p-&gt;DajTjeme(1), faktor);
            return p;
        });
    } catch(domain_error &amp;ex) {
        cout &lt;&lt; ex.what();
        return 0;
    }
    
    sort(trouglovi.begin(), trouglovi.end(), [](shared_ptr&lt;Trougao&gt; p1, shared_ptr&lt;Trougao&gt; p2) {
        return p1-&gt;DajPovrsinu() &lt; p2-&gt;DajPovrsinu();
    });
    cout &lt;&lt; "Trouglovi nakon obavljenih transformacija:" &lt;&lt; endl;
    for_each(trouglovi.begin(), trouglovi.end(), [](shared_ptr&lt;Trougao&gt; p) {
        p-&gt;Ispisi();
        cout &lt;&lt; endl;
    });
    
    cout &lt;&lt; "Trougao sa najmanjim obimom: ";
    (*(min_element(trouglovi.begin(), trouglovi.end(), [](shared_ptr&lt;Trougao&gt; p1, shared_ptr&lt;Trougao&gt; p2) {
        return p1-&gt;DajObim() &lt; p2-&gt;DajObim();
    })))-&gt;Ispisi();

    // Ispisujemo sve identicne parove trouglova.
    cout &lt;&lt; endl;
    bool cond(true);
    for(int i = 0; i &lt; n; i++) {
        for(int j = i + 1; j &lt; n; j++) {
            if (DaLiSuIdenticni(*trouglovi[i], *trouglovi[j])) {
                if (cond) {
                    cout &lt;&lt; "Parovi identicnih trouglova:" &lt;&lt; endl;
                    cond = false;
                }
                trouglovi[i]-&gt;Ispisi();
                cout &lt;&lt; " i ";
                trouglovi[j]-&gt;Ispisi();
                cout &lt;&lt; endl;
            }
        }
    }
    if (cond)
        cout &lt;&lt; "Nema identicnih trouglova!" &lt;&lt; endl;

    // Ispisujemo sve podudarne parove trouglova.    
    cond =true;
    for(int i = 0; i &lt; n; i++) {
        for(int j = i + 1; j &lt; n; j++) {
            if (DaLiSuPodudarni(*trouglovi[i], *trouglovi[j])) {
                if (cond) {
                    cout &lt;&lt; "Parovi podudarnih trouglova:" &lt;&lt; endl;
                    cond = false;
                }
                trouglovi[i]-&gt;Ispisi();
                cout &lt;&lt; " i ";
                trouglovi[j]-&gt;Ispisi();
                cout &lt;&lt; endl;
            }
        }
    }
    if (cond)
        cout &lt;&lt; "Nema podudarnih trouglova!" &lt;&lt; endl;

    // Ispisujemo sve slicne parove trouglova.    
    cond =true;
    for(int i = 0; i &lt; n; i++) {
        for(int j = i + 1; j &lt; n; j++) {
            if (DaLiSuSlicni(*trouglovi[i], *trouglovi[j])) {
                if (cond) {
                    cout &lt;&lt; "Parovi slicnih trouglova:" &lt;&lt; endl;
                    cond = false;
                }
                trouglovi[i]-&gt;Ispisi();
                cout &lt;&lt; " i ";
                trouglovi[j]-&gt;Ispisi();
                cout &lt;&lt; endl;
            }
        }
    }
    if (cond)
        cout &lt;&lt; "Nema slicnih trouglova!";
</font>
	return 0;
}</pre>
</body>
</html>
