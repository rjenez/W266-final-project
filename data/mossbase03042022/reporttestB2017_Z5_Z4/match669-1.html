<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student3871.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student3485.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;initializer_list&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

const double PI = std::atan(1) * 4;

class FourierovRed {
    int stepen_polinoma;
    double period;
    double* koeficijenti_a;
    double* koeficijenti_b;
    double b_0;
public:
    FourierovRed(double, std::initializer_list&lt;double&gt;, std::initializer_list&lt;double&gt;);
    FourierovRed(int, double, std::function&lt;double(int)&gt;, std::function&lt;double(int)&gt;);
    FourierovRed(int, double, double, std::function&lt;double(double)&gt;, int);
    FourierovRed(const FourierovRed&amp;);
    FourierovRed(FourierovRed&amp;&amp;);
    FourierovRed&amp; operator =(const FourierovRed&amp;);
    FourierovRed&amp; operator =(FourierovRed&amp;&amp;);
    ~FourierovRed() { delete[] koeficijenti_a; delete[] koeficijenti_b; }
    double operator ()(double) const;
    std::pair&lt;double&amp;, double&amp;&gt; operator [](int);
    const std::pair&lt;double, double&gt; operator[](int) const;
};

FourierovRed::FourierovRed(double T, std::initializer_list&lt;double&gt; a, std::initializer_list&lt;double&gt; b) {
    this -&gt; period = T;
    int stepen_a = a.size() - 1;
    int stepen_b = b.size();
    int veci = (stepen_a &gt;= stepen_b) ? stepen_a : stepen_b;
    veci += 1;
    koeficijenti_a = new double[veci];
    koeficijenti_b = new double[veci];
    int i = 0;
    for(auto it = a.begin(); it != a.end(); it++, i++) {
        koeficijenti_a[i] = *it;
    }
    for(int j = i; j &lt; veci; j++) {
        koeficijenti_a[j] = 0;
    }
    i = 1;
    if(a.size() || b.size() != 0)
        koeficijenti_b[0] = 0;
    for(auto it = b.begin(); it != b.end(); it++, i++) {
        koeficijenti_b[i] = *it;
    }
    for(int j = i; j &lt; veci; j++) {
        koeficijenti_b[j] = 0;
    }
    
    this -&gt; stepen_polinoma = veci - 1;
}

<a name="1"></a><font color="#00FF00"><a href="match669-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

FourierovRed::FourierovRed(int N, double T, std::function&lt;double(int)&gt; f1, std::function&lt;double(int)&gt; f2) {
    if(N &lt; 1)
        throw std::domain_error("Stepen mora biti pozitivan");
</font>    this -&gt; stepen_polinoma = N;
    this -&gt; period = T;
    
    koeficijenti_a = new double[stepen_polinoma + 1];
    for(int i = 0; i &lt; stepen_polinoma + 1; i++)
        koeficijenti_a[i] = f1(i);
        
    koeficijenti_b = new double[stepen_polinoma + 1];
    koeficijenti_b[0] = 0;
    for(int i = 1; i &lt; stepen_polinoma + 1; i++)
        koeficijenti_b[i] = f2(i);
}

<a name="0"></a><font color="#FF0000"><a href="match669-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

FourierovRed::FourierovRed(int N, double p, double q, std::function&lt;double(double)&gt; f, int M) {
    if(N &lt; 1)
        throw std::domain_error("Stepen mora biti pozitivan");
    if(M &lt; 1)
        throw std::domain_error("Broj podintervala mora biti pozitivan");
    if(p &gt;= q)
        throw std::range_error("Neispravan interval");
</font>    this -&gt; stepen_polinoma = N;
    this -&gt; period = q - p;
    
    koeficijenti_a = new double[stepen_polinoma + 1];
    for(int k = 0; k &lt; stepen_polinoma + 1; k++) {
        double izraz = ((f(p) + f(q)) / M) * std::cos((2 * k * p * PI) / period);
        double suma = 0;
        for(int i = 1; i &lt; M; i++) {
            suma += (f(p + ((period * i) / M)) * std::cos(2 * k * PI * (p / period + i / double(M))));
        }
        izraz += (2 / double(M)) * suma;
        koeficijenti_a[k] = izraz;
    }
    
    koeficijenti_b = new double[stepen_polinoma + 1];
    koeficijenti_b[0] = 0;
    for(int k = 1; k &lt; stepen_polinoma + 1; k++) {
        double izraz = ((f(p) + f(q)) / M) * std::sin((2 * k * p * PI) / period);
        double suma = 0;
        for(int i = 1; i &lt; M; i++) {
            suma += (f(p + ((period * i) / M)) * std::sin(2 * k * PI * (p / period + i / double(M))));
        }
        izraz += (2 / double(M)) * suma;
        koeficijenti_b[k] = izraz;
    }
}

FourierovRed::FourierovRed(const FourierovRed&amp; fourierovRed) {
    this -&gt; stepen_polinoma = fourierovRed.stepen_polinoma;
    this -&gt; period = fourierovRed.period;
    
    koeficijenti_a = new double[fourierovRed.stepen_polinoma + 1];
    for(int i = 0; i &lt; fourierovRed.stepen_polinoma + 1; i++)
        koeficijenti_a[i] = fourierovRed.koeficijenti_a[i];
        
    koeficijenti_b = new double[fourierovRed.stepen_polinoma + 1];
    for(int i = 0; i &lt; fourierovRed.stepen_polinoma + 1; i++)
        koeficijenti_b[i] = fourierovRed.koeficijenti_b[i];
}

FourierovRed::FourierovRed(FourierovRed&amp;&amp; fourierovRed) {
    this -&gt; stepen_polinoma = fourierovRed.stepen_polinoma;
    this -&gt; period = fourierovRed.period;
    this -&gt; koeficijenti_a = fourierovRed.koeficijenti_a;
    this -&gt; koeficijenti_b = fourierovRed.koeficijenti_b;
    fourierovRed.koeficijenti_a = nullptr;
    fourierovRed.koeficijenti_b = nullptr;
}

FourierovRed&amp; FourierovRed::operator =(const FourierovRed&amp; fourierovRed) {
    if(this == &amp;fourierovRed)
        return *this;
        
    delete[] koeficijenti_a;
    delete[] koeficijenti_b;
    
    this -&gt; stepen_polinoma = fourierovRed.stepen_polinoma;
    this -&gt; period = fourierovRed.period;
    
    koeficijenti_a = new double[fourierovRed.stepen_polinoma + 1];
    for(int i = 0; i &lt; fourierovRed.stepen_polinoma + 1; i++)
        koeficijenti_a[i] = fourierovRed.koeficijenti_a[i];
        
    koeficijenti_b = new double[fourierovRed.stepen_polinoma + 1];
    for(int i = 0; i &lt; fourierovRed.stepen_polinoma + 1; i++)
        koeficijenti_b[i] = fourierovRed.koeficijenti_b[i];
        
    return *this;
}

FourierovRed&amp; FourierovRed::operator =(FourierovRed&amp;&amp; fourierovRed) {
    if(this == &amp;fourierovRed)
        return *this;
    this -&gt; stepen_polinoma = fourierovRed.stepen_polinoma;
    this -&gt; period = fourierovRed.period;
    this -&gt; koeficijenti_a = fourierovRed.koeficijenti_a;
    this -&gt; koeficijenti_b = fourierovRed.koeficijenti_b;
    fourierovRed.koeficijenti_a = nullptr;
    fourierovRed.koeficijenti_b = nullptr;
    
    return *this;
}

double FourierovRed::operator ()(double x) const {
    double suma = 0;
    for(int k = 1; k &lt; stepen_polinoma + 1; k++) {
        suma += koeficijenti_a[k] * std::cos((2 * k * PI * x) / period);
        suma += koeficijenti_b[k] * std::sin((2 * k * PI * x) / period);
    }
    return koeficijenti_a[0] / 2. + suma;
}

std::pair&lt;double&amp;, double&amp;&gt; FourierovRed::operator [](int i) {
    if(i &lt; 0 || i &gt; stepen_polinoma)
        throw std::range_error("Neispravan indeks");
    double&amp; a_k = koeficijenti_a[i];
    b_0 = 0;
    double&amp; b_k = (i == 0) ? b_0 : koeficijenti_b[i];
    std::pair&lt;double&amp;, double&amp;&gt; k(a_k, b_k);
    return k;
}

const std::pair&lt;double, double&gt; FourierovRed::operator [](int i) const {
    if(i &lt; 0 || i &gt; stepen_polinoma)
        throw std::range_error("Neispravan indeks");
    return std::make_pair(koeficijenti_a[i], koeficijenti_b[i]);
}

int main() {
    int stepen = 50;
    double period = 2 * PI;
    int M = 1000;
    
    FourierovRed f1(stepen, period, [](int k) { return (k == 0) ? 8*PI*PI/3 : 4./(k*k); }, [](int k) { return -4*PI/k; });
    FourierovRed f2(stepen, 0, period, [](double x) { return x*x; }, M);
    
    std::cout &lt;&lt; "Aprox. koeficijenti vs stvarni koeficijenti: \n";
    for(int i = 0; i &lt;= stepen; i++) {
        std::cout &lt;&lt; f1[i].first &lt;&lt; ", " &lt;&lt; f1[i].second &lt;&lt; "         " &lt;&lt; f2[i].first &lt;&lt; ", " &lt;&lt; f2[i].second &lt;&lt; "\n";
    }
    
    int x = 3;
    std::cout &lt;&lt; "Vrijednost u tacki: " &lt;&lt; x &lt;&lt; ": " &lt;&lt; f1(x) &lt;&lt; "; " &lt;&lt; f2(x) &lt;&lt; "\n\n";
    
    //Ostale metode
    auto k1 = [](int k) { return (k == 0) ? 4 : 0; };
    auto k2 = [](int k) { return (k % 2 == 0) ? 4/(k*PI) : -4/(k*PI); };
    FourierovRed f3(50, 4, k1, k2);
    FourierovRed f4(7, {7, 7}, {7});
    f4 = std::move(f3); 
    f4 = std::move(f4); 
    FourierovRed f5(std::move(f4)); 
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4); 
    for(int i = 0; i &lt; 5; i++) {
        std::cout &lt;&lt; f5[i].first &lt;&lt; ", " &lt;&lt; f5[i].second &lt;&lt; "\n";
    }
    return 0;
}

</pre>
</body>
</html>
