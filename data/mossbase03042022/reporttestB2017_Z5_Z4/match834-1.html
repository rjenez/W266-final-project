<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student2267.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student4471.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;
#include &lt;cmath&gt;
#include &lt;functional&gt;
#include &lt;initializer_list&gt;


typedef std::initializer_list&lt;double&gt; Lista;
typedef std::function&lt;double(double)&gt; Fun;

class FourierovRed {
    int N;
    double T;
    double *ai, *bi;
    const double PI = 4*atan(1);
public:
    FourierovRed(double T, Lista l1, Lista l2);
    FourierovRed(int N, double T, Fun f1, Fun f2);
    FourierovRed(int N, double p, double q, Fun f, int M);
    FourierovRed(const FourierovRed &amp;red);
    FourierovRed(FourierovRed &amp;&amp;red);
    FourierovRed &amp;operator = (const FourierovRed &amp;red);
    FourierovRed &amp;operator = (FourierovRed &amp;&amp;red);
    ~FourierovRed() { delete [] ai; delete [] bi; }
    double operator () (double x) const;
    std::pair&lt;double &amp;, double &amp;&gt; operator [] (int k);
};

FourierovRed::FourierovRed(double T, Lista l1, Lista l2) : T(T) {
    N = l1.size() * (l1.size() &gt;= l2.size()) + l2.size() * (l2.size() &gt; l1.size()),
    ai = new double[N+1]{}; 
    try {
        bi = new double[N+1]{};
    }
    catch(...) {
        delete [] ai; throw;
    }
    auto it1(l1.begin()), it2(l2.begin());
    for (int i = 0; i &lt;= N; i++) {
        if (it1 != l1.end()) ai[i] = *it1++;
    //    else ai[i] = 0;
        if (it2 != l2.end()) bi[i] = *it2++;
    //    else bi[i] = 0;
    }
}

FourierovRed::FourierovRed(int N, double T, Fun f1, Fun f2) : N(N), T(T) {
    if (N &lt; 1) throw std::domain_error("Stepen mora biti pozitivan");
    ai = new double[N+1]{};
    try { bi = new double[N+1]{}; }
    catch(...) { delete [] ai; throw; }
    for (int i = 0; i &lt;= N; i++) {
        ai[i] = f1(i); bi[i] = f2(i);
    }
}

FourierovRed::FourierovRed(int N, double p, double q, Fun f, int M) : N(N), T(q-p) {
<a name="1"></a><font color="#00FF00"><a href="match834-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    if (N &lt; 1) throw std::domain_error("Stepen mora biti pozitivan");
    if (M &lt; 1) throw std::domain_error("Broj podintervala mora biti pozitivan");
    if (!(p&lt;q)) throw std::range_error("Neispravan interval");
    ai = new double[N+1]{};
</font>    try { bi = new double[N+1]{}; }
    catch (...) { delete [] ai; throw; }
    for (int k = 0; k &lt;= N; k++) {
        for (int i = 1; i &lt;= M-1; i++) {
            ai[k] += f(p + i*T/M)*cos(2*k*PI*(p/T + i/M));
            bi[k] += f(p + i*T/M)*sin(2*k*PI*(p/T + i/M));
        }
        ai[k] = 2*ai[k]/M + (f(p) + f(q))*cos(2*k*PI*p/T)/M;
        bi[k] = 2*bi[k]/M + (f(p) + f(q))*sin(2*k*PI*p/T)/M;
    }
}

FourierovRed::FourierovRed(const FourierovRed &amp;red) : N(red.N), T(red.T) {
    ai = new double[N]{};
    try { bi = new double[N]{}; }
    catch (...) { delete [] ai; throw; }
    for (int i = 0; i &lt; N; i++) {
        ai[i] = red.ai[i]; bi[i] = red.bi[i];
    }
}

double FourierovRed::operator() (double x) const {
    double rez(ai[0]/2);
    for (int i = 0; i &lt;= N; i++) 
        rez += ai[i]*cos(2*i*PI*x/T) + bi[i]*sin(2*i*PI*x/T);
    return rez;
}

<a name="0"></a><font color="#FF0000"><a href="match834-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

std::pair&lt;double &amp;, double &amp;&gt; FourierovRed::operator [] (int k) {
    if (k &lt; 0 || k &gt; N) throw std::range_error("Neispravan indeks");
    if (k == 0) return {ai[0], bi[0] = 0};
</font>    return {ai[k], bi[k]};
}



int main ()
{
    FourierovRed f(4, 4, [](int k) { if (k == 0) return 1.; return 1./k; }, [](int k) { return k-1; });
    auto x(f[2]);
    std::cout &lt;&lt; x.first;
	return 0;
}
</pre>
</body>
</html>
