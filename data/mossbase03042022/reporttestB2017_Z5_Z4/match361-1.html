<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student8789.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student5287.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;initializer_list&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;utility&gt;

using std::initializer_list;
using std::function;
using std::pair;

typedef function&lt;double(int)&gt; funkit;
typedef function&lt;double(double)&gt; funkd;

//Const
constexpr double pi = 4 * std::atan(1);

class FourierovRed{
    int stepen;
    double period;
    double *ak, *bk;
    
    double* Alloc(int n){
        return new double[n]{};
    }
    void DeAlloc(double* &amp;tod){
        delete[] tod;
        tod = nullptr;
    }
    void IzracunajKoef(double *koefi, int n, double p, double q, funkd f, int M, double periodicna(double));
public:
    FourierovRed(double T, initializer_list&lt;double&gt; a, initializer_list&lt;double&gt; b);
    FourierovRed(int n, double T, funkit f1, funkit f2);
    FourierovRed(int N, double p, double q, funkd f, int M);
    ~FourierovRed();
    
    FourierovRed(const FourierovRed &amp;fred);
    FourierovRed(FourierovRed &amp;&amp;fred);
    FourierovRed&amp; operator =(const FourierovRed &amp;fred);
    FourierovRed&amp; operator =(FourierovRed &amp;&amp;fred);
    
    double operator ()(double x);
    pair&lt;double&amp;, double&amp;&gt; operator [](int k);
    pair&lt;double, double&gt; operator [](int k) const;
};

FourierovRed::FourierovRed(double T, initializer_list&lt;double&gt; a, initializer_list&lt;double&gt; b){
    //Ttreba ovo +1, jer vjrv u init_listi prvi clan nije nula
    int max_size = std::max(a.size(), b.size()+1);
    
    ak = Alloc(max_size);
    bk = Alloc(max_size);
    
    std::copy(a.begin(), a.end(), ak);
    //Da li je bk[0] == 0?
    std::copy(b.begin(), b.end(), bk+1);
    
    stepen = max_size-1;
    period = T;
}

FourierovRed::FourierovRed(int n, double T, funkit f1, funkit f2){
    if(n &lt;= 0)
        throw std::domain_error("Stepen mora biti pozitivan");
    
    //Iako je nulti stepen, ima slobodni clan!
    ak = Alloc(n+1);
    bk = Alloc(n+1);
    
    stepen = n;
    period = T;
    
    for(int k = 0; k &lt;= n; k++)
        ak[k] = f1(k);
    //Da li je bk[0] == 0?
    for(int k = 1; k &lt;= n; k++)
        bk[k] = f2(k);
}

<a name="1"></a><font color="#00FF00"><a href="match361-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

FourierovRed::FourierovRed(int n, double p, double q, funkd f, int M){
    if(n &lt;= 0)
        throw std::domain_error("Stepen mora biti pozitivan");
    if(M &lt;= 0)
        throw std::domain_error("Broj podintervala mora biti pozitivan");
    if(p &gt;= q)
        throw std::range_error("Neispravan interval");
</font>    
    ak = Alloc(n+1);
    bk = Alloc(n+1);
    
    stepen = n;
    period = q - p;
    
    IzracunajKoef(ak, n, p, q, f, M, std::cos);
    //Da li je bk[0] == 0?
    IzracunajKoef(bk, n, p, q, f, M, std::sin);
}

void FourierovRed::IzracunajKoef(double *koefi, int n, double p, double q, funkd f, int M, double periodicna(double)){
    double period = p - q;
    
    for(int k = 0; k &lt;= n; k++){
        double sum = 0;
        
        for(int i = 1; i &lt; M; i++){
            sum += f(p + (i*period)/M) * periodicna(2 * k * pi * (p/period + (i*1.)/M));
        }
        
        koefi[k] = ((f(p) + f(q)) / M) * periodicna((2 * k * pi * p)/period) + 2*sum/M;
    }
}

double FourierovRed::operator ()(double x){
    double fourier = ak[0]/2;
    
    for(int k = 1; k &lt;= stepen; k++){
        fourier += ak[k] * std::cos((2*k*pi*x)/period) + bk[k] * std::sin((2*k*pi*x)/period);
    }
    
    return fourier;
}

pair&lt;double&amp;, double&amp;&gt; FourierovRed::operator [](int k){
    if(k &lt; 0 || k &gt; stepen)
        throw std::range_error("Neispravan indeks");
    
    return {ak[k], (k&gt;0)? bk[k] : (bk[0] = 0)};
}

pair&lt;double, double&gt; FourierovRed::operator [](int k) const {
    if(k &lt; 0 || k &gt; stepen)
        throw std::range_error("Neispravan indeks");
    
    return std::make_pair(ak[k], (k&gt;0)? bk[k] : 0);
}

FourierovRed::FourierovRed(const FourierovRed &amp;fred) : stepen(fred.stepen), period(fred.period) {
    ak = Alloc(stepen+1);
    bk = Alloc(stepen+1);
    std::copy(fred.ak, fred.ak+stepen+1, ak);
    std::copy(fred.bk, fred.bk+stepen+1, bk);
}

FourierovRed::FourierovRed(FourierovRed &amp;&amp;fred) : stepen(fred.stepen), period(fred.period), ak(fred.ak), bk(fred.bk) {
    fred.ak = fred.bk = nullptr;
}

FourierovRed&amp; FourierovRed::operator =(const FourierovRed &amp;fred) {
    if(&amp;fred == this) return *this;
    
    if(fred.stepen != stepen){
        DeAlloc(ak);
        DeAlloc(bk);
        ak = Alloc(fred.stepen+1);
        bk = Alloc(fred.stepen+1);
    }
    stepen = fred.stepen;
    period = fred.period;
    
    std::copy(fred.ak, fred.ak+stepen+1, ak);
    std::copy(fred.bk, fred.bk+stepen+1, bk);
    
    return *this;
}

FourierovRed&amp; FourierovRed::operator =(FourierovRed &amp;&amp;fred) {
    if(&amp;fred == this) return *this;
    
    DeAlloc(ak);
    DeAlloc(bk);
    ak = fred.ak;
    bk = fred.bk;
    period = fred.period;
    stepen = fred.stepen;
    fred.ak = fred.bk = nullptr;
    
    return *this;
}

FourierovRed::~FourierovRed(){
    DeAlloc(ak);
    DeAlloc(bk);
}

int main () {
    
    // int n = 50, m = 1000;
    // double p = 0, q = 2 * pi;
    
    // funkd f = [](double x){
    //     return x * x;
    // };
    // funkit a = [](int k){
    //     return (k == 0)? 8/3 * pi * pi : 4/(k*k);
    // };
    // funkit b = [](int k){
    //     return (k == 0)? 0 : -4 * pi / k;
    // };
    
    // FourierovRed fred(n, 2 * pi, a, b);
    // FourierovRed fred_aprox(n, p, q, f, m);
    
<a name="0"></a><font color="#FF0000"><a href="match361-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

    auto k1=[](int k) { return (k == 0) ? 8 * pi * pi / 3 : 4. / (k * k); };
    auto k2=[](int k) { return -4 * pi / k; };
    auto f=[](double x) { return x * x; };
    FourierovRed f1(50, 2*pi, k1, k2);
    FourierovRed f2(50, 0, 2*pi, f, 1000);
    
    std::cout &lt;&lt; "FourierovRed: " &lt;&lt; f1(3) &lt;&lt; std::endl;
</font>    std::cout &lt;&lt; "FourierovRed approx: " &lt;&lt; f2(3) &lt;&lt; std::endl;
    
	return 0;
}
</pre>
</body>
</html>
