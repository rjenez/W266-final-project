<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student9325.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student1066.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;initializer_list&gt;
#include &lt;functional&gt;
#include &lt;map&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

typedef std::pair&lt;double,double&gt; Par;
typedef std::pair&lt;double&amp;, double&amp;&gt; RefPar;

double PI = ((atan(1)*4));

double Polinom (double f(double), double s_ili_c(double), int M, double T, double p, double q, int k){
  double vrati( ((f(p)+f(q))*s_ili_c((2*k*p*PI)/T))/double(M)   );
  double suma(0);
  for (int i = 1; i&lt;=(M-1); i++) suma+=f(p+(i*T)/double(M))*s_ili_c(2*k*PI*(p/T+double(i)/M));
  suma=(suma*2.)/M;
  return suma+vrati;
}

class FourierovRed
{
  double *a_k, *b_k;
  int duzina;
  double period;

<a name="2"></a><font color="#0000FF"><a href="match532-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

public:
  FourierovRed (double period, std::initializer_list&lt;double&gt; a, std::initializer_list&lt;double&gt; b);
  FourierovRed (int N, double T, double a(int), double b(int));
</font>  FourierovRed (int N, double p, double q, double f(double),int M);
  
  // operator dodjele
  FourierovRed &amp;operator = (const FourierovRed &amp;f_red) {
    if (this==&amp;f_red) return *this; // destruktivna samododjela
    for (int i = 0; i&lt;duzina; i++) {
      delete [] a_k;
      delete [] b_k;
      a_k=nullptr;
      b_k=nullptr;
    }
    duzina=f_red.duzina;
    period=f_red.period;
    
<a name="0"></a><font color="#FF0000"><a href="match532-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

     a_k=new double [duzina] {};
     b_k=new double [duzina] {};
    for (int i = 0; i&lt;duzina; i++){
      a_k[i]=f_red.a_k[i];
</font>      b_k[i]=f_red.b_k[i];
    }
    return *this;
  }
  
  // kopirajuco konstruktor
  FourierovRed (const FourierovRed &amp;f_red) {
    if (this==&amp;f_red) return;
    duzina=f_red.duzina;
    period=f_red.period;
    
     a_k=new double [duzina] {};
     b_k=new double [duzina] {};
    for (int i = 0; i&lt;duzina; i++){
      a_k[i]=f_red.a_k[i];
      b_k[i]=f_red.b_k[i];
    }
  }
  
  // pomjerajuci operator dodjele
  FourierovRed &amp;operator = (FourierovRed &amp;&amp;f_red){
<a name="1"></a><font color="#00FF00"><a href="match532-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    std::swap(a_k,f_red.a_k);
    std::swap(b_k,f_red.b_k);
    std::swap (period,f_red.period);
    std::swap (duzina,f_red.duzina);
</font>    return *this;
  }
  
  // pomjerajuci konstruktor
  FourierovRed (FourierovRed &amp;&amp;f_red) : a_k(f_red.a_k), b_k(f_red.b_k), duzina(f_red.duzina), period(f_red.period) {
    f_red.a_k=nullptr;
    f_red.b_k=nullptr;
  }
  
  double operator () (double k) const;
  Par operator [] (int k) const;
  RefPar operator [] (int k);
  
  ~FourierovRed () {
    delete [] a_k;
    a_k=nullptr;
    delete [] b_k;
    b_k=nullptr;
  }
  void Ispisi() const;
  
};

FourierovRed::FourierovRed (double period, std::initializer_list&lt;double&gt; a, std::initializer_list&lt;double&gt; b) : period(period)
{
  bool a_manji(false),b_manji(false);
  if (a.size()&gt;b.size()) {
    duzina=a.size();
    b_manji=true;
  } else {
    duzina=b.size();
    a_manji=true;
  }
  if (a_manji) duzina++;
  a_k=new double [duzina] {};
  b_k=new double [duzina] {};

  for (int i = 0; i&lt;duzina; i++) {
    if (a_manji &amp;&amp; i&gt;=a.size()) a_k[i]=0;
    else
      a_k[i]=*(a.begin()+i);

    if (b_manji &amp;&amp; i&gt;=b.size()) b_k[i]=0;
    else if (i==0) b_k[0]=0.;
    else
      b_k[i]=*(b.begin()+i-1);
  }
}

FourierovRed::FourierovRed (int N, double T, double a(int), double b(int)) : period(T) {
  if (N&lt;=0) throw std::domain_error ("Stepen mora biti pozitivan");
  duzina=N;
  duzina++;
  a_k=new double [duzina] {};
  b_k=new double [duzina] {};
  for (int i = 0; i&lt;duzina; i++){
    a_k[i]=a(i);
    if (i==0) {b_k[0]=0.; continue; }
    b_k[i]=b(i);
  }
}

FourierovRed::FourierovRed (int N, double p, double q, double f(double), int M) {
  if (N&lt;=0) throw std::domain_error ("Stepen mora biti pozitivan");
  if (M&lt;=0) throw std::domain_error ("Broj podintervala mora biti pozitivan");
  if (p&gt;=q) throw std::range_error ("Neispravan interval");
  duzina=N;
  period=q-p;
  duzina++;
  a_k=new double [duzina] {};
  b_k=new double [duzina] {};
  for (int i = 0; i&lt;duzina; i++){
    a_k[i]=Polinom(f,std::cos, M, period, p, q, i);
    if (i==0) { b_k[0]=0.; continue; }
    b_k[i]=Polinom(f,std::sin, M, period, p, q, i);
  }
  
}

Par FourierovRed::operator [](int k) const{
  if (k&gt;=duzina || k&lt;0 ) throw std::range_error ("Neispravan indeks");
  return {a_k[k],b_k[k]};
}


RefPar FourierovRed::operator [](int k) {
  if (k&gt;=duzina || k&lt;0) throw std::range_error ("Neispravan indeks");
  return {a_k[k],b_k[k]};
}

double FourierovRed::operator () (double x) const {
  double suma(0.);
  for (int i = 1; i&lt;duzina; i++) suma+=a_k[i]*cos((2*PI*i*x)/period)+b_k[i]*sin((2*PI*i*x)/period);
  return (a_k[0]/2+suma);
  
}

void FourierovRed::Ispisi() const
{
  for (int i = 0; i&lt;duzina; i++) std::cout&lt;&lt;"a_k"&lt;&lt;i&lt;&lt;" = "&lt;&lt;a_k[i]&lt;&lt;"              b_k"&lt;&lt;i&lt;&lt;" = "&lt;&lt;b_k[i]&lt;&lt;std::endl;
}

int main ()
{
  try {
    FourierovRed red1(50, 2*PI, [](int k)-&gt;double {if (k==0) return 8*PI*PI/3; return 4./(k*k);}, 
    [](int k)-&gt;double {return -4*PI/k;});
   // red1.Ispisi();
    FourierovRed red2(50,0,2*PI, [](double x) {return x*x;}, 1000);
    std::cout&lt;&lt;std::endl;
    red1.Ispisi();
   // red2.Ispisi();
   red2=red1=red2=red1;
   std::cout&lt;&lt;std::endl;
   red1[0].first=5;
   red1[0].second=3;
   red1.Ispisi();
    std::cout&lt;&lt;red1(3)&lt;&lt;std::endl;
    std::cout&lt;&lt;red2(3);
    /*
    double L=2;
    FourierovRed f1(2*L, {2*L, 1}, {});
    FourierovRed f2(2*L, {1}, {-1.27324, 0.63662, -0.42441, 0.31831, -0.25465, 0.21221, -0.18189, 0.15915, -0.14147, 0.12732});
    FourierovRed f3(2*L, {2*L}, {-1.27324, 0.63662, -0.42441, 0.31831, -0.25465, 0.21221, -0.18189, 0.15915, -0.14147, 0.12732});
    f1.Ispisi();
    f2.Ispisi();
    f3.Ispisi();
    std::cout&lt;&lt;f1[2].first&lt;&lt;" "&lt;&lt;f1[2].second;
    
  FourierovRed red(3, {1}, {1,2,8,9});
  FourierovRed red2(10, 2.6, [] (int k)-&gt;double { if (k==0) return 1; return 1./k;}, [](int k)-&gt;double {return 0;} );
  FourierovRed red3(50, 0, 2*PI, [](double k) { return k*k;}, 1000);
  std::cout&lt;&lt;red3(1)&lt;&lt;std::endl;
 // red3.Ispisi();*/
}
catch (std::range_error iz){
  std::cout&lt;&lt;iz.what();
}
  return 0;
}
</pre>
</body>
</html>
