<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student9325.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student7795.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;cmath&gt;

class FourierovRed {
private:
    double static constexpr PI = 4 * std::atan(1);
    double static constexpr ERROR = 0.0000000001;
    int N;
    double T;
    double* a;
    double* b;
    
    void static checkParams(int num, int M = 1, double p = 1, double q = 1, bool ntype = false) {
      if(num &lt;= 0) throw std::domain_error("Stepen mora biti pozitivan");
      if(ntype) {
        if(M &lt;= 0) throw std::domain_error("Broj podintervala mora biti pozitivan");
        if(p - q &gt;= ERROR) throw std::range_error("Neispravan interval");
      }
    }
    void static createCoefficientArrays(double*&amp; arrA, double*&amp; arrB, int size) {
      try {
        arrA = new double[size]();
        arrB = new double[size]();
      } catch (...) {
        delete [] arrA; arrA = nullptr;
        delete [] arrB; arrB = nullptr;
        throw;
      }
    }
    void IsprazniMemoriju();
public:
  ~FourierovRed();
  FourierovRed(const FourierovRed&amp; red);
  FourierovRed(FourierovRed&amp;&amp; red);
  
  FourierovRed&amp; operator=(const FourierovRed&amp; red);
  FourierovRed&amp; operator=(FourierovRed&amp;&amp; red);
  
  int Dimenzija() const { return this-&gt; N; }
  
<a name="0"></a><font color="#FF0000"><a href="match118-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

  FourierovRed(double T, std::initializer_list&lt;double&gt; k_a, std::initializer_list&lt;double&gt; k_b);
  FourierovRed(int N, double T, std::function&lt;double(int)&gt; funk_a, std::function&lt;double(int)&gt; funk_b);
  FourierovRed(int N, double p, double q, std::function&lt;double(double)&gt; f, int M);
  
  double operator()(double x) const;
  std::pair&lt;double, double&gt; operator[](int k) const;
  std::pair&lt;double&amp;, double&amp;&gt; operator[](int k);
</font>};

/// implementation of FourierovRed interface
FourierovRed::~FourierovRed() {
	this-&gt;IsprazniMemoriju();
	this-&gt;N = 0; this-&gt;T = 0;
}
void FourierovRed::IsprazniMemoriju() {
	  delete[] this-&gt;a; this-&gt;a = nullptr;
	  delete[] this-&gt;b; this-&gt;b = nullptr;
    this-&gt;N = 0; this-&gt;T = 0;
}
/// ctors
FourierovRed::FourierovRed(double t, std::initializer_list&lt;double&gt; k_a, std::initializer_list&lt;double&gt; k_b) : 
    T(t), a(nullptr), b(nullptr) {
  N = std::max(k_a.size(), k_b.size()) + (k_b.size() &gt;= k_a.size() ? 1 : 0);
  
  createCoefficientArrays(a, b, N);

  int pos(0);
  for(auto it(k_a.begin()); it != k_a.end(); a[pos++] = *it++);
  pos = 1;
  for(auto it(k_b.begin()); it != k_b.end(); b[pos++] = *it++);
}
<a name="4"></a><font color="#FF00FF"><a href="match118-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

FourierovRed::FourierovRed(int N, double T, std::function&lt;double(int)&gt; funk_a, std::function&lt;double(int)&gt; funk_b) : 
	  N(N), T(T), a(nullptr), b(nullptr) {
</font>  checkParams(N);
  
  createCoefficientArrays(a, b, N + 1);
  try { a[0] = funk_a(0); }
  catch (...) {
    this-&gt;IsprazniMemoriju();
    throw;
  }
  
  for(int i(1); i &lt;= N; ++i) {
    try {
      a[i] = funk_a(i);
      b[i] = funk_b(i);
    } catch (...) {
      this-&gt;IsprazniMemoriju();
<a name="2"></a><font color="#0000FF"><a href="match118-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

      throw;
    }
  }
}
FourierovRed::FourierovRed(int N, double p, double q, std::function&lt;double(double)&gt; f, int M) : 
	  N(N), T(q - p), a(nullptr), b(nullptr) {
</font>  checkParams(N, M, p, q, true);
 
  double konstanta ((f(p) + f(q)) / M); /// downcasting, potential bug
  auto gen_function = [=](int k, std::function&lt;double(double)&gt; nizFunkcija) -&gt; double {
    double sum(0);
    for(int i(1); i &lt; M; ++i)
      sum += f(p + (i * T / M)) * nizFunkcija((2 * k * PI * (p / T + double(i) / M))); /// downcasting, potential bug
    return (konstanta * nizFunkcija(2 * k * PI * p / T) + 2. * sum / M);
  };
 
  createCoefficientArrays(a, b, N + 1);
  
  try { a[0] = gen_function(0, ::cos); }
  catch (...) {
    this-&gt;IsprazniMemoriju();
    throw;
  }
  for(int i(1); i &lt;= N; ++i) {
    try {
      a[i] = gen_function(i, ::cos);
      b[i] = gen_function(i, ::sin);
    } catch (...) {
      this-&gt;IsprazniMemoriju();
      throw;
    }
  }
}
FourierovRed::FourierovRed(const FourierovRed&amp; red) : N(red.N), T(red.T), a(nullptr), b(nullptr) {
  createCoefficientArrays(a, b, N + 1);
  for(int i(0); i &lt;= N; ++i) {
    a[i] = red.a[i];
    b[i] = red.b[i];
  }
}
FourierovRed::FourierovRed(FourierovRed&amp;&amp; red) {
   this-&gt;IsprazniMemoriju();
<a name="3"></a><font color="#00FFFF"><a href="match118-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

   std::swap(N, red.N); std::swap(T, red.T);
   std::swap(a, red.a); std::swap(b, red.b);
</font>}

/// operator implementation for class FourierovRed
/// DIJELJENJE NULOM, STA OVDJE? ZA T = 0
double FourierovRed::operator()(double x) const {
  double sum(0);
  for(int k(1); k &lt;= N; ++k)
    sum += a[k]*::cos(2*k*PI*x/T) + b[k]*::sin(2*k*PI*x/T);
  return a[0]/2. + sum;
}
<a name="5"></a><font color="#FF0000"><a href="match118-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

std::pair&lt;double, double&gt; FourierovRed::operator[](int k) const {
  if(k &lt; 0 || k &gt;= N)
    throw std::range_error("Neispravan indeks");
</font>  
  if(k == 0) return {a[0], 0};
<a name="1"></a><font color="#00FF00"><a href="match118-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

  return {a[k], b[k]};
}
std::pair&lt;double&amp;, double&amp;&gt; FourierovRed::operator[](int k) {
  if(k &lt; 0 || k &gt;= N)
    throw std::range_error("Neispravan indeks");

  b[0] = 0;
</font>  return {a[k], b[k]};
}

/// copy and move operators
FourierovRed&amp; FourierovRed::operator=(const FourierovRed&amp; red) {
	if (N != red.N) {
	  double* novi_a (nullptr); 
    double* novi_b (nullptr);
		createCoefficientArrays(novi_a, novi_b, red.N + 1);
		this-&gt;IsprazniMemoriju();
		std::swap(a, novi_a);
		std::swap(b, novi_b);
	}
	
  N = red.N; T = red.T;
  for(int i(0); i &lt;= N; ++i) {
    a[i] = red.a[i];
    b[i] = red.b[i];
  }
  return *this;
}
FourierovRed&amp; FourierovRed::operator=(FourierovRed&amp;&amp; red) {
   this-&gt;IsprazniMemoriju();
   std::swap(N, red.N); std::swap(T, red.T);
   std::swap(a, red.a); std::swap(b, red.b);
   return *this;
}

int main () {

	return 0;
}</pre>
</body>
</html>
