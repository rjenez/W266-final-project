<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student8863.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student3171.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;initializer_list&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;

constexpr double pi=4*std::atan(1);

class FourierovRed
{
double *a=nullptr,*b=nullptr;
int vel=0;
double T=0;
double ignore=0;
    public:
    FourierovRed(double period,std::initializer_list&lt;double&gt;,std::initializer_list&lt;double&gt;);
    FourierovRed(int stepen, double period, std::function&lt;double(int)&gt;,std::function&lt;double(int)&gt;);
    FourierovRed(int stepen, double p, double q,std::function&lt;double(double)&gt;, int m);
    //treba mi kopirajuci konstruktor
    FourierovRed(const FourierovRed&amp;);
    //pomjerajuci konstruktor
    FourierovRed( FourierovRed&amp;&amp;);
    //kopirajuci operator dodjele
    FourierovRed&amp; operator=(const FourierovRed&amp;);
    //pomjerajuci operator dodjele
    FourierovRed&amp; operator=( FourierovRed&amp;&amp;);
    
    std::pair&lt;double,double&gt; operator[](int)const;
    // std::pair&lt;double&amp;,double&amp;&gt; &amp;operator[](int);
    
    double operator()(double);
    ~FourierovRed();
};
FourierovRed&amp; FourierovRed::operator=( FourierovRed&amp;&amp; temp)
{
    if(this==&amp;temp)return *this;
    
        if(a)delete[] a;
        if(b)delete[] b;
    
        vel=temp.vel;
        T=temp.T;
        a=temp.a;
        b=temp.b;
        temp.vel=0;
        temp.T=0;
        temp.a=nullptr;
        temp.b=nullptr;
        return *this;
    
}
FourierovRed&amp; FourierovRed::operator=(const FourierovRed&amp; temp)
{
    if(this==&amp;temp)return *this;
        if(a)delete[] a;
        if(b)delete[] b;
    
    vel=temp.vel;
    T=temp.T;
    a=b=nullptr;
    try{
        a=new double[vel+1];
        b=new double[vel];
    }
    catch(...)
    {
        vel=0;
        if(a)delete[] a;
        if(b)delete[] b;
    }
    a[0]=temp.a[0];
    for(int i=0;i&lt;vel;i++)
    {
        a[i+1]=temp.a[i+1];
        b[i]=temp.b[i];
    }
    return *this;
}
FourierovRed::FourierovRed( FourierovRed&amp;&amp; temp)
{
        vel=temp.vel;
        T=temp.T;
        a=temp.a;
        b=temp.b;
        temp.vel=0;
        temp.T=0;
        temp.a=nullptr;
        temp.b=nullptr;
}
FourierovRed::FourierovRed(const FourierovRed&amp; temp)
{
    vel=temp.vel;
    T=temp.T;
    a=b=nullptr;
    try{
        a=new double[vel+1];
        b=new double[vel];
    }
    catch(...)
    {
        vel=0;
        if(a)delete[] a;
        if(b)delete[] b;
    }
    a[0]=temp.a[0];
    for(int i=0;i&lt;vel;i++)
    {
        a[i+1]=temp.a[i+1];
        b[i]=temp.b[i];
    }
}

std::pair&lt;double,double&gt; FourierovRed::operator[](int i)const
{
    if(i&lt;0||i&gt;vel)throw std::range_error("Neispravan indeks");
    return std::make_pair(a[i],(i==0)?0:b[i-1]);    
}
// std::pair&lt;double&amp;,double&amp;&gt; &amp;FourierovRed::operator[](int i)
// {
//     if(i&lt;0||i&gt;vel)throw std::range_error("Neispravan indeks");
//     return std::pair&lt;double&amp;,double&amp;&gt;&amp;(a[i],(i==0)?ignore:b[i-1]);    
// }

double FourierovRed::operator()(double x)
{
    double f=0;
    f+=a[0]/2;
    // std::cout&lt;&lt;f;
    for(int i=0;i&lt;vel;i++)
    {
        f+=a[i+1]*std::cos((2*(i+1)*pi*x)/T)+b[i]*std::sin((2*(i+1)*pi*x)/T);
    }
    return f;
}
FourierovRed::~FourierovRed()
{
    if(a)delete[] a;
    if(b)delete[] b;
    vel=0;
    T=0;
}
FourierovRed::FourierovRed(double period,std::initializer_list&lt;double&gt; ka,std::initializer_list&lt;double&gt;kb)
{
    T=period;
    vel=(ka.size()&gt;kb.size())?ka.size()-1:kb.size();
    a=b=nullptr;
    try{
        a=new double[vel+1];
        b=new double[vel];
    }
    catch(...)
    {
        vel=0;
        if(a)delete[] a;
        if(b)delete[] b;
    }
    auto poka(ka.begin());
    auto pokb(kb.begin());
    a[0]=0;
    if(ka.size()&gt;0)a[0]=*poka++;
    
    for(int i=0;i&lt;vel;i++)
    {
        a[i+1]=0;
        b[i]=0;
<a name="1"></a><font color="#00FF00"><a href="match960-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        if(poka!=ka.end() &amp;&amp; i+1&lt;ka.size())a[i+1]=*poka++;
        if(pokb!=kb.end())b[i]=*pokb++;
    }
}

FourierovRed::FourierovRed(int stepen, double period, std::function&lt;double(int)&gt; f,std::function&lt;double(int)&gt; g)
</font>{
    if(stepen&lt;1)throw std::domain_error("Stepen mora biti pozitivan");
    a=b=nullptr;
    vel=stepen;
    try{
        a=new double[vel+1];
        b=new double[vel];
    }
    catch(...)
    {
        delete[] a;
        delete[] b;
        vel=0;
    }
    a[0]=f(0);
    for( int i = 0; i&lt; vel;i++)
    {
        a[i+1]=f(i+1);
        b[i]=g(i+1);
    }
    T=period;
}

FourierovRed::FourierovRed(int stepen, double p, double q,std::function&lt;double(double)&gt; f, int m)
{
    
<a name="0"></a><font color="#FF0000"><a href="match960-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    if(stepen&lt;1)throw std::domain_error("Stepen mora biti pozitivan");
    if(m&lt;1)throw std::domain_error("Broj podintervala mora biti pozitivan");
    if(!(p&lt;q))throw std::range_error("Neispravan interval");
    a=b=nullptr;
</font>    vel=stepen;
    T=q-p;
    try{
        a=new double[vel+1];
        b=new double[vel];
    }
    catch(...)
    {
        delete[] a;
        delete[] b;
    }
    
    for(int k=0;k&lt;vel+1;k++)
    {
        a[k]=((f(p)+f(q))/m)*std::cos(2*k*pi*p/static_cast&lt;double&gt;(T));

        for(int i=1;i&lt;m;i++)
        {
            a[k]+=2./m*( f(p+i*T/static_cast&lt;double&gt;(m))*std::cos(2*k*pi*(p/T+i/static_cast&lt;double&gt;(m))));
        }
    }
    for(int k=0;k&lt;vel;k++)
    {
        b[k]=(f(p)+f(q))/m*std::sin(2*(k+1)*pi*p/static_cast&lt;double&gt;(T));
        for(int i=1;i&lt;m;i++)
        {
            b[k]+=2./m*( f(p+i*T/static_cast&lt;double&gt;(m))*std::sin(2*(k+1)*pi*(p/T+i/static_cast&lt;double&gt;(m))));
        }
    }
    
}

int main ()
{
    // std::cout&lt;&lt;"hasiuhkewekjkwefhwkef";
    FourierovRed f2(50, 0, 2*pi, [](double x) { return x * x; }, 1000);
    std::cout&lt;&lt;f2(3);
    
	return 0;
}
</pre>
</body>
</html>
