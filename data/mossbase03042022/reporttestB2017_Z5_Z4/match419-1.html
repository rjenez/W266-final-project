<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student5287.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z4/student9081.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;initializer_list&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;functional&gt;
#include &lt;cmath&gt;
#include &lt;utility&gt;

const double PI(4*std::atan(1));
double nula(0);

class FourierovRed
{
    double period;
    int stepen;
    double *ak,*bk;
public:
    FourierovRed (double T, std::initializer_list&lt;double&gt; koef1, std::initializer_list&lt;double&gt; koef2);
    FourierovRed (int n, double T, std::function&lt;double(int)&gt; f1, std::function&lt;double(int)&gt; f2);
    FourierovRed (int n, double p, double q, std::function&lt;double(double)&gt; f, int M);
    ~FourierovRed () {delete[] ak; delete[] bk;}
<a name="1"></a><font color="#00FF00"><a href="match419-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    FourierovRed (const FourierovRed &amp;f);
    FourierovRed (FourierovRed &amp;&amp;f);
    FourierovRed &amp;operator= (const FourierovRed &amp;f);
    FourierovRed &amp;operator= (FourierovRed &amp;&amp;f);
    double operator () (double x) const;
</font>    std::pair&lt;double,double&gt; operator [] (int k) const;
    std::pair&lt;double&amp;,double&amp;&gt; operator [] (int k);
};

std::pair&lt;double,double&gt; FourierovRed::operator[] (int k) const
{
    if (k&lt;0 || k&gt;stepen) throw std::range_error ("Neispravan indeks");
    if (k==0) return std::make_pair(ak[0],0);
    return std::make_pair(ak[k],bk[k-1]);
}

<a name="3"></a><font color="#00FFFF"><a href="match419-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

std::pair&lt;double&amp;,double&amp;&gt; FourierovRed::operator[] (int k)
{
    if (k&lt;0 || k&gt;stepen) throw std::range_error ("Neispravan indeks");
</font>    if (k==0)
    {
        nula=0;
        std::pair&lt;double&amp;,double&amp;&gt; par(ak[0],nula);
        return par;
    }
    std::pair&lt;double&amp;,double&amp;&gt; par(ak[k],bk[k-1]);
    return par;
}

double FourierovRed::operator() (double x) const
{
    double vrati(0);
    for (int i=1;i&lt;stepen+1;i++)
        vrati+=ak[i]*std::cos(2*i*PI*x/period);
    for (int i=0;i&lt;stepen;i++)
        vrati+=bk[i]*std::sin(2*(i+1)*PI*x/period);
    vrati+=ak[0]/2;
    return vrati;
}

FourierovRed::FourierovRed (int n, double p, double q, std::function&lt;double(double)&gt; f, int M):period(q-p),stepen(n),ak(nullptr),bk(nullptr)
{
    if (n&lt;=0) throw std::domain_error ("Stepen mora biti pozitivan");
    if (M&lt;=0) throw std::domain_error ("Broj podintervala mora biti pozitivan");
    if (!(p&lt;q)) throw std::range_error ("Neispravan interval");
    try
    {
        ak=new double[n+1]; bk=new double [n];
    }
    catch (std::bad_alloc)
    {
        delete[]ak; delete[] bk;
        throw;
    }
    for (int i=0;i&lt;n+1;i++)
    {
        double suma(0);
        for (int j=1;j&lt;=M-1;j++)
            suma+=(f(p+j*period/M)*std::cos(2*i*PI*(double(p)/period+double(j)/M)));
        suma*=2; suma/=M;
        ak[i]=(f(p)+f(q))*std::cos(double(2*i*PI*p)/period)/M+suma;
    }
    for (int i=0;i&lt;n;i++)
    {
        double suma(0);
        for (int j=1;j&lt;=M-1;j++)
            suma+=f(p+double(j*period)/M)*std::sin(2*(i+1)*PI*(double(p)/period+double(j)/M));
        suma=suma*2/M;
        bk[i]=(f(p)+f(q))/M*std::sin(double(2*(i+1)*PI*p)/period)+suma;
    }
}

FourierovRed::FourierovRed (int n, double T, std::function&lt;double(int)&gt; f1, std::function&lt;double(int)&gt; f2):period(T),stepen(n),ak(nullptr),bk(nullptr)
{
    if (n&lt;=0) throw std::domain_error ("Stepen mora biti pozitivan");
    try
    {
        ak=new double[n+1]; bk=new double [n];
    }
    catch (std::bad_alloc)
    {
        delete[] ak; delete[] bk;
        throw;
    }
<a name="2"></a><font color="#0000FF"><a href="match419-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

    for (int i=0;i&lt;n+1;i++)
        ak[i]=f1(i);
    for (int i=0;i&lt;n;i++)
        bk[i]=f2(i+1);
</font>}

FourierovRed::FourierovRed (double T, std::initializer_list&lt;double&gt; koef1, std::initializer_list&lt;double&gt; koef2): period(T),ak(nullptr),bk(nullptr)
{
    int vel(koef2.size());
    if (int(koef1.size())-1&gt;int(koef2.size())) vel=koef1.size()-1;
    stepen=vel;
    try
    {
        ak=new double [vel+1]; bk=new double[vel];
    }
    catch (std::bad_alloc)
    {
        delete[] ak; delete[] bk;
        throw;
    }
    auto lista1(koef1.begin()),lista2(koef2.begin());
    for (int i=0;i&lt;vel+1;i++)
    {
        if (i&lt;koef1.size())
        {
            ak[i]=*lista1;
            lista1++;
        }
        else ak[i]=0;
    }
    for (int i=0;i&lt;vel;i++)
    {
        if (i&lt;koef2.size())
        {
            bk[i]=*lista2;
            lista2++;
        }
        else bk[i]=0;
    }
}

FourierovRed::FourierovRed (const FourierovRed &amp;f): period(f.period),stepen(f.stepen),ak(nullptr),bk(nullptr)
{
    try
    {
        ak=new double[stepen+1]; bk=new double[stepen];
    }
    catch (std::bad_alloc)
    {
        delete[] ak; delete[] bk; throw;
    }
    for (int i=0;i&lt;stepen+1;i++)
        ak[i]=f.ak[i];
    for (int i=0;i&lt;stepen;i++)
        bk[i]=f.bk[i];
}

<a name="0"></a><font color="#FF0000"><a href="match419-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

FourierovRed::FourierovRed (FourierovRed &amp;&amp;f): period(f.period),stepen(f.stepen),ak(f.ak),bk(f.bk)
{
    f.ak=nullptr; f.bk=nullptr;
</font>}

FourierovRed &amp;FourierovRed::operator= (const FourierovRed &amp;f)
{
    double *novi_ak(nullptr),*novi_bk(nullptr);
    try
    {
        novi_ak=new double[f.stepen+1]; novi_bk=new double[f.stepen];
        for (int i=0;i&lt;f.stepen+1;i++)
            novi_ak[i]=f.ak[i];
        for (int i=0;i&lt;f.stepen;i++)
            novi_bk[i]=f.bk[i];
    }
    catch(std::bad_alloc)
    {
        delete[] novi_ak; delete[] novi_bk;
        throw;
    }
    period=f.period; stepen=f.stepen;
    delete[] ak; delete[] bk;
    ak=novi_ak; bk=novi_bk;
    return *this;
}

FourierovRed &amp;FourierovRed::operator= (FourierovRed &amp;&amp;f)
{
    std::swap(period,f.period); std::swap(stepen,f.stepen);
    std::swap(ak,f.ak); std::swap(bk,f.bk);
    return *this;
}

int main ()
{
    int n;
    for (;;) {
    int m;
    std::cout&lt;&lt;"Unesite stepen Fourierovog Reda: \n";
    std::cin&gt;&gt;m;
    if (m==-1) break;
    std::cout&lt;&lt;"Unesite broj podintervala: \n";
    std::cin&gt;&gt;n;
    double x;
    std::cout&lt;&lt;"Unesite tacku u kojoj se racuna vrijednost Fourierovog Reda: \n";
    std::cin&gt;&gt;x;
    try {
    FourierovRed f1(m,0,2*PI,[] (double x) {return x*x;},n),f2(m,2*PI,[] (int k) {return k==0 ? 8*PI*PI/3 : 4./(k*k);}, [] (int k) {return -4*PI/k;});
    std::cout&lt;&lt;"U tacki x = "&lt;&lt;x&lt;&lt;" je :\n";
    std::cout&lt;&lt;"f1("&lt;&lt;x&lt;&lt;") = "&lt;&lt;f1(x)&lt;&lt;" i f2("&lt;&lt;x&lt;&lt;") = "&lt;&lt;f2(x)&lt;&lt;std::endl;
    std::cout&lt;&lt;"Unesite indeks za poredbu: \n";
    int i;
    std::cin&gt;&gt;i;
    std::cout&lt;&lt;f1[i].first&lt;&lt;" i "&lt;&lt;f2[i].first&lt;&lt;"\n";
    std::cout&lt;&lt;f1[i].second&lt;&lt;" i "&lt;&lt;f2[i].second&lt;&lt;"\n";    
    }
    catch (...)
    {std::cout&lt;&lt;"Greska!Unesite ponovo!\n";}
    }
	return 0;
}
</pre>
</body>
</html>
