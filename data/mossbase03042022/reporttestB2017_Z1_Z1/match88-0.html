<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z1/student6631.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z1/student6631.cpp<p></p><pre>
//B 2017/2018, ZadaÄ‡a 1, Zadatak 1
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

<a name="0"></a><font color="#FF0000"><a href="match88-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

typedef std::vector&lt;int&gt; Vektor;
//Funkcija koja pretvara broj sa dekadnom bazom u broj sa ternarnom bazom
int Ternarni (int x)
{
    int y;
	y=x;
//Ako je broj manji od nule mijenjamo predznak	
    if(y&lt;0)y*=-1;
	int cif, ter(0), i(0);
//Cifre pri konverziji su ostaci pri dijeljenu sa brojem tri; daljim dijeljenjem sa tri raste stepen cifre za jedan	
	while(x&gt;0)
	{
    	cif=x%3;
    	ter=ter+cif*pow(10,i++);
    	x=x/3;
    }
    return ter;
}
//Funkcija koja vraca logicku vrijednost istina ili neistina zavisno od toga da li je broj prost ili nije, respektivno
bool DaLiJeProst (int n)
{	
//Ako je broj manji od nule mijenjamo predznak
    if(n&lt;=0)n*=-1;
//Ako je broj djeljiv i sa jednim brojem sem jedan i samim sobom nije prost; u suprotnom jeste    
	for(unsigned i=2; i&lt;sqrt(n+1) ;i++)if(n%i==0)return false;
	return true;
}
//Funkcija koja vraca logicku vrijednost istina ili neistina zavisno od toga da li je broj simetrican
bool Simetrican (int x)
{
	int broj, y;
	y=x;
	broj=x;
//Ako je broj manji od nule mijenjamo predznak
    if(y&lt;0)y*=-1;
	int br(0);
//Racunamo stepen broja	
	while(y&gt;0)
	{
		br++;
		y=y/10;
	}br=br-1;
	int naop(0), i, cif;
//Izvrcemo broj tako sto cifre nmanjeg stepena pretvaramo u cifre nveceg stepena; cifru sa najmanjih stepenom pretvaramo u cifru sa najvecim stepenom te stepen raste i opada, respektivno	
	for(i=br;i&gt;=0;i--)
	{
    	cif=x%10;
    	naop=naop+cif*pow(10,i);
    	x=x/10;
    }
//Ako je broj nakon izvrtanja jednak broju prije izvrtanja on je simetrican    
	if(naop==broj)return true;
	else return false;
}
//Funkcija koja prima vektor cijelih brojeva i logicku vrijednost, a vraca vektor cijelih brojeva koji su u ternarnom obliku simetricni i prosti za logicku vrijednost istina ili slozeni za logicku vrijednost neistina
Vektor IzdvojiSimetricneTernarne (Vektor v, bool prost)
{
    Vektor v1;
//Ako trazimo proste brojeve    
    if(prost)
    {
        for(int i=0; i&lt;v.size(); i++)
//Ako je element vektora prost i simetrican u ternarnom obliku stavljamo ga na kraj novog vektora    
            if(DaLiJeProst(v.at(i)) &amp;&amp; Simetrican((Ternarni(v.at(i)))) &amp;&amp; v.at(i)!=1)v1.push_back(v.at(i));
    }
//Ako trazimo slozene brojeve    
    else if(!prost)
    {
        for(int i=0; i&lt;v.size(); i++)
//Ako element vektora nije prost ali jeste simetrican u ternarnom obliku stavljamo ga na kraj novog vektora
            if(!DaLiJeProst(v.at(i)) &amp;&amp; Simetrican((Ternarni(v.at(i)))) &amp;&amp; v.at(i)!=1)v1.push_back(v.at(i));
    }
    return v1;  
}
//Funckija koja izbacuje ponavljajuce elemente iz finalnog vektora
Vektor IzbrisiPonavljajuce (Vektor v)
{  
    int n(v.size());
//U slucaju da primamo vektor nula    
    int nula(0);
    for(int i=0; i&lt;n; i++)
    {
        if(v.at(i)==0)nula++;
    }
    if(nula==v.size()){
        v.resize(1);
        v.at(0)=0;
        return v;
    }
    
    for(int i=0; i&lt;n; i++)
    {
        for(int j=i+1; j&lt;n-1; j++)
        {
//Ako se element ponavlja izbacujemo ga tako sto sve elemente poslije njega vracamo jedno mjesto unatrag i smanjujemo velicinu vektora za jedan element           
            if(v.at(i)==v.at(j))
            {
                for(int k=j; k&lt;n-1; k++)
                    v.at(k)=v.at(k+1);
                n--;
//Da bi provjerili da li je element prepisan preko elementa koji se ponavlja takodjer element koji se ponavlja smanjujemo brojac za jedan                
                j--;
            }
        }
    }
    v.resize(n);
    return v;
}

int main ()
{
    std::cout &lt;&lt; "Unesite elemente vektora (-1 za kraj): ";
    Vektor v;
    int n;
    do
    {
        std::cin &gt;&gt; n;
        if(n==-1)break;
        else v.push_back(n);
    }while(1);
    std::cout &lt;&lt; "Unesite: 1 - za proste brojeve, 0 - za slozene brojeve: ";
    std::cin &gt;&gt; n;
    while(n!=1 &amp;&amp; n!=0)
    {
            std::cout &lt;&lt; "Neispravan unos! Unesite ponovo: ";
            std::cin &gt;&gt; n;
    }
    Vektor V(IzbrisiPonavljajuce(IzdvojiSimetricneTernarne(v,n)));
    if(n)
    {
    	if(V.size()==0)std::cout &lt;&lt; "Nema prostih simetricnih brojeva u vektoru.";
    	else std::cout &lt;&lt; "Prosti simetricni brojevi iz vektora su: ";
    }
    else 
    {
    	if(V.size()==0)std::cout &lt;&lt; "Nema slozenih simetricnih brojeva u vektoru.";
    	else std::cout &lt;&lt; "Slozeni simetricni brojevi iz vektora su: ";
    }
    for(int i=0; i&lt;V.size(); i++)
    {
        std::cout &lt;&lt; V.at(i);
		if(i+1!=V.size())std::cout &lt;&lt; ", ";
		else std::cout &lt;&lt; "." &lt;&lt; std::endl;
</font>	}
    return 0;
}</pre>
</body>
</html>
