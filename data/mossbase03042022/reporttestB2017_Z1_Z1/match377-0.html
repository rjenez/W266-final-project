<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z1/student1237.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z1/student1237.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

// Less typing.
<a name="0"></a><font color="#FF0000"><a href="match377-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_94.gif"/></a>

typedef std::vector&lt;int&gt; v_int;

bool isPrime(int n)
{
	if (n &lt; 0)
		n = -n;
		
	if (n == 1 || n == 0)
		return false;
	
	for (int i(2); i &lt;= std::sqrt(n); i++)
		if (n % i == 0)
			return false;
			
	return true;
}

v_int getTernaryRepresentation(int n)
{
	if (n &lt; 0)
		n = -n;
	
	v_int ternary_representation;
	do
	{
		ternary_representation.push_back((n % 3));
		n /= 3;
	} while (n != 0);
	
	return ternary_representation;
}

bool isTernarySymmetrical(v_int ternary_representation)
{
	// One-digit numbers are given a default value of true.
	if (ternary_representation.size() == 1)
		return true;
	
	for (int i(0), j(ternary_representation.size() - 1); i &lt; j; i++, j--)
			if (ternary_representation.at(i) != ternary_representation.at(j))
				return false;
	
	return true;
}

v_int IzdvojiSimetricneTernarne(v_int v, bool b)
{
	bool skip(false);
	v_int ternaries;
	
	for (int i(0); i &lt; v.size(); i++)
	{
		// Checks for instances of the same number.
		for (int j(0); j &lt; ternaries.size(); j++)
			if (v.at(i) == ternaries.at(j))
			{
				// The value at v[i] is one that has already been stored in the vector ternaries,
				// so, having no need to store it again, we set skip to "true", so that we might
				// skip to the next iteration of the for-loop, i.e. move on to the next integer candidate.
				skip = true;
				break;
			}
		
		if (skip)
		{
			skip = false;
			continue;
		}
		
		if (isTernarySymmetrical(getTernaryRepresentation(v.at(i))))
			if (b)
			{
				// Prime number case.
				if (isPrime(v.at(i)))
					ternaries.push_back(v.at(i));
			}
			else
			{
				// Composite number case.
				if (!isPrime(v.at(i)))
					ternaries.push_back(v.at(i));
			}	
	}
	
	return ternaries;
}

int main (void)
{
	int input;
	v_int v_input;
	
	std::cout &lt;&lt; "Unesite elemente vektora (-1 za kraj): ";
	for (;;)
	{
		std::cin &gt;&gt; input;
		if (input == -1)
			break;
	
		v_input.push_back(input);
	}
	
	std::cout &lt;&lt; "Unesite: 1 - za proste brojeve, 0 - za slozene brojeve: ";
	for (;;)
	{
		std::cin &gt;&gt; input;
		if (input != 0 &amp;&amp; input != 1)
			std::cout &lt;&lt; "Neispravan unos! Unesite ponovo: ";
		else
			break;
	}
	
	v_int v(IzdvojiSimetricneTernarne(v_input, input));
	if (v.size() == 0)
		std::cout &lt;&lt; "Nema " &lt;&lt; ((input) ? "prostih " : "slozenih ") &lt;&lt; "simetricnih brojeva u vektoru.";
	else
	{
		if (input)
			std::cout &lt;&lt; "Prosti simetricni brojevi iz vektora su: ";
		else
			std::cout &lt;&lt; "Slozeni simetricni brojevi iz vektora su: ";
		
		for (int i(0); i &lt; v.size(); i++)
				if (i == v.size() - 1)
					std::cout &lt;&lt; v.at(i) &lt;&lt; ".";
</font>				else
					std::cout &lt;&lt; v.at(i) &lt;&lt; ", ";
	}
	
	return 0;
}</pre>
</body>
</html>
