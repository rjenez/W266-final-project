<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z1/student1966.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z1/student1966.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 1, Zadatak 1
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na email: bcocalic1@etf.unsa.ba.	
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

#include &lt;limits&gt;
#include &lt;cstdio&gt;

/*
 *  KONVENCIJA: U mom kodu volim koristiti static_cast, mada to bilu u nekim
 *  slucajevima redudantno, cisto radi lakseg deduciranja potrebnog tipa
 *  na prvi pogled
 */

// PROTOTIPI funkcija
// Prvo idu pomocne funkcije, te onda glavna
// Objasnjenja funkcija se nalaze uz njihovu implementaciju
<a name="0"></a><font color="#FF0000"><a href="match271-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

bool isPrime(int);
bool isSymmetric(std::string);
bool exists(std::vector&lt;int&gt;, int);

// Funkcije direktno vezane za zadatak
std::string Dec2Tert(int);

// Funkcija zadata za implementaciju
std::vector&lt;int&gt; IzdvojiSimetricneTernarne(std::vector&lt;int&gt;, bool);

int main ()
{
	std::vector&lt;int&gt; vect;
	std::cout &lt;&lt; "Unesite elemente vektora (-1 za kraj): ";
	do
	{
		int tmpUnos;
		std::cin &gt;&gt; tmpUnos;
		
		if (tmpUnos == -1)
			break;
			
		vect.push_back(tmpUnos);
	}
	while (true);
	
	int primeReq;
	std::cout &lt;&lt; "Unesite: 1 - za proste brojeve, 0 - za slozene brojeve: ";
	std::cin &gt;&gt; primeReq;
	while (primeReq != 0 &amp;&amp; primeReq != 1) {
		std::cout &lt;&lt; "Neispravan unos! Unesite ponovo: ";
		std::cin &gt;&gt; primeReq;
	}
	
	std::vector&lt;int&gt; res{std::move(IzdvojiSimetricneTernarne(vect, static_cast&lt;bool&gt;(primeReq)))};
	
	if (res.size() == 0)
		std::cout &lt;&lt; "Nema "
			&lt;&lt; (primeReq ? "prostih" : "slozenih")
			&lt;&lt; " simetricnih brojeva u vektoru." &lt;&lt; std::endl;
	else
	{
		std::cout &lt;&lt; (primeReq ? "Prosti" : "Slozeni")
			&lt;&lt; " simetricni brojevi iz vektora su: ";
		
		for (int i{0}; i &lt; res.size(); i++)
			std::cout &lt;&lt; res.at(i)
				&lt;&lt; ((i &lt; res.size() - 1) ? ", " : ".");
				
		std::cout &lt;&lt; std::endl;
	}
	
	return 0;
}

std::vector&lt;int&gt; IzdvojiSimetricneTernarne(std::vector&lt;int&gt; vect, bool primeReq)
{
	std::vector&lt;int&gt; res;
	
	for (int num : vect)
		// 1 i -1 se moraju preskociti jer nisu ni prosti ni slozeni
		// exists provjerava da li se vec nalazi u rjesenju
		if (num != -1 &amp;&amp; num != 1 &amp;&amp; !exists(res, num) &amp;&amp;
			isSymmetric(Dec2Tert(num)) &amp;&amp; isPrime(num) == primeReq)
				res.push_back(num);
			
	return res;
}

// Funkcija vraca string sa ternarnim zapisom broja koji joj je proslijedjen kao parametar
std::string Dec2Tert(int num)
{
	std::string res{""};
	
	do {
		char tmp{static_cast&lt;char&gt;(std::abs(num % 3) + '0')};
		res = std::move(tmp + res);
		num /= 3;
	}
	while (num != 0);
	
	return res;
}

// Funkcija vraca true ukoliko je apsolutna vrijednost broja prosta,
// a false u suprotnom
bool isPrime(int num)
{
	// Ukoliko je manji ili jednak od 1 po modulu, broj nije prost
	// On nije ni slozen, mada nas to ne interesira (funkcija provjerava prostost)
	if (num &gt;= -1 &amp;&amp; num &lt;= 1)
		return false;
	
	// Da je N tipa int, za -2^31 bi ovdje doslo do overflow-a
	unsigned int N{static_cast&lt;unsigned int&gt;((num &lt; 0) ? -num : num)};
	
	// Optimizacija koja bi trebala prepoloviti broj operacija
	if (N &gt; 2 &amp;&amp; N % 2 == 0)
		return false;
	
	// i &lt;= N / i je isto sto i i^2 &lt;= N, a to je isto sto i i &lt;= sqrt(N)
	for (unsigned int i{3}; i &lt;= N / i; i += 2)
		if (N % i == 0)
			return false;
			
	return true;
}

// Funkcija vraca true ukoliko je proslijedjeni string palindrom,
// a false u suprotnom
bool isSymmetric(std::string str)
{
	int len = str.length();
	for (int i{0}; i &lt;= len / 2; i++)
		if (str.at(i) != str.at(len - 1 - i))
			return false;
			
	return true;
}

// Funkcija vraca true ukoliko se u vektoru pronadje broj,
// a false u suprotnom
bool exists(std::vector&lt;int&gt; vect, int toBeFound)
{
	for (int num : vect)
		if (toBeFound == num)
			return true;
			
	return false;
</font>}</pre>
</body>
</html>
