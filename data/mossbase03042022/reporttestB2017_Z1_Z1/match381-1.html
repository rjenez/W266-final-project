<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z1/student9986.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z1/Z1/student6419.cpp<p></p><pre>

/* Kopirani su samo neki ispisi recenica iz autotestova ili iz maina, koji moraju biti isti kao u autotestovima da bi radili, u slucaju da bude sumnje u prepisanost! */

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;

<a name="0"></a><font color="#FF0000"><a href="match381-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_98.gif"/></a>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::deque;



bool jeLiProst(long broj){
	/*if(broj&lt;0) broj*=-1;
	if(broj==1) return false;*/
	if(broj&lt;=1) broj=abs(broj);		
	
	for(int i=2; i&lt;=sqrt(broj); i++){						
		if(broj%i==0) return false;
	}
	return true;
}

bool simetricanTernarno(long broj){
	
	//Pretvorimo prvo u ternarni (naopako) i zapisimo u dek
	deque&lt;int&gt; ternarni;
	if(broj&lt;0) broj*=-1;
	while(broj&gt;0){
		ternarni.push_front(broj%3);
		broj/=3;
	}
	
	//Provjeramao simetricnost tako sto provjerimo prvi i zadnji, drugi i predzadnji itd. sve do sredine 
	for(int i=0; i&lt;=ternarni.size()/2; i++){
		if(ternarni.at(i)!=ternarni.at(ternarni.size()-1-i))
			return false;
	}
	return true;
}

bool imaBrojUVektoru(std::vector&lt;int&gt; vektor, int broj){
	for(int nu:vektor){
		if(nu==broj) return true;
	}
	return false;
}


vector&lt;int&gt; IzdvojiSimetricneTernarne(vector&lt;int&gt; brojevi, bool proste){
	vector&lt;int&gt; rezultujuci;
	
	//Izdvajamo sve ili proste ili slozene ( ovisno od parametra 'proste' ) onim redoslijedom kako su dati u vektor-parametru
	
	for(int i=0; i&lt;brojevi.size(); i++){
		if(jeLiProst(brojevi.at(i))==proste &amp;&amp; simetricanTernarno(brojevi.at(i))){
			//Ne trebamo vise puta ubacivati isti broj, tako da ovdje provjerimo je li se vec nalazi u vektoru
			if(!imaBrojUVektoru(rezultujuci,brojevi.at(i)))
				rezultujuci.push_back(brojevi.at(i));
		}
	}
	return rezultujuci;
}



int main ()
{
	//Unesite elemente vektora (-1 za kraj): Unesite: 1 - za proste brojeve, 0 - za slozene brojeve:
	cout&lt;&lt;"Unesite elemente vektora (-1 za kraj): ";
	
	vector&lt;int&gt; testni;
	int broj;
	//Unos vektora do -1
	do{
		cin&gt;&gt;broj;
		if(broj!=-1) testni.push_back(broj);
		
	}while(broj!=-1);
	
	cout&lt;&lt;"Unesite: 1 - za proste brojeve, 0 - za slozene brojeve: ";
	int logicka;
	
	do{
		cin&gt;&gt;logicka;
		if(logicka!= 1 &amp;&amp; logicka !=0) cout&lt;&lt;"Neispravan unos! Unesite ponovo: ";
	}while(logicka!= 1 &amp;&amp; logicka !=0);
	
	
	auto rezultujuci(IzdvojiSimetricneTernarne(testni,logicka));
	
	//Ispis prije brojeva
	if(rezultujuci.size()&gt;0){
		if(logicka)
			cout&lt;&lt;"Prosti simetricni brojevi iz vektora su: ";
		else{
			cout&lt;&lt;"Slozeni simetricni brojevi iz vektora su: ";
		}
	}
	else{
		if(logicka)	
			cout&lt;&lt;"Nema prostih simetricnih brojeva u vektoru.";
		else
			cout&lt;&lt;"Nema slozenih simetricnih brojeva u vektoru.";
		
	}
		
	
	for(int i=0; i&lt;rezultujuci.size(); i++){
		cout&lt;&lt;rezultujuci.at(i);
		if(i==int(rezultujuci.size())-1) cout&lt;&lt;".";
		else cout&lt;&lt;", ";
</font>	}
	return 0;
}</pre>
</body>
</html>
