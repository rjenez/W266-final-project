<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student7791.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student8923.cpp<p></p><pre>
<a name="3"></a><font color="#00FFFF"><a href="match2-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;
using std::cout;
using std::cin;
using std::vector;
template &lt;typename Tip&gt;
struct Matrica
{
    int br_redova,br_kolona;
    Tip **elementi=nullptr;
};
template &lt;typename Tip&gt;
Matrica&lt;Tip&gt; StvoriMatricu(int br_redova,int br_kolona)
{
    try
    {
    Matrica&lt;Tip&gt; mat;
    mat.br_redova=br_redova;
    mat.br_kolona=br_kolona;
    mat.elementi=new Tip*[br_redova];
</font>    for(int i=0;i&lt;br_redova;i++)
    mat.elementi[i]=nullptr;
    try
    {
<a name="2"></a><font color="#0000FF"><a href="match2-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_12.gif"/></a>

        for(int i=0;i&lt;br_redova;i++)
        mat.elementi[i]=new Tip[br_kolona];
    }
    catch(...)
    {
        UnistiMatricu(mat);
        throw;
    }
    return mat;
    }
    catch(...)
    {
        throw;
    }
   // return mat;
}
template &lt;typename Tip&gt;
void UnistiMatricu(Matrica&lt;Tip&gt; mat)
{
    if(!mat.elementi) return;
    for(int i=0;i&lt;mat.br_redova;i++)
    delete[] mat.elementi[i];
    delete[] mat.elementi;
    mat.elementi=nullptr;
}
template &lt;typename Tip&gt;
void UnesiMatricu(char ime,Matrica&lt;Tip&gt; &amp;mat)
{
    for(int i=0;i&lt;mat.br_redova;i++)
    {
        for(int j=0;j&lt;mat.br_kolona;j++)
        {
            cout&lt;&lt;ime&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            cin&gt;&gt;mat.elementi[i][j];
        }
    }
}
template &lt;typename Tip&gt;
void IspisiMatricu(const Matrica&lt;Tip&gt; &amp;mat,int sirina,int preciznost=6,bool treba_brisati=false)
</font>{
<a name="4"></a><font color="#FF00FF"><a href="match2-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

for(int i=0; i&lt;mat.br_redova; i++) 
{
    for(int j=0; j&lt;mat.br_kolona; j++)
    {
    cout&lt;&lt;std::setw(sirina)&lt;&lt;std::setprecision(preciznost)&lt;&lt;mat.elementi[i][j];
    }
 cout &lt;&lt; std::endl;
 }
if(treba_brisati)
{
    UnistiMatricu(mat);
}
else
return;
}
template &lt;typename Tip&gt;
Matrica&lt;Tip&gt; ZbirMatrica(const Matrica&lt;Tip&gt; &amp;m1, const Matrica&lt;Tip&gt; &amp;m2) 
</font>{
 if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
 throw std::domain_error("Matrice nemaju jednake dimenzije!");
 auto m3(StvoriMatricu&lt;Tip&gt;(m1.br_redova, m1.br_kolona));
 for(int i = 0; i &lt; m1.br_redova; i++)
 for(int j = 0; j &lt; m1.br_kolona; j++)
<a name="1"></a><font color="#00FF00"><a href="match2-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

 m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
 return m3;
}
template &lt;typename Tip&gt;
bool SaglasneZaMnozenje(const Matrica&lt;Tip&gt; &amp;mat1,const Matrica&lt;Tip&gt; &amp;mat2)
{
    if(mat1.br_kolona==mat2.br_redova)
    return true;
    return false;
}
template &lt;typename Tip&gt;
Matrica&lt;Tip&gt; ProduktMatrica(const Matrica&lt;Tip&gt; &amp;mat1,const Matrica&lt;Tip&gt; &amp;mat2)
{
    if(!SaglasneZaMnozenje(mat1,mat2))
    throw std::domain_error("Matrice nisu saglasne za mnozenje");
    auto mat3(StvoriMatricu&lt;Tip&gt;(mat1.br_redova,mat2.br_kolona));
    if(mat3.br_redova==0 || mat3.br_kolona==0)
    return mat3;
    for(int i=0;i&lt;mat1.br_redova;i++)
    {
        for(int j=0;j&lt;mat2.br_kolona;j++)
        {
          //  Tip suma=Tip();
           Tip suma=0;
            for(int k=0;k&lt;mat2.br_redova;k++)
            suma+=(mat1.elementi[i][k]*mat2.elementi[k][j]);
</font><a name="6"></a><font color="#00FF00"><a href="match2-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

            mat3.elementi[i][j]=suma;
        }
    }
    return mat3;
}
template &lt;typename Tip&gt;
Matrica&lt;Tip&gt; JedinicnaMatrica(const Matrica&lt;Tip&gt; &amp;mat)
{
    auto mat2(StvoriMatricu&lt;Tip&gt;(mat.br_redova,mat.br_kolona));
    for(int i=0;i&lt;mat2.br_redova;i++)
</font>    {
        for(int j=0;j&lt;mat2.br_kolona;j++)
        {
            if(i==j)
<a name="5"></a><font color="#FF0000"><a href="match2-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

            mat2.elementi[i][j]=1;
            else
            mat2.elementi[i][j]=0;
        }
    }
    return mat2;
}
template &lt;typename Tip,typename Tipkoef&gt;
Matrica&lt;Tip&gt; PomnoziMatricuKoeficijentom(const Matrica&lt;Tip&gt; &amp;mat,Tipkoef koef)
{
    auto mat2(StvoriMatricu&lt;Tip&gt;(mat.br_redova,mat.br_kolona));
    for(int i=0;i&lt;mat2.br_redova;i++)
</font>    {
        for(int j=0;j&lt;mat2.br_kolona;j++)
        {
<a name="0"></a><font color="#FF0000"><a href="match2-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_41.gif"/></a>

            mat2.elementi[i][j]=koef*mat.elementi[i][j];
        }
    }
    return mat2;
}
template &lt;typename Tip&gt;
void pomfja(const Matrica&lt;Tip&gt; &amp;mat,Tip **elem)
{
    for(int i=0;i&lt;mat.br_redova;i++)
    {
        for(int j=0;j&lt;mat.br_kolona;j++)
        {
            elem[i][j]=mat.elementi[i][j];
        }
    }
}
template &lt;typename Tip&gt;
Matrica&lt;Tip&gt; MatricniPolinom(const Matrica&lt;Tip&gt; &amp;mat,vector&lt;double&gt; vek)
{
    if(mat.br_redova!=mat.br_kolona)
    throw std::domain_error("Matrica mora biti kvadratna");
    bool nulvektor(true);
    for(int i=0;i&lt;vek.size();i++)
    {
        if(std::fabs(vek[i])&gt;0.0000000001)
        {
            nulvektor=false;
            break;
        }
    }
   // Matrica&lt;Tip&gt; konacna,jedinicna,pom;
try
{
    auto konacna=StvoriMatricu&lt;Tip&gt;(mat.br_redova,mat.br_kolona);
        for(int i=0;i&lt;konacna.br_redova;i++)
        for(int j=0;j&lt;konacna.br_kolona;j++)
        konacna.elementi[i][j]=0;
    if(nulvektor)
    {
        return konacna;
    }
    for(int i=0;i&lt;vek.size();i++)
    {
        if(i==0)
        {
           try
           {
             Matrica&lt;Tip&gt; jedinicna;
             jedinicna=JedinicnaMatrica&lt;Tip&gt;(mat);
              try
              {
           Matrica&lt;Tip&gt; pom;
          Matrica&lt;Tip&gt; pom2;
            pomfja(pom2=ZbirMatrica(konacna,pom=PomnoziMatricuKoeficijentom(jedinicna,vek[i])),konacna.elementi);
            UnistiMatricu(pom);
            UnistiMatricu(jedinicna);
            UnistiMatricu(pom2);
              }
              catch(...)
               {
               UnistiMatricu(konacna);
               UnistiMatricu(jedinicna);
             //  UnistiMatricu(pom);
               throw;
              }
           }
           catch(...)
           {
               UnistiMatricu(konacna);
             //  UnistiMatricu(jedinicna);
               throw;
           }
        }
        else if(i==1)
        {
            try
            {
          Matrica&lt;Tip&gt; pom;
          //  pom=PomnoziMatricuKoeficijentom(mat,vek[i]);
            try
            {
           Matrica&lt;Tip&gt; pom2;
            pomfja(pom2=ZbirMatrica(konacna,pom=PomnoziMatricuKoeficijentom(mat,vek[i])),konacna.elementi);
            UnistiMatricu(pom);
            UnistiMatricu(pom2);
            }
            catch(...)
            {
                UnistiMatricu(konacna);
                
                UnistiMatricu(pom);
                throw;
            }
            }
            catch(...)
            {
                UnistiMatricu(konacna);
              //  UnistiMatricu(pom);
                throw;
            }
        }
        else
        {
            try
            {
            auto matmnoz(StvoriMatricu&lt;Tip&gt;(mat.br_redova,mat.br_kolona));
            pomfja&lt;Tip&gt;(mat,matmnoz.elementi);
            for(int j=1;j&lt;i;j++)
            {
            Matrica&lt;Tip&gt; konacna1;
            pomfja(konacna1=ProduktMatrica&lt;Tip&gt;(matmnoz,mat),matmnoz.elementi);
            UnistiMatricu(konacna1);
            }
           Matrica&lt;Tip&gt; konacna1;
            pomfja(konacna1=PomnoziMatricuKoeficijentom&lt;Tip&gt;(matmnoz,vek[i]),matmnoz.elementi);
          Matrica&lt;Tip&gt; konacna2;
            pomfja(konacna2=ZbirMatrica&lt;Tip&gt;(konacna,matmnoz),konacna.elementi);
            UnistiMatricu(matmnoz);
            UnistiMatricu(konacna1);
            UnistiMatricu(konacna2);
            }
            catch(...)
            {
                UnistiMatricu(konacna);
              //  UnistiMatricu(matmnoz);
                throw;
            }
        }
    }
    return konacna;
}
catch(...)
{
  //  UnistiMatricu(konacna);
    throw;
}
 //   return konacna;
}
int main ()
{
    cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    int dim;
    cin&gt;&gt;dim;
    Matrica&lt;double&gt; a;
    try
    {
        a=StvoriMatricu&lt;double&gt;(dim,dim);
        cout&lt;&lt;"Unesite elemente matrice A: "&lt;&lt;std::endl;
        UnesiMatricu('A',a);
        cout&lt;&lt;"Unesite red polinoma: ";
        int red;
        cin&gt;&gt;red;
        cout&lt;&lt;"Unesite koeficijente polinoma: ";
        vector&lt;double&gt; vek;
        for(int i=0;i&lt;=red;i++)
        {
            double pom;
            cin&gt;&gt;pom;
            vek.push_back(pom);
        }
     IspisiMatricu(MatricniPolinom(a,vek),10,6,true);
     //IspisiMatricu(PomnoziMatricuKoeficijentom(a,2.2),10,6,true);
    }
     catch(std::bad_alloc) 
     {
     cout &lt;&lt; "Nema dovoljno memorije!\n";
     }
    UnistiMatricu(a);
	return 0;
</font>}</pre>
</body>
</html>
