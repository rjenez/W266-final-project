<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student5741.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student8152.cpp<p></p><pre>
/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

using namespace std;

template &lt;typename TipEl&gt;
struct Matrica{
    
    int redovi, kolone;
    TipEl **el = nullptr;
    
};


template&lt;typename TipEl&gt;
void UnistiMatricu(Matrica&lt;TipEl&gt; mat){
    
    if(!mat.el) return;
    
    for(int i = 0; i &lt; mat.redovi; i++) delete[] mat.el[i];
    delete[] mat.el;
    
    mat.el = nullptr;
}

template &lt;typename TipEl&gt;

Matrica&lt;TipEl&gt; StvoriMatricu (int redovi, int kolone){
    
    Matrica&lt;double&gt; mat;
    
    mat.redovi = redovi;
    mat.kolone = kolone;
    
    mat.el = new TipEl*[redovi];
    
    for(int i = 0; i &lt; redovi; i++) mat.el[i] = nullptr;
    
    try {
        
        for(int i = 0; i &lt; redovi; i++) mat.el[i] = new TipEl[kolone];
        
    } catch(...){
        
        UnistiMatricu(mat);
        throw;
    }
    
    return mat;
}

template &lt;typename TipEl&gt;
void UnesiMatricu(char ime, Matrica&lt;TipEl&gt; &amp;mat){
    
<a name="1"></a><font color="#00FF00"><a href="match788-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

    for(int i = 0; i &lt; mat.redovi; i++)
        
        for(int j = 0; j &lt; mat.kolone; j++){
            
            cout &lt;&lt; ime &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
            cin &gt;&gt; mat.el[i][j];
        }
    
}

template &lt;typename TipEl&gt;
void IspisiMatricu(const Matrica&lt;TipEl&gt; &amp;mat, int sirina_ispisa, int preciznost = 6, bool treba_brisati = false){
</font>    
<a name="0"></a><font color="#FF0000"><a href="match788-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

    for(int i = 0; i &lt; mat.redovi; i++){
        for(int j = 0; j &lt; mat.kolone; j++){
            
            
            cout &lt;&lt; setw(sirina_ispisa) &lt;&lt; setprecision(preciznost) &lt;&lt; mat.el[i][j];
            
        }
        
        cout &lt;&lt; endl;
    }
    
    if(treba_brisati) UnistiMatricu(mat);
}

template &lt;typename TipEl&gt;
Matrica&lt;TipEl&gt; ProduktMatrica(const Matrica&lt;TipEl&gt; &amp;mat1, const Matrica&lt;TipEl&gt; &amp;mat2){
</font>    
<a name="3"></a><font color="#00FFFF"><a href="match788-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    if(mat1.kolone != mat2.redovi) throw domain_error("Matrice nisu saglasne za mnozenje");
    
    auto mat3(StvoriMatricu&lt;TipEl&gt;(mat1.redovi, mat2.kolone));
    
    for(int i = 0; i &lt; mat3.redovi; i++)
</font>        for(int j = 0; j &lt; mat3.kolone; j++)
        {
            mat3.el[i][j]=0;
        }
        
   for(int i = 0; i &lt; mat1.redovi; i++){
       
       for(int j = 0; j &lt; mat2.kolone; j++){
           
           for(int k = 0; k &lt; mat1.kolone; k++){
               
               mat3.el[i][j] += mat1.el[i][k] * mat2.el[k][j];
           }
       }
   }
   
   return mat3;
    
}

template &lt;typename TipEl&gt;
void Jedinicna(Matrica&lt;TipEl&gt; &amp;mat){
    
    
    for(int i = 0; i &lt; mat.redovi; i++) {
        
        for(int j = 0; j &lt; mat.kolone; j++) {
            
            if(i == j) mat.el[i][j] = 0;
            else mat.el[i][j] = 1;
        }
    }

    
}

template &lt;typename TipEl&gt;
void PopuniNulama(Matrica&lt;TipEl&gt; &amp;mat){
    
    
    for(int i = 0; i &lt; mat.redovi; i++) {
        
        for(int j = 0; j &lt; mat.kolone; j++) {
            mat.el[i][j] = 0;
        }
    }

    
}

/*void Izmnozi(Matrica&lt;TipEl&gt; &amp;rez, const Matrica&lt;TipEl&gt; &amp;stepe, vector&lt;double&gt; v, int br){
    
    
    for(int i = 0; i &lt; rez.redovi; i++){
        for(int j = 0; j &lt; rez.redovi; j++){
            
            
            
        }
    }
    
}
*/

<a name="2"></a><font color="#0000FF"><a href="match788-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

template &lt;typename TipEl&gt;

Matrica&lt;TipEl&gt; MatricniPolinom(const Matrica&lt;TipEl&gt; &amp;mat, vector&lt;double&gt; v){
    
    
    if(mat.redovi != mat.kolone) throw domain_error("Matrica mora biti kvadratna");
</font>    
    Matrica&lt;TipEl&gt; MatPol(StvoriMatricu&lt;TipEl&gt;(mat.redovi, mat.redovi));
    PopuniNulama(MatPol);
    Matrica&lt;TipEl&gt; stepen(StvoriMatricu&lt;TipEl&gt;(mat.redovi, mat.redovi));
    
    Matrica&lt;TipEl&gt; jed(StvoriMatricu&lt;TipEl&gt;(mat.redovi, mat.redovi));
    Jedinicna(jed);
    stepen = mat;
    
    
    for(int i = 0; i &lt; v.size(); i++) {
        
        for(int j = 0; j &lt; mat.redovi; j++){
            
            for(int k = 0; k &lt; mat.redovi; k++){
                
                if(i == 0){
                    
                    MatPol.el[j][k] = v[0] * jed.el[j][k];
                    
                }
                
                
                //Izmnozi(MatPol, stepen, v, i);
                
                MatPol.el[j][k] += stepen.el[j][k] * v[i];
                
                stepen = ProduktMatrica(stepen, mat);
                
            }
        }
    }
    
    
    
   
    
}


int main ()
{
    
    Matrica&lt;double&gt; a, matpol;
    int n, red,m;
   
    
    cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    cin &gt;&gt; n;
    
    try {
        
        a = StvoriMatricu&lt;double&gt;(n,n);
     
        
        cout &lt;&lt; "Unesite elemente matrice A:" &lt;&lt; endl;
        UnesiMatricu('A', a);
        
        cout &lt;&lt; "Unesite red polinoma: ";
        cin &gt;&gt; red;
        
        vector&lt;double&gt; v;
        
        cout &lt;&lt; "Unesite koeficijente polinoma: ";
        
        for(int i = 0; i &lt; red; i++){
            
            cin &gt;&gt; m;
            v.push_back(m);
        }
        
        
        
        cout &lt;&lt; "Matrica glasi: " &lt;&lt; endl;
        
        matpol = MatricniPolinom(a, v);
        IspisiMatricu(matpol, 10, 6, false);
        
        
        
        
    }catch(domain_error x){
        
        cout &lt;&lt; x.what();
        
    }catch(bad_alloc){
        
    cout &lt;&lt; "Nema dovoljno memorije!";
    }
    
    UnistiMatricu(a);
    UnistiMatricu(matpol);
	return 0;
}</pre>
</body>
</html>
