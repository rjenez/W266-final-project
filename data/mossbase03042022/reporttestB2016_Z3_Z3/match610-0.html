<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student4415.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student4415.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;



template &lt;typename TipElementa&gt;
struct Matrica {
	int br_redova, br_kolona;
	TipElementa **elementi = nullptr;
};

// UNISTI MATRICU
template &lt;typename TipElementa&gt;
void UnistiMatricu(Matrica&lt;TipElementa&gt; mat)
{
	if (!mat.elementi) return;
	for (int i = 0; i &lt; mat.br_redova; i++) {
		delete[] mat.elementi[i];
	}
	delete[] mat.elementi;
	mat.elementi = nullptr;
}

// KREIRAJ MATRICU
template &lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; StvoriMatricu(int br_redova, int br_kolona)
{
	Matrica&lt;TipElementa&gt; mat;
	mat.br_redova = br_redova;
	mat.br_kolona = br_kolona;

	try {
		mat.elementi = new TipElementa*[br_redova];
		for (int i = 0; i &lt; br_redova; i++) {
			mat.elementi[i] = nullptr;
		}
	}
	catch (...) {
		throw;
	}
	try {
		for (int i = 0; i &lt; br_redova; i++) {
			mat.elementi[i] = new TipElementa[br_kolona];                       // OVA FJA BACA IZUZETAK KORISTI TRY CATCH
		}
	}
	catch (...) {
		UnistiMatricu(mat);
		throw;
	}
	return mat;
}

template &lt;typename TipElementa&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElementa&gt; &amp;mat)
{
	for (int i = 0; i &lt; mat.br_redova; i++) {
		for (int j = 0; j &lt; mat.br_kolona; j++) {
			std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
			std::cin &gt;&gt; mat.elementi[i][j];
		}
	}
}

template&lt;typename TipElementa&gt;
void IspisiMatricu(const Matrica&lt;TipElementa&gt; &amp;mat, int sirina_ispisa, int preciznost = 6, bool treba_brisati = false)
{
	for (int i = 0; i &lt; mat.br_redova; i++) {
		for (int j = 0; j &lt; mat.br_kolona; j++) {
			std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; std::setprecision(preciznost) &lt;&lt; mat.elementi[i][j];
		}
		std::cout &lt;&lt; std::endl;
	}
	if (treba_brisati) {
		UnistiMatricu(mat);
	}
}

template &lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; ZbirMatrica(const Matrica&lt;TipElementa&gt; &amp;m1, const Matrica&lt;TipElementa&gt; &amp;m2)
{
<a name="2"></a><font color="#0000FF"><a href="match610-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	if (m1.br_redova != m2.br_redova or m1.br_kolona != m2.br_kolona) throw std::domain_error("Matrice nemaju jednake dimenzije!");
	try {
		auto m3(StvoriMatricu&lt;TipElementa&gt;(m1.br_redova, m1.br_kolona));
		for (int i = 0; i &lt; m1.br_redova; i++) {
</font>			for (int j = 0; j &lt; m1.br_kolona; j++) {
<a name="0"></a><font color="#FF0000"><a href="match610-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

				m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
			}
		}
		return m3;
	}
	catch (...) {
		throw;
	}

	/// MORAMO OBRISATI OVU MATRICU
}

template &lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; ProduktMatrica(const Matrica&lt;TipElementa&gt; &amp;m1, const Matrica&lt;TipElementa&gt; &amp;m2)
{
	if (m1.br_kolona != m2.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
	try {
		auto m3(StvoriMatricu&lt;TipElementa&gt;(m1.br_redova, m2.br_kolona));
		for (int i = 0; i &lt; m1.br_redova; i++) {
</font>			for (int j = 0; j &lt; m2.br_kolona; j++) {
				TipElementa suma{};
				for (int k = 0; k &lt; m1.br_kolona; k++) {
<a name="1"></a><font color="#00FF00"><a href="match610-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

					suma += m1.elementi[i][k] * m2.elementi[k][j];
				}
				m3.elementi[i][j] = suma;
			}
		}
		return m3;
	}
	catch (...) {
		throw;
	}
}


// Ovo je stara fja ako bude sve radilo ovu fju treba izbrisati

/*
template &lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; MatricniPolinom(const Matrica&lt;TipElementa&gt; &amp;mat, std::vector&lt;double&gt; v1)
{
	if (mat.br_kolona != mat.br_redova) throw std::domain_error("Matrica mora biti kvadratna");
	Matrica&lt;TipElementa&gt; P;         // KREIRAMO MATRICU POLINOMA
	try {
		P = StvoriMatricu&lt;TipElementa&gt;(mat.br_kolona, mat.br_kolona);
		for (int i = 0; i &lt; mat.br_kolona; i++) {
			for (int j = 0; j &lt; mat.br_kolona; j++) {
				P.elementi[i][j] = 0;
			}
		}
	}
	catch (...) {
		throw;
	}


	if (v1.size() == 0) return P;// TREBA OBRISAT
	std::vector&lt;Matrica&lt;TipElementa&gt;&gt; v_pok(v1.size());         // KREIRAMO VEKTOR MATRICA ?? 
	for (int i = 0; i &lt; v1.size(); i++) {
		if (i == 0) {
			try {
				auto I(StvoriMatricu&lt;TipElementa&gt;(mat.br_kolona, mat.br_kolona)); // TREBA OBRISAT
				for (int i = 0; i &lt; mat.br_kolona; i++) {
					for (int j = 0; j &lt; mat.br_kolona; j++) {
						if (i == j) I.elementi[i][j] = 1;
						else I.elementi[i][j] = 0;
					}
				}
				v_pok[i] = I;
			}
			catch (...) {

			}
		}
		else {
			try {
				v_pok[i] = ProduktMatrica(mat, v_pok[i - 1]); // TREBA OBRISAT
			}
			catch (...) {
				for (int i = 0; i &lt; v1.size(); i++) {
					UnistiMatricu(v_pok[i]);
				}
			}
		}
	}
	for (int i = 0; i &lt; v1.size(); i++) {
		for (int j = 0; j &lt; mat.br_kolona; j++) {
			for (int k = 0; k &lt; mat.br_kolona; k++) {
				P.elementi[j][k] += v1[i] * (v_pok[i].elementi[j][k]);
			}
		}
	}
	for (int i = 0; i &lt; v1.size(); i++) {
		UnistiMatricu(v_pok[i]);
	}
	return P;
}
*/


template &lt;typename TipElementa&gt;
Matrica&lt;TipElementa&gt; MatricniPolinom(const Matrica&lt;TipElementa&gt; &amp;mat, int n,double *pokazivac_na_niz_koeficjenata)
</font>{
	if (mat.br_kolona != mat.br_redova) throw std::domain_error("Matrica mora biti kvadratna");
	if (n &lt; 0) throw std::domain_error("Neispravan stepen polinoma");

	Matrica&lt;TipElementa&gt; P;         // KREIRAMO MATRICU POLINOMA
	try {
		P = StvoriMatricu&lt;TipElementa&gt;(mat.br_kolona, mat.br_kolona);
		for (int i = 0; i &lt; mat.br_kolona; i++) {
			for (int j = 0; j &lt; mat.br_kolona; j++) {
				P.elementi[i][j] = 0;
			}
		}
	}
	catch (...) {
		throw;
	}


	std::vector&lt;Matrica&lt;TipElementa&gt;&gt; v_pok(n);         // KREIRAMO VEKTOR MATRICA ?? 
	for (int i = 0; i &lt; n; i++) {
		if (i == 0) {
<a name="4"></a><font color="#FF00FF"><a href="match610-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

			try {
				auto I(StvoriMatricu&lt;TipElementa&gt;(mat.br_kolona, mat.br_kolona)); // TREBA OBRISAT
				for (int i = 0; i &lt; mat.br_kolona; i++) {
</font>					for (int j = 0; j &lt; mat.br_kolona; j++) {
						if (i == j) I.elementi[i][j] = 1;
						else I.elementi[i][j] = 0;
					}
				}
				v_pok[i] = I;
			}
			catch (...) {

			}
		}
		else {
			try {
				v_pok[i] = ProduktMatrica(mat, v_pok[i - 1]); // TREBA OBRISAT
			}
			catch (...) {
				for (int i = 0; i &lt; n; i++) {
					UnistiMatricu(v_pok[i]);
				}
			}
		}
	}
	for (int i = 0; i &lt; n; i++) {
		for (int j = 0; j &lt; mat.br_kolona; j++) {
			for (int k = 0; k &lt; mat.br_kolona; k++) {
				P.elementi[j][k] += *pokazivac_na_niz_koeficjenata * (v_pok[i].elementi[j][k]);
			}
		}
		pokazivac_na_niz_koeficjenata++;
	}
	for (int i = 0; i &lt; n; i++) {
		UnistiMatricu(v_pok[i]);
	}
	return P;
}

<a name="3"></a><font color="#00FFFF"><a href="match610-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

int main()
{
	Matrica&lt;double&gt; a;
	int n;
	std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
	std::cin &gt;&gt; n;
	try {
		a = StvoriMatricu&lt;double&gt;(n, n);
</font>
		std::cout &lt;&lt; "Unesite elemente matrice A: " &lt;&lt; std::endl;
		UnesiMatricu('A', a);
	}
	catch (std::bad_alloc) {
		std::cout &lt;&lt; "Nema dovoljno memorije!";
	}
	std::cout &lt;&lt; "Unesite red polinoma: ";
	std::cin &gt;&gt; n;
	std::vector&lt;double&gt; v1(n + 1);
	std::cout &lt;&lt; "Unesite koeficijente polinoma: ";
	for (auto &amp;i : v1) {
		std::cin &gt;&gt; i;
	}
	auto P(MatricniPolinom(a, n+1 ,&amp;v1[0]));
	IspisiMatricu(P, 10, 6, true);
	UnistiMatricu(a);
	return 0;
}</pre>
</body>
</html>
