<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student7597.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student6999.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
template &lt;typename lopata&gt;
struct Matrica{
    int br_redova,br_kolona;
    lopata **elementi = nullptr;
};
template &lt;typename lopata&gt;
void UnistiMatricu(Matrica&lt;lopata&gt; mat){
    if(!mat.elementi) return;
    for(int i=0;i&lt;mat.br_redova;i++) delete[] mat.elementi[i];
    delete[] mat.elementi;
    mat.elementi = nullptr;
}
template &lt;typename lopata&gt;
Matrica&lt;lopata&gt; StvoriMatricu(int br_redova, int br_kolona){
    Matrica&lt;lopata&gt; mat;
    mat.br_redova = br_redova; mat.br_kolona = br_kolona;
    mat.elementi  = new lopata*[br_redova];
    for(int i=0;i&lt;br_redova;i++) mat.elementi[i] = nullptr;
    try{
        for(int i=0;i&lt;br_redova;i++)
            mat.elementi[i] = new lopata[br_kolona];
        
    }catch(...){UnistiMatricu(mat);throw;}
return mat;
}
template &lt;typename lopata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;lopata&gt; &amp;mat){
    for(int i=0;i&lt;mat.br_redova;i++)
        for(int j=0;j&lt;mat.br_kolona;j++){
            std::cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            std::cin&gt;&gt;mat.elementi[i][j];
        }
}
template &lt;typename lopata&gt;
void IspisiMatricu(const Matrica&lt;lopata&gt; mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false){
    for(int i=0;i&lt;mat.br_redova;i++){
        for(int j=0;j&lt;mat.br_kolona;j++)
        std::cout&lt;&lt;std::setprecision(preciznost)&lt;&lt;std::setw(sirina_ispisa)&lt;&lt;mat.elementi[i][j];
        std::cout&lt;&lt;std::endl;
    }
    if(treba_brisati) UnistiMatricu(mat);
}
template &lt;typename lopata&gt;
Matrica&lt;lopata&gt; ZbirMatrica(const Matrica&lt;lopata&gt; &amp;m1, const Matrica&lt;lopata&gt; &amp;m2){
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)throw std::domain_error("Matrice nemaju jednake dimenzije!");
auto m3(StvoriMatricu&lt;lopata&gt;(m1.br_redova,m1.br_kolona));
for(int i=0;i&lt;m1.br_redova;i++)
    for(int j=0;j&lt;m1.br_kolona;j++){
        m3.elementi[i][j]=m1.elementi[i][j]+m2.elementi[i][j];
    }
    return m3;
}
template &lt;typename lopata&gt;
Matrica&lt;lopata&gt; ProduktMatrica(const Matrica&lt;lopata&gt; &amp;m1,const Matrica&lt;lopata&gt; &amp;m2);
template &lt;typename lopata&gt;
Matrica&lt;lopata&gt; MatricniPolinom(const Matrica&lt;lopata&gt; &amp;metrice_hehe,const std::vector&lt;double&gt; &amp;peovi);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main (){
Matrica&lt;double&gt; a; int m;
std::cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";    
std::cin&gt;&gt;m;
try{
   a=StvoriMatricu&lt;double&gt;(m,m);
    std::cout&lt;&lt;"Unesite elemente matrice A: \n"; UnesiMatricu('A',a);
    std::cout&lt;&lt;"Unesite red polinoma: "; unsigned red; std::cin&gt;&gt;red;
    std::vector&lt;double&gt; vektory; double temp;
    std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
    for(unsigned i=0;i&lt;red+1;i++) {std::cin&gt;&gt;temp; vektory.push_back(temp);}
    auto polinom=MatricniPolinom(a,vektory);
    IspisiMatricu(polinom,10,6);UnistiMatricu(polinom);
}catch(std::bad_alloc){std::cout&lt;&lt;"Nema dovoljno memorije!\n";}
catch(std::domain_error &amp;ex){std::cout&lt;&lt;ex.what();}
catch(std::logic_error &amp;ex){std::cout&lt;&lt;ex.what();}
UnistiMatricu(a);
return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template &lt;typename lopata&gt;
Matrica&lt;lopata&gt; ProduktMatrica(const Matrica&lt;lopata&gt; &amp;m1,const Matrica&lt;lopata&gt; &amp;m2){
if(m1.br_kolona != m2.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
try{
    auto izlazna = StvoriMatricu&lt;lopata&gt;(m1.br_redova,m2.br_kolona);UnistiMatricu(izlazna);}catch(std::bad_alloc){throw;}
auto izlazna = StvoriMatricu&lt;lopata&gt;(m1.br_redova,m2.br_kolona);
for(unsigned i=0;i&lt;izlazna.br_redova;i++){
<a name="0"></a><font color="#FF0000"><a href="match423-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

    for(unsigned j=0;j&lt;izlazna.br_kolona;j++){
        lopata suma{};
        for(int k=0;k&lt;m1.br_kolona;k++) suma+=m1.elementi[i][k]*m2.elementi[k][j];
        izlazna.elementi[i][j]=suma;
    }
}
return izlazna;
}
template&lt;typename lopata&gt;
void SkalarniProdukt(Matrica&lt;lopata&gt;&amp;m, double skalar){
</font>    for(unsigned i=0;i&lt;m.br_redova;i++)
<a name="4"></a><font color="#FF00FF"><a href="match423-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

    for(unsigned j=0;j&lt;m.br_kolona;j++)
        m.elementi[i][j]*=skalar;
}
template&lt;typename lopata&gt;
void KopirajDruguUPrvu(Matrica&lt;lopata&gt; m1,const Matrica&lt;lopata&gt; &amp;m2){
</font>    for(unsigned i=0;i&lt;m1.br_redova;i++)
<a name="3"></a><font color="#00FFFF"><a href="match423-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    for(unsigned j=0;j&lt;m2.br_kolona;j++)
        m1.elementi[i][j]=m2.elementi[i][j];
}
template &lt;typename lopata&gt;
Matrica&lt;lopata&gt; MatricniPolinom(const Matrica&lt;lopata&gt; &amp;mat,const std::vector&lt;double&gt; &amp;peovi){
</font>    if(mat.br_redova!=mat.br_kolona) throw std::domain_error("Matrica mora biti kvadratna");
if(!peovi.size()){
    for(unsigned i=0;i&lt;mat.br_redova;i++)
<a name="5"></a><font color="#FF0000"><a href="match423-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    for(unsigned j=0;j&lt;mat.br_kolona;j++)
        mat.elementi[i][j]=0;
return mat;
}
    Matrica&lt;lopata&gt; priv1,priv2,polinom,stepen;
</font>try{
<a name="6"></a><font color="#00FF00"><a href="match423-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

 priv1=StvoriMatricu&lt;lopata&gt;(mat.br_redova,mat.br_kolona);
 polinom=StvoriMatricu&lt;lopata&gt;(mat.br_redova,mat.br_kolona);  
</font> stepen=StvoriMatricu&lt;lopata&gt;(mat.br_redova,mat.br_kolona);
KopirajDruguUPrvu(stepen,mat);
KopirajDruguUPrvu(priv1,mat);
for(unsigned i=0;i&lt;polinom.br_redova;i++)
<a name="2"></a><font color="#0000FF"><a href="match423-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

for(unsigned j=0;j&lt;polinom.br_kolona;j++)
    if(j==i) polinom.elementi[i][j]= peovi[0];
    else polinom.elementi[i][j] = 0;
</font><a name="1"></a><font color="#00FF00"><a href="match423-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

for(unsigned n=1;n&lt;peovi.size();n++){
    SkalarniProdukt(priv1,peovi[n]);
    priv2=ZbirMatrica(polinom,priv1);
    //sad ima n-ti stepen
    KopirajDruguUPrvu(polinom,priv2);
    //sad ima polinom dignut na odg. stepen
    UnistiMatricu(priv2);
    priv2=ProduktMatrica(stepen,mat);
    KopirajDruguUPrvu(stepen,priv2);
    UnistiMatricu(priv2);
    KopirajDruguUPrvu(priv1,stepen);
}
    UnistiMatricu(priv1);UnistiMatricu(stepen);
</font>return polinom;
}catch(std::bad_alloc){UnistiMatricu(priv1);UnistiMatricu(stepen);UnistiMatricu(polinom);throw;}
}</pre>
</body>
</html>
