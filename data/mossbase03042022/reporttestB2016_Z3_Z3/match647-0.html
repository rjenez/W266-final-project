<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student3178.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student3178.cpp<p></p><pre>
#include &lt;new&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;

template &lt;typename TipEle&gt;
   struct Matrica{
       int br_redova, br_kolona;
       TipEle **elementi = nullptr;
   };
   

template &lt;typename TipEle&gt;
   void UnistiMatricu(Matrica&lt;TipEle&gt; mat){
       if(!mat.elementi) return;
       for(int i=0; i&lt;mat.br_redova; i++) delete[] mat.elementi[i];
       delete[] mat.elementi;
       mat.elementi=nullptr;
   }
   

template &lt;typename TipEle&gt;
   Matrica&lt;TipEle&gt; StvoriMatricu(int br_redova, int br_kolona){
      Matrica&lt;TipEle&gt; mat;
      mat.br_redova = br_redova; mat.br_kolona = br_kolona;
      mat.elementi =new TipEle*[br_redova];
      for(int i=0; i&lt;br_redova; i++) mat.elementi[i] = nullptr;
      try{
           for(int i=0; i&lt;br_redova; i++)
              mat.elementi[i] = new TipEle[br_kolona];
   }
   catch(...){
       UnistiMatricu(mat);
       throw;
   }
   return mat;
   }
   
   
template &lt;typename TipEle&gt;
   void UnesiMatricu(char ime_matrice, Matrica&lt;TipEle&gt; &amp;mat){
       for(int i=0; i&lt;mat.br_redova; i++){
        for(int j=0; j&lt;mat.br_kolona; j++){
            std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i+1 &lt;&lt; "," &lt;&lt; j+1 &lt;&lt; ") = ";
            std::cin &gt;&gt; mat.elementi[i][j];
   } }
}

template &lt;typename TipEle&gt;
   void IspisiMatricu(const  Matrica&lt;TipEle&gt; mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false ){
       for(int i=0; i&lt;mat.br_redova; i++){
        for(int j=0; j&lt;mat.br_kolona; j++){
            std::cout &lt;&lt; std::setprecision(preciznost) &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; mat.elementi[i][j];}
        std::cout &lt;&lt; std::endl;
        }
        if(treba_brisati==true) UnistiMatricu(mat);
   }
   
   
template &lt;typename TipEle&gt;
   void PomnoziSaKoeficijentom(Matrica&lt;TipEle&gt; &amp;A, double p){
       for(int i=0; i&lt;A.br_redova; i++){
           for(int j=0; j&lt;A.br_kolona; j++){
             A.elementi[i][j]*=p;
             }
           }
   }

   
<a name="0"></a><font color="#FF0000"><a href="match647-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

template &lt;typename TipEle&gt;
   void ZbrojZaSumu(const  Matrica&lt;TipEle&gt; &amp;A1, const  Matrica&lt;TipEle&gt; &amp;A2){
   if(A1.br_redova != A2.br_redova || A1.br_kolona != A2.br_kolona)
     throw std::domain_error("Matrice nemaju jednake dimenzije!");
 
    for(int i=0; i&lt;A1.br_redova; i++){
        for(int j=0; j&lt;A2.br_kolona; j++){
            A1.elementi[i][j] += A2.elementi[i][j];
        } 
    }   
}
   
template &lt;typename TipEle&gt;
</font>   Matrica&lt;TipEle&gt; ZbirMatrica(const  Matrica&lt;TipEle&gt; &amp;m1, const  Matrica&lt;TipEle&gt; &amp;m2){
   if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
     throw std::domain_error("Matrice nemaju jednake dimenzije!");
    auto m3(StvoriMatricu&lt;TipEle&gt;(m1.br_redova,m1.br_kolona));
    for(int i=0; i&lt;m1.br_redova; i++)
        for(int j=0; j&lt;m1.br_kolona; j++){
            m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
    return m3;
    }
    
   }
template &lt;typename TipEle&gt;  
Matrica&lt;TipEle&gt;   ProduktMatrica(const Matrica&lt;TipEle&gt; &amp;m1,const Matrica&lt;TipEle&gt; &amp;m2){
         if(m1.br_kolona != m2.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
         Matrica&lt;TipEle&gt; m3;
         try{
             m3=StvoriMatricu&lt;TipEle&gt;(m1.br_redova, m2.br_kolona);} 
             catch(std::bad_alloc){throw;
             }
             
<a name="1"></a><font color="#00FF00"><a href="match647-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

             for(int i=0; i&lt;m1.br_redova; i++){
                 for(int j=0; j&lt;m2.br_kolona; j++){
                     TipEle suma{}; // TipEle suma{};
                     for(int k=0; k&lt;m1.br_kolona; k++){
                         suma+=m1.elementi[i][k]*m2.elementi[k][j];
</font>                 }
                 m3.elementi[i][j] =suma;
                 }
             }
     return m3;
    }
   


 template &lt;typename TipEle&gt;
 Matrica&lt;TipEle&gt; DajNulMatricu(const Matrica&lt;TipEle&gt; &amp;A){
     for(int i=0; i&lt;A.br_redova; i++){
        for(int j=0; j&lt;A.br_kolona; j++){
            A.elementi[i][j] = 0 ;}
     }
            return A;
 }
 
 template &lt;typename TipEle&gt;
 Matrica&lt;TipEle&gt; DajJedinicnuMatricu(const Matrica&lt;TipEle&gt; A){
     Matrica&lt;TipEle&gt; B;
      try{
             B=StvoriMatricu&lt;TipEle&gt;(A.br_redova, A.br_kolona);} 
             catch(std::bad_alloc){
                 throw;
             }
    for(int i=0; i&lt;A.br_redova; i++){
        for(int j=0; j&lt;A.br_kolona; j++){
           if(i==j) B.elementi[i][j] = 1 ;
           else B.elementi[i][j] = 0;}
           }
            return B;
 }
 
 
template &lt;typename TipEle&gt;
void UpisiUVektorMat(const Matrica&lt;TipEle&gt; &amp;A1, const Matrica&lt;TipEle&gt; &amp;A2){
       for(int i=0; i&lt;A1.br_redova; i++){
<a name="2"></a><font color="#0000FF"><a href="match647-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

        for(int j=0; j&lt;A1.br_kolona; j++){
         A2.elementi[i][j] = A1.elementi[i][j];   }
         }
   }
    
template &lt;typename TipEle&gt;  
Matrica&lt;TipEle&gt;  MatricniPolinom(const Matrica&lt;TipEle&gt; &amp;A, std::vector&lt;double&gt; v){
</font>      if(A.br_kolona != A.br_redova) throw std::domain_error("Matrica mora biti kvadratna");
      if(v.size() == 0) return DajNulMatricu(A);
      
   std::vector&lt;Matrica&lt;TipEle&gt;&gt; vek_mat(v.size());
    
    try{
        vek_mat[0]=StvoriMatricu&lt;TipEle&gt;(A.br_redova,A.br_kolona);}
    catch(std::bad_alloc) {
        throw;
        }
    
 
    UpisiUVektorMat(DajJedinicnuMatricu(A), vek_mat[0]);
   // UpisiUVektorMat(PomnoziSaKoeficijentom(A, v[1]),vek_mat[1]);
    // IspisiMatricu(vek_mat[0], 10);  
    for(int i=1; i&lt; v.size(); i++){
        try{
            vek_mat[i]=ProduktMatrica&lt;TipEle&gt;(vek_mat[i-1],A);
          //  IspisiMatricu(vek_mat[i], 10);
    }catch(std::bad_alloc){
        for(int i=0; i&lt; v.size(); i++)
           UnistiMatricu(vek_mat[i]);  
        throw;
        }
    }
    
    for(int i= 0; i&lt;v.size(); i++){    
        PomnoziSaKoeficijentom(vek_mat[i],v[i]);
       // ZbrojZaSumu(vek_mat[0],vek_mat[i]);
      //  UnistiMatricu(vek_mat[i]);
    }  
    for(int i= 1; i&lt;v.size(); i++){    
        ZbrojZaSumu(vek_mat[0],vek_mat[i]);
        UnistiMatricu(vek_mat[i]);}
        
    return vek_mat[0];
    }
   
int main(){
    
    Matrica&lt;double&gt;  A;
    int broj;
    std::cout&lt;&lt; "Unesite dimenziju kvadratne matrice: ";
<a name="3"></a><font color="#00FFFF"><a href="match647-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    std::cin &gt;&gt; broj;
    try{
    A=StvoriMatricu&lt;double&gt;(broj,broj);
    std::cout &lt;&lt; "Unesite elemente matrice A:\n";
    UnesiMatricu('A', A);
   
    int n;
    std::cout&lt;&lt;"Unesite red polinoma: ";
    std::cin &gt;&gt; n;
    
    std::vector&lt;double&gt; vektor_koeficijenata;
</font>    std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
    int i{0};
    while(i&lt;=n){
        double element;
        std::cin &gt;&gt; element;
        vektor_koeficijenata.push_back(element);
        i++;
    }
    try{

   IspisiMatricu(MatricniPolinom(A,vektor_koeficijenata), 10);
  }
   catch(std::domain_error e){
       std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
   }
    catch(std::logic_error e){
       std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
   }
    }
    
    catch(std::bad_alloc){
        std::cout &lt;&lt; "Nema dovoljno memorije!\n";
    }
   UnistiMatricu(A); 
    return 0;
    
}

</pre>
</body>
</html>
