<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student2922.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student2922.cpp<p></p><pre>
<a name="2"></a><font color="#0000FF"><a href="match800-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
using namespace std;

template &lt;typename TipElemenata&gt; 
    struct Matrica {
        int br_redova, br_kolona;
        TipElemenata **elementi {nullptr};
</font>};

template &lt;typename TipElemenata&gt;
    void UnistiMatricu (Matrica&lt;TipElemenata&gt; mat){
        if(!mat.elementi) return;
        for(int i{0}; i&lt;mat.br_redova; i++  ) delete[] mat.elementi[i];
        delete[] mat.elementi;
        mat.elementi = nullptr;
}

template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona){
        Matrica&lt;TipElemenata&gt; mat;
        mat.br_redova = br_redova; mat.br_kolona = br_kolona;
        mat.elementi = new TipElemenata*[br_redova];
        try{
            for(int i{0}; i&lt;br_redova; i++){
                mat.elementi[i] = new TipElemenata[br_kolona];
            }
        } catch (...){
            UnistiMatricu(mat);
            throw;
        }
        return mat;
    }
    
template &lt;typename TipElemenata&gt;
    void UnesiMatricu( char ime_matrice, const Matrica&lt;TipElemenata&gt; &amp;mat ){
        for(int i{0}; i&lt;mat.br_redova; i++){
<a name="1"></a><font color="#00FF00"><a href="match800-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

            for( int j{0}; j&lt;mat.br_kolona; j++){
                cout&lt;&lt; ime_matrice &lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
                cin&gt;&gt;mat.elementi[i][j];
            }
        }
    }

template&lt;typename TipElemenata&gt;
    void IspisiMatricu (const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost=6, bool treba_brisati = false){
</font>        for(int i{0}; i&lt;mat.br_redova; i++){
<a name="0"></a><font color="#FF0000"><a href="match800-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

            for(int j{0}; j&lt;mat.br_kolona; j++){
                cout&lt;&lt;setw(sirina_ispisa)&lt;&lt;setprecision(preciznost)&lt;&lt;mat.elementi[i][j];
            }
            cout&lt;&lt;endl;
        }
        if(treba_brisati) UnistiMatricu( mat );
    }

template&lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; ZbirMatrica ( const Matrica&lt;TipElemenata&gt; &amp; m1,
    const Matrica&lt;TipElemenata&gt; &amp;m2){
        if(m1.br_kolona != m2.br_kolona || m1.br_redova != m2.br_redova){
            throw domain_error ("Matrice nemaju jednake dimenzije!");
</font>        }
        auto m3 = StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona);
        for(int i {0}; i&lt;m1.br_redova; i++)
            for(int j {0}; j&lt;m1.br_kolona; j++)
                m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
        return m3;
    }
    
template &lt;typename TipElemenata&gt;
    TipElemenata SkalarniProizvod ( const vector&lt;TipElemenata&gt; &amp;kolona, const vector &lt;TipElemenata&gt; &amp;red  ){
        TipElemenata proizvod{0};
        //Sad cemo pronaci skalarni proizvod ova dva vektora!
        for(int i{0}; i&lt;kolona.size(); i++)
                proizvod += kolona[i] * red[i];
        //Taj skal proizvod je upravo jedan element matrice ProduktMatrica
        return proizvod;
    }

template&lt;typename TipElemenata&gt;
<a name="3"></a><font color="#00FFFF"><a href="match800-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    Matrica&lt;TipElemenata&gt; ProduktMatrica( const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2){
        if(m1.br_kolona != m2.br_redova ) throw domain_error("Matrice nisu saglasne za mnozenje");
        
        auto m3 = StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona);
</font>        
        for(int i{0}; i&lt; m1.br_redova; i++){
            for(int j{0}; j&lt;m2.br_kolona; j++){
                
                
                //Sad uzimanje vektora reda prve i kolone druge matrice
                vector&lt;TipElemenata&gt; kolona, red;
                for(int po_redu{0}; po_redu &lt; m1.br_kolona; po_redu++) kolona.push_back(m1.elementi[i][po_redu]);
                for(int po_koloni{0}; po_koloni &lt; m2.br_redova; po_koloni++) red.push_back(m2.elementi[po_koloni][j]);
                
                m3.elementi[i][j] = SkalarniProizvod ( kolona, red );
                
            }
        } 
        return m3;
    }

template&lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; SkalarxMat (const Matrica&lt;TipElemenata&gt; &amp;mat, TipElemenata x){
        Matrica&lt;TipElemenata&gt; pomocna = StvoriMatricu&lt;TipElemenata&gt; (mat.br_redova, mat.br_kolona );
        for(int i{0}; i&lt;mat.br_redova; i++)
            for(int j{0}; j&lt;mat.br_kolona; j++)
                pomocna.elementi [i][j] = mat.elementi[i][j] * x;
                
        return pomocna;
    }
template&lt;typename TipElemenata&gt;
    Matrica &lt;TipElemenata&gt; StepMatrica ( const Matrica&lt;TipElemenata&gt; &amp;mat, int stepen){
        Matrica&lt;TipElemenata&gt; pomocna = StvoriMatricu&lt;TipElemenata&gt;(mat.br_kolona, mat.br_redova);
        for(int i{0}; i&lt;pomocna.br_redova; i++) for (int j{0}; j&lt;mat.br_kolona; j++) pomocna.elementi[i][j] = mat.elementi[i][j];
        for(int i {0}; i&lt;stepen; i++){
            auto brisac = pomocna;
            pomocna = ProduktMatrica(pomocna,mat);
            UnistiMatricu(brisac);
        }
        return pomocna;
    }

template&lt;typename TipElemenata, typename tipKoef&gt;
    Matrica&lt;TipElemenata&gt; MatricniPolinom ( const Matrica&lt;TipElemenata&gt; &amp;mat,
    vector&lt;tipKoef&gt; koef){
         Matrica&lt;TipElemenata&gt; c;
         if( mat.br_redova != mat.br_kolona) throw domain_error("Matrica mora biti kvadratna");
         int format {mat.br_kolona};
         //Stvaranje jedinicne matrice radi konvencije
         auto jedinicna = StvoriMatricu&lt;TipElemenata&gt;(format,format);
         for(int i{0}; i&lt;format; i++) 
            for (int j{0}; j&lt;format; j++) 
                if(i==j) jedinicna.elementi[i][j] = 1;
                else jedinicna.elementi[i][j] = 0;
                
            auto pomic_za_brisanje = jedinicna;
            
        jedinicna = SkalarxMat&lt;TipElemenata&gt;(jedinicna, koef[0]);
        UnistiMatricu(pomic_za_brisanje);
        
        //Stvaranje pomocne koju cemo zapravo vratiti
        auto m3 = StvoriMatricu&lt;TipElemenata&gt;(format, format);
        
        int n {(int)koef.size()};
        //A sad sumiranje
        auto polinomka = StvoriMatricu&lt;TipElemenata&gt;(format, format);
        try{
        //Dodatni uslovi zbog jedinicne matrice
        //Ona se posebno tretira i pri racunu i pri vracanju iz funkcije
        if (n==0){
            for(int i{0}; i&lt;format; i++)
                for(int j{0}; j&lt;format; j++)
                    jedinicna.elementi[i][j] = 0;
                   
            return jedinicna;
        } 
        auto pomocnik = m3;
        m3 = ZbirMatrica(jedinicna, c=SkalarxMat&lt;TipElemenata&gt;(mat,koef[1]));
        UnistiMatricu(pomocnik);
        if(n==1) return m3;
        
       
        for(int i{0}; i&lt;format; i++)
            for(int j{0}; j&lt;format; j++)
                polinomka.elementi[i][j] = mat.elementi[i][j];
        
        for (int k{1}; k&lt;n-1; k++){
            
            
            //for(int l{0}; l&lt;k; l++){
                auto pom_za_bris1 = polinomka;
               
                polinomka = StepMatrica( mat, k );
                UnistiMatricu(pom_za_bris1);
            //} 
            auto pom_za_bris = polinomka;
            polinomka = SkalarxMat&lt;TipElemenata&gt;(polinomka, koef[k+1]);
            UnistiMatricu(pom_za_bris);
            
            
            auto pom_bris_m3 = m3;
            m3 = ZbirMatrica(m3, polinomka);
            UnistiMatricu(pom_bris_m3);
            
        }
        UnistiMatricu(jedinicna); UnistiMatricu(polinomka); UnistiMatricu(c);
        return m3;
        } catch (...) {
            UnistiMatricu(jedinicna); UnistiMatricu(m3); UnistiMatricu(polinomka); UnistiMatricu(c);
            throw;
        }
     
       
        
    }
    


int main (){
    cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    int n;
    cin&gt;&gt;n;
    
    
    Matrica&lt;int&gt; M, polinomka;
    try{
    M = StvoriMatricu&lt;int&gt;(n,n);
    
    cout &lt;&lt; "Unesite elemente matrice A: "&lt;&lt;endl;
    UnesiMatricu( 'A', M);
    
    vector&lt;int&gt; koef;
    cout &lt;&lt; "Unesite red polinoma: ";
    int red;
    cin&gt;&gt;red;
    cout &lt;&lt; "Unesite koeficijente polinoma: ";
    for(int i{0}; i&lt;=red; i++) {
        int koeficijent;
        cin&gt;&gt;koeficijent;
        koef.push_back(koeficijent);
    }
    
    
    polinomka = MatricniPolinom( M, koef );
    IspisiMatricu(  polinomka, 10, 6, true );
    
    } catch(...) {
        cout&lt;&lt;"Problemi s memorijom...";
        
    }
    UnistiMatricu(M);
    
    
    
	return 0;
}</pre>
</body>
</html>
