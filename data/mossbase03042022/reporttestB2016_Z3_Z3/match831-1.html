<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student2634.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student8430.cpp<p></p><pre>
/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
using namespace std;


template &lt;typename TipElemenata&gt;
struct Matrica {
    int br_redova, br_kolona;
    TipElemenata **elementi = nullptr; // VEOMA BITNA INICIJALIZACIJA!
};


template &lt;typename TipElemenata&gt;
void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat) {

    if(!mat.elementi) return;
    for(int i = 0; i &lt; mat.br_redova; i++) delete[] mat.elementi[i];
    delete[] mat.elementi;
<a name="3"></a><font color="#00FFFF"><a href="match831-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    mat.elementi = nullptr;

    
}

template&lt;typename Tip&gt;
void inicijalizuj(Matrica&lt;Tip&gt; &amp;matrica){
    
    for(int i = 0 ; i &lt; matrica.br_redova ; i++){
        for(int j = 0 ; j &lt; matrica.br_kolona ; j++){
</font>            matrica.elementi[i][j] = 0;
        }
    }
    
}


template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) {

    Matrica&lt;TipElemenata&gt; mat;
    mat.br_redova = br_redova; mat.br_kolona = br_kolona;
    mat.elementi = new TipElemenata*[br_redova];
    
    for(int i = 0; i &lt; br_redova; i++) mat.elementi[i] = nullptr;
        try {
        for(int i = 0; i &lt; br_redova; i++)
            mat.elementi[i] = new TipElemenata[br_kolona];
        }
        catch(...) {
        UnistiMatricu(mat);
        throw;
    }

return mat;
}


template &lt;typename TipElemenata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) {
    
    for(int i = 0; i &lt; mat.br_redova; i++)
        for(int j = 0; j &lt; mat.br_kolona; j++) {
            std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
            std::cin &gt;&gt; mat.elementi[i][j];
        }
    }


template &lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat,int sirina_ispisa, int preciznost = 6, bool treba_brisati = false) {

    for(int i = 0; i &lt; mat.br_redova; i++) {
        for(int j = 0; j &lt; mat.br_kolona; j++){
            std::cout &lt;&lt; std::setw(sirina_ispisa)&lt;&lt; std::setprecision(preciznost) &lt;&lt; mat.elementi[i][j];
        }
        std::cout &lt;&lt; std::endl;
    }
    
    if(treba_brisati){
        UnistiMatricu(mat);
    }

}


template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2) {
 
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
        throw std::domain_error("Matrice nemaju jednake dimenzije!");
    auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
    for(int i = 0; i &lt; m1.br_redova; i++)
        for(int j = 0; j &lt; m1.br_kolona; j++)
<a name="4"></a><font color="#FF00FF"><a href="match831-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

        m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
return m3;
}
 
template&lt;typename Tip&gt;
Matrica&lt;Tip&gt; ProduktMatrica(Matrica&lt;Tip&gt; &amp;matrica_1 , Matrica&lt;Tip&gt; &amp;matrica_2){
</font>    
    Matrica&lt;Tip&gt; matrica_3 = StvoriMatricu&lt;Tip&gt;(matrica_1.br_redova , matrica_2.br_kolona);
    inicijalizuj(matrica_3);
    
    if(matrica_2.br_redova == matrica_1.br_kolona){
        for(int i = 0 ; i &lt; matrica_1.br_redova ; i++){
            for(int j = 0 ; j &lt; matrica_2.br_kolona ; j++){
                
                double zbir = 0;
                for(int m = 0 ; m &lt; matrica_2.br_redova ; m++){
                    zbir = zbir + matrica_1.elementi[i][m] * matrica_2.elementi[m][j];
                }
                matrica_3.elementi[i][j] = zbir;
                
            }
        }
    }
    else{
        UnistiMatricu(matrica_3);
        throw std::domain_error("Matrice nisu saglasne za mnozenje");
    }
    
    return matrica_3;
}

<a name="2"></a><font color="#0000FF"><a href="match831-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

template&lt;typename Tip&gt;
void PomnoziSaBrojem(Matrica&lt;Tip&gt; &amp;matrica , double broj){

    for(int i = 0 ; i &lt; matrica.br_redova ; i++){
        for(int j = 0 ; j &lt; matrica.br_kolona ; j++){
</font>            matrica.elementi[i][j] = matrica.elementi[i][j] * broj;
        }
    }
}

<a name="0"></a><font color="#FF0000"><a href="match831-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

template&lt;typename Tip&gt;
void Kopiraj(Matrica&lt;Tip&gt; &amp;matrica_1 , Matrica&lt;Tip&gt; &amp;matrica_2){
    
    for(int i = 0 ; i &lt; matrica_1.br_redova ; i++){
        for(int j = 0 ; j &lt; matrica_1.br_kolona ; j++){
</font>            
            matrica_1.elementi[i][j] = matrica_2.elementi[i][j];
            
        }
    }
    
}

<a name="1"></a><font color="#00FF00"><a href="match831-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

template&lt;typename Tip&gt;
void Saberi(Matrica&lt;Tip&gt; &amp;matrica_1 , Matrica&lt;Tip&gt; &amp;matrica_2){
    
    for(int i = 0 ; i &lt; matrica_1.br_redova ; i++){
        for(int j = 0 ; j &lt; matrica_1.br_kolona ; j++){
</font>            
<a name="5"></a><font color="#FF0000"><a href="match831-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

            matrica_1.elementi[i][j] = matrica_1.elementi[i][j] + matrica_2.elementi[i][j];
            
        }
    }
    
}

template&lt;typename Tip&gt;
Matrica&lt;Tip&gt; MatricniPolinom(Matrica&lt;Tip&gt; &amp;matrica, vector&lt;double&gt; brojevi){
</font>    Matrica&lt;Tip&gt; rez = StvoriMatricu&lt;Tip&gt;(matrica.br_redova , matrica.br_kolona);
    inicijalizuj(rez);
    
    
    //IspisiMatricu(rez , 5 , 20);
    for(int i = 0 ; i &lt; brojevi.size() ; i++){

        Matrica&lt;Tip&gt; pomocna(StvoriMatricu&lt;Tip&gt;(matrica.br_redova, matrica.br_kolona));
        //inicijalizuj(pomocna);
        
        if(i == 0){
            
            for(int m = 0 ; m &lt; pomocna.br_redova ; m++){
                for(int j = 0 ; j &lt; pomocna.br_kolona ; j++){
                    
                    if(m == j){
                        pomocna.elementi[m][j] = 1;
                    }
                    else{
                        pomocna.elementi[m][j] = 0;
                    }
                }
            }
        }
        else{
            //pomocna = matrica;
            Kopiraj(pomocna, matrica);
        }
        
        for(int j = 0 ; j &lt; i - 1 ; j++){
            Matrica&lt;Tip&gt; privremena(StvoriMatricu&lt;Tip&gt;(pomocna.br_redova , pomocna.br_kolona));
            //inicijalizuj(privremena);
            Kopiraj(privremena, pomocna);
            //UnistiMatricu(pomocna);
           // cout &lt;&lt; "Unisti pomocnu" &lt;&lt; endl;
            Matrica&lt;Tip&gt; prod(ProduktMatrica(matrica, privremena));
            Kopiraj(pomocna, prod);
            //pomocna = ProduktMatrica(matrica , privremena);
            //Kopiraj(pomocna, ProduktMatrica(matrica, privremena));
            //pomocna = ProduktMatrica(matrica, pomocna);
            UnistiMatricu(privremena);
            UnistiMatricu(prod);
        }

        Matrica&lt;Tip&gt; produkt(StvoriMatricu&lt;Tip&gt;(pomocna.br_redova , pomocna.br_kolona));
        inicijalizuj(produkt);
        
        Kopiraj(produkt , pomocna);
        
        PomnoziSaBrojem(produkt, brojevi[i]);
        
        Saberi(rez, produkt);
        
        
      
        UnistiMatricu(pomocna);
        UnistiMatricu(produkt);
        
        //return rez;
        
    }

    return rez;
}
 
int main(){

    cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    int dimenzija;
    cin &gt;&gt; dimenzija;
    Matrica&lt;double&gt; matrica = StvoriMatricu&lt;double&gt;(dimenzija, dimenzija);
    cout &lt;&lt; "Unesite elemente matrice A:" &lt;&lt; endl;
    UnesiMatricu('A' , matrica);
    cout &lt;&lt; "Unesite red polinoma: ";
    int red_polinoma;
    cin &gt;&gt; red_polinoma;
    cout &lt;&lt; "Unesite koeficijente polinoma: ";
    vector&lt;double&gt; v;
    for(int i = 0 ; i &lt;= red_polinoma ; i++){
        int b;
        cin &gt;&gt; b;
        v.push_back(b);
    }
    Matrica&lt;double&gt; rez = MatricniPolinom(matrica, v);
    IspisiMatricu(rez, 10, 6);
    UnistiMatricu(rez);
    UnistiMatricu(matrica);
    

  
    return 0;
}</pre>
</body>
</html>
