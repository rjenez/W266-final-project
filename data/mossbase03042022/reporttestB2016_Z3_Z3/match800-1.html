<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student2922.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student2888.cpp<p></p><pre>
<a name="2"></a><font color="#0000FF"><a href="match800-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;new&gt;
using namespace std;
template&lt;typename TipElemenata&gt; struct Matrica {
int br_redova, br_kolona;
TipElemenata**elementi= nullptr; };
</font>

template &lt;typename TipElemenata&gt;
 void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat) {
 if(!mat.elementi) return;
 for(int i = 0; i &lt; mat.br_redova; i++) delete[] mat.elementi[i];
 delete[] mat.elementi;
 mat.elementi = nullptr;
 }

template&lt;typename TipElemenata&gt; 
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) {
Matrica&lt;TipElemenata&gt; mat;
mat.br_redova = br_redova;
mat.br_kolona = br_kolona;
mat.elementi = new TipElemenata*[br_redova];
for(int i = 0; i &lt; br_redova; i++)
mat.elementi[i] = nullptr;
try
{
for(int i = 0; i &lt; br_redova; i++) 
mat.elementi[i] = new TipElemenata[br_kolona];  
}
catch
(...) {
UnistiMatricu(mat);
throw ;
}
return mat;
}
template&lt;typename TipElemenata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) {
for(int i = 0; i &lt; mat.br_redova; i++)
<a name="1"></a><font color="#00FF00"><a href="match800-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

for(int j = 0; j &lt; mat.br_kolona; j++) {
cout &lt;&lt; ime_matrice&lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
cin &gt;&gt; mat.elementi[i][j];
}
}
template&lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt;&amp;mat, int sirina_ispisa,int preciznost = 6,bool treba_brisati=false){
</font>    if(treba_brisati==true) UnistiMatricu(mat);
for(int i = 0; i &lt; mat.br_redova; i++) {
<a name="0"></a><font color="#FF0000"><a href="match800-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

for(int j = 0; j &lt; mat.br_kolona; j++) 
cout &lt;&lt; setw(sirina_ispisa)&lt;&lt;setprecision(preciznost) &lt;&lt; mat.elementi[i][j];
cout &lt;&lt; endl;
if(treba_brisati) UnistiMatricu(mat);
}
}
template&lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1,const Matrica&lt;TipElemenata&gt; &amp;m2) {
if (m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)throw domain_error("Matrice nemaju jednake dimenzije!");
</font>auto m3 (StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova,m1.br_kolona));
for(int i = 0; i &lt; m1.br_redova; i++)
for( int j = 0; j &lt; m1.br_kolona; j++)
m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
return m3;
}
template&lt;typename TipElemenata&gt;
<a name="3"></a><font color="#00FFFF"><a href="match800-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

Matrica&lt;TipElemenata&gt;ProduktMatrica(const Matrica&lt;TipElemenata&gt;&amp;m1,const Matrica&lt;TipElemenata&gt;&amp;m2){
    if(m1.br_kolona!=m2.br_redova) throw domain_error("Matrice nisu saglasne za mnozenje");
     Matrica&lt;TipElemenata&gt;x;
</font>    auto m3=(x=StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova,m2.br_kolona));
    for(int i=0;i&lt;m1.br_redova;i++)
    for(int j=0;j&lt;m2.br_kolona;j++)
    for(int k=0;k&lt;m2.br_kolona;k++)
    m3.elementi[i][j]+=m1.elementi[i][k]*m2.elementi[k][j];
    UnistiMatricu(x);
    return m3;
}

template&lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; MatricniPolinom(const Matrica&lt;TipElemenata&gt; &amp;m, vector&lt;double&gt; &amp;v){
    if(m.br_redova!=m.br_kolona) throw domain_error("Matrica mora biti kvadratna");
    Matrica&lt;TipElemenata&gt;a,b,c,d,e,f,g;
    auto Jed (a=StvoriMatricu&lt;TipElemenata&gt;(m.br_redova,m.br_kolona));
    for(int i=0;i&lt;Jed.br_redova;i++){
        for(int j=0;j&lt;Jed.br_kolona;j++){
            Jed.elementi[i][j]=0;
        }
    }
    for(int i=0;i&lt;Jed.br_redova;i++)
    Jed.elementi[i][i]=1;
    auto Null(b=StvoriMatricu&lt;TipElemenata&gt;(m.br_redova,m.br_kolona));
    for(int i=0;i&lt;Null.br_redova;i++)
    for(int j=0;j&lt;Null.br_kolona;j++)
    Null.elementi[i][j]=0;
  
   if(v.size()==0) return Null;
    auto Nova(c=StvoriMatricu&lt;TipElemenata&gt;(m.br_redova,m.br_kolona));
    auto Zavrsna(d=StvoriMatricu&lt;TipElemenata&gt;(m.br_redova,m.br_kolona));
    for(int j=0;j&lt;Nova.br_redova;j++)
            for(int k=0;k&lt;Nova.br_kolona;k++)
            Nova.elementi[j][k]=m.elementi[j][k];
    auto Nova2(e=StvoriMatricu&lt;TipElemenata&gt;(m.br_redova,m.br_kolona));
    auto Pomocna(f=StvoriMatricu&lt;TipElemenata&gt;(m.br_redova,m.br_kolona));
    for(int i=0;i&lt;v.size();i++){
        if(i==0){
            for(int j=0;j&lt;Jed.br_redova;j++)
            for(int k=0;k&lt;Jed.br_kolona;k++)
            Jed.elementi[j][k]=Jed.elementi[j][k]*v[0];
        
        //Ispis prve
  /*     cout&lt;&lt;"Matrica za i="&lt;&lt;i&lt;&lt;": "&lt;&lt;endl;
        for(int j=0;j&lt;Jed.br_redova;j++){
            for(int k=0;k&lt;Jed.br_kolona;k++)
            cout&lt;&lt;Jed.elementi[j][k]&lt;&lt;"  ";
            cout&lt;&lt;endl;
        } */
        
        }
        else if(i==1){
            for(int j=0;j&lt;m.br_redova;j++)
            for(int k=0;k&lt;m.br_kolona;k++)
            Pomocna.elementi[j][k]=m.elementi[j][k];
            for(int j=0;j&lt;m.br_redova;j++)
            for(int k=0;k&lt;m.br_kolona;k++)
            Pomocna.elementi[j][k]=Pomocna.elementi[j][k]*v[1];
     /*          cout&lt;&lt;"Matrica za i="&lt;&lt;i&lt;&lt;": "&lt;&lt;endl;
        for(int j=0;j&lt;Pomocna.br_redova;j++){
            for(int k=0;k&lt;Pomocna.br_kolona;k++)
            cout&lt;&lt;Pomocna.elementi[j][k]&lt;&lt;"  ";
            cout&lt;&lt;endl;
        }*/ 
        }
        else{
            Nova=(g=ProduktMatrica(Nova,m));
            for(int j=0;j&lt;m.br_redova;j++)
                for(int k=0;k&lt;m.br_kolona;k++)
                    Nova2.elementi[j][k]=Nova.elementi[j][k]*v[i];
     /*       cout&lt;&lt;"Matrica za i="&lt;&lt;i&lt;&lt;": "&lt;&lt;endl;
            for(int j=0;j&lt;Nova.br_redova;j++){
            for(int k=0;k&lt;Nova.br_kolona;k++)
           cout&lt;&lt;Nova.elementi[j][k]&lt;&lt;" ";
           cout&lt;&lt;endl;
            } */
        }
       
}
for(int i=0;i&lt;m.br_redova;i++)
for(int j=0;j&lt;m.br_kolona;j++)
Zavrsna.elementi[i][j]=Jed.elementi[i][j]+Pomocna.elementi[i][j]+Nova.elementi[i][j];
        
/*    for(int i=0;i&lt;m.br_redova;i++){
for(int j=0;j&lt;m.br_kolona;j++)
    cout&lt;&lt;Zavrsna.elementi[i][j]&lt;&lt;" ";
cout&lt;&lt;endl;
} */
UnistiMatricu(a);UnistiMatricu(b);UnistiMatricu(c);UnistiMatricu(d);UnistiMatricu(e);UnistiMatricu(f);UnistiMatricu(g);
return Zavrsna;
    
    }
    
   



int main() {
Matrica&lt;double&gt; a, b, c,d;
int m;
cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
cin&gt;&gt;m;
vector&lt;double&gt;v;
int dim;
int x;
try
{
a = StvoriMatricu&lt;double&gt;(m,m); 
cout &lt;&lt; "Unesite elemente matrice A:"&lt;&lt;endl;;
UnesiMatricu('A', a);
cout&lt;&lt;"Unesite red polinoma: ";
cin&gt;&gt;dim;
cout&lt;&lt;"Unesite koeficijente polinoma: ";
for(int i=0;i&lt;dim+1;i++){
cin&gt;&gt;x;
v.push_back(x);
}

d=MatricniPolinom(a,v);
IspisiMatricu(d,10,6,true);

}
catch(bad_alloc) {
cout &lt;&lt; "Nema dovoljno memorije!\n";
}
UnistiMatricu(a);UnistiMatricu(d);
return 0;
}</pre>
</body>
</html>
