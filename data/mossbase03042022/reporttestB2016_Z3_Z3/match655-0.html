<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student6029.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student6029.cpp<p></p><pre>
/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
//#include "TestCurenja.h"

using namespace std;

template &lt;typename TipElemenata&gt;
 struct Matrica 
 {
    int br_redova, br_kolona; 
    TipElemenata **elementi = nullptr; // VEOMA BITNA INICIJALIZACIJA!
 };
 
 template &lt;typename TipElemenata&gt;
 void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false) 
 {
<a name="1"></a><font color="#00FF00"><a href="match655-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    for(int i = 0; i &lt; mat.br_redova; i++) 
    {
        for(int j = 0; j &lt; mat.br_kolona; j++)
        cout&lt;&lt;setw(sirina_ispisa)&lt;&lt;setprecision(preciznost)&lt;&lt;mat.elementi[i][j];
        cout&lt;&lt;endl;
    }
    if(treba_brisati)
        UnistiMatricu(mat);
 }
 
template &lt;typename TipElemenata&gt;
</font> void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat) 
 {
     //cout&lt;&lt;"Unistavam matricu: "&lt;&lt;endl; IspisiMatricu(mat, 10);
    if(!mat.elementi) return;
    for(int i = 0; i &lt; mat.br_redova; i++) 
        delete[] mat.elementi[i];
    delete[] mat.elementi;
    mat.elementi = nullptr;
 }
 
template &lt;typename TipElemenata&gt;
 Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) 
 {
    //cout&lt;&lt;"STVORI MATRICU"&lt;&lt;endl;
    Matrica&lt;TipElemenata&gt; mat;
    mat.br_redova = br_redova; mat.br_kolona = br_kolona;
    mat.elementi = new TipElemenata*[br_redova];
    for(int i=0; i&lt;br_redova; i++)
        mat.elementi[i]=nullptr;
    try 
    {
        for(int i = 0; i &lt; br_redova; i++)
            mat.elementi[i] = new TipElemenata[br_kolona];
    }
    catch(...) 
    {
        UnistiMatricu(mat);
        throw;
    }
 return mat;
 }
 
template &lt;typename TipElemenata&gt;
 void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) 
 {
<a name="0"></a><font color="#FF0000"><a href="match655-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    for(int i = 0; i &lt; mat.br_redova; i++)
    for(int j = 0; j &lt; mat.br_kolona; j++) 
    {
        cout &lt;&lt; ime_matrice&lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
        cin &gt;&gt; mat.elementi[i][j];
    }
 }

 
 
 template &lt;typename TipElemenata&gt;
</font><a name="2"></a><font color="#0000FF"><a href="match655-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

 Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2) 
 {
    //cout&lt;&lt;"ZBIR MATRICA"&lt;&lt;endl;
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
        throw domain_error("Matrice nemaju jednake dimenzije!");
    auto pom(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
    for(int i = 0; i &lt; m1.br_redova; i++)
</font>        for(int j = 0; j &lt; m1.br_kolona; j++)
            pom.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
    return pom;
    
 }

template &lt;typename TipElemenata&gt;
<a name="3"></a><font color="#00FFFF"><a href="match655-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

Matrica&lt;TipElemenata&gt; ProduktMatrica(Matrica&lt;TipElemenata&gt; m1, const Matrica&lt;TipElemenata&gt; &amp;m2)
{
    //cout&lt;&lt;"PRODUKT MATRICA"&lt;&lt;endl;
    if(m1.br_kolona != m2.br_redova)
        throw domain_error("Matrice nisu saglasne za mnozenje");
        
    auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona));
    for(int i=0; i&lt;m1.br_redova; i++)
</font>    {
        int suma=0;
        for(int j=0; j&lt;m2.br_kolona; j++)
        {
            suma=0;
            for(int k=0; k&lt;m2.br_redova; k++)
                suma+=m1.elementi[i][k]*m2.elementi[k][j];
            m3.elementi[i][j]=suma;
        }
    }
    return m3;
}


template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StepenujMatricu(Matrica&lt;TipElemenata&gt; &amp;m, int stepen)
{
    //cout&lt;&lt;"STEPENUJ"&lt;&lt;endl;
    auto mat(StvoriMatricu&lt;TipElemenata&gt;(m.br_redova, m.br_kolona));
    auto pom(StvoriMatricu&lt;TipElemenata&gt;(m.br_redova, m.br_kolona));
    for(int i=0; i&lt;m.br_redova; i++)
        for(int j=0; j&lt;m.br_kolona; j++)
        {
            mat.elementi[i][j]=m.elementi[i][j];
            pom.elementi[i][j]=m.elementi[i][j];
        }
    if(stepen==0)
        for(int i=0; i&lt;m.br_redova; i++)
            for(int j=0; j&lt;m.br_kolona; j++)
                {
                    if(i==j)
                        mat.elementi[i][j]=1;
                    else
                        mat.elementi[i][j]=0;
                }
    else
        for(int i=1; i&lt;stepen; i++)
        {    
            Matrica&lt;TipElemenata&gt;pom2=ProduktMatrica(mat, pom);
            for(int i=0; i&lt;m.br_redova; i++)
                for(int j=0; j&lt;m.br_kolona; j++)
                    mat.elementi[i][j]=pom2.elementi[i][j];
            UnistiMatricu(pom2);
            
        }
    UnistiMatricu(pom);
    return mat;
}


template &lt;typename TipElemenata1, typename TipElemenata2&gt;
Matrica&lt;TipElemenata1&gt; PomnoziSkalarom(const Matrica&lt;TipElemenata1&gt; &amp;m1, TipElemenata2 a)
{
    //cout&lt;&lt;"POMNOZI SA SKALAROM"&lt;&lt;endl;
    auto pom(StvoriMatricu&lt;TipElemenata1&gt;(m1.br_redova, m1.br_kolona));
    for(int i=0; i&lt;m1.br_redova; i++)
        for(int j=0; j&lt;m1.br_kolona; j++)
            pom.elementi[i][j]=m1.elementi[i][j]*a;
    return pom;
}


template &lt;typename TipElemenata, typename TipElemenata2&gt;
Matrica&lt;TipElemenata&gt; MatricniPolinom(const Matrica&lt;TipElemenata&gt; &amp;mat, vector&lt;TipElemenata2&gt; koef)
{
    //cout&lt;&lt;"MATRICNI POLINOM"&lt;&lt;endl;
    if(mat.br_kolona!=mat.br_redova)
        throw domain_error("Matrica mora biti kvadratna");
        
    auto pom(StvoriMatricu&lt;TipElemenata&gt;(mat.br_redova, mat.br_kolona));
    for(int i=0; i&lt;mat.br_redova; i++)
<a name="4"></a><font color="#FF00FF"><a href="match655-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        for(int j=0; j&lt;mat.br_kolona; j++)
            pom.elementi[i][j]=0;
    
    if(koef.size()==0)
</font>        return pom;
        
    auto salji(StvoriMatricu&lt;TipElemenata&gt;(mat.br_redova, mat.br_kolona));
    
    for(int f=0; f&lt;koef.size(); f++)
    {
        for(int i=0; i&lt;mat.br_redova; i++)
            for(int j=0; j&lt;mat.br_kolona; j++)
                salji.elementi[i][j]=mat.elementi[i][j];
        Matrica&lt;TipElemenata&gt; pom1=StepenujMatricu(salji, f);
        Matrica&lt;TipElemenata&gt; pom2=PomnoziSkalarom(pom1, koef[f]);
        Matrica&lt;TipElemenata&gt; pom3=ZbirMatrica(pom, pom2);
        
        for(int i=0; i&lt;mat.br_redova; i++)
            for(int j=0; j&lt;mat.br_kolona; j++)
                pom.elementi[i][j]=pom3.elementi[i][j];
        UnistiMatricu(pom3); UnistiMatricu(pom2); UnistiMatricu(pom1);
        /*cout&lt;&lt;endl&lt;&lt;"Prije stepenovanja: "&lt;&lt;endl;
        IspisiMatricu(mat, 7);
        cout&lt;&lt;endl&lt;&lt;"Nakon stepenovanja: "&lt;&lt;endl;
        IspisiMatricu(StepenujMatricu(mat, i),7);
        cout&lt;&lt;endl&lt;&lt;"Nakon mnozenja skalarom: "&lt;&lt;endl;
        IspisiMatricu(PomnoziSkalarom(StepenujMatricu(mat, i), koef[i]),7);
        cout&lt;&lt;endl&lt;&lt;"-------------------"&lt;&lt;endl;
        IspisiMatricu(pom, 7);
        cout&lt;&lt;endl;*/
    }
    UnistiMatricu(salji);
    return pom;
}


int main()
{
    //UKLJUCI_OBAVJESTAVANJE;
    
     int dim;
     cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
     cin &gt;&gt;dim;
     Matrica&lt;double&gt; a;
     try {
         a = StvoriMatricu&lt;double&gt;(dim, dim);
         //b = StvoriMatricu&lt;double&gt;(m, n);
         cout &lt;&lt; "Unesite elemente matrice A: "&lt;&lt;endl;
         UnesiMatricu('A', a);
         //cout &lt;&lt; "Unesi matricu B:\n";
         //UnesiMatricu('B', b);
         //cout &lt;&lt; "Produkt ove dvije matrice je:\n";
         //IspisiMatricu(c = ProduktMatrica(a, b), 7);
         //cout&lt;&lt;endl&lt;&lt;"Stepenovana prva na 3 iznosi: "&lt;&lt;endl;
         //IspisiMatricu(c=StepenujMatricu(a, 3), 7);
         cout&lt;&lt;"Unesite red polinoma: ";
         int red;
         cin&gt;&gt;red;
         cout&lt;&lt;"Unesite koeficijente polinoma: ";
         vector&lt;double&gt; koef; int br=0; 
         if(red!=0)
         {
            for(int i=0; i&lt;=red; i++)
            {
                cin&gt;&gt;br;
                koef.push_back(br);
            }
         }
        Matrica&lt;double&gt;c=MatricniPolinom(a, koef);
         IspisiMatricu(c,10);
         UnistiMatricu(c);UnistiMatricu(a); 
     }
     catch(domain_error dom)
     {
         cout&lt;&lt;dom.what();
         UnistiMatricu(a);
     }
     catch(bad_alloc) 
     {
        cout &lt;&lt; "Nema dovoljno memorije!\n";
     }
     
     return 0;
}</pre>
</body>
</html>
