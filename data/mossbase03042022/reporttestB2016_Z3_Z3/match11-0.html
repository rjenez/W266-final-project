<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student6516.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student6516.cpp<p></p><pre>
<a name="2"></a><font color="#0000FF"><a href="match11-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

using std::cout;
using std::cin;
using std::endl;

template&lt;typename tip&gt;
struct Matrica {
    int br_redova, br_kolona;
    tip ** elementi= nullptr;
    
};

template&lt;typename tip&gt;
void UnistiMatricu( Matrica&lt;tip&gt; mat)
</font>{
    if(!mat.elementi) return;
    for(int i=0; i&lt;mat.br_redova; i++)
    {
        delete[] mat.elementi[i];
    }
    delete[] mat.elementi;
    mat.elementi=nullptr;
}

template&lt;typename tip&gt;
Matrica&lt;tip&gt; StvoriMatricu ( int br_redova, int br_kolona)
{
    Matrica&lt;tip&gt; mat;
<a name="1"></a><font color="#00FF00"><a href="match11-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_16.gif"/></a>

    mat.br_redova=br_redova;
    mat.br_kolona=br_kolona;
    mat.elementi= new tip*[br_redova];
    for( int i(0); i&lt;br_redova; i++)
    {
        mat.elementi[i]=nullptr;
    }
    try{
        
        for(int i(0); i&lt;br_redova; i++)
        {
            mat.elementi[i]= new tip[br_kolona];
        }
        for( int i=0; i&lt;br_redova; i++)
        {
            for( int j=0; j&lt;br_kolona; j++)
            {
                mat.elementi[i][j]=0;
            }
        }
        
    }
    catch(... ){
        UnistiMatricu(mat);
        throw;
        
        }
    return mat;
    
}

template&lt; typename tip&gt;
void UnesiMatricu( char ime_matrice, Matrica&lt;tip&gt; &amp;mat)
{
    for( int i=0; i&lt;mat.br_redova; i++)
    {
        for( int j =0; j&lt;mat.br_kolona; j++)
        {
            cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
            cin&gt;&gt;mat.elementi[i][j];
        }
    }
}

template &lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat,int sirina_ispisa, int preciznost=6, bool treba_brisati=false) 
</font>{
    for(int i = 0; i &lt; mat.br_redova; i++) 
    {
        for(int j = 0; j &lt; mat.br_kolona; j++)
        {
<a name="0"></a><font color="#FF0000"><a href="match11-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_67.gif"/></a>

            std::cout &lt;&lt; std::setprecision(preciznost)&lt;&lt;std::setw(sirina_ispisa) &lt;&lt; mat.elementi[i][j];
        }
    std::cout &lt;&lt; std::endl;
    }
    if(treba_brisati==true)
    {
        UnistiMatricu(mat);
    }
}
template&lt;typename tip&gt;
void ZbirMatrica( Matrica&lt;tip&gt; &amp;m1, const Matrica&lt;tip&gt; &amp; m2)
{
    for( int i=0; i&lt;m1.br_redova; i++)
    {
        for( int j=0; j&lt;m1.br_kolona; j++)
        {
            m1.elementi[i][j]+=m2.elementi[i][j];
        }
    }
}
        

template&lt;typename tip&gt;
Matrica&lt;tip&gt; ProduktMatrica ( const Matrica&lt;tip&gt; &amp;a, const  Matrica&lt;tip&gt; &amp;b)
{
    if(a.br_kolona != b.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
    Matrica&lt;tip&gt; c;
    try{
        c=StvoriMatricu&lt;tip&gt;(a.br_redova,b.br_kolona);
    }
    catch(std::bad_alloc)
    {
        UnistiMatricu(c);
        throw;
    }
    for(int i=0; i&lt;a.br_redova; i++)
    {
        for(int j=0; j&lt;b.br_kolona; j++)
        {
            tip suma{};
            for(int k=0; k&lt;a.br_kolona; k++)
            {
               suma+=a.elementi[i][k] * b.elementi[k][j];
            }
            c.elementi[i][j]=suma;
       
        }
    }
    
    return c;
    
}

template&lt;typename tip&gt;
void MnozenjeSaSkalarom( double n, Matrica&lt;tip&gt; &amp;mat)
{
    for(int i=0; i&lt;mat.br_redova; i++)
    {
        for(int j=0; j&lt;mat.br_kolona; j++)
        {
            mat.elementi[i][j]=n*mat.elementi[i][j];
        }
    }
    
}



template&lt;typename tip&gt;
Matrica&lt;tip&gt; MatricniPolinom ( Matrica&lt;tip&gt; mat, std::vector&lt;double&gt; v)
{
    if(mat.br_kolona != mat.br_redova) throw std::domain_error("Matrica mora biti kvadratna");
    Matrica&lt;tip&gt; mat_pol;
    try
    {
        mat_pol=StvoriMatricu&lt;tip&gt;(mat.br_redova, mat.br_kolona);
    }
    
    catch(std::bad_alloc)
    {
        UnistiMatricu(mat_pol);
        throw;
    }
   if(v.size()==0) return mat_pol;
   std::vector&lt;Matrica&lt;tip&gt;&gt; vektor_matrica(v.size());
   try{
     
     vektor_matrica[0]=StvoriMatricu&lt;tip&gt;(mat.br_redova, mat.br_kolona);
     vektor_matrica[1]=StvoriMatricu&lt;tip&gt;(mat.br_redova, mat.br_kolona);
   }
   catch(std::bad_alloc)
    {
        
        UnistiMatricu(vektor_matrica[0]);
        UnistiMatricu(vektor_matrica[1]);
         throw;
    }
   for(int i=0; i&lt;mat.br_redova; i++)
        {
            for(int j=0; j&lt;mat.br_kolona; j++)
            {
                if(i==j) vektor_matrica[0].elementi[i][j]=1;
                else vektor_matrica[0].elementi[i][j]=0;
            }
        }
    for( int i=0; i&lt;mat.br_redova; i++)
        {
            for( int j=0; j&lt;mat.br_kolona; j++)
            {
                vektor_matrica[1].elementi[i][j]=mat.elementi[i][j];
            }
        }
    for( int i=2; i&lt;v.size(); i++)
        {
            try
            {
                
                vektor_matrica[i]=ProduktMatrica(vektor_matrica[i-1], mat);
            }
            catch(std::bad_alloc)
            {
                for(int i=0; i&lt;v.size(); i++)
                {
                    UnistiMatricu(vektor_matrica[i]);
                }
                throw;
            }
        }
    try{
       for(int i=0; i&lt;v.size(); i++)
       {
           MnozenjeSaSkalarom(v[i], vektor_matrica[i]);
       }}
    catch(std::bad_alloc)
       {
           for(int i=0; i&lt;v.size(); i++)
           {
               UnistiMatricu(vektor_matrica[i]);
           }
           throw;
       }
    for( int i=0; i&lt;v.size(); i++)
       {
           ZbirMatrica(mat_pol, vektor_matrica[i]);
           UnistiMatricu(vektor_matrica[i]);
       }

    return mat_pol;
        
}


int main ()
{
    Matrica&lt;double&gt; a,c;
    cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    int br_redova;
    cin&gt;&gt;br_redova;
    try {
        a=StvoriMatricu&lt;double&gt;(br_redova , br_redova);
        cout&lt;&lt;"Unesite elemente matrice A: "&lt;&lt;endl;
        UnesiMatricu('A', a);
        cout&lt;&lt;"Unesite red polinoma: ";
        int n;
        cin&gt;&gt;n;
        n++;
        std::vector&lt;double&gt; v;
        cout&lt;&lt;"Unesite koeficijente polinoma: ";
        for(int i=0; i&lt;n; i++)
        {
            double broj;
            cin&gt;&gt;broj;
            v.push_back(broj);
        }
        try{
            c=MatricniPolinom(a,v);
            IspisiMatricu(c,10);
              UnistiMatricu(a);
            UnistiMatricu(c);
        }
        catch(std::domain_error e)
        {
              UnistiMatricu(a);
                UnistiMatricu(c);
            cout&lt;&lt;e.what();
        }
    }
    catch(std::bad_alloc)
    {
        UnistiMatricu(a);
        UnistiMatricu(c);
        cout&lt;&lt;"Nema dovoljno memorije!";
</font>    }
 
	return 0;
}</pre>
</body>
</html>
