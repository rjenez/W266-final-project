<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student3047.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student2586.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

template &lt;typename TipElemenata&gt;
struct Matrica
{
	int br_redova, br_kolona;
	TipElemenata** elementi = nullptr;
};

template &lt;typename TipElemenata&gt;
void UnistiMatricu (Matrica&lt;TipElemenata&gt; mat)
{
	if (!mat.elementi)
		return;
	for (int i = 0; i &lt; mat.br_redova; i++)
<a name="1"></a><font color="#00FF00"><a href="match36-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

		delete[] mat.elementi[i];
	delete[] mat.elementi;
	mat.elementi = nullptr;
}

template &lt;typename TipElemenata&gt;
void AnulirajMatricu (Matrica&lt;TipElemenata&gt;&amp; mat)
{
	for (int i = 0; i &lt; mat.br_redova; i++)
		for (int j = 0; j &lt; mat.br_kolona; j++)
			mat.elementi[i][j] = 0;
}
template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu (int br_redova, int br_kolona)
{
	Matrica&lt;TipElemenata&gt; mat;
	mat.br_redova = br_redova;
</font>	mat.br_kolona = br_kolona;
	mat.elementi = new TipElemenata*[br_redova];
	for (int i = 0; i &lt; br_redova; i++)
		mat.elementi[i] = nullptr;
	try
	{
		for (int i = 0; i &lt; br_redova; i++)
			mat.elementi[i] = new TipElemenata[br_kolona];
	}
	catch (...)
	{
		UnistiMatricu (mat);
		throw;
	}
	return mat;
}
template &lt;typename TipElemenata&gt;
void UnesiMatricu (char ime_matrice, Matrica&lt;TipElemenata&gt;&amp; mat)
{
	for (int i = 0; i &lt; mat.br_redova; i++)
		for (int j = 0; j &lt; mat.br_kolona; j++)
		{
<a name="2"></a><font color="#0000FF"><a href="match36-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

			std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
			std::cin &gt;&gt; mat.elementi[i][j];
		}
}
template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ZbirMatrica (const Matrica&lt;TipElemenata&gt;&amp; m1, const Matrica&lt;TipElemenata&gt;&amp; m2, bool treba_brisati = false)
{
	if (m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
		throw std::domain_error ("Matrice nemaju jednake dimenzije!");
	auto m3 (StvoriMatricu&lt;TipElemenata&gt; (m1.br_redova, m1.br_kolona) );
</font>	for (int i = 0; i &lt; m1.br_redova; i++)
		for (int j = 0; j &lt; m1.br_kolona; j++)
<a name="0"></a><font color="#FF0000"><a href="match36-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_64.gif"/></a>

			m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
	if (treba_brisati)
		UnistiMatricu (m1);
	
	return m3;
}
template &lt;typename TipElemenata&gt;
void IspisiMatricu (const Matrica&lt;TipElemenata&gt;&amp; mat, int sirina_ispisa, int preciznost = 6, bool treba_brisati = false)
{
	for (int i = 0; i &lt; mat.br_redova; ++i)
	{
		for (int j = 0; j &lt; mat.br_kolona; ++j)
			std::cout &lt;&lt; std::setw (sirina_ispisa) &lt;&lt; std::setprecision (preciznost) &lt;&lt; mat.elementi[i][j];
		std::cout &lt;&lt; "\n";
	}
	std::cout &lt;&lt; "\n";
	if (treba_brisati)
		UnistiMatricu (mat);
}

template&lt;typename T&gt;
Matrica&lt;T&gt; ProduktMatrica(const Matrica&lt;T&gt;&amp; m1, const Matrica&lt;T&gt;&amp; m2)
{
    if(m1.br_kolona !=  m2.br_redova)
        throw std::domain_error("Matrice nisu saglasne za mnozenje");
    auto m = StvoriMatricu&lt;T&gt;(m1.br_redova, m2.br_kolona);
    for(int i = 0; i &lt; m1.br_redova; ++i){
        for(int j = 0; j &lt; m2.br_kolona; ++j){
            double suma = 0;
            for(int k = 0; k &lt; m2.br_redova; ++k)
                suma += m1.elementi[i][k] * m2.elementi[k][j];
            m.elementi[i][j]=suma;
        }
    }
    return m;
}

template&lt;typename T&gt;
Matrica&lt;T&gt; Jedinicna(int dim)
{
    auto m = StvoriMatricu&lt;T&gt;(dim, dim);
    for(int i = 0; i &lt; dim; ++i)
        for(int j = 0; j &lt; dim ; ++j)
        if( i == j)
            m.elementi[i][i] = 1;
        else
            m.elementi[i][j] = 0;
    return m;
}


template&lt;typename T&gt;
void Pomnozi_skalarom(Matrica&lt;T&gt;&amp; m, int n)
{
    for(int i = 0; i &lt;m.br_redova; ++i)
        for(int j = 0; j &lt; m.br_kolona; ++j)
            m.elementi[i][j] *= n;
}

template&lt;typename T&gt;
void Dodijela(Matrica&lt;T&gt;&amp; m, const Matrica&lt;T&gt; &amp; m2, bool treba_brisati = false)
{
    for(int i = 0; i &lt;m.br_redova; ++i)
        for(int j = 0; j &lt; m.br_kolona; ++j)
            m.elementi[i][j] = m2.elementi[i][j];
    if(treba_brisati)
        UnistiMatricu(m2);
}


template&lt;typename T&gt;
Matrica&lt;T&gt; MatricniPolinom(const Matrica&lt;T&gt;&amp; A, const std::vector&lt;double&gt;&amp; p)
{
    if(A.br_kolona != A.br_redova)
        throw std::domain_error("Matrica mora biti kvadratna");
        
    Matrica&lt;T&gt; s, m1, m2;
    try {
        s = Jedinicna&lt;T&gt;(A.br_kolona);
        if(p.size() == 0){
            AnulirajMatricu(s);
            return s;
        }
    
        Pomnozi_skalarom(s, p[0]);
        
        m1 = StvoriMatricu&lt;T&gt;(A.br_kolona, A.br_kolona);
        Dodijela(m1, A);
        
        m2 = StvoriMatricu&lt;T&gt;(A.br_kolona, A.br_kolona);
        Dodijela(m2, A);
        
        for(int i = 1; i&lt; p.size(); ++i){
            Pomnozi_skalarom(m1, p[i]);
            s = ZbirMatrica(s, m1, true);
            Dodijela(m2, ProduktMatrica(m2, A), true);
            Dodijela(m1, m2);
           
        }
    }
    catch (std::bad_alloc) {
       UnistiMatricu(s);
       UnistiMatricu(m1);
       UnistiMatricu(m2);
       throw;
    }
    UnistiMatricu(m1);
    UnistiMatricu(m2);
    return s;
}

int main()
{
    std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    int n;
    std::cin &gt;&gt; n;
    auto A = StvoriMatricu&lt;double&gt;(n, n);
    std::cout &lt;&lt; "Unesite elemente matrice A: \n";
    UnesiMatricu('A', A);
    std::cout &lt;&lt; "Unesite red polinoma: ";
    std::cin &gt;&gt; n;
    std::vector&lt;double&gt; p(n + 1);
    std::cout &lt;&lt; "Unesite koeficijente polinoma: ";
    for(auto&amp; elem : p)
        std::cin &gt;&gt; elem;
    IspisiMatricu(MatricniPolinom(A, p),10, 6, true);
</font>    UnistiMatricu(A);
}</pre>
</body>
</html>
