<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student1476.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student1476.cpp<p></p><pre>
/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
template &lt;typename NekiTip&gt;
struct Matrica{      //Kreiramo strukturu Matrice
    int br_redova, br_kolona;
    NekiTip **elementi=nullptr;
};
template &lt;typename NekiTip&gt;
void UnistiMatricu(Matrica&lt;NekiTip&gt; Mat){
    if(!Mat.elementi) return;
    for(int i=0; i&lt;Mat.br_redova; i++)
    delete [] Mat.elementi[i];
    delete [] Mat.elementi;
    Mat.elementi=nullptr;
}
template &lt;typename NekiTip&gt;
Matrica&lt;NekiTip&gt; StvoriMatricu(int m, int n){
    Matrica&lt;NekiTip&gt; Mat;
    Mat.br_redova = m;
    Mat.br_kolona = n;
    Mat.elementi= new NekiTip*[m];
    for(int i=0; i&lt;m; i++) 
    Mat.elementi[i]= nullptr;
<a name="0"></a><font color="#FF0000"><a href="match484-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

    try{
        for(int i=0; i&lt;m; i++)
        Mat.elementi[i]= new NekiTip[n];
        for(int i=0; i&lt;m; i++)
        for(int j=0; j&lt;n; j++){
            Mat.elementi[i][j]=0;
        }
        
    }
    catch(...){
        UnistiMatricu(Mat); 
        throw;
    }
    return Mat;
}
template &lt;typename NekiTip&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;NekiTip&gt; &amp;Mat){
    for(int i=0; i&lt;Mat.br_redova; i++)
</font>        for(int j=0; j&lt;Mat.br_kolona; j++){
<a name="2"></a><font color="#0000FF"><a href="match484-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

        std::cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
        std::cin&gt;&gt;Mat.elementi[i][j];
    }
}
template &lt;typename NekiTip&gt;
Matrica&lt;NekiTip&gt; NapraviKopiju(Matrica&lt;NekiTip&gt; Mat){
  Matrica&lt;NekiTip&gt; copy;
</font>  copy.br_redova=Mat.br_redova;
  copy.br_kolona=Mat.br_kolona;
  copy.elementi=new NekiTip*[copy.br_redova];
  for(int i=0; i&lt;copy.br_redova; i++)
  copy.elementi[i]=new NekiTip [copy.br_kolona];
  for(int i=0; i&lt;copy.br_redova; i++)
  for(int j=0; j&lt;copy.br_kolona; j++)
<a name="1"></a><font color="#00FF00"><a href="match484-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

  copy.elementi[i][j]=Mat.elementi[i][j];
  return copy;
}
template &lt;typename NekiTip&gt;
void PKopija(Matrica&lt;NekiTip&gt; &amp;m2, Matrica&lt;NekiTip&gt; m1){   //"Plitka kopija" matrice m2 u m1
    UnistiMatricu(m2);
    m2=NapraviKopiju(m1);
}
template&lt;typename NekiTip&gt;
Matrica&lt;NekiTip&gt; Saberi(Matrica&lt;NekiTip&gt; &amp;a, Matrica&lt;NekiTip&gt; &amp;b){ 
</font>    if(a.br_redova!=b.br_redova || a.br_kolona!=b.br_kolona) throw std::domain_error ("Matrice nemaju jednake dimenzije!");
    auto suma(StvoriMatricu&lt;NekiTip&gt;(a.br_kolona, a.br_redova));
    for(int i=0; i&lt;suma.br_redova; i++)
    for(int j=0; j&lt;suma.br_kolona; j++)
    suma.elementi[i][j]=a.elementi[i][j]+b.elementi[i][j];
    return suma;
}
template &lt;typename NekiTip&gt;
Matrica&lt;NekiTip&gt; PomnoziSkalarom(Matrica&lt;NekiTip&gt; a, double n){
    Matrica&lt;NekiTip&gt; produkt=NapraviKopiju(a);
    for(int i=0; i&lt;a.br_redova; i++)
    for(int j=0; j&lt;a.br_kolona; j++)
    produkt.elementi[i][j]=n*a.elementi[i][j];
    return produkt;
}
template &lt;typename NekiTip&gt;
Matrica&lt;NekiTip&gt; ProduktMatrica(Matrica&lt;NekiTip&gt; a, Matrica&lt;NekiTip&gt; b){
    if(a.br_redova!=b.br_kolona) throw std::domain_error ("Matrice nisu saglasne za mnozenje!");
    auto  c (StvoriMatricu&lt;NekiTip&gt;(a.br_redova,b.br_kolona)); 
    for(int i=0; i&lt;c.br_redova; i++){
        for(int j=0; j&lt;c.br_kolona; j++){
            for(int k=0; k&lt;c.br_redova; k++)
            c.elementi[i][j]+=a.elementi[i][k]*b.elementi[k][j];
        }
    }
    return c;
}
template&lt;typename NekiTip&gt;
Matrica&lt;NekiTip&gt; Stepenuj(const Matrica&lt;NekiTip&gt; &amp;a, int stepen){  
    Matrica&lt;NekiTip&gt; c=NapraviKopiju(a);
    if(stepen&gt;=2){
        for(int i=1; i&lt;stepen; i++)
        PKopija(c, ProduktMatrica(c,a));
        return c;
    }
    if(stepen==1) {return c;}
    if(stepen==0) { 
        for(int i=0; i&lt;c.br_redova; i++)
        for(int j=0; j&lt;c.br_kolona; j++){
<a name="3"></a><font color="#00FFFF"><a href="match484-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

            if(i==j) c.elementi[i][j]=1;
            else c.elementi[i][j]=0;
        }
        return c;
    }
}
template&lt;typename NekiTip&gt;
Matrica&lt;NekiTip&gt; MatricniPolinom(Matrica&lt;NekiTip&gt; mat, std::vector&lt;double&gt; v){
</font>    if(mat.br_redova!=mat.br_kolona) throw std::domain_error ("Matrica nije kvadratna!");
<a name="4"></a><font color="#FF00FF"><a href="match484-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

    auto sum (StvoriMatricu&lt;NekiTip&gt;(mat.br_redova, mat.br_kolona));
    for(int i=0; i&lt;v.size(); i++){
       Matrica&lt;NekiTip&gt; d=Stepenuj(mat,i);
       Matrica&lt;NekiTip&gt; e=PomnoziSkalarom(d,v[i]);
</font>       PKopija(sum, Saberi(sum,e));
       UnistiMatricu(d);
       UnistiMatricu(e);
    }
<a name="5"></a><font color="#FF0000"><a href="match484-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

    return sum;
}
template&lt;typename NekiTip&gt;
void IspisiMatricu(const Matrica&lt;NekiTip&gt; &amp;mat, int sirina_ispisa, int preciznost=6, bool treba_brisati=false ){
</font>    for(int i=0; i&lt;mat.br_redova; i++){
        for(int j=0; j&lt;mat.br_kolona; j++)
        std::cout&lt;&lt;std::setw(sirina_ispisa)&lt;&lt;std::setprecision(preciznost)&lt;&lt;mat.elementi[i][j];
        std::cout&lt;&lt;std::endl;
    }
    if(treba_brisati) UnistiMatricu(mat);
}
int main ()
{
    Matrica&lt;double&gt; a,b; //Incijalizacija matrica;
    int m,n,x;
    std::cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    std::cin&gt;&gt;m;
    try{
        a=StvoriMatricu&lt;double&gt;(m,m);
        std::cout&lt;&lt;"Unesite elemente matrice A: \n";
        UnesiMatricu('A', a);
        std::cout&lt;&lt;"Unesite red polinoma: ";
        std::cin&gt;&gt;n;
        std::vector&lt;double&gt; v1(n+1);
        std::cout&lt;&lt;"Unesite koeficijente polinoma: ";
        for(int i=0; i&lt;v1.size(); i++)
        {std::cin&gt;&gt;x;
        v1[i]=x;}
        IspisiMatricu(b=MatricniPolinom(a,v1),10, 7, true);
    }
    catch(std::bad_alloc){
        std::cout&lt;&lt;"Nema dovoljno memorije!\n";
    }
    UnistiMatricu(a);
    UnistiMatricu(b);
	return 0;
}







</pre>
</body>
</html>
