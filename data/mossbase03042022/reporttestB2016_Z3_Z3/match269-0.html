<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student5741.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student5741.cpp<p></p><pre>
/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

using std::cin;
using std::cout;
<a name="2"></a><font color="#0000FF"><a href="match269-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

using std::endl;
using std::domain_error;
using std::bad_alloc;
using std::setw;
using std::vector;
using std::setprecision;

template&lt;typename TipElemenata&gt;
    struct Matrica{
        int br_redova,br_kolona;
        TipElemenata **elementi=nullptr;
    };
    
template&lt;typename TipElemenata&gt;
    void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat){
</font>        if(!mat.elementi) return;
        for(int i=0;i&lt;mat.br_redova;i++) delete[] mat.elementi[i];
        delete[] mat.elementi;
        mat.elementi=nullptr;
    }
    
template&lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova,int br_kolona){
        Matrica&lt;TipElemenata&gt; mat;
        mat.br_redova=br_redova; mat.br_kolona=br_kolona;
        mat.elementi=new TipElemenata* [br_redova];
        for(int i=0;i&lt;br_redova;i++) mat.elementi[i]=nullptr;
        try{
            for(int i=0;i&lt;br_redova;i++){
                mat.elementi[i]=new TipElemenata [br_kolona];
                for(int j=0;j&lt;br_kolona;j++){
                    mat.elementi[i][j]=0;
                }
            }
        }
        catch(...){
            UnistiMatricu(mat);
            throw;
        }
        return mat;
    }
    
template&lt;typename TipElemenata&gt;
    void UnesiMatricu(char ime_matrice,Matrica&lt;TipElemenata&gt; &amp;mat){
<a name="1"></a><font color="#00FF00"><a href="match269-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

        for(int i=0;i&lt;mat.br_redova;i++){
            for(int j=0;j&lt;mat.br_kolona;j++){
                cout&lt;&lt;ime_matrice&lt;&lt;"("&lt;&lt;i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
                cin&gt;&gt;mat.elementi[i][j];
            }
        }
    }

template&lt;typename TipElemenata&gt;
    void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat,int sirina_ispisa,int preciznost=6,bool treba_brisati=false){
</font><a name="0"></a><font color="#FF0000"><a href="match269-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

        for(int i=0;i&lt;mat.br_redova;i++){
            for(int j=0;j&lt;mat.br_kolona;j++){
                cout&lt;&lt;setw(sirina_ispisa)&lt;&lt;setprecision(preciznost)&lt;&lt;mat.elementi[i][j];
            }
            cout&lt;&lt;endl;
        }
        if(treba_brisati){
            UnistiMatricu(mat);
        }
    }
    
template&lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1,const Matrica&lt;TipElemenata&gt; &amp;m2){
        if(m1.br_redova!=m2.br_redova || m1.br_kolona!=m2.br_kolona){
            throw domain_error("Matrice nemaju jednake dimenzije!");
        }
        auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova,m1.br_kolona));
        for(int i=0;i&lt;m1.br_redova;i++){
</font>            for(int j=0;j&lt;m1.br_kolona;j++){
                m3.elementi[i][j]=m1.elementi[i][j]+m2.elementi[i][j];
            }
        }
        return m3;
    }

template&lt;typename TipElemenata&gt;
<a name="3"></a><font color="#00FFFF"><a href="match269-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

    Matrica&lt;TipElemenata&gt; ProduktMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1,const Matrica&lt;TipElemenata&gt; &amp;m2){
        if(m1.br_kolona!=m2.br_redova){
            throw domain_error("Matrice nisu saglasne za mnozenje");
        }
        auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova,m2.br_kolona));
        for(int i=0;i&lt;m1.br_redova;i++){
</font>            for(int j=0;j&lt;m2.br_kolona;j++){
                for(int k=0;k&lt;m1.br_kolona;k++){
                    m3.elementi[i][j]=m3.elementi[i][j]+m1.elementi[i][k]*m2.elementi[k][j];
                }
            }
        }
<a name="4"></a><font color="#FF00FF"><a href="match269-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

        return m3;
    }
    
template&lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; MatricniPolinom(const Matrica&lt;TipElemenata&gt; &amp;m1,vector&lt;double&gt; p){
        if(m1.br_redova!=m1.br_redova){
            throw domain_error("Matrica mora biti kvadratna");
</font>        }
        auto matricni_polinom(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova,m1.br_kolona));
        for(int i=0;i&lt;matricni_polinom.br_redova;i++){
<a name="5"></a><font color="#FF0000"><a href="match269-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

            for(int j=0;j&lt;matricni_polinom.br_kolona;j++){
                matricni_polinom.elementi[i][j]=0;
            }
        }
        if(p.size()==0){
</font>            return matricni_polinom;
        }
        else{
            for(int l=0;l&lt;p.size();l++){
                auto pomocna(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova,m1.br_kolona));
                for(int i=0;i&lt;m1.br_redova;i++){
                    for(int j=0;j&lt;m1.br_kolona;j++){
                        pomocna.elementi[i][j]=m1.elementi[i][j];
                    }
                }
                if(l==0){
                    for(int i=0;i&lt;m1.br_redova;i++){
                        for(int j=0;j&lt;m1.br_kolona;j++){
                            if(i==j){
                                pomocna.elementi[i][j]=p[l];
                            }
                            else{
                                pomocna.elementi[i][j]=0;
                            }
                        }
                    }
                }
                else{
                    for(int k=0;k&lt;l-1;k++){
                        auto dodatna(ProduktMatrica(pomocna,m1));
                        for(int i=0;i&lt;m1.br_redova;i++){
                            for(int j=0;j&lt;m1.br_kolona;j++){
                                pomocna.elementi[i][j]=dodatna.elementi[i][j];
                            }
                        }
                        UnistiMatricu(dodatna);
                    }
                    for(int i=0;i&lt;pomocna.br_redova;i++){
                        for(int j=0;j&lt;pomocna.br_kolona;j++){
                            pomocna.elementi[i][j]=p[l]*pomocna.elementi[i][j];
                        }
                    }
                }
                for(int i=0;i&lt;pomocna.br_redova;i++){
                    for(int j=0;j&lt;pomocna.br_kolona;j++){
                        matricni_polinom.elementi[i][j]=matricni_polinom.elementi[i][j]+pomocna.elementi[i][j];
                    }
                }
                UnistiMatricu(pomocna);
            }
        }
        return matricni_polinom;
    }
    
int main ()
{
    Matrica&lt;double&gt; a,matricni_polinom;
    int m,n;
    cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    cin&gt;&gt;m;
    n=m;
    try{
        a=StvoriMatricu&lt;double&gt;(m,n);
        cout&lt;&lt;"Unesite elemente matrice A: \n";
        UnesiMatricu('A',a);
        int red_polinoma;
        cout&lt;&lt;"Unesite red polinoma: ";
        cin&gt;&gt;red_polinoma;
        vector&lt;double&gt; p(red_polinoma+1);
        cout&lt;&lt;"Unesite koeficijente polinoma: ";
        for(int i=0;i&lt;=red_polinoma;i++){
            double broj;
            cin&gt;&gt;broj;
            p[i]=broj;
        }
        matricni_polinom=MatricniPolinom(a,p);
        IspisiMatricu(matricni_polinom,10,6,true);
    }
    catch(bad_alloc){
        cout&lt;&lt;"Nema dovoljno memorije!\n";
    }
    catch(domain_error izuzetak){
        cout&lt;&lt;izuzetak.what()&lt;&lt;endl;
    }
    catch(...){
        cout&lt;&lt;"Nema dovoljno memorije!\n";
    }
    UnistiMatricu(a);
	return 0;
}</pre>
</body>
</html>
