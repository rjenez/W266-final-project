<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student9272.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student9272.cpp<p></p><pre>
/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
using std::cin;
using std::cout;
using std::vector;

template &lt;typename TipElemenata&gt;
    struct Matrica {
        int br_redova, br_kolona;
        TipElemenata **elementi=nullptr;
    };

template &lt;typename TipElemenata&gt;
    void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat){
        if (!mat.elementi) return;
        for (int i=0; i&lt;mat.br_redova; i++) delete[] mat.elementi[i];
        delete[] mat.elementi;
        mat.elementi=nullptr;
    }
    
template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova,int br_kolona){
        Matrica&lt;TipElemenata&gt; mat;
        try{
        mat.br_redova=br_redova;  mat.br_kolona=br_kolona;
        mat.elementi = new TipElemenata*[br_redova];
        for (int i=0; i&lt;br_redova; i++) mat.elementi[i] = nullptr;
        
            for(int i=0; i&lt;br_redova; i++)
                mat.elementi[i] = new TipElemenata[br_kolona];
        }
        catch(...){
            UnistiMatricu(mat);
            throw;
        }
         for (int i(0); i&lt;mat.br_redova; i++){
             for (int j(0); j&lt;mat.br_kolona; j++){
                 mat.elementi[i][j]={};
             }
    }
    return mat;
    }
    
template &lt;typename TipElemenata&gt;
    void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) {
        for (int i=0; i&lt;mat.br_redova; i++)
            for (int j=0; j&lt;mat.br_kolona; j++){
                std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i+1 &lt;&lt; "," &lt;&lt; j+1 &lt;&lt; ") = ";
<a name="0"></a><font color="#FF0000"><a href="match759-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

                std::cin &gt;&gt; mat.elementi[i][j];
            }
    }
    
template &lt;typename TipElemenata&gt;
    void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost, bool treba_brisati){
        for (int i=0; i&lt;mat.br_redova; i++){
            for (int j=0; j&lt;mat.br_kolona; j++){
</font>                std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; std::setprecision(preciznost) &lt;&lt; mat.elementi[i][j];
            } cout &lt;&lt; std::endl;
        }
        if (treba_brisati) UnistiMatricu(mat);
    }
    
template &lt;typename TipElemenata&gt;
    void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost){
        for (int i=0; i&lt;mat.br_redova; i++){
            for (int j=0; j&lt;mat.br_kolona; j++){
                std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; std::setprecision(preciznost) &lt;&lt; mat.elementi[i][j];
            } cout &lt;&lt; std::endl;
        }
       
    }

template &lt;typename TipElemenata&gt;
    void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa){
        for (int i=0; i&lt;mat.br_redova; i++){
            for (int j=0; j&lt;mat.br_kolona; j++){
                std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; mat.elementi[i][j];;
            } cout &lt;&lt; std::endl;
        }
       
    }

template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; ProduktMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2){
        try{
        if (m1.br_kolona!=m2.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
        }catch(std::domain_error izuzetak){
            cout &lt;&lt; izuzetak.what();
            UnistiMatricu(m1);
            UnistiMatricu(m2);
            throw;
        }
         Matrica&lt;TipElemenata&gt; a;
         try {
         a= StvoriMatricu&lt;TipElemenata&gt;(m1.br_kolona,m2.br_redova);
         for (int i(0); i&lt;m1.br_redova; i++){
             for (int j(0); j&lt;m1.br_kolona; j++){
                 a.elementi[i][j]={};
             }
         }
         for (int i(0); i&lt;m1.br_redova; i++){
             int o(0);
             for (int j(0); j&lt;m1.br_kolona; j++){
                 for (int k(0); k&lt;m2.br_kolona; k++){
                     j=0;
                    for (int h(0); h&lt;m2.br_redova; h++){
                     a.elementi[i][o]+=m1.elementi[i][j]*m2.elementi[h][k];
                     j++;
                    }
                    o++;
                }
             }  
         }
         return a;
        }catch(...){
            UnistiMatricu(a);
            UnistiMatricu(m1);
            UnistiMatricu(m2);
            throw;
        }
    }
    
template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2){
<a name="3"></a><font color="#00FFFF"><a href="match759-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

      try{  if (m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona)
            throw std::range_error("Matrice nemaju jednake dimenzije!");
      Matrica&lt;TipElemenata&gt; m3;
      try{
         m3=StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona);
</font>      }catch(...){
          UnistiMatricu(m3);
          UnistiMatricu(m1);
          UnistiMatricu(m2);
          throw;
      }
         for (int i(0); i&lt;m3.br_redova; i++){
             for (int j(0); j&lt;m3.br_kolona; j++){
                 m3.elementi[i][j]={};
             }
    }
        for (int i=0; i&lt;m1.br_redova; i++)
            for (int j=0; j&lt;m1.br_kolona; j++)
                m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
        return m3;
      } catch(...){
          throw;
      }
    }
    
   
template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; MatricniPolinom( const Matrica&lt;TipElemenata&gt; &amp;x, vector&lt;double&gt; polinom){
        
       
        if (x.br_redova!=x.br_kolona) throw std::domain_error("Matrica mora biti kvadratna");
      Matrica&lt;TipElemenata&gt; a(StvoriMatricu&lt;TipElemenata&gt;(x.br_redova,x.br_kolona));
      Matrica&lt;TipElemenata&gt; jedinicna(StvoriMatricu&lt;TipElemenata&gt;(x.br_redova,x.br_kolona));
<a name="4"></a><font color="#FF00FF"><a href="match759-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    Matrica&lt;TipElemenata&gt; pomocna2(StvoriMatricu&lt;TipElemenata&gt;(a.br_redova,a.br_kolona));
         
       for (int i(0); i&lt;a.br_redova; i++){
           for (int j(0); j&lt;a.br_kolona; j++){
</font>               if (i==j) jedinicna.elementi[i][j]=1;
           }
       }
       for (int i(0); i&lt;a.br_redova; i++){
           for (int j(0); j&lt;a.br_kolona; j++){
                a.elementi[i][j]=jedinicna.elementi[i][j]*polinom[0];
           }
       }
       
       for (int i(0); i&lt;a.br_redova; i++){
<a name="1"></a><font color="#00FF00"><a href="match759-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

           for (int j(0); j&lt;a.br_kolona; j++){
               jedinicna.elementi[i][j]=x.elementi[i][j];
           }
       }
       
      
        for (int i(0); i&lt;a.br_redova; i++){
           for (int j(0); j&lt;a.br_kolona; j++){
               pomocna2.elementi[i][j]=x.elementi[i][j];
</font>           }
       }
       
<a name="2"></a><font color="#0000FF"><a href="match759-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

       for (int k=1; k&lt;polinom.size(); k++){
           for (int i(0); i&lt;a.br_redova; i++){
           for (int j(0); j&lt;a.br_kolona; j++){
               a.elementi[i][j]+=(jedinicna.elementi[i][j]*polinom[k]);
</font>           }
       }
       
      Matrica&lt;TipElemenata&gt; pomocna3(ProduktMatrica(jedinicna,pomocna2));
      for (int i(0); i&lt;a.br_redova; i++){
           for (int j(0); j&lt;a.br_kolona; j++){
               jedinicna.elementi[i][j]=pomocna3.elementi[i][j];
           }
       }UnistiMatricu(pomocna3);
       }
       UnistiMatricu(jedinicna);
       UnistiMatricu(pomocna2);
       return a;
    }
       /* 
        Matrica&lt;TipElemenata&gt; jedinicna;
        Matrica&lt;TipElemenata&gt; matricni_polinom;
        Matrica&lt;TipElemenata&gt; pomocna;
        Matrica&lt;TipElemenata&gt; pomocna1;
        Matrica&lt;TipElemenata&gt; pomocna2;
     //   Matrica&lt;TipElemenata&gt; pomocna3;
    try{
    
    
    try{
    jedinicna=StvoriMatricu&lt;TipElemenata&gt;(a.br_redova,a.br_kolona);
     for (int i(0); i&lt;jedinicna.br_redova; i++){
             for (int j(0); j&lt;jedinicna.br_kolona; j++){
                 jedinicna.elementi[i][j]={};
             }
    }
    }catch(...){
        UnistiMatricu(jedinicna);
        throw;
    }
    
    try{
    matricni_polinom = StvoriMatricu&lt;TipElemenata&gt;(a.br_redova,a.br_kolona);
    }catch(...){
        UnistiMatricu(matricni_polinom);
        throw;
    }
    for (int i(0); i&lt;jedinicna.br_redova; i++){
        for (int j(0); j&lt;jedinicna.br_kolona; j++){
            if (i==j) jedinicna.elementi[i][j]=1;
        }
    }
  
  
  try{
        pomocna=StvoriMatricu&lt;TipElemenata&gt;(a.br_redova,a.br_kolona);}
        catch(...){
            UnistiMatricu(pomocna);
            throw;
        }
        for (int i(0); i&lt;jedinicna.br_redova; i++){
        for (int j(0); j&lt;jedinicna.br_kolona; j++){
             pomocna.elementi[i][j]=a.elementi[i][j];
        }
    }
        
         
         try{
        pomocna1=StvoriMatricu&lt;TipElemenata&gt;(a.br_redova,a.br_kolona);
         } catch(...){
             UnistiMatricu(pomocna1);
             throw;
         }
         for (int i(0); i&lt;jedinicna.br_redova; i++){
        for (int j(0); j&lt;jedinicna.br_kolona; j++){
             pomocna1.elementi[i][j]=a.elementi[i][j];
        }
    }
     
         try{
        pomocna2=StvoriMatricu&lt;TipElemenata&gt;(a.br_redova,a.br_kolona);
         } catch(...){
             UnistiMatricu(pomocna2);
             throw;
         }
               
for (int k(0); k&lt;polinom.size(); k++){
         
        if(k==1) {
            for (int i(0); i&lt;jedinicna.br_redova; i++){
                 for (int j(0); j&lt;jedinicna.br_kolona; j++){
                     pomocna1.elementi[i][j]=a.elementi[i][j];
        }
    } 
    for (int i(0); i&lt;jedinicna.br_redova; i++){
                for (int j(0); j&lt;jedinicna.br_kolona; j++){
                    TipElemenata x;
                    x = pomocna1.elementi[i][j];
                    TipElemenata y;
                    y=polinom[k]*x;
                    pomocna1.elementi[i][j]=y;
            }   }
             for (int i(0); i&lt;a.br_redova; i++){
                for (int j(0); j&lt;a.br_kolona; j++){
                    matricni_polinom.elementi[i][j]+=pomocna1.elementi[i][j];
                }
            }
        }
        else if (k==0) {
            for (int i(0); i&lt;jedinicna.br_redova; i++){
        for (int j(0); j&lt;jedinicna.br_kolona; j++){
             pomocna1.elementi[i][j]=jedinicna.elementi[i][j];
        }
    }
        
       
             for (int i(0); i&lt;jedinicna.br_redova; i++){
                for (int j(0); j&lt;jedinicna.br_kolona; j++){
                    TipElemenata x;
                    x = pomocna1.elementi[i][j];
                    TipElemenata y;
                    y=polinom[k]*x;
                    pomocna1.elementi[i][j]=y;
            }   }
            for (int i(0); i&lt;a.br_redova; i++){
                for (int j(0); j&lt;a.br_kolona; j++){
                    matricni_polinom.elementi[i][j]+=pomocna1.elementi[i][j];
                }
            }
        
        }
       else  {
            
               auto pomocna3=ProduktMatrica(a,pomocna);
                
                   for (int i(0); i&lt;jedinicna.br_redova; i++){
                         for (int j(0); j&lt;jedinicna.br_kolona; j++){
                            pomocna2.elementi[i][j]=pomocna.elementi[i][j];
                     }
                         }
                          UnistiMatricu(pomocna);
                pomocna=ProduktMatrica(pomocna2,a);
                 for (int i(0); i&lt;jedinicna.br_redova; i++){
                for (int j(0); j&lt;jedinicna.br_kolona; j++){
                    TipElemenata x;
                    x = pomocna3.elementi[i][j];
                    TipElemenata y;
                    y=polinom[k]*x;
                    pomocna3.elementi[i][j]=y;
            }   }
             for (int i(0); i&lt;a.br_redova; i++){
                for (int j(0); j&lt;a.br_kolona; j++){
                    matricni_polinom.elementi[i][j]+=pomocna3.elementi[i][j];
                }
            }
            UnistiMatricu(pomocna3);
        } 
    }
     UnistiMatricu(pomocna);
     UnistiMatricu(pomocna1);
     UnistiMatricu(pomocna2);
     
    return matricni_polinom;
    }catch(...){
         UnistiMatricu(pomocna);
     UnistiMatricu(pomocna1);
     UnistiMatricu(pomocna2);
     
     UnistiMatricu(matricni_polinom);
        throw;
    }

}
    
*/
int main ()
{
    
    Matrica&lt;int&gt; a;
    Matrica&lt;int&gt; c;
    int m,n;
    cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    cin &gt;&gt; m;
    n=m;
    try{
    a=StvoriMatricu&lt;int&gt;(m,n);
    cout &lt;&lt; "Unesite elemente matrice A: " &lt;&lt; std::endl;
    UnesiMatricu('A',a);
    cout &lt;&lt; "Unesite red polinoma: ";
    int red;
    cin &gt;&gt; red;
    vector&lt;double&gt; polinom;
    cout &lt;&lt; "Unesite koeficijente polinoma: ";
    for (int i(0); i&lt;=red; i++){
        double x;
        cin &gt;&gt; x;
        polinom.push_back(x);
    }
    

             c=MatricniPolinom(a,polinom);
   
    IspisiMatricu(c,10,6,true);
    
    UnistiMatricu(a);
   
	return 0;
    }catch(std::domain_error izuzetak){
        cout &lt;&lt; izuzetak.what();
        UnistiMatricu(a);
        
        return 0;
    }catch(std::range_error izuzetak){
        cout &lt;&lt; izuzetak.what();
        UnistiMatricu(a);
        UnistiMatricu(c);
        return 0;
    }
    
     catch(...){
        UnistiMatricu(a);
        UnistiMatricu(c);
        return 0;
    }
}</pre>
</body>
</html>
