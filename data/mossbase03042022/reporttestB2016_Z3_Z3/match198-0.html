<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student7080.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student7080.cpp<p></p><pre>
/B2016/2017: ZadaÄ‡a 3, Zadatak 3
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

template &lt;typename TipElemenata&gt;
struct Matrica {
    int br_redova, br_kolona;
    TipElemenata **elementi = nullptr;   // postavljamo dvojni pok na nullptr
};

template &lt;typename TipElemenata&gt;
void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat) {
    if(!mat.elementi) return;   // ako nije bilo nikakve alokacije
    for(int i = 0; i &lt; mat.br_redova; i++) delete[] mat.elementi[i];
    delete[] mat.elementi;
    mat.elementi = nullptr;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) {
    Matrica&lt;TipElemenata&gt; mat;
    mat.br_redova = br_redova;
    mat.br_kolona = br_kolona;
    mat.elementi = new TipElemenata*[br_redova];
    
    for(int i = 0; i &lt; br_redova; i++) mat.elementi[i] = nullptr;    // postavljamo niz pokazivaca na nullptr
    try {
        for(int i = 0; i &lt; br_redova; i++) mat.elementi[i] = new TipElemenata[br_kolona];
    }
    catch (...) {
        UnistiMatricu(mat);
        throw;
    }
    return mat;
}

template &lt;typename TipElemenata&gt;
void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) {      // unos elemenata matrice
    for(int i = 0; i &lt; mat.br_redova; i++)
      for(int j = 0; j &lt; mat.br_kolona; j++) {
          std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
          std::cin &gt;&gt; mat.elementi[i][j];
      }
}

template &lt;typename TipElemenata&gt;
void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa, int preciznost = 6, bool treba_brisati = false) {
    
    for(int i = 0; i &lt; mat.br_redova; i++) {
        for(int j = 0; j &lt; mat.br_kolona; j++) 
           std::cout &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; std::setprecision(preciznost) &lt;&lt; mat.elementi[i][j];
        
        std::cout &lt;&lt; std::endl;
    }
    if(treba_brisati) UnistiMatricu(mat);
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2) {
    if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona) throw std::domain_error("Matrice nemaju jednake dimenzije!");
    
    auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
    
    for(int i = 0; i &lt; m1.br_redova; i++)
      for(int j = 0; j &lt; m1.br_kolona; j++)
        m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
        
    return m3;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; ProduktMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2) {
    if(m1.br_kolona != m2.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
    
    auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona));
    
    for(int i = 0; i &lt; m1.br_redova; i++) {
        for(int j = 0; j &lt; m2.br_kolona; j++) {
            for(int k = 0; k &lt; m1.br_kolona; k++) {
<a name="1"></a><font color="#00FF00"><a href="match198-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

                m3.elementi[i][j] += m1.elementi[i][k] * m2.elementi[k][j];
            }
        }
    }
    
    return m3;
}
/*
template &lt;typename TipElemenata&gt;
TipElemenata Determinanta(const Matrica&lt;TipElemenata&gt; &amp;mat) {
    
    int p;
    TipElemenata d = 1, mi = 0;
    for(int k = 0; k &lt; mat.br_redova; i++) {
        p = k;
        for(int int i = k + 1; i &lt; mat.br_redova; i++) {
            if(std::fabs(mat.elementi[i][k]) &gt; std::fabs(mat.elementi[p][k])) p = i;
        }
        if(p != k) {
            for(int j = 0; j &lt; mat.br_redova; j++) {  // razmijenimo k-ti i p-ti red matrice
                TipElemenata temp = mat.elementi[k][j];
                mat.elementi[k][j] = mat.elementi[p][j];
                mat.elementi[p][j] = temp;
            }
            d = -d;
        }
        for(int i = k + 1; i &lt; mat.br_redova; i++) {
            mi = mat.elementi[i][k] / mat.elementi[k][k];
            for(int j = k + 1; j &lt; mat.br_redova; j++)
              mat.elementi[i][j] = mat.elementi[i][j] - (mi * mat.elementi[k][j]);
        }
    }
    for(int i = 0; i &lt; mat.br_redova; i++)
      d = d * mat.elementi[i][i];
      
    return d;
}
*/

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; MatricniPolinom(const Matrica&lt;TipElemenata&gt; &amp;a, const std::vector&lt;double&gt; &amp;v) {
    if(a.br_redova != a.br_kolona) throw std::domain_error("Matrica mora biti kvadratna");
    if(v.empty()) {
        auto m(a);
        for(int i = 0; i &lt; m.br_redova; i++)
          for(int j = 0; j &lt; m.br_kolona; j++)
             m.elementi[i][j] = 0;
             
        return m;
    }
    
    auto jedinicna(StvoriMatricu&lt;TipElemenata&gt;(a.br_redova, a.br_kolona));
    
    for(int i = 0; i &lt; a.br_redova; i++) {
</font>        for(int j = 0; j &lt; a.br_kolona; j++) {
<a name="0"></a><font color="#FF0000"><a href="match198-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_29.gif"/></a>

            if(i == j) jedinicna.elementi[i][j] = 1;
            else jedinicna.elementi[i][j] == 0;
        }
    }
    
    auto b(StvoriMatricu&lt;TipElemenata&gt;(a.br_redova, a.br_kolona));
    for(int k = 0; k &lt; v.size(); k++) {   // petlja po stepenima polinoma
        for(int i = 0; i &lt; a.br_redova; i++) {
            for(int j = 0; j &lt; a.br_kolona; j++) {
                b[i][j] += v[k] * a[i][j];
            }
        }
    }
    
    UnistiMatricu(jedinicna);
    
    return b;
}

int main ()
{
    Matrica&lt;double&gt; a, m1, m2, m3;
    int n, z, g;
    std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    std::cin &gt;&gt; n &gt;&gt; z &gt;&gt; g;
    try {
        a = StvoriMatricu&lt;double&gt;(n,n);
        std::cout &lt;&lt; "Unesite elemente matrice A: \n";
        UnesiMatricu&lt;double&gt;('A', a);
        IspisiMatricu(a, 5, 2);
        m1 = StvoriMatricu&lt;double&gt;(n, z);
        m2 = StvoriMatricu&lt;double&gt;(z, g);
        std::cout &lt;&lt; "Unesite elemente matrice 1: \n";
        UnesiMatricu&lt;double&gt;('1', m1);
        IspisiMatricu(m1, 5, 2);
        std::cout &lt;&lt; "Unesite elemente matrice 2: \n";
        UnesiMatricu('2', m2);
        m3 = ProduktMatrica(m1, m2);
        IspisiMatricu(m3, 3);
        
        std::cout &lt;&lt; "Unesite red polinoma: ";
        int d;
        std::cin &gt;&gt; d;
        int vel = d + 1;
        std::vector&lt;double&gt; polinom(vel);
        std::cout &lt;&lt; "Unesite koeficijente polinoma: ";
        for(int i = 0; i &lt; polinom.size(); i++)
          std::cin &gt;&gt; polinom[i];
          
        
    }
    catch (std::bad_alloc) {
        std::cout &lt;&lt; "Nema dovoljno memorije!\n";
    }
    
    UnistiMatricu(a);
    UnistiMatricu(m1);
    UnistiMatricu(m2);
</font>    UnistiMatricu(m3);
    
	return 0;
}</pre>
</body>
</html>
