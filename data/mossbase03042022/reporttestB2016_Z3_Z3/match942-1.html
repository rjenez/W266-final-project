<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student1547.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student1266.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

using std::vector;
using std::cin;
using std::cout;

template &lt;typename TipElemenata&gt;
    struct Matrica 
    {
        int br_redova, br_kolona;
        TipElemenata **elementi = nullptr;
    };
    
template &lt;typename TipElemenata&gt;
    void UnistiMatricu(Matrica&lt;TipElemenata&gt; mat) 
    {
        if(!mat.elementi) return;
        for(int i = 0; i &lt; mat.br_redova; i++) delete[] mat.elementi[i];
        delete[] mat.elementi;
        mat.elementi = nullptr;
    }
    
template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) 
    {
        Matrica&lt;TipElemenata&gt; mat;
        mat.br_redova = br_redova; mat.br_kolona = br_kolona;
        mat.elementi = new TipElemenata*[br_redova];
        for(int i = 0; i &lt; br_redova; i++) mat.elementi[i] = nullptr;
        try 
        {
            for(int i = 0; i &lt; br_redova; i++)
            mat.elementi[i] = new TipElemenata[br_kolona];
        }
        catch(...) 
        {
            UnistiMatricu(mat);
            throw;
        }
        return mat;
    }
    
template &lt;typename TipElemenata&gt;
    void UnesiMatricu(char ime_matrice, Matrica&lt;TipElemenata&gt; &amp;mat) 
    {
        for(int i = 0; i &lt; mat.br_redova; i++)
            for(int j = 0; j &lt; mat.br_kolona; j++) 
            {
                std::cout &lt;&lt; ime_matrice &lt;&lt; "(" &lt;&lt; i + 1 &lt;&lt; "," &lt;&lt; j + 1 &lt;&lt; ") = ";
                std::cin &gt;&gt; mat.elementi[i][j];
            }
    }
    
template &lt;typename TipElemenata&gt;
    void IspisiMatricu(const Matrica&lt;TipElemenata&gt; &amp;mat, int sirina_ispisa) 
    {
        for(int i = 0; i &lt; mat.br_redova; i++) 
        {
            for(int j = 0; j &lt; mat.br_kolona; j++) std::cout &lt;&lt; std::setprecision(6) &lt;&lt; std::setw(sirina_ispisa) &lt;&lt; mat.elementi[i][j];
            std::cout &lt;&lt; std::endl;
        }
    }

template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; ZbirMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2) 
    {
<a name="2"></a><font color="#0000FF"><a href="match942-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

        if(m1.br_redova != m2.br_redova || m1.br_kolona != m2.br_kolona) throw std::domain_error("Matrice nemaju jednake dimenzije!");
        try
        {
            auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m1.br_kolona));
            for(int i = 0; i &lt; m1.br_redova; i++)
</font><a name="0"></a><font color="#FF0000"><a href="match942-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

            for(int j = 0; j &lt; m1.br_kolona; j++) m3.elementi[i][j] = m1.elementi[i][j] + m2.elementi[i][j];
            return m3;
        }
        catch(...)
        {
            throw;
        }
    }
    
template &lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; ProduktMatrica(const Matrica&lt;TipElemenata&gt; &amp;m1, const Matrica&lt;TipElemenata&gt; &amp;m2)
    {
        if(m1.br_kolona!=m2.br_redova) throw std::domain_error("Matrice nisu saglasne za mnozenje");
        try
        {
            auto m3(StvoriMatricu&lt;TipElemenata&gt;(m1.br_redova, m2.br_kolona));
            for(int i=0;i&lt;m1.br_redova;i++)
</font>            {
                for(int j=0;j&lt;m2.br_kolona;j++)
                {
                    for(int k=0;k&lt;m2.br_redova;k++)
                    {
<a name="1"></a><font color="#00FF00"><a href="match942-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

                        m3.elementi[i][j]+=m1.elementi[i][k]*m2.elementi[k][j];
                    }
                }
            }
            return m3;
        }
        catch(...)
        {
            throw;
        }
    }

template&lt;typename TipElemenata&gt;
    Matrica&lt;TipElemenata&gt; MatricniPolinom(const Matrica&lt;TipElemenata&gt; &amp;A, vector&lt;double&gt; v)
</font>    {
        Matrica&lt;TipElemenata&gt; pol;
        try
        {
            pol=StvoriMatricu&lt;TipElemenata&gt;(A.br_redova, A.br_kolona);
            if(v.size()&gt;1)
            {
                vector&lt;Matrica&lt;TipElemenata&gt;&gt; m(v.size()-1);
                try
                {
                    for(int i=0;i&lt;m.size();i++) m[i]=StvoriMatricu&lt;TipElemenata&gt;(A.br_redova, A.br_kolona);
                    for(int i=0;i&lt;A.br_redova;i++)
                    {
                        for(int j=0;j&lt;A.br_kolona;j++)
                        {
                            if(i==j) pol.elementi[i][j]=1; else pol.elementi[i][j]=0;
                        }
                    }
                    for(int i=0;i&lt;v.size();i++)
                    {
                        if(i==0)
                        {
                            for(int x=0;x&lt;A.br_redova;x++)
                            {
                                pol.elementi[x][x]*=v[0];
                            }
                        }
                        else
                        {
                            for(int r=0;r&lt;A.br_redova;r++)
                            {
                                for(int t=0;t&lt;A.br_kolona;t++)
                                {
                                    m[i-1].elementi[r][t]=A.elementi[r][t];
                                }
                            }
                            for(int o=1;o&lt;i;o++)
                            {
                                Matrica&lt;TipElemenata&gt; priv=m[i-1];
                                m[i-1]=ProduktMatrica(m[i-1], A);
                                UnistiMatricu(priv);
                            }
                            for(int x=0;x&lt;A.br_redova;x++)
                            {
                                for(int y=0;y&lt;A.br_kolona;y++)
                                {
                                    m[i-1].elementi[x][y]*=v[i];
                                }
                            }
                            Matrica&lt;TipElemenata&gt; priv=pol;
                            pol=ZbirMatrica(pol, m[i-1]);
                            UnistiMatricu(priv);
                        }
                    }
                    for(int i=0;i&lt;m.size();i++) UnistiMatricu(m[i]);
                }
                catch(...)
                {
                    for(int i=0;i&lt;m.size();i++) UnistiMatricu(m[i]);
                    UnistiMatricu(pol);
                    throw;
                }
            }
        }
        catch(...)
        {
            throw;
        }
        return pol;
    }

int main() 
{
    Matrica&lt;double&gt; a, b;
    int n;
    std::cout &lt;&lt; "Unesite dimenziju kvadratne matrice: ";
    std::cin &gt;&gt; n;
    a = StvoriMatricu&lt;double&gt;(n, n);
    std::cout &lt;&lt; "Unesite elemente matrice A: ";
    UnesiMatricu('A', a);
    cout &lt;&lt; "Unesite red polinoma: ";
    int r;
    cin &gt;&gt; r;
    vector&lt;double&gt; v(r+1);
    cout &lt;&lt; "Unesite koeficijente polinoma: ";
    for(int i=0;i&lt;v.size();i++)
    {
        cin &gt;&gt; v[i];
    }
    b=MatricniPolinom(a, v);
    IspisiMatricu(b, 10);
    UnistiMatricu(a); UnistiMatricu(b);
    return 0;
}
</pre>
</body>
</html>
