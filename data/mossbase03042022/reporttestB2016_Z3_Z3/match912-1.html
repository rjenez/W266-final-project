<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student9325.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2016/Z3/Z3/student7643.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;new&gt;

using namespace std;

template &lt;typename TipElemenata&gt;
struct Matrica {
    int br_redova, br_kolona;
    TipElemenata **elementi=nullptr;
};

template &lt;typename TipElemenata&gt;
void UnistiMatricu(Matrica&lt;TipElemenata&gt; matrica) {
    if(!matrica.elementi) return;
    for(int i=0;i&lt;matrica.br_redova;i++) delete[] matrica.elementi[i];
    delete [] matrica.elementi;
    matrica.elementi=nullptr;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; StvoriMatricu(int br_redova, int br_kolona) {
    Matrica&lt;TipElemenata&gt; matrica;
    matrica.br_redova=br_redova;
    matrica.br_kolona=br_kolona;
    matrica.elementi=new TipElemenata*[br_redova];
    for(int i=0;i&lt;br_redova;i++) matrica.elementi[i]=nullptr;
    try{
        for(int i=0;i&lt;br_redova;i++) matrica.elementi[i]=new TipElemenata[br_kolona];
    }
    catch(...) {
        UnistiMatricu(matrica);
        throw;
    }
    return matrica;
}

template &lt;typename TipElemenata&gt;
void UnesiMatricu (char ime, Matrica &lt;TipElemenata&gt; &amp;matrica) {
    for(int i=0;i&lt;matrica.br_redova;i++)
    for(int j=0;j&lt;matrica.br_kolona;j++) {
        cout&lt;&lt; ime &lt;&lt;"(" &lt;&lt; i+1&lt;&lt;","&lt;&lt;j+1&lt;&lt;") = ";
        cin&gt;&gt;matrica.elementi[i][j];
    }
}

template &lt;typename TipElemenata&gt;
void IspisiMatricu (Matrica&lt;TipElemenata&gt; &amp;matrica,int sirina, int preciznost=6, bool treba_brisati=true) {
    for(int i=0;i&lt;matrica.br_redova;i++) {
        for(int j=0;j&lt;matrica.br_kolona;j++) cout&lt;&lt;setprecision(preciznost)&lt;&lt;setw(sirina)&lt;&lt;matrica.elementi[i][j];
        cout&lt;&lt;"\n";
    }
    if(treba_brisati) UnistiMatricu(matrica);
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt;ZbirMatrica(Matrica&lt;TipElemenata&gt; &amp;A, Matrica&lt;TipElemenata&gt; &amp;B) {
<a name="4"></a><font color="#FF00FF"><a href="match912-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

    if(A.br_redova != B.br_redova || A.br_kolona != B.br_kolona) throw domain_error("Matrice nemaju jednake dimenzije!");
    auto C=StvoriMatricu&lt;TipElemenata&gt;(A.br_redova, B.br_kolona);
    for(int i=0;i&lt;A.br_redova;i++)
</font>    for(int j=0;j&lt;A.br_kolona;j++) 
    C.elementi[i][j]=A.elementi[i][j]+B.elementi[i][j];
    return C;
}

<a name="0"></a><font color="#FF0000"><a href="match912-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

template &lt;typename TipElemenata&gt;
void SaberiSa(Matrica&lt;TipElemenata&gt; &amp;A, Matrica&lt;TipElemenata&gt; &amp;B) {
    for(int i=0;i&lt;A.br_redova;i++)
    for(int j=0;j&lt;A.br_kolona;j++)
</font><a name="3"></a><font color="#00FFFF"><a href="match912-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    A.elementi[i][j] += B.elementi[i][j];
}
template&lt;typename TipElemenata&gt; 
</font>void PomnoziSaSkalarom(Matrica&lt;TipElemenata&gt; &amp;A, double x) {
    for(int i=0;i&lt;A.br_redova;i++) 
    for(int j=0;j&lt;A.br_kolona;j++)
    A.elementi[i][j] *=x;
}

<a name="1"></a><font color="#00FF00"><a href="match912-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

template&lt;typename TipElemenata&gt; 
void KopirajMatricu(Matrica &lt;TipElemenata&gt; &amp;A, Matrica &lt;TipElemenata&gt; &amp;B) {
    for(int i=0;i&lt;A.br_redova;i++)
    for(int j=0;j&lt;A.br_kolona;j++)
</font>    B.elementi[i][j]=A.elementi[i][j];
}

template&lt;typename TipElemenata&gt; 
Matrica&lt;TipElemenata&gt;ProduktMatrica(Matrica &lt;TipElemenata&gt; &amp;A, Matrica &lt;TipElemenata&gt; &amp;B) {
    Matrica&lt;TipElemenata&gt;C;
    try{
        C=StvoriMatricu&lt;TipElemenata&gt;(A.br_redova,B.br_kolona);
    }
    catch (bad_alloc) {
        throw;
    }
    for(int i=0;i&lt;A.br_redova;i++) {
        for(int j=0;j&lt;B.br_kolona;j++) {
            TipElemenata suma{};
            for(int k=0;k&lt;A.br_kolona;k++) {
                suma+= A.elementi[i][k] * B.elementi[k][j];
            }
            C.elementi[i][j] = suma;
        }
    }
    return C;
}

template &lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; Jedinicna(int br_redova, int br_kolona){
    auto matrica = StvoriMatricu&lt;TipElemenata&gt;(br_redova,br_kolona);
    
    for(int i=0; i&lt;br_redova; i++)
    for(int j=0; j&lt;br_kolona;j++){
        if(i==j) matrica.elementi[i][j]=1;
        else matrica.elementi[i][j]=0;
    }
<a name="2"></a><font color="#0000FF"><a href="match912-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

    return matrica;
}

template &lt;typename TipElemenata&gt;
void Anuliraj(Matrica&lt;TipElemenata&gt; &amp;matrica) {
    for(int i=0;i&lt;matrica.br_redova;i++)
    for(int j=0;j&lt;matrica.br_kolona;j++) {
</font>        matrica.elementi[i][j]=0;
    }
}

template&lt;typename TipElemenata&gt;

void PomnoziSa (Matrica &lt;TipElemenata&gt; &amp;A, Matrica &lt;TipElemenata&gt; &amp;B) {
    auto nova(StvoriMatricu&lt;TipElemenata&gt;(A.br_redova, B.br_kolona));
        Anuliraj(nova);
        for(int i=0;i&lt;A.br_redova;i++){
            for(int j=0;j&lt;B.br_kolona;j++){
                for(int k=0;k&lt;A.br_kolona;k++){
                    nova.elementi[i][j] += A.elementi[i][k]*B.elementi[k][j];
                }
            }
        }
        for(int i=0;i&lt;nova.br_redova;i++){
            for(int j=0;j&lt;nova.br_kolona;j++){
                A.elementi[i][j]=nova.elementi[i][j];
            }
        }
        UnistiMatricu(nova);
}

template&lt;typename TipElemenata&gt;
Matrica&lt;TipElemenata&gt; MatricniPolinom(Matrica&lt;TipElemenata&gt;&amp;matrica, vector&lt;double&gt;skalari) {
    int br_skalara = skalari.size();
    auto polinom(StvoriMatricu&lt;TipElemenata&gt;(matrica.br_redova,matrica.br_kolona));
    auto kvadrat(StvoriMatricu&lt;TipElemenata&gt;(matrica.br_redova,matrica.br_kolona));
    Matrica&lt;TipElemenata&gt; nova;
    Anuliraj(polinom);
    KopirajMatricu(matrica,kvadrat); 
  
    for(int q=0;q&lt;br_skalara;q++){
        if(q==0) Matrica &lt;TipElemenata&gt; Jedinicna(kvadrat);
        else{
            KopirajMatricu(matrica, kvadrat);
            for(int i(1);i&lt;q;i++) {
            nova=ProduktMatrica(kvadrat,matrica);
            UnistiMatricu(kvadrat);
            kvadrat=nova;
            }
<a name="5"></a><font color="#FF0000"><a href="match912-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

        PomnoziSa(kvadrat, skalari[q]);
        SaberiSa(polinom,kvadrat);
    
        }
 
    }

        UnistiMatricu(nova);
        UnistiMatricu(kvadrat);
        return polinom;
}


int main() {
    Matrica&lt;double&gt;a,b,c;
</font>    int n;
    cout&lt;&lt;"Unesite dimenziju kvadratne matrice: ";
    cin&gt;&gt;n;
    try {
        a=StvoriMatricu&lt;double&gt;(n,n);
 
        cout&lt;&lt;"Unesite elemente matrice A: \n";
        UnesiMatricu('A',a);
 
    int r;
    cout&lt;&lt;"Unesite red polinoma: ";
    cin&gt;&gt;r;
 
    vector&lt;double&gt; skalari;
    double skalar;
    cout&lt;&lt;"Unesite koeficijente polinoma: ";
    for(int i=0;i&lt;r+1;i++){
        cin&gt;&gt;skalar;
        skalari.push_back(skalar);
    }
    IspisiMatricu&lt;double&gt;(c = MatricniPolinom&lt;double&gt;(a, skalari), 10, 6, false);
    }
    catch(bad_alloc) {
        cout&lt;&lt;"Nema dovoljno memorije!\n";
    }
    UnistiMatricu(a);UnistiMatricu(c);
    return 0;
}</pre>
</body>
</html>
