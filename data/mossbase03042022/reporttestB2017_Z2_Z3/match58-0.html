<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student9864.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student9864.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;


<a name="0"></a><font color="#FF0000"><a href="match58-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template &lt;typename tip&gt;
bool TestPerioda(const std::vector&lt;tip&gt; &amp;v,int p){
	 for(int i(0);i&lt;v.size();i++){
	 	for(int j(i); j&lt;v.size();j+=p) {
	 		if(v.at(i) != v.at(j)) return false;
	 	}
	 }
	 return true;
}

template&lt;typename tip&gt;
int Period(const std::vector&lt;tip&gt; &amp;v){
	int n=v.size()-1;
	for(int i=n;i&gt;=1;i--){
		if(TestPerioda(v,i))
		return i;
	}
	return 0;
}

template&lt;typename tip&gt;
int Najveci(const std::vector&lt;tip&gt; &amp;v){
	int max(0);
	for(int i(0); i &lt; v.size(); i++) {
		if(v.at(i) &gt; max) max = v.at(i);
	}
	return max;
}

template&lt;typename tip&gt;
int Najmanji(const std::vector&lt;tip&gt; &amp;v){
	int min(v[0]);
	for(int i(1);i&lt;v.size();i++){
	if(v.at(i)&lt;min) min=v.at(i);	
	}
	return min;
}


template &lt;typename tip&gt;
int **AlocirajKontinualno (const std::vector&lt;tip&gt; &amp;v,int &amp;koliko_puta){
	if(v.size()==0) throw("Prazan vektor!");
	for(int i(0);i&lt;v.size();i++){
		if(v.at(i) &lt;=0 ) throw std::domain_error("Neispravan vektor!");
	}
	int period=Period(v);
	int produzenje=0;
	if(period!=0){
		int modul=v.size()%period;
		produzenje= period-modul;
		if(produzenje==period) produzenje = 0;
		koliko_puta=(v.size()+produzenje)/period;
	}
	else{
		koliko_puta=2;
		period=v.size();
		produzenje=v.size();
	}
	
	int suma=0;
	for(int i(0);i&lt;period;i++)
	  suma+=v.at(i);
	try{
		int **mat=new int*[v.size()+produzenje]{};
		try{
			mat[0]= new int[suma*koliko_puta];
			for(int i(1);i&lt;v.size()+produzenje;i++){
				mat[i]=mat[i-1]+v[i%period];
			}
			int min = Najmanji(v);
			for(int i(0); i&lt;v.size()+produzenje;i++) {
				for(int j(v.at(i % period)-1); j &gt;= 0;j--) {
					
					if(j == v.at(i % period)-1) mat[i][j] = min;
					
					else mat[i][j] = mat[i][j + 1] + 1;
					
				}
			}
			return mat;
		}
		catch(...){
			
				delete[] mat[0];
				mat[0] = nullptr;
		
			delete[] mat;
			mat = nullptr;
			throw;
		}
	}
	catch(...){
		throw;
	}
}
		
	

template &lt;typename tip&gt;
int **AlocirajFragmentirano (const std::vector&lt;tip&gt; &amp;v,int &amp;koliko_puta) {
	if(v.size() == 0) throw ("Prazan vektor!");
	for(int i(0); i &lt; v.size(); i++) {
		if(v.at(i) &lt;= 0) throw std::domain_error("Neispravan vektor!");
	}
	int period=Period(v);
	int produzenje=0;
	if(period!=0){
		int modul = v.size() % period;
		produzenje = period - modul;
		if(produzenje == period) produzenje = 0;
		koliko_puta = (v.size() + produzenje) / period;
	}
	else {
		koliko_puta = 2;
		period = v.size();
		produzenje = v.size();
	}
	try{ 
		int **mat=new int*[v.size()+produzenje]{}; // period * koliko_puta
		try{
			for(int i(0);i&lt;v.size()+produzenje;i++){
				mat[i]=new int[v[i%period]];
			}
			int max = Najveci(v);
			for(int i(0); i&lt;v.size()+produzenje;i++) {
				for(int j(v.at(i % period) - 1); j &gt;= 0;j--) {
					if(j == v.at(i % period) - 1) mat[i][j] = max;
					else mat[i][j] = mat[i][j + 1] - 1;
				}
			}
			return mat;
		}
		catch(...){
			for(int i(0); i&lt;v.size()+produzenje;i++) {
				delete[] mat[i];
				mat[i] = nullptr;
			}
			delete[] mat;
			mat = nullptr;
			throw;
		}
	}
	catch(...){
		throw;
	}
}


int main () {
	try {
		std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
		int n;
		std::cin&gt;&gt;n;
		std::cout&lt;&lt;"Unesite elemente vektora: ";
		std::vector&lt;int&gt;v;
		for(int i(0); i &lt; n; i++) {
			int x;
			std::cin&gt;&gt;x;
			v.push_back(x);
		}
		std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		int a;
		std::cin &gt;&gt; a;
		int koliko_puta;
		int **matrica = nullptr;
		if(a == 1) {
			matrica = AlocirajFragmentirano(v, koliko_puta);
		}
		else if(a == 0) {
			matrica = AlocirajKontinualno(v, koliko_puta);
			
		}
		int period = Period(v);
		int produzenje = 0;
		if(period != 0) {
			int modul = v.size() % period;
			produzenje = period - modul;
			if(produzenje == period) produzenje = 0;
		}
		else {
			period = v.size();
			produzenje = v.size();
		}
		std::cout &lt;&lt; "Dinamicki alocirana matrica: " &lt;&lt; std::endl;
		for(int i(0); i &lt; v.size()+produzenje; i++) {
			for(int j(0); j &lt; v.at(i % period); j++) {
				std::cout &lt;&lt; std::left &lt;&lt; std::setw(3) &lt;&lt; matrica[i][j];
			}
			std::cout &lt;&lt; std::endl;
		}
		if(a==1){
		for(int i(0); i &lt; v.size()+produzenje; i++) {
			delete[] matrica[i];
		}
		delete[] matrica;
	}
	
	if(a==0){
		delete [] matrica[0];
		delete [] matrica;
	}
	}
	catch(std::domain_error e) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what();
	}
	catch(const char *e) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e;
	}
	catch(...) {
		// alokacija
		std::cout &lt;&lt; "alokacija";
	}
	return 0;
</font>}</pre>
</body>
</html>
