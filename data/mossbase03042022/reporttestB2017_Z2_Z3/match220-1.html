<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student9557.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student5639.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
/*
template&lt;typename TipEl&gt;
	void UnistiMatricu(TipEl **mat, int broj_redova){
		if(!mat) return;
		for(int i=0; i&lt;broj_redova; i++){
			delete[] mat.at(i);
		}
		delete[] mat;
	}

template &lt;typename TipEl&gt;
	TipEl **StvoriMatricu(int broj_redova, int broj_kolona){
		TipEl **mat(new TipEl*[broj_redova]{});
		try {
			for(int i=0; i&lt;broj_redova; i++){
				mat[i]=new TipEl[broj_kolona];
			}
		}
		catch (...) {
			UnistiMatricu(mat, broj_redova);
			throw;
		}
		return mat;
	}
*/
<a name="0"></a><font color="#FF0000"><a href="match220-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template&lt;typename tip&gt;
bool DaLiJePeriodican(const std::vector&lt;tip&gt;&amp;v, int T)
{
	if(T&lt;1 || T&gt;=v.size()) return false;
	for(int i=0; i&lt;v.size()-T; i++) {
		if((v[i]-v[i+T])!=0) return false;
	}
	return true;
}
/*
template&lt;typename tip&gt;
int OsnovniPeriod(const std::vector&lt;tip&gt;&amp;v){
	for(int i=1; i&lt;v.size(); i++){
		if(DaLiJePeriodican(v, i)) return i;
	}
	return 0;
}
*/
template &lt;typename tip&gt;
tip *AlocirajFragmentirano(std::vector&lt;tip&gt; &amp;v, int &amp;koliko_puta) //koliko puta
{
	int period;
	for(int i=0; i&lt;v.size(); i++) {
		if(DaLiJePeriodican(v, i)) period=i;
	}
	int k=0;
	int vel1;
	while((v.size()+k)%3!=0) {
		vel1=v.size()+k;
		k++;
	}
	vel1++;
	v.resize(vel1);
	for(int i=v.size()-1; i&lt;vel1; i++) {
		int dodaj=i%3+1;
		v.push_back(v[dodaj]);
	}
	int brojac_perioda=0;
	for(int i=0; i&lt;v.size(); i++) {
		if(v[i]=v[0]) brojac_perioda++;
	}
	koliko_puta=brojac_perioda;

	int brojac_uspjelihal=0;
	tip **mat=nullptr;
	try {
		mat=new tip*[v.size()];
		for(int i=0; i&lt;v.size(); i++) {
			mat[i]=new tip[v[i]];
			brojac_uspjelihal++;
		}
		for(int i=0; i&lt;mat.size(); i++) {
			for(int j=0; j&lt;mat[i].size(); j++) {
				auto najveci=std::max_element(mat, mat+mat[i].size());
				if(j==mat[i].size()-1) mat[i][j]=*najveci;
				else mat[i][j]=j;
			}
		}
		return mat[0];
		for(int i=0; i&lt;mat.size(); i++) {
			delete[] mat[i];
			delete[] mat;
		}
	} catch(...) {
		for(int i=0; i&lt;brojac_uspjelihal; i++) {
			delete[] mat[i];
			delete[] mat;
		}
	}
}
int main ()
{
	int n;
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	std::cin &gt;&gt; n;
	std::vector&lt;int&gt; v(n);
	std::cout &lt;&lt; "Unesite elemente vektora: ";
	int element;
	int i=0;
	while(v.size()!=n){
		std::cin &gt;&gt; element;
		v[i]=element;
		i++;
	}
	int odaberi;
	std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	std::cin &gt;&gt; odaberi;
	
	std::cout &lt;&lt; "Dinamicki alocirana matrica: " &lt;&lt; std::endl;
	int koliko_puta;
	int *mat=AlocirajFragmentirano(v, koliko_puta);
	for(int i=0; i&lt;koliko_puta; i++){
			std::cout &lt;&lt; mat[i] &lt;&lt; " ";
		}
		std::cout &lt;&lt; std::endl;
</font>
	return 0;
}</pre>
</body>
</html>
