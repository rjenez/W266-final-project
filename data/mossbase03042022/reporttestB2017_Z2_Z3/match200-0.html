<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3542.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3542.cpp<p></p><pre>
/*B 2017/2018, ===TITLE===
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/

/*
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;numeric&gt;
#include &lt;new&gt;

template &lt;typename TIP&gt; int DajPeriod (const std::vector &lt;TIP&gt; &amp;vektor)
{
    int i{0}, T{1};
    while ((i + T) &lt; vektor.size())
        i += vektor.at(i) == vektor.at(i + T) ? 1 : (T++, -i);
    return T;
}
template &lt;typename TIP&gt; void Validiraj (const std::vector&lt;TIP&gt; &amp;v)
{
    if (v.empty())
        throw "Prazan vektor!";
    if (std::count_if (v.begin(), v.end(), [] (TIP x) {return x &lt;= 0;}) &gt; 0)
        throw std::domain_error("Neispravan vektor!");
}
template &lt;typename TIP&gt;
TIP **AlocirajFragmentirano(const std::vector&lt;TIP&gt; &amp;v, int&amp; koliko_puta)
{
    Validiraj(v);
    TIP **matrica{nullptr}, najveci{*max_element(v.begin(), v.end())};
    koliko_puta = int (v.size() / DajPeriod(v));
    
    if ((v.size() % DajPeriod(v)) != 0 || DajPeriod(v) == v.size())
        koliko_puta++;
    
        try 
        {
            matrica = new TIP* [DajPeriod(v) * koliko_puta]{};
            for (int i{0}; i &lt; DajPeriod(v) * koliko_puta; i++)
                matrica[i] = new TIP [v.at(i % DajPeriod(v))]{};
        }
        catch (std::bad_alloc)
        {
            for (int i{0}; i &lt; DajPeriod(v) * koliko_puta; i++)
                delete [] matrica[i];
            delete [] matrica;
            throw;
        }
    
        for (int k{0}; k &lt; koliko_puta; k++)
            for (int i{0}; i &lt; DajPeriod(v); i++)
                for (int j{v.at(i) - 1}, l{0}; j &gt; -1; j--, l++)
                    matrica[i + DajPeriod(v) * k][j] = najveci - l;
    return matrica;
}
template &lt;typename TIP&gt;
TIP **AlocirajKontinualno(const std::vector&lt;TIP&gt; &amp;v, int&amp; koliko_puta)
{
    Validiraj(v); 
    TIP **matrica{nullptr}, broj(accumulate(v.begin(), v.end(), 0.)); 
    koliko_puta = int (v.size() / DajPeriod(v));
    
    if ((v.size() % DajPeriod(v)) != 0 || DajPeriod(v) == v.size())
        koliko_puta++;
    
    try
    {
        matrica = new TIP* [DajPeriod(v) * koliko_puta]{};
        try
        {   
            matrica[0] = new TIP [broj * koliko_puta];
            for (int i{1}; i &lt;  DajPeriod(v) * koliko_puta; i++)
                matrica[i] = matrica[i - 1] + v.at((i - 1) %  DajPeriod(v));
        }
        catch (...)
        {
            delete [] matrica;
            throw;
        }
    }
    catch (...)
    {   
        throw;
    }
            
    for (int k{0}; k &lt; koliko_puta; k++)
        for (int i{0}; i &lt;  DajPeriod(v); i++)
            for (int j{v.at(i) - 1}; j &gt; -1; j--)
                matrica[i +  DajPeriod(v) * k][j] = v.at(i) - j;
    return matrica;
}

int main()
{
    int brojElemenata {0}, brojPuta;
    bool fragmentirana {true};
    std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
    std::cin &gt;&gt; brojElemenata;
    std::vector&lt;int&gt; vektor(brojElemenata);
    std::cout &lt;&lt; "Unesite elemente vektora: ";
    for (int&amp; v : vektor)
        std::cin &gt;&gt; v;
    std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
    std::cin &gt;&gt; fragmentirana;
    try
    {
        int **matrica{};
        matrica = (fragmentirana ? AlocirajFragmentirano(vektor, brojPuta) : AlocirajKontinualno(vektor, brojPuta));
        
        std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::endl;
        for (int i{0}; i &lt; DajPeriod(vektor) * brojPuta; i++)
            for (int j{0}; j &lt; vektor.at(i % DajPeriod(vektor)); j++)
                 std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left &lt;&lt; matrica[i][j] &lt;&lt; ((j + 1 != vektor.at(i % DajPeriod(vektor))) ? "" : "\n");
        
        if (fragmentirana)
           for (int i{0}; i &lt; DajPeriod(vektor) * brojPuta; i++)
                delete [] matrica[i];
        else       
            delete [] matrica[0];            
        delete [] matrica;
    }
    catch (const std::domain_error&amp; e)
    {
        std::cout&lt;&lt; "Izuzetak: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch (const char izuzetak[])
    {
        std::cout &lt;&lt; "Izuzetak: "&lt;&lt; izuzetak &lt;&lt; std::endl;
    }
    
    return 0;
}*/



#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
<a name="1"></a><font color="#00FF00"><a href="match200-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_25.gif"/></a>

using std::vector;
template &lt;typename T&gt; int period(const vector&lt;T&gt; &amp;v)
{
	for (int i(1); i &lt; v.size(); i++)
	{
	    for (int j(i); j &lt; v.size(); j++)
	    	if (v.at(j) != v.at(j-i)) goto preskok;
	    return i;
	    preskok:;
	}
	return 0;
}
template &lt;typename T&gt; int predradnje(const vector&lt;T&gt; &amp;v, int &amp;koliko_puta)
{
	if (v.empty()) throw "Prazan vektor!";
	for (auto x : v)
		if (x &lt;= 0) throw std::domain_error("Neispravan vektor!");
	int p(period(v));
	koliko_puta = p != 0 ? v.size() / p + (v.size() % p != 0) : 2;
	return p != 0 ? p : v.size();
}
template &lt;typename T&gt; T **AlocirajFragmentirano(const vector&lt;T&gt; &amp;v, int &amp;koliko_puta)
{
	int p(predradnje(v, koliko_puta)), n(p * koliko_puta);
	T **mat = new T*[n]{nullptr};
</font>	int max(0);
	try
	{
<a name="4"></a><font color="#FF00FF"><a href="match200-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

		for (int i(0); i &lt; n; i++) mat[i] = new T[v.at(i % p)]{};
	}
	catch (...)
</font>	{
	    if (!mat)
<a name="2"></a><font color="#0000FF"><a href="match200-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_22.gif"/></a>

		for (int i(0); i &lt; n &amp;&amp; mat[i] != nullptr; i++)
			delete[] mat[i];
		delete[] mat;
		throw;
	}
	for (const auto &amp;x : v)
		if (x &gt; max) max = x;
	for (int i(0); i &lt; n; i++)
		for (int j(0); j &lt; v.at(i % p); j++)
			mat[i][v.at(i % p)-1-j] = max-j;
	return mat;
}
template &lt;typename T&gt; T **AlocirajKontinualno(const vector&lt;T&gt; &amp;v, int &amp;koliko_puta)
{
	int p(predradnje(v, koliko_puta)), m(0), n(p * koliko_puta);
	for (int i(0); i &lt; p; i++) m += v.at(i);
	m *= koliko_puta;
	T **mat = new T*[n]{nullptr};
</font>	try
	{
<a name="3"></a><font color="#00FFFF"><a href="match200-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

		mat[0] = new T[m];
		for (int i(1); i &lt; n; i++)
			mat[i] = mat[i-1] + v.at((i-1) % p);
	}
	catch (...) { if (!mat) delete[] mat; throw; }
</font><a name="0"></a><font color="#FF0000"><a href="match200-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_37.gif"/></a>

	for (int i(0); i &lt; n; i++)
		for (int j(0); j &lt; v.at(i % p); j++)
			mat[i][v.at(i % p)-1-j] = j+1;
	return mat;
}

int main()
{
	int n, f, p;
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	std::cin &gt;&gt; n;
	std::cout &lt;&lt; "Unesite elemente vektora: ";
	vector&lt;int&gt; v(n);
	for (int &amp;x : v) std::cin &gt;&gt; x;
	std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	std::cin &gt;&gt; f;
	try
	{
		int **mat = f ? AlocirajFragmentirano(v, n) : AlocirajKontinualno(v, n);
		p = period(v);
		n = (p = p != 0 ? p : v.size()) * n;
		std::cout &lt;&lt; "Dinamicki alocirana matrica: ";
		for (int i(0); i &lt; n; i++)
		{
			std::cout &lt;&lt; std::endl;
			for (int j(0); j &lt; v.at(i % p); j++)
				std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left &lt;&lt; mat[i][j];
			if (f) delete[] mat[i];
		}
		if (!f) delete[] *mat;
		delete[] mat;
	}
	catch (const char *s) { std::cout &lt;&lt; "Izuzetak: " &lt;&lt; s; }
	catch (std::domain_error e) { std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what(); }
	catch (...) { }
</font>	return 0;
}
</pre>
</body>
</html>
