<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4772.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4772.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;iomanip&gt;

template &lt;typename CjelobrojniTip&gt;
	bool DaLiJePeriodican(const std::vector&lt;CjelobrojniTip&gt;&amp;v) {
		bool period;
		for (int i=1; i&lt;int(v.size()); i++) {
			period=true;
			for (int j=0; j&lt;int(v.size() - i); j++) {
				if(v.at(j)!=v.at(j+i)) {
					period=false;
					break;
				}
			}
			if (period) return true;
		}
		return false;
	}
	
template &lt;typename CjelobrojniTip&gt;
	int OsnovniPeriod (const typename std::vector&lt;CjelobrojniTip&gt;&amp;v) {
		if(DaLiJePeriodican(v)) {
			for (int i=1; i&lt;int(v.size()); i++) {
				bool period(true);
				for (int j=0; j&lt;int(v.size()-i); j++) {
					if(v.at(j)!=v.at(j+i)) {
						period=false;
					}
				}
				if(period) return i;
			}
		} 
		return 0;
	}
	
template &lt;typename CjelobrojniTip&gt;
	int NajveciBroj (const typename std::vector&lt;CjelobrojniTip&gt;&amp;v) {
		int max(v.at(0));
		for (int i=1; i&lt;v.size(); i++) 
			if(v.at(i)&gt;max) 
				max=v.at(i);
		return max;
	}

template &lt;typename CjelobrojniTip&gt;
<a name="1"></a><font color="#00FF00"><a href="match566-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	int** AlocirajFragmentirano (const typename std::vector&lt;CjelobrojniTip&gt;&amp;v, int &amp;koliko_puta) {
		if(v.size()==0) throw ("Prazan vektor!");
		for (int i=0; i&lt;v.size(); i++) 
			if(v.at(i)&lt;=0) throw std::domain_error ("Neispravan vektor!");
</font>		int period (OsnovniPeriod(v));
		int vel;
		if(DaLiJePeriodican(v)) {
			for (int i=period+1; ; i++) {
				if(i%period==0) {
					vel=i;
					break;
				}
			}
			koliko_puta=vel/period;
		}
		else {
			koliko_puta=2;
			vel=koliko_puta*int(v.size());
		}
		int** p(nullptr);
		try {
			p=new int* [vel] {};	
			try {
				for (int i=0; i&lt;vel; i++) {
					if(i&lt;int(v.size()))
						p[i]=new int[v.at(i)];
					else {
						if(DaLiJePeriodican(v))
							p[i]=new int[v.at(i-period)];
						else p[i]=new int[v.at(i-v.size())];
					}
				}
				int maxbroj(NajveciBroj(v));
				for (int i=0; i&lt;vel; i++) {
					if(i&lt;int(v.size())) {
						p[i][0]=maxbroj-v.at(i) + 1;
						int k(p[i][0] + 1);
						for (int j=1; j&lt;v[i]; j++) {
							p[i][j]=k;
							k++;
						}
					}
					else {
						if(DaLiJePeriodican(v)) {
							p[i][0]=maxbroj-v.at(i-period) + 1;
							int k(p[i][0] + 1);
							for (int j=1; j&lt;v[i-period]; j++) {
								p[i][j]=k;
								k++;
							}
						} else {
							p[i][0]=maxbroj-v.at(i-v.size()) + 1;
							int k(p[i][0] + 1);
							for (int j=1; j&lt;v[i-v.size()]; j++) {
								p[i][j]=k;
								k++;
							}
						}
					}
				}
				return p;
			} catch (std::bad_alloc) {
				for (int i=0; i&lt;vel; i++) delete[] p[i];
				delete[] p;
				throw;
			}
		} catch (std::bad_alloc) {
			throw;
		}	
		
	}

	
template &lt;typename CjelobrojniTip&gt;
<a name="2"></a><font color="#0000FF"><a href="match566-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	int** AlocirajKontinualno (const typename std::vector&lt;CjelobrojniTip&gt;&amp;v, int &amp;koliko_puta) {
		/*Kopirala sam sadrzaj prethodne funkcije, pa onda prilagodjavala ovoj novoj funkciji*/
		if(v.size()==0) throw ("Prazan vektor!");
		for (int i=0; i&lt;v.size(); i++) 
			if(v.at(i)&lt;=0) throw std::domain_error ("Neispravan vektor!");
</font>		int period (OsnovniPeriod(v));
		int vel;
		if(DaLiJePeriodican(v)) {
			for (int i=period+1; ; i++) {
				if(i%period==0) {
					vel=i;
					break;
				}
			}
			koliko_puta=vel/period;
		}
		else {
			koliko_puta=2;
			vel=koliko_puta*int(v.size());
		}
		int** p {};
		try {
			int suma(0);
			for (int i=0; i&lt;v.size(); i++) suma+=v.at(i);
			p=new int* [vel] {};	
			try {
				p[0]=new int [suma];
			/*	for (int i=1; i&lt;vel; i++) {
					if(DaLiJePeriodican(v)) {
						if(i&lt;int((koliko_puta-1)*period)) {
							p[i]=p[i-1] + v.at(i-1);
						} else p[i]=p[i-1] + v.at(i-period);
					}
					else {
						if(i&lt;v.size()) {
							p[i]=p[i-1] + v.at(i-1);
						} else p[i]=p[i-1] + v.at(i-int(v.size()));
					}
				}*/
				
				
				for (int i=1; i&lt;vel; i++) {
					if (i&lt;v.size()) p[i]=p[i-1] + v.at(i-1);
					else  {
						if(!DaLiJePeriodican(v))
							p[i]=p[i-1] + v.at(i-int(v.size()));
						else p[i]=p[i-1] + v.at(i-period);
					}
				}
				for (int i=0; i&lt;vel; i++) {
					if(DaLiJePeriodican(v)) {
						if(i&lt;int((koliko_puta-1)*period)) {
							p[i][0]=v.at(i);
							int k(p[i][0]-1);
							for (int j=1; j&lt;v[i]; j++) {
								p[i][j]=k;
								k--;
							}
						} else {
							p[i][0]=v.at(i-period);
							int k(p[i][0]-1);
							for (int j=1; j&lt;v.at(i-period); j++) {
								p[i][j]=k;
								k--;
							}
						}
					}
					else {
						if(i&lt;v.size()) {
							p[i][0]=v.at(i);
							int k(p[i][0]-1);
							for (int j=1; j&lt;v.at(i); j++) {
								p[i][j]=k;
								k--;
							}
						} else {
							int q=i-int(v.size());
							p[i][0]=v.at(q);
							int k(p[i][0]-1);
							for (int j=1; j&lt;v.at(q); j++) {
								p[i][j]=k;
								k--;
							}
						}
						
					}
				}
				return p;
			} catch (std::bad_alloc) {
				delete[] p;
				throw;
			}
		} catch (std::bad_alloc) {
			throw;
		}	
		
	}

int main ()
{
	try {
		std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
		int n;
<a name="0"></a><font color="#FF0000"><a href="match566-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

		std::cin &gt;&gt; n;
		std::vector&lt;int&gt; v (n);
		std::cout &lt;&lt; "Unesite elemente vektora: ";
		for (int i=0; i&lt;n; i++) 
			std::cin &gt;&gt; v.at(i);
		std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		int opcija;
		std::cin &gt;&gt; opcija;
</font>		int** p;
		int koliko_puta;
		int period(OsnovniPeriod(v));
		int vel;
		if(opcija==1) p=AlocirajFragmentirano(v, koliko_puta);
		else p=AlocirajKontinualno(v, koliko_puta);
		if(DaLiJePeriodican(v)) vel=koliko_puta*period;
		else vel=2*v.size();
		std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::endl;
			if(DaLiJePeriodican(v)) {
					for (int i=0; i&lt;vel; i++) {
						if(i&lt;v.size()) {
							for (int j=0; j&lt;v.at(i); j++) {
								std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left &lt;&lt; p[i][j];
							}
						} else for (int j=0; j&lt;v.at(i-period); j++) 
							std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left &lt;&lt; p[i][j];
						std::cout &lt;&lt; std::endl;
					}
			} else {
					for (int i=0; i&lt;vel; i++) {
						if(i&lt;v.size()) {
							for (int j=0; j&lt;v.at(i); j++) {
								std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left &lt;&lt; p[i][j];
							}
						} else {
							int b=v.size();
							for (int j=0; j&lt;v.at(i-b); j++) 
								std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left &lt;&lt; p[i][j];
						}
						std::cout &lt;&lt; std::endl;
					}
			}
	
		if(opcija==0) delete[] p[0];
		else 
<a name="3"></a><font color="#00FFFF"><a href="match566-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

			for (int i=0; i&lt;vel; i++) delete[] p[i];
		
		delete[] p;
	}	
	catch (std::domain_error izuzetak) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
</font>	}
	catch (const char e[]) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e &lt;&lt; std:: endl;
	}
	catch (...) {
		std::cout &lt;&lt; "Nedovoljno memorije." &lt;&lt; std::endl;
	}
	
	return 0;
}</pre>
</body>
</html>
