<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1793.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1793.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
<a name="0"></a><font color="#FF0000"><a href="match127-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;

template &lt;typename T&gt;
int period(const vector&lt;T&gt;&amp; v)
{
	if(v.size()==0) throw "Prazan vektor!";

	int p=0;

	for (int i = 1; i &lt; v.size(); i++) {
		if(v[i]&lt;=0) throw domain_error("Neispravan vektor!");

		if(v[i]==v[0]) {
			p=i;
			bool periodican=true;

			for (int j = 0; j &lt; v.size()-p; j++) {
				if(v[j]!=v[j+p]) {
					periodican=false;
					break;
				}
			}
			if(periodican) break;
			p=0;
		}
	}

	return p;
}


template &lt;typename T&gt;
int** AlocirajFragmentirano(const vector&lt;T&gt;&amp; v,int&amp; koliko_puta)
{
	int element;
	int p = period(v);
	int broj_elemenata;

	if(p==0) {
		koliko_puta=2;
		broj_elemenata = koliko_puta * v.size();
		p=v.size();
	} else {
		int ostatak = v.size()%p;
		koliko_puta = v.size()/p;
		if(ostatak&gt;0) {
			koliko_puta++;
		}
		broj_elemenata = koliko_puta * p;
	}





	int** matrica=nullptr;


	try {
		matrica = new int*[broj_elemenata];
		for (int i = 0; i &lt; broj_elemenata; i++) {
			matrica[i]=nullptr;
		}

		try {
			for (int i = 0; i &lt; broj_elemenata; i++) {
				if(i&lt;v.size())element=v[i];
				else element=v[i-p];
				matrica[i] = new int[element];
			}

		} catch(bad_alloc) {
			for (int i = 0; i &lt; broj_elemenata; i++) {
				delete[] matrica[i];
			}
			delete[] matrica;
			throw;
		}

	} catch(bad_alloc) {
		throw;
	}

	int najveci = v[0];

	for (int i = 0; i &lt; v.size(); i++) {
		if(v[i]&gt;najveci) najveci=v[i];
	}


	for(int i=0; i&lt;broj_elemenata; i++) {
		int k=najveci;
		if(i&lt;v.size())element=v[i];
		else element=v[i-p];
		for(int j=element-1; j&gt;=0; j--) {
			matrica[i][j]=k--;
		}
	}



	return matrica;
}



template &lt;typename T&gt;
int** AlocirajKontinualno(const vector&lt;T&gt;&amp; v,int&amp; koliko_puta)
{
	int element;
	int p = period(v);
	int broj_elemenata;

	if(p==0) {
		koliko_puta=2;
		broj_elemenata = koliko_puta * v.size();
		p=v.size();
	} else {
		int ostatak = v.size()%p;
		koliko_puta = v.size()/p;
		if(ostatak&gt;0) {
			koliko_puta++;
		}
		broj_elemenata = koliko_puta * p;
	}

	int** matrica=nullptr;

	try {
		matrica = new int*[broj_elemenata];

		int ukupno = 0;
		for (int i = 0; i &lt; broj_elemenata; i++) {

			if(i&lt;v.size())element=v[i];
			else element=v[i-p];
			ukupno+=element;
		}
		try {
			matrica[0] = new int[ukupno];

			for (int i = 1; i &lt; broj_elemenata; i++) {
				int prethodni_element;
				if(i-1&lt;v.size())prethodni_element=v[i-1];
				else prethodni_element=v[i-1-p];
				matrica[i] = matrica[i-1]+prethodni_element; //prethodni element
			}
		} catch(bad_alloc) {
			delete[] matrica;
		}

	} catch(bad_alloc) {
		throw;
	}




	for(int i=0; i&lt;broj_elemenata; i++) {
		int k=1;
		if(i&lt;v.size())element=v[i];
		else element=v[i-p];
		for(int j=element-1; j&gt;=0; j--) {
			matrica[i][j]=k++;
		}
	}

	return matrica;
}



int main ()
{
	int n,element;
	cout&lt;&lt;"Unesite broj elemenata vektora: ";
	cin&gt;&gt;n;
	vector&lt;int&gt;v(n);
	cout&lt;&lt;"Unesite elemente vektora: ";
	for (int i = 0; i &lt; v.size(); i++) {
		cin&gt;&gt;v[i];
	}

	cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int vrsta_alokacije;
	cin&gt;&gt;vrsta_alokacije;

	int **M=nullptr;
	int koliko_puta;
	try {
		if(vrsta_alokacije==1) {
			M=AlocirajFragmentirano(v,koliko_puta);
		} else {
			M = AlocirajKontinualno(v,koliko_puta);
		}

		int p = period(v);

		int broj_elemenata;
		if(p==0){
			broj_elemenata = v.size()*koliko_puta;
			p=v.size();
		}
		else{
			broj_elemenata = p*koliko_puta;
		}
		cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;endl;
		for (int i = 0; i &lt; broj_elemenata ; i++) {
			if(i&lt;v.size())element=v[i];
			else element=v[i-p];

			for (int j = 0; j &lt; element; j++) {
				cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;M[i][j];
			}
			cout&lt;&lt;endl;
		}

		if(vrsta_alokacije==1) {
			for (int i = 0; i &lt; broj_elemenata; i++) {
				delete[] M[i];
			}
			delete[] M;
		} else {
			delete[] M[0];
			delete[] M;
		}
	} catch(domain_error e) {
		cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what()&lt;&lt;endl;
	} catch(bad_alloc e) {
		cout&lt;&lt;"Izuzetak: "&lt;&lt;"Nema memorije!"&lt;&lt;endl;
	} catch(const char poruka[]) {
		cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka&lt;&lt;endl;
	}
	return 0;
</font>}</pre>
</body>
</html>
