<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8776.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1502.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
<a name="0"></a><font color="#FF0000"><a href="match195-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;

int p(vector&lt;int&gt;v){
	
	for(int i=2;i&lt;v.size();i++){
		for(int j=0;j&lt;v.size();j++){
			
			if(v.at(j)==v.at(j+i)){
				if(i+j==v.size()-1) return i;
			}else break;
			
		}
	}
	return -1;
}

int **AlocirajFragmentirano(vector&lt;int&gt; &amp;v, int &amp;koliko_puta){
	int period=p(v);
	if(v.size()%period==0)	koliko_puta=v.size()/period;
	else koliko_puta=int(v.size()/period)+1;
	int **pok=nullptr;
	try{
	pok=new int *[v.size()];
	int korisna_varijabla=koliko_puta*period;
	int mozda=0;
	for(int i=0;i&lt;korisna_varijabla;i++){//alocirano
		if(mozda==period)mozda=0;
		pok[i]=new int[v.at(mozda)];
		mozda++;
	}
	mozda=0;
	for(int i=0;i&lt;korisna_varijabla;i++){
		if(mozda==period)mozda=0;
		int k=0;
		for(int j=v.at(mozda)-1;j&gt;=0;j--){
		pok[i][j]=period-k;
		k++;
		} 
		mozda++;
	}
	
	return pok;
	}catch(...){
			for(int i=0;i&lt;period*koliko_puta;i++){
		delete[] pok[i];
	}
	delete[] pok;
		throw;
	}
	
}

int **AlocirajKontinualno(vector&lt;int&gt; &amp;v, int &amp;koliko_puta){
	int **pok=nullptr;
	try{
	int period=p(v);
	if(v.size()%period==0)	koliko_puta=v.size()/period;
	else koliko_puta=int(v.size()/period)+1;
	pok=(new int *[v.size()]);
	int korisna_varijabla=koliko_puta*period;
	
	pok[0]=new int[korisna_varijabla];
	
	int mozda=0;
	for(int i=0;i&lt;korisna_varijabla;i++){
		if(mozda==period)mozda=0;
		int k=0;
		for(int j=v.at(mozda)-1;j&gt;=0;j--){
		pok[i][j]=period-k;
		k++;
		} 
		mozda++;
	}
	
	return pok;
}catch(...){
	delete[] pok[0];
	
	delete[] pok;
		throw;
	}
}





int main (){
	int koliko_puta=0;
	cout&lt;&lt;"Unesite broj elemenata vektora: ";
	int n;
	cin&gt;&gt;n;
	vector&lt;int&gt; v;
	int element;
	cout&lt;&lt;"Unesite elemente vektora: ";
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;element;
		v.push_back(element);
	}
	cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int izbor;
	cin&gt;&gt;izbor;
	cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;endl;
	if(izbor){
			int **pok=AlocirajFragmentirano(v,koliko_puta);
			int period=p(v);
			int molim_te=0;
			
			for(int i=0; i&lt;period*koliko_puta; i++){
			if(molim_te==period)molim_te=0;
			for(int j=0; j&lt;v.at(molim_te); j++){
			cout&lt;&lt;setw(3)&lt;&lt;pok[i][j];
			
		}
		cout&lt;&lt;endl;
		molim_te++;
	}
	for(int i=0;i&lt;period*koliko_puta;i++){
		delete[] pok[i];
	}
	delete[] pok;
	}else{
		int **pok=AlocirajKontinualno(v,koliko_puta);
			int period=p(v);
			int molim_te=0;
			
			for(int i=0; i&lt;period*koliko_puta; i++){
			if(molim_te==period)molim_te=0;
			for(int j=0; j&lt;v.at(molim_te); j++){
			cout&lt;&lt;setw(3)&lt;&lt;pok[i][j];
			
		}
		cout&lt;&lt;endl;
		molim_te++;
	}
	delete[] pok[0];
	
	delete[] pok;
</font>	}

	return 0;
}</pre>
</body>
</html>
