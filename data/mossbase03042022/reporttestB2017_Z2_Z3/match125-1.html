<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1966.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student5129.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;

#include &lt;vector&gt;

#include &lt;stdexcept&gt;

<a name="0"></a><font color="#FF0000"><a href="match125-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template &lt;typename IntType&gt;
bool areValidDim(const std::vector&lt;IntType&gt; &amp;);

template &lt;typename IntType&gt;
int findPeriod(const std::vector&lt;IntType&gt; &amp;);

template &lt;typename IntType&gt;
IntType **AlocirajFragmentirano(const std::vector&lt;IntType&gt;&amp;, int&amp;);

template &lt;typename IntType&gt;
IntType **AlocirajKontinualno(const std::vector&lt;IntType&gt;&amp;, int&amp;);

int main ()
{
	int n;
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	std::cin &gt;&gt; n;
	
	std::vector&lt;int&gt; v(n);
	std::cout &lt;&lt; "Unesite elemente vektora: ";
	for (auto &amp;el : v)
		std::cin &gt;&gt; el;
	
	int fragmentation;
	std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	std::cin &gt;&gt; fragmentation;
	
	if (fragmentation != 0 &amp;&amp; fragmentation != 1)
		return 0; // problem
	
	int **res{nullptr};
	int koliko{0};
	
	try {
		if (fragmentation == 0)
			res = AlocirajKontinualno(v, koliko);
		else
			res = AlocirajFragmentirano(v, koliko);
	}
	catch (std::domain_error er) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; er.what() &lt;&lt; std::endl;
		return 0;
	}
	
	int period{findPeriod(v)};
	std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::left &lt;&lt; std::endl;
	for (int i = 0; i &lt; koliko * period; i++)
	{
		for (int j = 0; j &lt; v[i &lt; period ? i : i - period]; j++)
			std::cout &lt;&lt; std::setw(3) &lt;&lt; res[i][j];

		std::cout &lt;&lt; std::endl;
	}
	
	if (fragmentation == 0)
		delete[] res[0];
	else
		for (int i = 0; i &lt; koliko * period; i++)
			delete[] res[i];
	
	delete[] res;
	
	return 0;
}

template &lt;typename IntType&gt;
IntType **AlocirajFragmentirano(const std::vector&lt;IntType&gt; &amp;v, int &amp;koliko_puta)
{
	if (!areValidDim(v))
		throw std::domain_error("Neispravan vektor!");
	
	int period{findPeriod(v)};
	koliko_puta = v.size() / period + (v.size() % period != 0 || v.size() == period ? 1 : 0);
	
	IntType **ret{nullptr};
	try {
		ret = new IntType*[koliko_puta * period]{};
		
		for (int i = 0; i &lt; koliko_puta * period; i++)
			ret[i] = new IntType[i &gt;= v.size() ? v[i - period] : v[i]]{};
	}
	catch (...) {
		if (ret != nullptr)
			for (int i = 0; i &lt; koliko_puta * period; i++)
				delete[] ret[i];
				
		delete[] ret;
		
		throw;
	}
	
	IntType beginNumber = *std::max_element(v.begin(), v.end());
	for (int i = 0; i &lt; koliko_puta * period; i++)
		for (int j = 0; j &lt; v[i &gt;= v.size() ? i - period : i]; j++)
			ret[i][j] = beginNumber - v[i &gt;= v.size() ? i - period : i ] + j + 1;
	
	return ret;
}

template &lt;typename IntType&gt;
IntType **AlocirajKontinualno(const std::vector&lt;IntType&gt; &amp;v, int &amp;koliko_puta)
{
	if (!areValidDim(v))
		throw std::domain_error("Neispravan vektor!");
	
	int period{findPeriod(v)};
	koliko_puta = v.size() / period + (v.size() % period != 0 || v.size() == period ? 1 : 0);
	
	int howManySlots = 0;
	for (int i = 0; i &lt; koliko_puta * period; i++)
		howManySlots += v[i &lt; period ? i : i - period];
	
	IntType **ret{nullptr};
	try {
		ret = new IntType*[koliko_puta * period]{};
		ret[0] = new IntType[howManySlots];
	}
	catch (...) {
		if (ret != nullptr)
			delete[] ret[0];
			
		delete[] ret;
	}
	
	for (int i = 1; i &lt; koliko_puta * period; i++)
		ret[i] = ret[i - 1] + v[i &lt;= period ? i - 1 : i - period - 1];
		
	for (int i = 0; i &lt; koliko_puta * period; i++)
		for (int j = 0; j &lt; v[i &lt; period ? i : i - period]; j++)
			ret[i][j] = v[i &lt; period ? i : i - period] - j;
			
	return ret;
}

template &lt;typename IntType&gt;
int findPeriod(const std::vector&lt;IntType&gt; &amp;v)
{
	auto searchBegin = v.begin(), found = v.begin();
	
	while ((found = std::find(searchBegin + 1, v.end(), v[0])) != v.end())
	{
		auto ptr1 = v.begin(), ptr2 = found;
		while (ptr2 != v.end() &amp;&amp; *ptr1 == *ptr2)
		{
			ptr1++;
			ptr2++;
		}
		
		if (ptr2 == v.end())
			break;
			
		searchBegin = found;
	}
	
	return static_cast&lt;int&gt;(found - v.begin());
}

template &lt;typename IntType&gt;
bool areValidDim(const std::vector&lt;IntType&gt; &amp;dims)
{
	if (dims.size() == 0)
		throw std::domain_error("Prazan vektor!");
	
	for (auto dim : dims)
		if (dim &lt;= 0)
			return false;
			
	return true;
</font>}</pre>
</body>
</html>
