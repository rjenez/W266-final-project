<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student7485.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student5624.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;type_traits&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match13-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using std::cout;
using std::cin;
using std::vector;

template &lt;typename Tip&gt;
bool DaLiJePeriodicno(const vector&lt;Tip&gt; &amp;v, int p)
{
	if (v.size()==1 || v.size()-p==0)
		return false;
		
	for(int i=0; i&lt;v.size() - p; i++)
		if (v[i]!=v[i+p])
			return false;
			
	return true;	
}

template&lt;typename Tip&gt; 
int Periodicnost(const vector&lt;Tip&gt; &amp;v)
{
	for(int i=1; i&lt;v.size(); i++)
		if (DaLiJePeriodicno(v,i))
			return i;
	
	return 0;		
}

template &lt;typename Tip&gt;
int ** AlocirajFragmentirano(const vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta)
{
	if (v.size()&lt;=0)
		throw std::domain_error("Prazan vektor!");
	
	for(int i=0; i&lt;v.size(); i++)
		if (v[i]&lt;=0)
			throw std::domain_error("Neispravan vektor!");
	
	int p;
	bool periodicno=false;
	p=Periodicnost(v);
	if (p!=0)
		periodicno=true;

	//DA LI MOGU UPISIVATI U MATRICU POSTO SAM STAVIO TIP A TAMO **POK
	Tip max(0);
	for(int i=0; i&lt;v.size(); i++)
		if (v[i]&gt;max)
			max=v[i];

	int duzina = v.size(), **pok;
	if (periodicno)
	{
		if (duzina % p==0)
			koliko_puta=duzina/p;
		else if (duzina % p!=0)
		{
			while(1)
			{
				if (duzina % p==0)
					break;
				duzina++;	
			}
			koliko_puta=duzina/p;
		}
		try
		{
			pok=new int *[duzina]{};
			int k(0);
			for(int i=0; i&lt;duzina; i++)
			{
				try
				{
					pok[i]=new int [v[k]];
					if (k==v.size()-1)
						k=v.size()-p;
					else 
						k++;
				}
				catch(std::bad_alloc)
				{
					for(int i=0; i&lt;duzina; i++)
						delete[] pok[i];
					delete[] pok;
					throw;
				}
			}
		}	
		catch(std::bad_alloc)
		{
			throw;
		}
		
		int upisi, k(0);
		Tip var;
		for(int i=0; i&lt;duzina; i++)
		{
			upisi=v[k];
			if (k==v.size() - 1)
				k=v.size()-p;
			else
				k++;
			var=max;	
			for(int j=upisi-1; j&gt;=0; j--)
			{
				pok[i][j]= var;
				var--;
			}	
		}
		
	}
	
	else if (periodicno==false)
	{
		koliko_puta=2;
		duzina*=2;
		try
		{
			pok=new int *[duzina]{};
			int k(0);
			for(int i=0; i&lt;duzina; i++)
			{
				try
				{
					pok[i]=new int [v[k]];
					if (k==v.size()-1)
						k=0;
					else 
						k++;
				}
				catch(std::bad_alloc)
				{
					for(int i=0; i&lt;duzina; i++)
						delete[] pok[i];
					delete[] pok;		
					throw;	
				}
			
			}
		
		}
		catch(std::bad_alloc)
		{
			throw;
		}
	
		int upisi, k(0);
		Tip var;
		for(int i=0; i&lt;duzina; i++)
		{
			upisi=v[k];
			if (k==v.size() - 1)
				k=0;
			else 
				k++;
			var=max;	
			for(int j=upisi-1; j&gt;=0; j--)
			{
				pok[i][j]=var;
				var--;
			}	
		}
	}	
	
	return pok;
}

template&lt;typename Tip&gt;
int **AlocirajKontinualno (const vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta)
{
	
	if (v.size()&lt;=0)
		throw std::domain_error("Prazan vektor!");
	
	for(int i=0; i&lt;v.size(); i++)
		if (v[i]&lt;=0)
			throw std::domain_error("Neispravan vektor!");
			
	int p;
	bool periodicno=false;
	
	p=Periodicnost(v);
	if (p!=0)
		periodicno=true;
	

	int duzina;
	duzina=v.size();
	int k(0);
	Tip suma(0);
	int **pok;
	
	// AKO JE PERIODICNO
	if (periodicno)
	{
		if (duzina % p==0)
			koliko_puta=duzina/p;
		if (duzina % p!=0)
		{
			while(1)
			{
				if (duzina % p==0)
					break;
				duzina++;	
			}
			koliko_puta=duzina/p;
		}
		for(int i=0; i&lt;duzina; i++)
		{
			suma+=v[k];
			if (k==v.size()-1)
				k=v.size()-p;
			else 
				k++;
		}
		try
		{
			pok=new int*[duzina];
			try
			{
				pok[0]=new int[suma];
				k=0;
				for(int i=1; i&lt;duzina; i++)
				{
					pok[i]=pok[i-1] + v[k];
					if (k==v.size()-1)
						k=v.size() - p;
					else 
						k++;
				}
			}
			catch(std::bad_alloc)
			{
				delete[] pok;
				throw;
			}
		}
		catch(std::bad_alloc)
		{
			throw;
		}
		
		int upisi;
		k=0;
		for(int i=0; i&lt;duzina; i++)
		{
			upisi=v[k];
			if (k==v.size() - 1)
				k=v.size() - p;
			else 
				k++;
			for(int j=0; j&lt;upisi; j++)
				pok[i][j]=upisi - j;
		}
	}
	
	
	else if (periodicno==false)
	{
		koliko_puta=2;
		duzina*=2;
		for(int i=0; i&lt;duzina; i++)
		{
			suma+=v[k];
			if (k==v.size()-1)
				k=0;
			else 
				k++;
		}
		try
		{
			pok=new int*[duzina];
			try
			{
				pok[0]=new int[suma];
				k=0;
				for(int i=1; i&lt;duzina; i++)
				{
					pok[i]=pok[i-1] + v[k];
					if (k==v.size()-1)
						k=0;
					else 
						k++;
				}
			}
			catch(std::bad_alloc)
			{
				delete[] pok;
				throw;
			}
		}
		catch(std::bad_alloc)
		{
			throw;
		}
	
		int upisi;
		k=0;
		for(int i=0; i&lt;duzina; i++)
		{
			upisi=v[k];
			if (k==v.size() - 1)
				k=0;
			else 
				k++;
			for(int j=0; j&lt;upisi; j++)
				pok[i][j]=upisi - j;
		}
	}	
	
	return pok;
}


int main ()
{
	vector&lt;int&gt; vektor;
	int vel;
	cout&lt;&lt;"Unesite broj elemenata vektora: ";
	cin&gt;&gt;vel;
	cout&lt;&lt;"Unesite elemente vektora: ";
	for(int i=0; i&lt;vel; i++)
	{
		int br;
		cin&gt;&gt;br;
		vektor.push_back(br);
	}
	int alo;
	cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	cin&gt;&gt;alo;
	int **pok;
	int koliko_puta;
	if (alo==1)
	{
		try
		{
			int duzina;
			duzina=vektor.size();
			pok=AlocirajFragmentirano(vektor, koliko_puta);
	
			int k(0), upisi, p;
			
			p=Periodicnost(vektor);
			if (p!=0)
			{
				if (duzina % koliko_puta!=0)
				{
					while(1)
					{
						if (duzina % koliko_puta!=0)
							duzina++;
						else 
							break;	
					}
				}
				cout&lt;&lt;"Dinamicki alocirana matrica: \n";
				for(int i=0; i&lt;duzina; i++)
				{
					upisi=vektor[k];
					if (k==vektor.size() - 1)
						k=vektor.size() - p;
					else 
						k++;
					for(int j=0; j&lt;upisi; j++)
						cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
					cout&lt;&lt;"\n";	
				}
			}
			else if (p==0)
			{
				duzina*=2;
				cout&lt;&lt;"Dinamicki alocirana matrica: \n";
				for(int i=0; i&lt;duzina; i++)
				{
					upisi=vektor[k];
					if (k==vektor.size() - 1)
						k=0;
					else 
						k++;
					for(int j=0; j&lt;upisi; j++)
						cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
					cout&lt;&lt;"\n";	
				
				}
			}
			
			for(int i=0; i&lt;duzina; i++)
				delete[] pok[i];
			delete[] pok;
		}
		catch(std::bad_alloc)
		{
			cout&lt;&lt;"Neuspjesna alokacija";
		}
		catch(std::domain_error izuzetak)
		{
			cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
		}
	}
	
	else if(alo==0)
	{
		try
		{
			int duzina;
			duzina=vektor.size();
			pok=AlocirajKontinualno(vektor, koliko_puta);
		
			int k(0), upisi, p;
			
			p=Periodicnost(vektor);
			if (p!=0)
			{
				if (duzina % koliko_puta!=0)
				{
					while(1)
					{
						if (duzina % koliko_puta!=0)
							duzina++;
						else
							break;
					}
				}
				cout&lt;&lt;"Dinamicki alocirana matrica: \n";
				for(int i=0; i&lt;duzina; i++)
				{
					upisi=vektor[k];
					if (k==vektor.size() - 1)
						k=vektor.size() - p;
					else 
						k++;
					for(int j=0; j&lt;upisi; j++)
						cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
					cout&lt;&lt;"\n";	
				}
			}
			else if (p==0)
			{
				duzina*=2;
				cout&lt;&lt;"Dinamicki alocirana matrica: \n";
				for(int i=0; i&lt;duzina; i++)
				{
					upisi=vektor[k];
					if (k==vektor.size() - 1)
						k=0;
					else 
						k++;
					for(int j=0; j&lt;upisi; j++)
						cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
					cout&lt;&lt;"\n";	
				}
			}
			
			delete[] pok[0];
			delete[] pok;
		}
		catch(std::bad_alloc)
		{
			cout&lt;&lt;"Neuspjesna alokacija";
		}
		catch(std::domain_error izuzetak)
		{
			cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
</font>		}
	}
	
	return 0;
}</pre>
</body>
</html>
