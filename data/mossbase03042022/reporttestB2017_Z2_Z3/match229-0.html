<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student7546.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student7546.cpp<p></p><pre>
/*B 2017/2018, Zadaća 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;

<a name="0"></a><font color="#FF0000"><a href="match229-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

int JeLiPeriodican(const std::vector&lt;int&gt; &amp;v) {
	int period(0);
	for(int i=1; i&lt;v.size(); i++) {
		bool periodican(true);
		for(int k=0; k&lt;v.size()-i; k++) {
			if(v[k] != v[k+i]) periodican=false;
		}
		if(periodican) {
			period=i;
			break;
		}
	}
	
	return period;
}

int** AlocirajFragmentirano(const std::vector&lt;int&gt; &amp;v, int &amp;koliko_puta) {
	
	if(v.size()==0) throw "Nesto ne znam sada sta ugl neka poruka za main ";
	
	int period(JeLiPeriodican(v));
	if(period) {
		if(v.size()%period == 0 ) koliko_puta=period;
		else koliko_puta=period+1;
		//ovdje fakat ne znam kako da dopunis vektor ako je konstantan, vjerovatno za to sluzi ono koliko_puta
	}
	if(period==0) koliko_puta=2;
	}
	int* najveci_el(std::max_element(&amp;v[0], &amp;v[period+1]));
	
	/*std::cout &lt;&lt; "Najveci " &lt;&lt; *najveci_el &lt;&lt; "\n";*/
	
	int** mat(nullptr);
	try {
		mat=new int* [v.size()]{};
		
			for(int i=0; i&lt;v.size(); i++) mat[i]=new int [v.at(i)];
			
			for(int i=0; i&lt;v.size(); i++) {
				for(int j=v[i]; j&gt;=0; j--) {
					if(j==v[i]) mat[i][j] = *najveci_el+1;
					else mat[i][j]=mat[i][j+1] - 1;
				}
			}
			return mat;
	}
	catch(std::bad_alloc) {
			for(int i=0; i&lt;v.size(); i++) delete [] mat[i];
			delete [] mat;
				throw;
	}
}
}

int main ()
{
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	int br_elemenata;
	std::cin &gt;&gt; br_elemenata;
	
	std::cout &lt;&lt; "Unesite elemente vektora: ";
	std::vector&lt;int&gt; vektor(br_elemenata);
	
	for(int i=0; i&lt;br_elemenata; i++) {
		int element(0);
		std::cin &gt;&gt; element;
		vektor.at(i)=element;
	}
	
	std::cout &lt;&lt; "Odaberite alokaciju: 1 – fragmentirana, 0 – kontinualna:" ;
	int alokacija(0);
	std::cin &gt;&gt; alokacija;
	
	try {
		int** rezultat(AlocirajFragmentirano(vektor, alokacija));
		std::cout &lt;&lt; "Dinamicki alocirana matrica: \n";
		for(int i=0; i&lt;vektor.size(); i++) {
			for (int j=0; j&lt;vektor.at(i); j++) {
				std::cout &lt;&lt; rezultat[i][j] &lt;&lt; "  ";
			}
			std::cout &lt;&lt; std::endl;
		}
		for(int i=0; i&lt;vektor.size(); i++) delete [] rezultat[i];
		delete [] rezultat;
	}
	catch(std::bad_alloc) {
		std::cout &lt;&lt; "nedostatak memorije: ";
</font>	}
	
	
	
	return 0;
}

</pre>
</body>
</html>
