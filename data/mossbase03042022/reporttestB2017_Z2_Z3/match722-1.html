<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3631.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4882.cpp<p></p><pre>
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;limits&gt;
#include &lt;type_traits&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

template &lt;typename Tip&gt;
bool TestPerioda (const std::vector&lt;Tip&gt; vektor, int p) {
    bool period(true);
    const double eps=pow(10, -10);
    if (vektor.size()==1) {
        period=false;
        return period;
    }
    if (p&gt;=vektor.size()) {
        period=false;
        return period;
    }
    for (int i=0; i&lt;(vektor.size()-p); i++) {
        if (fabs(vektor.at(i)-vektor.at(i+p))&gt;eps) {
            period=false;
            return period;
        }
    }
    return period;
}

template &lt;typename Tip&gt;
int OdrediOsnovniPeriod (const std::vector&lt;Tip&gt; vektor) {
    int brojac=0;
    const double eps=pow(10, -10);
    for (int i=1; i&lt;vektor.size(); i++) {
        brojac++;
        if (fabs(vektor.at(0)-vektor.at(i))&lt;=eps) {
            if (TestPerioda(vektor, brojac)==true) {
                return brojac;
            }
        }
    }
    brojac=0;
    return brojac;
}

template &lt;typename Tip&gt;
int** AlocirajFragmentirano (const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta) {
    int n=v.size(), t;
    if (n==0) throw std::domain_error("Prazan vektor!");
    for (int i=0; i&lt;n; i++) {
        if (v.at(i)&lt;=0) throw std::domain_error("Neispravan vektor!");
    }
    if (OdrediOsnovniPeriod(v)!=0) {
        t=OdrediOsnovniPeriod(v);
        if (n%t==0) koliko_puta=(n/t);
        else koliko_puta=int(n/t)+1;
    }
    if (OdrediOsnovniPeriod(v)==0) {
        t=n;
        koliko_puta=2;
    }
    int **pok=nullptr;
    try {
        pok=new typename std::remove_reference&lt;decltype(v.at(0)+v.at(0))&gt;::type* [koliko_puta*t];
        try {
            for (int i=0; i&lt;koliko_puta*t; i++) {
                pok[i]=new Tip [v.at(i%t)];
            }
        }
        catch (...) {
            for (int i=0; i&lt;koliko_puta*t; i++) delete [] pok[i];
            delete [] pok;
            throw;
        }
        int najveci=0;
        for (int i=0; i&lt;n; i++) {
            if (v.at(i)&gt;najveci) najveci=v.at(i);
        }
        for (int i=0; i&lt;koliko_puta*t; i++) {
            int k=najveci-v.at(i%t)+1;
            for (int j=0; j&lt;v.at(i%t); j++) {
                pok[i][j]=k;
                k++;
            }
        }
        return pok;
    }
    catch (...) {
        for (int i=0; i&lt;n; i++) {
            delete [] pok[i];
        }
        delete [] pok;
        throw;
    }
}

template &lt;typename Tip&gt;
int** AlocirajKontinualno (const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta) {
    int n=v.size(), t;
    if (n==0) throw std::domain_error("Prazan vektor!");
    for (int i=0; i&lt;n; i++) {
        if (v.at(i)&lt;=0) throw std::domain_error("Neispravan vektor!");
    }
    if (OdrediOsnovniPeriod(v)!=0) {
        t=OdrediOsnovniPeriod(v);
        if (n%t==0) koliko_puta=(n/t);
        else koliko_puta=int(n/t)+1;
    }
    if (OdrediOsnovniPeriod(v)==0) {
        t=n;
        koliko_puta=2;
    }
    int **pok=nullptr;
    try {
        pok=new typename std::remove_reference&lt;decltype(v.at(0)+v.at(0))&gt;::type* [koliko_puta*t];
        int brojac(0);
        for (int i=0; i&lt;t; i++) {
            brojac+=v.at(i);
        }
        brojac=brojac*koliko_puta;
        try {
            pok[0]=new typename std::remove_reference&lt;decltype(v.at(0)+v.at(0))&gt;::type [brojac];
        }
        catch (...) {
            delete [] pok [0];
            delete [] pok;
            throw;
        }
<a name="1"></a><font color="#00FF00"><a href="match722-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        for (int i=1; i&lt;koliko_puta*t; i++) {
            pok[i]=pok[i-1]+v.at((i-1)%t);
</font>        }
        int najveci=0;
        for (int i=0; i&lt;n; i++) {
            if (v.at(i)&gt;najveci) najveci=v.at(i);
        }
        for (int i=0; i&lt;koliko_puta*t; i++) {
            int k=v.at(i%t);
            for (int j=0; j&lt;v.at(i%t); j++) {
                pok[i][j]=k;
                k--;
            }
        }
        return pok;
    }
    catch (...) {
        delete [] pok[0];
        delete [] pok;
        throw;
    }
}

int main ()
{
    try {
        int n;
        std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
        std::cin &gt;&gt; n;
        std::cout &lt;&lt; "Unesite elemente vektora: ";
        std::vector&lt;int&gt; v (n);
        int k;
        for (int i=0; i&lt;n; i++) {
            std::cin &gt;&gt; k;
            v.at(i)=k;
        }
        int t;
        if (OdrediOsnovniPeriod(v)!=0) {
            t=OdrediOsnovniPeriod(v);
        }
        else {
            t=n;
        }
        std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
        std::cin &gt;&gt; k;
        int **pok=nullptr;
        int koliko_puta;
        if (k==1) { 
            pok=AlocirajFragmentirano(v, koliko_puta);
            std::cout &lt;&lt; "Dinamicki alocirana matrica: " &lt;&lt; std::endl;
<a name="2"></a><font color="#0000FF"><a href="match722-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

            for (int i=0; i&lt;koliko_puta*t; i++) {
                for (int j=0; j&lt;v.at(i%t); j++) {
                    std::cout &lt;&lt; std::left &lt;&lt; std::setw(2) &lt;&lt; pok[i][j] &lt;&lt; " ";
</font><a name="0"></a><font color="#FF0000"><a href="match722-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

                }
                std::cout &lt;&lt; std::endl;
            }
            for (int i=0; i&lt;koliko_puta*t; i++) delete [] pok[i];
            delete [] pok;
</font>        }
        else if (k==0) {
            pok=AlocirajKontinualno(v, koliko_puta);
            std::cout &lt;&lt; "Dinamicki alocirana matrica: " &lt;&lt; std::endl;
            for (int i=0; i&lt;koliko_puta*t; i++) {
                for (int j=0; j&lt;v.at(i%t); j++) {
<a name="3"></a><font color="#00FFFF"><a href="match722-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

                    std::cout &lt;&lt; std::left &lt;&lt; std::setw(2) &lt;&lt; pok[i][j] &lt;&lt; " ";
                }
                std::cout &lt;&lt; std::endl;
            }
            delete [] pok[0];
            delete [] pok;
</font>        }
    }
    catch (std::domain_error izuzetak1) {
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak1.what() &lt;&lt; std::endl;
    }
    catch (std::bad_alloc) {
        std::cout &lt;&lt; "Izuzetak: Alokacija nije uspjela!" &lt;&lt; std::endl;
    }
    catch (...) {
        std::cout &lt;&lt; "Izuzetak: Alokacija nije uspjela!" &lt;&lt; std::endl;
    }
	return 0;
}</pre>
</body>
</html>
