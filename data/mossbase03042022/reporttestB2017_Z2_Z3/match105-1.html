<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student5695.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student2547.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;

<a name="0"></a><font color="#FF0000"><a href="match105-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;

template &lt;typename tip_int&gt;
bool TestPerioda(vector&lt;tip_int&gt; vektor, int p) {
	if(vektor.size()==0 || vektor.size()&lt;=p || p==0) return false;
	for(int i=0;i&lt;vektor.size();i++) {
		if(i+p&gt;=vektor.size()) break;
 		if(vektor[i]!=vektor[i+p]) return false; 
 	}
 	return true;
}

template &lt;typename tip_int&gt;
int OdrediOsnovniPeriod(vector&lt;tip_int&gt; vektor) {
	for(int i=2;i&lt;vektor.size();i++) {
		if(TestPerioda(vektor,i)) return i;
	}
	return 0;
}

template &lt;typename tip_int&gt;
tip_int** AlocirajFragmentirano(const vector&lt;tip_int&gt; &amp;v, int &amp;koliko_puta) {
	if(v.size()==0) throw length_error("Prazan vektor!");
	for(int i=0;i&lt;v.size();i++) {
		if(v.at(i)&lt;=0) throw domain_error("Neispravan vektor!");
	}
	int osnovni(OdrediOsnovniPeriod(v));
	int duzina=v.size();
	tip_int **f;
	try {
	    if(osnovni==0) {
	        duzina=v.size()*2;
	        osnovni=v.size();
	        koliko_puta=2;
	    }
	    else {
	    	koliko_puta=v.size()/osnovni;
		    if(koliko_puta*osnovni!=v.size()) {
		    	duzina=(koliko_puta+1)*osnovni;
		    	koliko_puta+=1;
		    }
		    else if(v.size()%osnovni!=0) {
		    	koliko_puta=v.size()/osnovni;
		    	duzina=v.size();
		    }
	    }
	    // alociranje matrice
	    f=new tip_int*[duzina];
	    int el(0);
	    for(int i=0;i&lt;duzina;i++) {
	    	if(el==osnovni) el=0;
	    	f[i]=new tip_int[v.at(el)];
	    	el++;
	    }
	    tip_int max(v.at(0));
	    for(int i=1;i&lt;osnovni;i++) {
	    	if(v.at(i)&gt;max) max=v.at(i);
	    }
	    // popunjavanje alocirane matrice
	    el=0;
	    for(int i=0;i&lt;duzina;i++) {
	    	auto pom_max=max;
	    	for(int j=v.at(el)-1;j&gt;=0;j--) {
	    		f[i][j]=pom_max;
	    		pom_max--;
	    	}
	    	el++;
	    	if(el==osnovni) el=0;
	    }
	    return f;
    }
    catch(bad_alloc) {
    	for(int i=0;i&lt;osnovni*koliko_puta;i++) delete [] f[i];
		delete [] f;
		f=nullptr;
		throw;
    }
    catch(...) {
    	throw;
    } 
}

template &lt;typename tip_int&gt;
int** AlocirajKontinualno(vector&lt;tip_int&gt; &amp;v, int &amp;koliko_puta) {
	if(v.size()==0) throw length_error("Prazan vektor!");
	for(int i=0;i&lt;v.size();i++) {
		if(v.at(i)&lt;=0) throw domain_error("Neispravan vektor!");
	}
	int osnovni(OdrediOsnovniPeriod(v));
	int duzina=v.size();
	tip_int **f=nullptr;
	try {
	    if(osnovni==0) {
	        duzina=v.size()*2;
	        osnovni=v.size();
	        koliko_puta=2;
	    }
	    else {
	    	koliko_puta=v.size()/osnovni;
		    if(koliko_puta*osnovni!=v.size()) {
		    	duzina=(koliko_puta+1)*osnovni;
		    	koliko_puta+=1;
		    }
		    else if(v.size()%osnovni!=0) {
		    	koliko_puta=v.size()/osnovni;
		    	duzina=v.size();
		    }
	    }
	    int suma(0);
	    for(int i=0;i&lt;osnovni;i++) suma+=v.at(i);
	    // alociranje matrice
	    int **f=new int*[duzina];
	    f[0]=new int[koliko_puta*suma];
	    int el(0);
	    for(int i=1;i&lt;duzina;i++) {
	    	f[i]=f[i-1]+v.at(el);
	    	el++;
	    	if(el==osnovni) el=0;
	    }
	    // popunjavanje matrice
	    el=0;
	    for(int i=0;i&lt;duzina;i++) {
	    	int min(1);
	    	for(int j=v.at(el)-1;j&gt;=0;j--) {
	    		f[i][j]=min;
	    		min++;
	    	}
	    	el++;
	    	if(el==osnovni) el=0;
	    }
	    return f;
	}
	catch(bad_alloc) {
		delete [] f[0];
		delete f;
		f=nullptr;
		throw;
	}
	catch(...) {
		throw;
	}
}

int main() {
	int broj_el;
	cout &lt;&lt; "Unesite broj elemenata vektora: ";
	cin &gt;&gt; broj_el;
	cout &lt;&lt; "Unesite elemente vektora: ";
	vector&lt;int&gt; vektor;
	for(int i=0;i&lt;broj_el;i++) {
		int pom;
		cin &gt;&gt; pom;
		vektor.push_back(pom);
	}
	cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int al;
	cin &gt;&gt; al;
	int koliko_puta(0);
	int **pok;
	try {
		if(al==1) pok=AlocirajFragmentirano(vektor,koliko_puta);
		else if(al==0) pok=AlocirajKontinualno(vektor,koliko_puta);
	}
	catch (bad_alloc) {
		cout &lt;&lt; "Losa alokacija!";
		return 0;
	}
	catch (domain_error izuzetak) {
		cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak.what();
		return 0;
	}
	catch (length_error izuzetak) {
		cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak.what();
		return 0;
	}
	int osnovni(OdrediOsnovniPeriod(vektor));
	if(osnovni==0) osnovni=vektor.size();
	cout &lt;&lt; "Dinamicki alocirana matrica: " &lt;&lt; endl;
	int el(0);
	for(int i=0;i&lt;osnovni*koliko_puta;i++) {
		for(int j=0;j&lt;vektor.at(el);j++) cout &lt;&lt; setw(3) &lt;&lt; left &lt;&lt; pok[i][j];
		el++;
		if(el==osnovni) el=0;
		cout&lt;&lt;endl;
	}
	if(al==1) {
		for(int i=0;i&lt;osnovni*koliko_puta;i++) delete [] pok[i];
			delete [] pok;
		}
	else if(al==0) {
		delete [] pok[0];
		delete  [] pok;
	}
	return 0;
</font>}</pre>
</body>
</html>
