<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8566.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1571.cpp<p></p><pre>

#include &lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;new&gt;
#include&lt;stdexcept&gt;
#include &lt;iomanip&gt;


<a name="0"></a><font color="#FF0000"><a href="match3-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template&lt;typename Tip&gt;

bool DaLiJePeriodican(std::vector&lt;Tip&gt;v,int p){
  
  for(int i(0);i&lt;v.size();i++){
    
  
  
  if(p&gt;=v.size() || p&lt;1) return false;
  if(i+p&gt;=v.size()) break;
  if(v.at(i)!=v.at(i+p)) return false ;
  }
   return true;
  }
  
  template&lt;typename Tip2&gt;
  Tip2 OsnovniPeriod (std::vector&lt;Tip2&gt; v){
      int p(0);
      for(int i(0);i&lt;v.size();i++){
          if(DaLiJePeriodican(v,i)){
          p=i;
          
          return p;
      }
  }
return p;
}
template &lt;typename Tip3&gt;
 Tip3 **AlocirajFragmentirano(const std::vector&lt;Tip3&gt;&amp;v,int &amp;koliko_puta){
  if(v.size()==0) throw std::domain_error("Prazan vektor!");
  for(int i(0);i&lt;v.size();i++){
   if(v[i]&lt;=0) throw std::domain_error("Neispravan vektor!");
  }
  Tip3 ** a=nullptr;
  
  typename std::vector&lt;Tip3&gt;::const_iterator pocetak;
  typename std::vector&lt;Tip3&gt;::const_iterator iza_kraja;
  typename std::vector&lt;Tip3&gt;::const_iterator pomocni;
  //typename std::vector&lt;Tip3&gt;::const_iterator pomocni2;
  
  if(OsnovniPeriod(v)!=0){
   int period(OsnovniPeriod(v));
   pocetak=std::begin(v);
   pomocni = pocetak;
   iza_kraja=std::begin(v)+period;
  
   int glavni(v[0]);
   int brojac(1);
   for(int i(1); i&lt;v.size(); i++){
  
      if(glavni==v[i])
      brojac++;
  
   }
koliko_puta=brojac;

 try{
  a=new Tip3*[period*koliko_puta];
  int duzina=period*koliko_puta;   
  int red(0);
  for(int i(0);i&lt;koliko_puta;i++){
   
   while(pocetak!=iza_kraja){
    
    int broj(*pocetak);
    a[red] = new int[broj];
    red++;pocetak++;
   }
   
   pocetak=pomocni;
  }
  
  pocetak=pomocni;
    
int oduzmi(0);
for(int i(0);i&lt;duzina;i++){
   oduzmi = 0;
   while(pocetak!=iza_kraja){
    
    for(int j(*pocetak - 1); j&gt;=0; j--){  
     a[i][j] = period - oduzmi++; 
    }
    
   if(pocetak == iza_kraja - 1) pocetak = pomocni;
   else pocetak++;
   break;  
   }
}

}catch(...){
 throw;
}
}else{
 
   pocetak=std::begin(v);
   pomocni = pocetak;
   iza_kraja=std::end(v);
  
   koliko_puta=2;

 try{ 
  a=new Tip3*[(iza_kraja - pocetak) * koliko_puta];
  int duzina=(iza_kraja - pomocni)*koliko_puta;
  int red(0);
  
  for(int i(0);i&lt;koliko_puta;i++){
   
   while(pocetak!=iza_kraja){
    
    int broj(*pocetak);
    a[red] = new int[broj];
    red++;pocetak++;
   }
   
   pocetak=pomocni;
  }
  
  pocetak=pomocni;
    
int oduzmi(0);    
for(int i(0);i&lt;duzina;i++){
   oduzmi = 0;
   while(pocetak!=iza_kraja){
    
    for(int j(*pocetak - 1); j&gt;=0; j--){  
     a[i][j] = (iza_kraja-pomocni) - oduzmi++; 
    }
    
   if(pocetak == iza_kraja - 1) pocetak = pomocni;
   else pocetak++;
   break;  
   }
}

}catch(...){
 throw;
}
}

 return a;
  }
  template &lt;typename Tip3&gt;
 Tip3 **AlocirajKontinualno(const std::vector&lt;Tip3&gt;&amp;v,int &amp;koliko_puta){
  if(v.size()==0) throw std::domain_error("Prazan vektor!");
  for(int i(0);i&lt;v.size();i++){
   if(v[i]&lt;=0) throw std::domain_error("Neispravan vektor!");
  }
  Tip3 ** a=nullptr;
  
  typename std::vector&lt;Tip3&gt;::const_iterator pocetak;
  typename std::vector&lt;Tip3&gt;::const_iterator iza_kraja;
  typename std::vector&lt;Tip3&gt;::const_iterator pomocni;
  //typename std::vector&lt;Tip3&gt;::const_iterator pomocni2;
  
  if(OsnovniPeriod(v)!=0){
   int period(OsnovniPeriod(v));
   pocetak=std::begin(v);
   pomocni = pocetak;
   iza_kraja=std::begin(v)+period;
  
   int glavni(v[0]);
   int brojac(1);
   for(int i(1); i&lt;v.size(); i++){
  
      if(glavni==v[i])
      brojac++;
  
   }
koliko_puta=brojac;

 try{
  a=new Tip3*[period*koliko_puta];    
  int duzina=period*koliko_puta;   
  int red(1);
 // 1 2 3 1 2 3 = 12 = koliko_puta na kvadrat * period(3)
 a[0] = new Tip3 [koliko_puta * koliko_puta * period];
 
 for(int i(0);i&lt;koliko_puta;i++){
  
  while(pocetak!=iza_kraja){
   a[red]=a[red-1]+ *pocetak;
   red++;
   if(red == duzina) break;
   if(pocetak==iza_kraja-1) break;
   pocetak++;
   
   
  }
  pocetak=pomocni;
  
 }
 pocetak=pomocni;
 
 int broj(1);
 for(int i(0);i&lt;koliko_puta*period;i++){
  
  while(pocetak!=iza_kraja){
   broj = 1;
   for(int j(*pocetak - 1);j&gt;=0;j--){
    a[i][j]=broj++;
    Tip3 debuger = a[i][j];
    int bezze(0);
   }
 
   if(pocetak!=iza_kraja-1) pocetak++;
   else {
    pocetak=pomocni;
   }
   break; //ovo da nam ide na sljedeci i
   }
  }
    
}catch(...){
 throw;
}
}else{ //ovo sada moramo
 
   pocetak=std::begin(v);
   pomocni = pocetak;
   iza_kraja=std::end(v);
  
   koliko_puta=2;

 try{
  a=new Tip3*[(iza_kraja - pomocni)*koliko_puta];    
  int duzina=(iza_kraja - pomocni)*koliko_puta;   
  int red(1);
 // 1 2 3 1 2 3 = 12 = koliko_puta na kvadrat * period(3)
 a[0] = new Tip3 [koliko_puta * koliko_puta * (iza_kraja - pomocni)];
 
 for(int i(0);i&lt;koliko_puta;i++){
  
  while(pocetak!=iza_kraja){
   a[red]=a[red-1]+ *pocetak;
   red++;
   if(red == duzina) break;
   if(pocetak==iza_kraja-1) break;
    pocetak++;

   
  }
  pocetak=pomocni;
  
 }
 pocetak=pomocni;
 
 int broj(1);
 for(int i(0);i&lt;koliko_puta*(iza_kraja - pomocni); i++){
  
  while(pocetak!=iza_kraja){
   broj = 1;
   for(int j=*pocetak - 1;j&gt;=0;j--){
    a[i][j]=broj++;
   }
 
   if(pocetak!=iza_kraja-1) pocetak++;
   else {
    pocetak=pomocni;
   }
   break; //ovo da nam ide na sljedeci i
   }
  }
    
}catch(...){
 throw;
}
}

return a;
 
  }
int main ()
{
 int broj;
 int n;
std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
std::cin&gt;&gt;n;

 std::vector&lt;int&gt; v;
std::cout&lt;&lt;"Unesite elemente vektora: ";
 for(int i(0);i&lt;n;i++){
  std::cin&gt;&gt;broj;
  v.push_back(broj); }
  int koliko_puta(0);
 
  std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
int alokacija;
std::cin&gt;&gt;alokacija;
if(alokacija==1){
 int **c(nullptr);
 try{
c=AlocirajFragmentirano(v,koliko_puta);

int period = OsnovniPeriod(v);
if(period != 0){
int duzina = period * koliko_puta;

  typename std::vector&lt;int&gt;::const_iterator pocetak(std::begin(v));
  typename std::vector&lt;int&gt;::const_iterator iza_kraja(std::begin(v) + period);
  typename std::vector&lt;int&gt;::const_iterator pomocni(pocetak);

std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
for(int i(0);i&lt;duzina;i++){
 
   while(pocetak!=iza_kraja){
    
    for(int j(0); j&lt;(*pocetak); j++){  
     std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;c[i][j]; 
    }
    
   if(pocetak == iza_kraja - 1) pocetak = pomocni;
   else pocetak++;
   break;  
   }
   std::cout&lt;&lt;std::endl;
}

for(int i(0); i&lt;duzina; i++) delete[] c[i];
delete[] c;

}else if(period == 0){

  typename std::vector&lt;int&gt;::const_iterator pocetak(std::begin(v));
  typename std::vector&lt;int&gt;::const_iterator iza_kraja(std::end(v));
  typename std::vector&lt;int&gt;::const_iterator pomocni(pocetak);

   int duzina = (iza_kraja - pocetak) * koliko_puta;
std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
for(int i(0);i&lt;duzina;i++){
 
   while(pocetak!=iza_kraja){
    
    for(int j(0); j&lt;(*pocetak); j++){  
     std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;c[i][j]; 
    }
    
   if(pocetak == iza_kraja - 1) pocetak = pomocni;
   else pocetak++;
   break;  
   }
   std::cout&lt;&lt;std::endl;
}

for(int i(0); i&lt;duzina; i++) delete[] c[i];
delete[] c;
}
}catch(std::bad_alloc){
 std::cout&lt;&lt;"Nije uspjelo";
}catch(std::domain_error e){
 std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
}
  
 }else if(alokacija == 0){ //--------------------------------------------------
  
    int **c(nullptr);
 try{
c=AlocirajKontinualno(v,koliko_puta);

int period = OsnovniPeriod(v);
if(period != 0){
int duzina = period * koliko_puta;

  typename std::vector&lt;int&gt;::const_iterator pocetak(std::begin(v));
  typename std::vector&lt;int&gt;::const_iterator iza_kraja(std::begin(v) + period);
  typename std::vector&lt;int&gt;::const_iterator pomocni(pocetak);

std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
for(int i(0);i&lt;duzina;i++){
 
   while(pocetak!=iza_kraja){
    
    for(int j(0); j&lt;(*pocetak); j++){  
     std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;c[i][j]; 
    }
    
   if(pocetak == iza_kraja - 1) pocetak = pomocni;
   else pocetak++;
   break;  
   }
   std::cout&lt;&lt;std::endl;
}

delete[] c[0];
delete[] c;

}else if(period == 0){

  typename std::vector&lt;int&gt;::const_iterator pocetak(std::begin(v));
  typename std::vector&lt;int&gt;::const_iterator iza_kraja(std::end(v));
  typename std::vector&lt;int&gt;::const_iterator pomocni(pocetak);

   int duzina = (iza_kraja - pocetak) * koliko_puta;
std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
for(int i(0);i&lt;duzina;i++){
 
   while(pocetak!=iza_kraja){
    
    for(int j(0); j&lt;(*pocetak); j++){  
     std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;c[i][j]; 
    }
    
   if(pocetak == iza_kraja - 1) pocetak = pomocni;
   else pocetak++;
   break;  
   }
   std::cout&lt;&lt;std::endl;
}

delete[] c[0];
delete[] c;
}
}catch(std::bad_alloc){
 std::cout&lt;&lt;"Nije uspjelo";
}catch(std::domain_error e){
 std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
}
  
  
 }

	return 0;
</font>}</pre>
</body>
</html>
