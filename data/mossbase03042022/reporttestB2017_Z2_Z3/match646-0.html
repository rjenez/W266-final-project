<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8257.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8257.cpp<p></p><pre>
/*B 2017/2018, Zadaća 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;

using std::vector;


template&lt;typename tip&gt;
	bool TestPerioda(const vector&lt;tip&gt; &amp;nizBrojeva,int p) {
<a name="2"></a><font color="#0000FF"><a href="match646-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

		if(p&lt;1 || p&gt;=nizBrojeva.size()) 
			return false;
		for(int i=0;i&lt;nizBrojeva.size()-p;i++) {
			if(nizBrojeva.at(i) != nizBrojeva.at(i+p)) 
				return false;
</font>		}
		return true;
	}
template&lt;typename tip&gt;
	int OdrediOsnovniPeriod(const vector&lt;tip&gt; &amp;nizBrojeva) {
		for(int i=1;i&lt;nizBrojeva.size();i++) {
			if(TestPerioda(nizBrojeva,i)==true) 
				return i;
		}
		return nizBrojeva.size(); // SAMO ZA OVAJ ZADATAK , INAČE JE 0 PERIOD
	}

template&lt;typename tip&gt;
	int **AlocirajFragmentirano(const vector&lt;tip&gt; &amp;v , int &amp;koliko_puta) {
		if (v.size() == 0)
			throw ("Prazan vektor!");
		for(tip x : v ) 
			if(x&lt;=0) throw std::domain_error("Neispravan vektor!");
		int osnovniPeriod = OdrediOsnovniPeriod(v);
		int novaDuzina;
		if(osnovniPeriod == v.size()) {
			koliko_puta = 2;
			novaDuzina = v.size()*2;
		}
		else {
			novaDuzina = v.size();
			while(novaDuzina % osnovniPeriod != 0)
				novaDuzina++;
			koliko_puta = novaDuzina / osnovniPeriod ;
		}
		
		// ALOKACIJA I POPUNJAVANJE GRBAVE MATRICE
		int **grbava = new int*[novaDuzina]{};
			
		int brojac = 0;
		int max = *std::max_element(v.begin(),v.end());
		try {
			for(int i=0;i&lt;koliko_puta;i++) {
				for(int j=0;j&lt;osnovniPeriod;j++) {
					grbava[brojac] = new tip[v.at(j)]; // ALOKACIJA REDOVA
					for(int k=0;k&lt;v.at(j);k++)
						grbava[brojac][v.at(j)-1-k] = max - k;	// POPUNJAVANJE REDA
					brojac++;
				}
			}
		}
<a name="3"></a><font color="#00FFFF"><a href="match646-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

		catch (std::bad_alloc) {
			for(int i=0;i&lt;novaDuzina;i++)
				delete[] grbava[i];
			delete[] grbava;
			throw;
		}
		return grbava;
</font>	}
template&lt;typename tip&gt;
	int **AlocirajKontinualno(const vector&lt;tip&gt; &amp;v , int &amp;koliko_puta) {
		if (v.size() == 0)
			throw ("Prazan vektor!");
		for(tip x : v ) 
			if(x&lt;=0) throw std::domain_error("Neispravan vektor!");
		int osnovniPeriod = OdrediOsnovniPeriod(v);
		int novaDuzina;
		if(osnovniPeriod == v.size()) {
			koliko_puta = 2;
			novaDuzina = v.size()*2;
		}
		else {
			novaDuzina = v.size();
			while(novaDuzina % osnovniPeriod != 0)
				novaDuzina++;
			koliko_puta = novaDuzina / osnovniPeriod ;
		}
		
		// ALOKACIJA I POPUNJAVANJE GRBAVE MATRICE
		int **grbava = new int*[novaDuzina]{};
		int brElem = 0;
		for(int i=0;i&lt;osnovniPeriod;i++)
			brElem+=v.at(i);
		brElem*=koliko_puta;
		
		int brojac = 1;
		try {
			grbava[0] = new tip[brElem];
				
			for(int i=0;i&lt;koliko_puta;i++) {
				for(int j=0;j&lt;osnovniPeriod;j++) {
					if(brojac==novaDuzina)
						break;
					grbava[brojac] = grbava[brojac-1]+v.at(j); // ALOKACIJA REDOVA
					brojac++;
				}
			}
			brojac = 0;
			for(int i=0;i&lt;koliko_puta;i++) {
				for(int j=0;j&lt;osnovniPeriod;j++) {   // POPUNJAVANJE REDOVA
					for(int k=0;k&lt;v.at(j);k++)
						grbava[brojac][v.at(j)-1-k] = k+1;
					brojac++;
				}
			}
		}
		catch (std::bad_alloc) {
			delete[] grbava;
			throw;
		}
		return grbava;
	}

int main ()
{
	try {
		std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
		int n;
		std::cin&gt;&gt;n;
		std::cout&lt;&lt;"Unesite elemente vektora: ";
		vector&lt;int&gt; v(n);
		for(int i=0;i&lt;n;i++) 
			std::cin&gt;&gt;v.at(i);
		int izbor;
		std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		std::cin&gt;&gt;izbor;
		int **matrica = nullptr;
		int koliko_puta;
		if(izbor==1) 
			matrica = AlocirajFragmentirano(v,koliko_puta);
		else
			matrica = AlocirajKontinualno(v,koliko_puta);
		int brojac = 0;
		std::cout&lt;&lt;"Dinamicki alocirana matrica: \n";
		for(int i=0;i&lt;koliko_puta;i++) {          // ISPIS
<a name="0"></a><font color="#FF0000"><a href="match646-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

			for(int j=0;j&lt;OdrediOsnovniPeriod(v);j++) {
				for(int k=0;k&lt;v.at(j);k++)
					std::cout&lt;&lt;std::setw(3)&lt;&lt;std::left&lt;&lt;matrica[brojac][k];
				brojac++;
</font>				std::cout&lt;&lt;"\n";
			}
		} 
		if(izbor==1) {
			for(int i=0;i&lt;brojac;i++)
				delete[] matrica[i];
			delete[] matrica;
		}
		else {
			delete[] matrica[0];
<a name="1"></a><font color="#00FF00"><a href="match646-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

			delete[] matrica;
		}
	} 
	catch (const char poruka[]) {
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka;
	}
	catch(std::domain_error d) {
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;d.what();
</font>	}
	
	return 0;
}</pre>
</body>
</html>
