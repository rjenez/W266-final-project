<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4471.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4471.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match179-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template &lt;typename IntTip&gt;
int OsnovniPeriod(const std::vector&lt;IntTip&gt; &amp;v) {
	if (v.size() &lt;= 1) return 0;
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[0] == v[i]) {
			int j(0);
			for (j = 0; i+j &lt; v.size(); j++) 
				if (v[j] != v[i+j]) break;
			if (i+j == v.size()) return i;
		}
	}
	return 0;
}

template &lt;typename IntTip&gt;
bool DaLiJeIspravan(const std::vector&lt;IntTip&gt; &amp;v) {
	for (auto x : v) if (x &lt; 1) return 0;
	return 1;
}

template &lt;typename IntTip&gt;
IntTip DuzinaNajduzeg(const std::vector&lt;IntTip&gt; &amp;v) {
	IntTip duzina(0);
	for (int i = 0; i &lt; v.size(); i++)
		if (v[i] &gt; duzina) duzina = v[i];
	return duzina;
}

template &lt;typename IntTip&gt;
IntTip Suma(const std::vector&lt;IntTip&gt; &amp;v, int period, int koliko_puta) {
	IntTip suma(0);
	for (int i = 0; i &lt; period * koliko_puta; i++)
		suma += v[i%period];
	return suma;
} 

template &lt;typename IntTip&gt;
IntTip **AlocirajFragmentirano(const std::vector&lt;IntTip&gt; &amp;v, int &amp;koliko_puta) {
	if (v.size() == 0) throw "Prazan vektor!";
	if (!DaLiJeIspravan(v)) throw std::domain_error("Neispravan vektor!");
	int period(OsnovniPeriod(v));
	if (period != 0) {
		koliko_puta = v.size()/period;
		if (v.size() % period != 0) koliko_puta++;
	}
	else  {
		period = v.size();
		koliko_puta = 2;
	}
	IntTip **mat(new IntTip *[period*koliko_puta]);
	for (int i = 0; i &lt; period * koliko_puta; i++) mat[i] = nullptr;
	try {
		for (int i = 0; i &lt;	koliko_puta; i++) 
			for (int j = 0; j &lt; period; j++) 
				mat[i*period+j] = new IntTip [v[j]];
	}
	catch(...) {
		for (int i = 0; i &lt; period * koliko_puta; i++)
			delete [] mat[i];
		delete [] mat;
		throw;
	}
	auto max(DuzinaNajduzeg(v));
	for (int i = 0; i &lt; period * koliko_puta; i++) 
		for (IntTip j = 0; j &lt; v[i%period]; j++) 
			mat[i][j] = max - v[i%period] + j + 1;
	return mat;
}

template &lt;typename IntTip&gt;
IntTip **AlociraKontinualno(const std::vector&lt;IntTip&gt; &amp;v, int &amp;koliko_puta) {
	if (v.size() == 0) throw "Prazan vektor!";
	if (!DaLiJeIspravan(v)) throw std::domain_error("Neispravan vektor!");
	int period(OsnovniPeriod(v));
	if (period != 0) {
		koliko_puta = v.size()/period;
		if (v.size() % period != 0) koliko_puta++;
	}
	else  {
		period = v.size();
		koliko_puta = 2;
	}
	int br_el(Suma(v,period, koliko_puta));
	IntTip **mat(new IntTip *[br_el]);
	for (int i = 0; i &lt; period * koliko_puta; i++) mat[i] = nullptr;
	try {
		mat[0] = new IntTip [br_el];
		for (int i = 1; i &lt;	period * koliko_puta; i++) 
			mat[i] = mat[i-1] + v[i%period];
	}
	catch(...) {
		delete [] mat;
		throw;
	}
	int brojac(0);
	for (int i = 0; i &lt; period * koliko_puta; i++) {
		auto x (v[i%period]);
		while (x &gt; 0) mat[0][brojac++] = x--;
	}
	return mat;
}


int main ()
{
	/*try {
		int n;
		std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
		std::cin &gt;&gt; n;
		std::cout &lt;&lt; "Unesite elemente vektora: ";
		std::vector&lt;int&gt; v(n);
		for (int &amp;x : v) std::cin &gt;&gt; x;
		std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		int alokacija, **mat, koliko_puta, period(OsnovniPeriod(v));
		if (period == 0) period = v.size();
		if (std::cin &gt;&gt; alokacija, alokacija == 1) {
			mat = AlocirajFragmentirano(v, koliko_puta);
			std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::endl;
			for (int i = 0; i &lt; period * koliko_puta; i++) {
				for (int j = 0; j &lt; v[i%period]; j++)
					std::cout &lt;&lt; std::left &lt;&lt; std::setw(3) &lt;&lt; mat[i][j];
				std::cout &lt;&lt; std::endl;
			}
			for (int i = 0; i &lt; period * koliko_puta; i++)
				delete [] mat[i];
			delete [] mat;
		}
		else if (alokacija == 0) {
			mat = AlociraKontinualno(v, koliko_puta);
			std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::endl;
			for (int i = 0; i &lt; Suma(v, period, koliko_puta); i++) {
				std::cout &lt;&lt; std::left &lt;&lt; std::setw(3) &lt;&lt; mat[0][i];
				if (mat[0][i] == 1) std::cout &lt;&lt; std::endl;
			}
			delete [] mat[0];
			delete [] mat;
		}
		else return 0;
	}
	catch (const char izuzetak[]) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak;
	}
	catch (std::domain_error izuzetak) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak.what();
	}
	catch (std::bad_alloc) {
		std::cout &lt;&lt; "Izuzetak: Alokacija nije uspjela";
	}*/
	const std::vector&lt;int&gt; vektor{1, -2, 3, 4, 1, -2};
        int brojPuta{};
        int **matrica{nullptr};
        try
        {
            matrica = AlocirajKontinualno(vektor, brojPuta); 
            std::cout &lt;&lt; "Ovo se ne smije ispisati!" &lt;&lt; std::endl;       
        }
        catch(std::domain_error e)
        {
            if (matrica == nullptr)
                std::cout &lt;&lt; "OK." &lt;&lt; std::endl;
            std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what();
</font>        }
	return 0;
}</pre>
</body>
</html>
