<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student2232.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student2196.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match116-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template &lt;typename Tip&gt;
bool TestPreioda(std::vector&lt;Tip&gt; brojevi, int period){
	for(int i=0; i&lt;int(brojevi.size())-period; i++)
		if(brojevi.at(i)!=brojevi.at(i+period)) return false;
	return true;
}

template &lt;typename Tip&gt;
int Period(std::vector&lt;Tip&gt; brojevi){
	for(int i=1; i&lt;int(brojevi.size()); i++)
		if(TestPreioda(brojevi, i)) return i;
	return int(brojevi.size());
}

template &lt;typename Tip&gt;
Tip **AlocirajFragmentirano(const std::vector&lt;Tip&gt; &amp;brojevi, int &amp;koliko_puta) {
	if(brojevi.size()==0) throw ("Prazan vektor!");
	for(int i=0; i&lt;int(brojevi.size()); i++) if(brojevi.at(i)&lt;1) throw std::domain_error("Neispravan vektor!");
	int period(Period(brojevi));
	koliko_puta=int(brojevi.size())/period+1;
	if(int(brojevi.size())%period==0 &amp;&amp; koliko_puta!=2) koliko_puta--;
	Tip max=brojevi.at(0);
	for(int i=0; i&lt;int(brojevi.size()); i++) if(brojevi.at(i)&gt;max) max=brojevi.at(i);
	try{
		Tip **matrica(new Tip* [koliko_puta*period]{});
		try{
			for(int i=0; i&lt;koliko_puta*period; i++){
				int temp(i);
				while(temp&gt;=period) temp-=period;
				matrica[i]=new Tip[*(brojevi.begin()+temp)];
				for(int j=0; j&lt;*(brojevi.begin()+temp); j++){
					matrica[i][*(brojevi.begin()+temp)-1-j]=max-j;
				}
			}
			return matrica;
		}
		catch(std::bad_alloc){
			for(int i=0; i&lt;koliko_puta*period; i++) delete[] matrica[i];
			delete[] matrica;
			throw;
		}
	}
	catch(std::bad_alloc){
		throw;
	}
}

template &lt;typename Tip&gt;
Tip** AlocirajKontinualno(const std::vector&lt;Tip&gt; &amp;brojevi, int &amp;koliko_puta){
	if(brojevi.size()==0) throw ("Prazan vektor!");
	for(int i=0; i&lt;int(brojevi.size()); i++) if(brojevi.at(i)&lt;1) throw std::domain_error("Neispravan vektor!");
	int period(Period(brojevi)), suma(0);
	koliko_puta=int(brojevi.size())/period+1;
	if(int(brojevi.size())%period==0 &amp;&amp; koliko_puta!=2) koliko_puta--;
	Tip** matrica(nullptr);
	for(int i=0; i&lt;period; i++) suma+=brojevi.at(i);
	try{
		matrica = new Tip*[koliko_puta*period]{};
		*matrica = new Tip[suma*koliko_puta];
		for(int i=0; i&lt;brojevi.at(0); i++) matrica[0][i]=brojevi.at(0)-i;
			for(int i=1; i&lt;koliko_puta*period; i++){
			int temp(i-1);
			while(temp&gt;=period) temp-=period;
			matrica[i]=matrica[i-1]+*(brojevi.begin()+temp);
			temp++;
			while(temp&gt;=period) temp-=period;
			for(int j=0; j&lt;*(brojevi.begin()+temp); j++){
				matrica[i][j]=*(brojevi.begin()+temp)-j;
			}
		}
		return matrica;
	}
	catch(std::bad_alloc){
		delete[] matrica;
		throw;
	}
}

int main ()
{
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	int broj_elemenata;
	std::cin &gt;&gt; broj_elemenata;
	std::cout &lt;&lt; "Unesite elemente vektora: ";
	try{
		std::vector&lt;int&gt; vektor(broj_elemenata);
		for(int i=0; i&lt;broj_elemenata; i++)
			std::cin &gt;&gt; vektor.at(i);	
		std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		int alokacija, koliko_puta;
		std::cin &gt;&gt; alokacija;
		if(alokacija==1){
			int** matrica(AlocirajFragmentirano(vektor, koliko_puta));
			int period(Period(vektor));
			std::cout &lt;&lt; "Dinamicki alocirana matrica:\n";
			for(int i=0; i&lt;period*koliko_puta; i++){
				int temp(i);
				while(temp&gt;=period) temp-=period;
				for(int j=0; j&lt;*(vektor.begin()+temp); j++){
					std::cout &lt;&lt; std::left &lt;&lt; std::setw(3) &lt;&lt; matrica[i][j];
				}
				std::cout &lt;&lt; std::endl;
			}
			for(int i=0; i&lt;koliko_puta*period; i++) delete[] matrica[i];
			delete[] matrica;
		}
		else if(alokacija==0){
			int** matrica(AlocirajKontinualno(vektor, koliko_puta));
			int period(Period(vektor));
			std::cout &lt;&lt; "Dinamicki alocirana matrica:\n";
			for(int i=0; i&lt;period*koliko_puta; i++){
				int temp(i);
				while(temp&gt;=period) temp-=period;
				for(int j=0; j&lt;*(vektor.begin()+temp); j++){
					std::cout &lt;&lt; std::left &lt;&lt; std::setw(3) &lt;&lt; matrica[i][j];
				}
				std::cout &lt;&lt; std::endl;
			}
			delete[] *matrica;
			delete[] matrica;
		}
	}
	catch(const char s[]){
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; s &lt;&lt; std::endl;
	}
	catch(std::domain_error e){
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what() &lt;&lt; std::endl;
	}
	catch(...){	}
</font>	return 0;
}</pre>
</body>
</html>
