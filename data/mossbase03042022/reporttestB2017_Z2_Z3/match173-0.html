<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4261.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4261.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match173-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template &lt;typename Tip&gt;
bool Period (const std::vector&lt;Tip&gt; &amp;v, int p) {
	for (int i=0; i&lt;v.size()-p; i++) {
		if (v.at(i)!=v.at(i+p)) return false;
	}
	return true;
}

template &lt;typename Tip&gt;
int OsnovniPeriod (const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta) {
	int i;
	for (i=1; i&lt;v.size(); i++) {
		if (Period(v, i)) break;
	}
	
	if (i==v.size()) koliko_puta=2;
	else if (v.size()%i) koliko_puta=v.size()/i+1;
	else koliko_puta=v.size()/i;
	
	return i;
}

template &lt;typename Tip&gt;
void ProvjeriVrijednosti (const std::vector&lt;Tip&gt; &amp;v) {
	if (!v.size()) throw ("Prazan vektor!");
	for (int i=0; i&lt;v.size(); i++) if (v.at(i)&lt;=0) throw std::domain_error("Neispravan vektor!");
	return;
}

template &lt;typename Tip&gt;
int **AlocirajFragmentirano (const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta) {
	
	ProvjeriVrijednosti(v);
	
	int period(OsnovniPeriod(v, koliko_puta));
	
	
	Tip **matrica(nullptr);
	
	try {
		matrica=new Tip*[koliko_puta*period]{};
		
		try {
			for (int i=0; i&lt;koliko_puta*period; i++) matrica[i]=new Tip[v.at(i%period)];
		}
		catch(...) {
			if (matrica!=nullptr) {
				for (int i=0; i&lt;koliko_puta*period; i++) delete[] matrica[i];
				delete[] matrica;
			}
			throw;
		}
		
		Tip max(0);
		for (int i=0; i&lt;v.size(); i++) if (v.at(i)&gt;max) max=v.at(i);
		
		for (int i=0; i&lt;koliko_puta*period; i++) {
			for (int j=0; j&lt;v.at(i%period); j++) {
				matrica[i][j]=std::abs(v.at(i%period)-max)+1+j;
			}
		}
	}
	catch(...) {
		throw;
	}
	return matrica;
	
}

template &lt;typename Tip&gt;
int **AlocirajKontinualno (const std::vector&lt;Tip&gt; v, int &amp;koliko_puta) {
	
	ProvjeriVrijednosti(v);
	
	int period(OsnovniPeriod(v, koliko_puta));
	
	int velicina(0);
	for (int i=0; i&lt;koliko_puta*period; i++) velicina+=v.at(i%period);
	
	Tip **matrica(nullptr);

	try {
		matrica=new Tip*[koliko_puta*period]{};
		try {
			matrica[0]=new Tip[velicina];
			for (int i=1; i&lt;koliko_puta*period; i++) matrica[i]=matrica[i-1]+v.at((i-1)%period);
		}
		catch(...) {
			if (matrica!=nullptr) {
				delete[] matrica[0];
				delete[] matrica;
			}
			throw;
		}
		for (int i=0; i&lt;koliko_puta*period; i++) {
			for (int j=0; j&lt;v.at(i%period); j++) {
				matrica[i][j]=v.at(i%period)-j;
			}
		}
	}
	catch(...) {
		throw;
	}
	return matrica;
}


int main ()
{
	std::vector&lt;int&gt; v;
	int n;
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	std::cin &gt;&gt; n;
	v.resize(n);
	std::cout &lt;&lt; "Unesite elemente vektora: ";
	for (auto &amp;x: v) std::cin &gt;&gt; x;
	
	int alokacija;
	std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	std::cin &gt;&gt; alokacija;
	
	int **matrica, koliko_puta, period(OsnovniPeriod(v, koliko_puta));
	
	try {
		if (alokacija) matrica=AlocirajFragmentirano(v, koliko_puta);
		else matrica=AlocirajKontinualno(v, koliko_puta);
		
		std::cout &lt;&lt; "Dinamicki alocirana matrica: " &lt;&lt; std::endl;
		
		for (int i=0; i&lt;koliko_puta*period; i++) {
			for (int j=0; j&lt;v.at(i%period); j++) {
				std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left &lt;&lt; matrica[i][j];
			}
			std::cout &lt;&lt; std::endl;
		}
		
		if (alokacija) for (int i=0; i&lt;koliko_puta*period; i++) delete[] matrica[i];
		else delete[] matrica[0];
		delete[] matrica;
		
	}
	catch(std::bad_alloc) { std::cout &lt;&lt; "Nedovoljno memorije"; }
	catch(const char* izuzetak) { std::cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak; }
	catch(std::exception &amp;izuzetak) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak.what();
	}
	return 0;
</font>}</pre>
</body>
</html>
