<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3315.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student6795.cpp<p></p><pre>
<a name="0"></a><font color="#FF0000"><a href="match24-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

/B 2017/2018, ZadaÄ‡a 2, Zadatak 3
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

//Funkcija koja Testira period
template &lt;typename Tip&gt;
bool Test_Perioda(const std::vector&lt;Tip&gt; &amp;v, int T)
{
    for(int i(0); i&lt;v.size(); ++i) {
        if(i + T == v.size()) break;
        if(v.at(i) != v.at(i+T)) return false;
    }

    return true;
}

//Funkcija koja ispituje da li je vektor periodican
template &lt;typename Tip&gt;
bool Periodican_slijed (const std::vector&lt;Tip&gt; &amp;v, int &amp;period)
{

    for(int i(1); i&lt;v.size(); ++i) {
        if(Test_Perioda(v,i) == true) {
            period = i;
            return true;
        }
    }

    return false;
}

//Funkcija koja dodaje clanove vektoru sve dok velicina istog nije djeljiva sa periodom
template &lt;typename Tip&gt;
int Produzi_Vektor(const std::vector&lt;Tip&gt; &amp;v, int &amp;period)
{
    Tip prvi(v.at(0));
    int pozicija_i(0);

    for(int i(1); i &lt; v.size(); ++i) {
        if(prvi == v.at(i)) break;
        pozicija_i = i;
    }

    std::vector&lt;Tip&gt; novi;

    bool prekini(false);
    for(;;) {
        for(int i(0); i &lt;= pozicija_i; ++i) {
            if(novi.size() &gt;= v.size()) {
                if(novi.size() % period == 0) {
                    prekini = true;
                    break;
                }
            }
            novi.push_back(v.at(i));
        }
        if(prekini) break;
    }

    int koliko_puta(0);
    koliko_puta = novi.size() / period;

    return koliko_puta;
}

template &lt;typename Tip&gt;
std::vector&lt;Tip&gt; VektorIspis(std::vector&lt;Tip&gt; &amp;v, int period)
{
    Tip prvi(v.at(0));
    int pozicija_i(0);

    for(int i(1); i &lt; v.size(); ++i) {
        if(prvi == v.at(i)) break;
        pozicija_i = i;
    }

    std::vector&lt;Tip&gt; novi;

    bool prekini(false);
    for(;;) {
        for(int i(0); i &lt;= pozicija_i; ++i) {
            if(novi.size() &gt;= v.size()) {
                if(novi.size() % period == 0) {
                    prekini = true;
                    break;
                }
            }
            novi.push_back(v.at(i));
        }
        if(prekini) break;
    }

    return novi;
}

template &lt;typename Tip&gt;
int koliko_puta_funkcija(const std::vector&lt;Tip&gt; &amp;v)
{
    int brojac(1);

    Tip prvi(v.at(0));
    for(int i(1); i&lt;v.size(); ++i) {
        if(prvi == v.at(i)) ++brojac;
    }

    return brojac;
}

template&lt;typename Tip&gt;
std::vector&lt;Tip&gt; Dopuni_Vektor(const std::vector&lt;Tip&gt; &amp;v)
{

    std::vector&lt;Tip&gt; novi;
    for(int ponovi(1); ponovi&lt;=2; ++ponovi) {
        for(int i(0); i&lt;v.size(); ++i) {
            novi.push_back(v.at(i));
        }
    }

    return novi;
}

template &lt;typename Tip&gt;
Tip **AlocirajFragmentirano(const std::vector&lt;Tip&gt; &amp;Radni_Vektor, int &amp;koliko_puta)
{
    typename std::vector&lt;Tip&gt;::const_iterator pocetak;
    typename std::vector&lt;Tip&gt;::const_iterator iza_kraja_perioda;
    if(Radni_Vektor.size() == 0) throw std::logic_error("Prazan vektor!");
    int period(0);

    if(Periodican_slijed(Radni_Vektor,period)) {
        koliko_puta = Produzi_Vektor(Radni_Vektor, period);
        pocetak = std::begin(Radni_Vektor);
        iza_kraja_perioda = std::begin(Radni_Vektor) + period;
    } else {
        koliko_puta = 2;
        pocetak = std::begin(Radni_Vektor);
        iza_kraja_perioda = std::end(Radni_Vektor);
    }

    for(int i(0); i&lt;Radni_Vektor.size(); ++i) {
        if(Radni_Vektor.at(i) &lt;= 0) throw std::domain_error("Neispravan vektor!");
    }

    //Najveci broj kolona
    int najveci(0);
    for(int i(0); i&lt;Radni_Vektor.size(); ++i) if(Radni_Vektor.at(i) &gt; najveci) najveci = Radni_Vektor.at(i);
    int max(najveci);

    typename std::vector&lt;Tip&gt;::const_iterator temp;
    temp = pocetak;
    int elemenati(0);
    while(pocetak != iza_kraja_perioda) {
        ++elemenati;
        ++pocetak;
    }
    pocetak = temp;
    //Kreiranje matrice
    Tip **pok(nullptr);
    try {
        int red_alokacije(0);
        pok = new Tip* [elemenati * koliko_puta];
        for(int i(0); i&lt;koliko_puta; ++i) {
            while(pocetak != iza_kraja_perioda) {
                int n = int (*pocetak);
                pok[red_alokacije] = new Tip [n];
                ++pocetak;
                ++red_alokacije;
            }
            pocetak = temp;
        }
        pocetak = temp;
        //UPIS
        int j(0);
        for(int i(0); i&lt;elemenati * koliko_puta; ++i) {
            while(pocetak != iza_kraja_perioda) {
                int n = int(*pocetak);
                for(j = n-1; j&gt;=0; --j) {
                    pok[i][j] = najveci--;
                }
                if(j == -1) break;
            }
            if(pocetak == iza_kraja_perioda -1) pocetak = temp;
            else ++pocetak;
            najveci = max;
        }


    } catch(...) {
        throw;
    }

    return pok;
}

template &lt;typename Tip&gt;
Tip **AlocirajKontinualno(const std::vector&lt;Tip&gt; &amp;Radni_Vektor, int &amp;koliko_puta)
{
    typename std::vector&lt;Tip&gt;::const_iterator pocetak;
    typename std::vector&lt;Tip&gt;::const_iterator iza_kraja_perioda;
    if(Radni_Vektor.size() == 0) throw std::logic_error("Prazan vektor!");
    int period(0);

    if(Periodican_slijed(Radni_Vektor,period)) {
        koliko_puta = Produzi_Vektor(Radni_Vektor, period);
        pocetak = std::begin(Radni_Vektor);
        iza_kraja_perioda = std::begin(Radni_Vektor) + period;
    } else {
        pocetak = std::begin(Radni_Vektor);
        iza_kraja_perioda = std::end(Radni_Vektor);
        koliko_puta = 2;
    }

    for(int i(0); i&lt;Radni_Vektor.size(); ++i) {
        if(Radni_Vektor.at(i) &lt;= 0) throw std::domain_error("Neispravan vektor!");
    }

    typename std::vector&lt;Tip&gt;::const_iterator temp;
    temp = pocetak;
    int elementi(0);
    while(pocetak != iza_kraja_perioda) {
        ++elementi;
        ++pocetak;
    }
    pocetak = temp;
    //Kreiranje matrice
    Tip **pok(nullptr);
    int j(0);
    try {
        int red_alokacije(1);
        pok = new Tip* [elementi * koliko_puta];
        pok[0] = new Tip[koliko_puta * koliko_puta * elementi];
        for(int i(0); i&lt;koliko_puta; ++i) {
            while(pocetak != iza_kraja_perioda) {
                if(red_alokacije == elementi * koliko_puta) break;
                int n = int(*pocetak);
                pok[red_alokacije] = pok[red_alokacije - 1] + n;
                ++pocetak;
                ++red_alokacije;
            }
            pocetak = temp;
        }
        pocetak = temp;

        //UPIS
        for(int i(0); i&lt;koliko_puta * elementi; ++i) {
            while(pocetak != iza_kraja_perioda) {
                int n = int(*pocetak);
                int unos = int(*pocetak);
                for(j = 0; j&lt;n; ++j) {
                    pok[i][j] = unos--;
                }
                if(j == n) break;
            }
            if(pocetak == iza_kraja_perioda - 1) pocetak = temp;
            else ++pocetak;
        }


    } catch(...) {
        throw;
    }


    return pok;
}

int main ()
{
    std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
    int br_elemenata;
    std::cin&gt;&gt;br_elemenata;
    std::vector&lt;int&gt; vektor(br_elemenata);
    std::cout&lt;&lt;"Unesite elemente vektora: ";
    std::for_each(std::begin(vektor), std::begin(vektor) + br_elemenata, [](int &amp;broj) {
        std::cin&gt;&gt;broj;
    });
    std::cout &lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
    int alokacija;
    std::cin&gt;&gt;alokacija;
    int koliko_puta(0);
    if(alokacija == 1) {
        int **pok(nullptr);
        std::vector&lt;int&gt; MojVektor;
        try {
            pok=AlocirajFragmentirano(vektor, koliko_puta);
            int period(0);
            Periodican_slijed(vektor, period);
            if(period != 0) MojVektor = VektorIspis(vektor, period);
            else MojVektor = Dopuni_Vektor(vektor);
            std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
            for(int i(0); i&lt;MojVektor.size(); ++i) {
                for(int j(0); j&lt;MojVektor.at(i); ++j) {
                    std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
                }
                std::cout&lt;&lt;std::endl;
            }

            //BRISANJE
            for(int i(0); i&lt;MojVektor.size(); ++i) delete[] pok[i];
            delete[] pok;

        } catch(std::logic_error poruka) {
            std::cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka.what();
        } catch(std::domain_error poruka) {
            std::cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka.what();
        } catch(std::bad_alloc) {
            delete[] pok;
            std::cout&lt;&lt;"Nedovoljno memorije";
        } catch(...) {
            std::cout&lt;&lt;"Neocekivani Izuzetak";
        }
    } else if(alokacija == 0) {
        int **pok(nullptr);
        std::vector&lt;int&gt; MojVektor;
        try {
            pok=AlocirajKontinualno(vektor, koliko_puta);
            int period(0);
            Periodican_slijed(vektor, period);
            if(period != 0) MojVektor = VektorIspis(vektor, period);
            else MojVektor = Dopuni_Vektor(vektor);

            std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
            for(int i(0); i&lt;MojVektor.size(); ++i) {
                for(int j(0); j&lt;MojVektor.at(i); ++j) {
                    std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
                }
                std::cout&lt;&lt;std::endl;
            }

            //BRISANJE
            delete[] pok[0];
            delete[] pok;

        } catch(std::logic_error poruka) {
            std::cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka.what();
        } catch(std::domain_error poruka) {
            std::cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka.what();
        } catch(std::bad_alloc) {
            delete[] pok;
            std::cout&lt;&lt;"Nedovoljno memorije";
        } catch(...) {
            std::cout&lt;&lt;"Neocekivani Izuzetak";
        }
    }

    return 0;
</font>}</pre>
</body>
</html>
