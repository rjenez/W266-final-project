<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3568.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3568.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt; 
#include &lt;vector&gt;
#include &lt;stdexcept&gt; 
#include &lt;iomanip&gt;

bool TestPerioda (const std::vector&lt;int&gt; &amp;v, int p)
{
	for(int i=0; i&lt;v.size()-p; i++) {
		if(v[i] != v[i+p])
			return false;
	}
	return true;
}

int OdrediOsnovniPeriod (const std::vector&lt;int&gt; &amp;v)
{
	for(int i=1; i&lt;v.size(); i++) {
		if(TestPerioda(v,i)) return i;
	}

	return v.size();
}

<a name="0"></a><font color="#FF0000"><a href="match429-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

int** AlocirajFragmentirano (const std::vector&lt;int&gt; &amp;v, int &amp;koliko_puta)
{
	if(v.size() == 0) throw std::domain_error ("Prazan vektor!");
	for(int i=0; i&lt;v.size(); i++) {
		if(v[i] &lt;= 0) throw std::domain_error ("Neispravan vektor!");
</font>	}

	int period(OdrediOsnovniPeriod(v));
	if(period != v.size() &amp;&amp; v.size()%period == 0)
		koliko_puta = v.size() / period ;
	else if(period !=v.size())
		koliko_puta = int(v.size()/period) + 1;
	else
		koliko_puta=2;

	int** matrica(nullptr);
	try {
		int duzina(koliko_puta*period);
		matrica = new int*[duzina] {};
		for(int i=0; i&lt;duzina; i++) {
			int m;
			if(i&gt;=v.size()) m=i-period;
			else m=i;
			matrica[i] = new int[v[m]];
		}
		int m;
		for(int i=0; i&lt;duzina; i++) {
			int k(v[period-1]);
			if(i&gt;=v.size()) m=i-period;
			else m=i;
<a name="3"></a><font color="#00FFFF"><a href="match429-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

			for(int j=v[m]-1; j&gt;=0; j--) {
				matrica[i][j] = k;
				k--;
			}
		}
	} catch(std::bad_alloc) {
</font>		if(matrica != nullptr) {
			for( int i=0; i&lt;koliko_puta*period; i++)
				delete[] matrica[i];
		}
		delete[] matrica;
		throw;
	}

	return matrica;
}

<a name="1"></a><font color="#00FF00"><a href="match429-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

int** AlocirajKontinualno(const std::vector&lt;int&gt; &amp;v, int &amp;koliko_puta)
{ 
	if(v.size() == 0) throw std::domain_error ("Prazan vektor!");
	for(int i=0; i&lt;v.size(); i++) {
		if(v[i] &lt;= 0) throw std::domain_error ("Neispravan vektor!");
</font>	}

	int period(OdrediOsnovniPeriod(v));
	if(period != v.size() &amp;&amp; v.size()%period == 0)
		koliko_puta = v.size() / period ;
	else if(period !=v.size())
		koliko_puta = int(v.size()/period) + 1;
	else
		koliko_puta=2;

	int** matrica(nullptr); 
	try {
		int duzina(koliko_puta*period);
		matrica=new int*[duzina] {};

		int suma(0);
		for(int i=0; i&lt;period; i++) suma+=v[i];
		matrica[0] = new int[koliko_puta*suma];
		int m;
		for(int i=1; i&lt;duzina; i++) {
			if(i&gt;v.size()) m=i-period;
			else m=i;
<a name="4"></a><font color="#FF00FF"><a href="match429-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

			matrica[i] = matrica[i-1] + v[m-1];
		}
		
		for(int i=0; i&lt;duzina; i++) {
</font>			int k(1);
			if(i&gt;=v.size()) m=i-period;
			else m=i;
			for(int j=v[m]-1; j&gt;=0; j--) {
				matrica[i][j] = k;
				k++;
			}
		}

	} catch (std::bad_alloc) {
		if(matrica != nullptr) delete[] matrica[0];
		delete[] matrica;
		throw;
	}


	return matrica;

}


int main ()
{
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	int br_el;
	std::cin &gt;&gt; br_el;
	std::vector&lt;int&gt; v(br_el);
	std::cout &lt;&lt; "Unesite elemente vektora: ";
	for(auto &amp;e : v) std::cin &gt;&gt; e;

	std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int f;
	std::cin &gt;&gt; f;
	int koliko_puta;
	int**matrica(nullptr);

	int period;

	try {
		if(f==1) matrica=AlocirajFragmentirano(v,koliko_puta);
		else matrica=AlocirajKontinualno(v, koliko_puta);

		period=OdrediOsnovniPeriod(v);

		std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::endl;
		int k;
		for( int i=0; i&lt;koliko_puta*period; i++) {
			if(i&gt;=v.size()) k=i-period;
			else k=i;
			for(int j=0; j&lt;v[k]; j++) {
				std::cout &lt;&lt; std::left &lt;&lt; std::setw(3) &lt;&lt; matrica[i][j];
			}
			std::cout &lt;&lt; std::endl;
		}

		if(f==1) {
			for( int i=0; i&lt;koliko_puta*period; i++)
				delete[] matrica[i];
			delete[] matrica;
		} else {
<a name="2"></a><font color="#0000FF"><a href="match429-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

			if(matrica != nullptr) delete[] matrica[0];
			delete[] matrica;
		}
	} catch(std::domain_error izuzetak) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt;izuzetak.what() &lt;&lt; std::endl;
</font>	} catch(std::bad_alloc izuzetak) {
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt;izuzetak.what() &lt;&lt; std::endl;
		if(f==1) {
			if(matrica!=nullptr) {
				for( int i=0; i&lt;koliko_puta*period; i++)
					delete[] matrica[i];
			} 
			delete[] matrica;
		} else {
			if(matrica != nullptr) delete[] matrica[0];
			delete[] matrica;
		}
	}

	return 0;
}</pre>
</body>
</html>
