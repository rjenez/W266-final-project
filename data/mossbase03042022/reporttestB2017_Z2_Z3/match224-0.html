<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8794.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8794.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;type_traits&gt;
<a name="0"></a><font color="#FF0000"><a href="match224-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template&lt;typename NekiTip&gt;
bool TestPerioda (std::vector&lt;NekiTip&gt; brojevi, int p){
	if (p==0 || p==brojevi.size() || brojevi.size()==1) return false;
	
	for (int i=0; i&lt;=p; i++){
		if ((i+p)==brojevi.size()) break;
		if (brojevi[i]!=brojevi[i+p]) return false;
		
	}
	return true;
}
/*vraca osnovni period*/
template&lt;typename NekiTip&gt;
int OdrediOsnovniPeriod (std::vector&lt;NekiTip&gt; brojevi){
	for (int i=0; i&lt;brojevi.size(); i++){
		if (TestPerioda(brojevi, i)){
			
		}
		return i;
	}
	return 0;
}

template &lt;typename NekiTip&gt;

auto AlocirajFragmentirano (const std::vector&lt;NekiTip&gt; &amp;vek, int &amp;koliko_puta)-&gt;typename std::remove_reference&lt;decltype(vek)&gt;::type**{
try{
		if (vek.size()==0) throw std::range_error ("Prazan vektor!");	
			
			for (int i=0; i&lt;vek.size(); i++){
				if (vek.at(i)&lt;=0){ 
					//fali delete
					throw std::domain_error ("Neispravan vektor!");
			}
			
		}
}

catch(std::domain_error){
	//obrisati alocirano...
	throw;
}
catch(...){
	throw;
}
		//return ;
}

template &lt;typename NekiTip&gt;
auto AlocirajKontinualno (const std::vector&lt;NekiTip&gt; &amp;vek, int &amp;koliko_puta)-&gt;typename std::remove_reference&lt;decltype(vek)&gt;::type**{
try{
	if (vek.size()==0) throw std::range_error ("Prazan vektor!");
	for (int i=0; i&lt;vek.size(); i++){
		if (vek.at(i)&lt;=0){
			throw std::domain_error ("Neispravan vektor!");
		}
	}
}

catch (std::domain_error){
	//obrisati alocirano
	throw;
}
catch (...){
	throw;
}

}


int main ()
{
	int brel;
	std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
	std::cin&gt;&gt;brel;
	std::cin.ignore(1000, '\n');
	std::cin.clear();
	std::cout&lt;&lt;"Unesite elemente vektora: ";
	std::vector&lt;int&gt; vektor;
	int element;
	for (int i=0; i&lt;brel; i++){
		std::cin&gt;&gt;element;
		
		vektor.push_back(element);
	}
	std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int opcija;
	do{
	std::cin&gt;&gt;opcija;
	if (opcija!=1 &amp;&amp; opcija!=0) std::cout&lt;&lt;"Neispravna opcija, unesite novu";
	}while (opcija!=1 &amp;&amp; opcija!=0);
	
	int kolikoputa;
	if (opcija==1){
	try{
		auto m1=AlocirajFragmentirano(vektor, kolikoputa);
		std::cout&lt;&lt;"Dinamicki alocirana matrica: ";
		
	/*	for (int i=0; i&lt;brel; i++){
			for (int j=0; j&lt;brel; j++)
				std::cout&lt;&lt;m1[i][j];
				std::cout&lt;&lt;std::endl;
		}
		*/
	}
	catch(std::range_error izuzetak){
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
	}
	catch (std::domain_error izuzetak){
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
	}
}

if (opcija==0){
	try{
		auto m2=AlocirajKontinualno(vektor, kolikoputa);
		std::cout&lt;&lt;"Dinamicki alocirana matrica: ";
		
	}
	catch (std::range_error izuzetak){
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
	}
	catch (std::domain_error izuzetak){
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
</font>	}
}

	return 0;
}</pre>
</body>
</html>
