<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8576.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4305.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;iomanip&gt;

using namespace std;

template&lt;typename NekiTip&gt;
bool TestPerioda(const vector&lt;NekiTip&gt; &amp;elementi, int period) {
<a name="0"></a><font color="#FF0000"><a href="match765-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

	if (period &gt;= elementi.size() || period &lt;= 0)
		return false;
	for (int i = 0; i &lt; elementi.size()-period; i++) 
		if (elementi.at(i) != elementi.at(i + period))
			return false;
	
	return true;
}

template&lt;typename NekiTip&gt;
int Period(const vector&lt;NekiTip&gt; &amp;elementi) {
	//vraca 0 ako niz nije periodican	
	//u suprotnom vraca period
	for (int i = 1; i &lt; elementi.size(); i++)
		if (TestPerioda(elementi, i)) return i;
		
	return 0;
}

template&lt;typename NekiTip&gt;
</font>void ProvjeriVektor(const vector&lt;NekiTip&gt; &amp;elementi) {
	//ako je prazan vektor
	if (elementi.size() == 0)
		throw ("Prazan vektor!");
	//ako u vektoru ima besmislenih vrijednosti	
	for (int i = 0; i &lt; elementi.size(); i++)
		if (elementi.at(i) &lt;= 0)
			throw domain_error("Neispravan vektor!");
}

template&lt;typename NekiTip&gt;
NekiTip** AlocirajFragmentirano(const vector&lt;NekiTip&gt; &amp;elementi, int &amp;koliko_puta) {
	//ne dodavati elemente u vektor nego pri alokaciji nastaviti dok se osnovni period ne ponovi do kraja
	NekiTip** matrica = nullptr;
	try {
		
		ProvjeriVektor(elementi);
		
		int period = Period(elementi);
		
		if (period == 0) {
			koliko_puta = 2;
			period = elementi.size();
		} 
		else {
			int brojac = 0;
			for (int i = period-1; i &lt; elementi.size(); i += period)
				brojac++;
			
			if (elementi.at(elementi.size()-1) != elementi.at(period-1))
				brojac++;
			
			koliko_puta = brojac;	
		}
		
		int br_redova = period * koliko_puta;
		//alokacija redova
		matrica = new NekiTip* [br_redova]{};
		for (int i = 0; i &lt; br_redova; i++)
			matrica[i] = nullptr;
			
		try {
			//alokacija kolona
			int periodicni_dio = period * (koliko_puta - 1);
			for (int i = 0; i &lt; br_redova; i++) {
				NekiTip element;
				if (i &lt; periodicni_dio)
					element = elementi.at(i);
				else
					element = elementi.at(i - period);
					
				matrica[i] = new NekiTip[element];
			}
			
			//najveci element u periodu
			NekiTip max_element = elementi.at(0);
			for (int i = 0; i &lt; period; i++)
				if (elementi.at(i) &gt; max_element)
					max_element = elementi.at(i);
			//popunjavanje matrice		
			for (int i = 0; i &lt; br_redova; i++) {
				NekiTip temp = max_element;
				for (int j = elementi.at(i%period) - 1; j &gt;= 0; j--) {
					matrica[i][j] = temp;
					temp--;
				}
			}
			
			return matrica;
			
		} catch (...) {
			for (int i = 0; i &lt; koliko_puta * period; i++)
				delete[] matrica[i];
			delete[] matrica;
			
			throw;
		}
		
	} catch (...) {
		delete[] matrica;
		
		throw;
	}
}

/*------------------------------------------------------------------------------------------------------------------*/

template&lt;typename NekiTip&gt;
NekiTip** AlocirajKontinualno(const vector&lt;NekiTip&gt; &amp;elementi, int &amp;koliko_puta) {
	NekiTip** matrica = nullptr;
	try {
		
		ProvjeriVektor(elementi);
		
		int period = Period(elementi);
		if (period == 0) {
			koliko_puta = 2;
			period = elementi.size();
		}
		else {
			int brojac = 0;
			for (int i = period-1; i &lt; elementi.size(); i += period)
				brojac++;
			
			if (elementi.at(elementi.size()-1) != elementi.at(period-1))
				brojac++;
			
			koliko_puta = brojac;
		}
		
		
		int br_redova = koliko_puta * period;
		matrica = new NekiTip* [br_redova]{};
		for (int i = 0; i &lt; br_redova; i++)
			matrica[i] = nullptr;
			
		try {
			//treba nam suma svih elemenata
			int periodicni_dio = period * (koliko_puta - 1);
			int suma_elemenata = 0;
			for (int i = 0; i &lt; koliko_puta * period; i++) {
				if (i &lt; periodicni_dio)
					suma_elemenata += elementi.at(i);
				else
					suma_elemenata += elementi.at(i - period);
			}
			//alociranje kontinualne matrice
			matrica[0] = new NekiTip[suma_elemenata];
			//rasporedjivanje pokazivaca
			for (int i = 1; i &lt; br_redova; i++) {
				NekiTip element;
				if (i - 1 &lt; periodicni_dio)
					element = elementi.at(i - 1);
				else
					element = elementi.at(i - period - 1);
					
				matrica[i] = matrica[i - 1] + element;
			}
			//Popunjavanje matrice
			for (int i = 0; i &lt; br_redova; i++) {
				NekiTip element;
				if (i &lt; periodicni_dio)
					element = elementi.at(i);
				else
					element = elementi.at(i - period);

				for (int j = 0; j &lt; element; j++) {
					matrica[i][j] = element - j;
				}
			}

			return matrica;
			
		} catch (...) {
			delete[] matrica[0];
			delete[] matrica;
			throw;
		}
	} catch (...) {
		delete[] matrica;
		throw;
	}
	
}


int main () {
	// 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5
	try {
		
		//ISPIS ZA FRAGMENTIRANU
		int broj_elemenata;
		cout &lt;&lt; "Unesite broj elemenata vektora: ";
		cin &gt;&gt; broj_elemenata;
		
		cout &lt;&lt; "Unesite elemente vektora: ";
		vector&lt;int&gt; elementi(broj_elemenata);
<a name="1"></a><font color="#00FF00"><a href="match765-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

		for (int i = 0; i &lt; broj_elemenata; i++)
			cin &gt;&gt; elementi.at(i);
		
		int f;	
		cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		cin &gt;&gt; f;
		
		int koliko_puta;
</font>		int** matrica;

		if (f == 1) 
			matrica = AlocirajFragmentirano(elementi, koliko_puta);
		else if (f == 0)
			matrica = AlocirajKontinualno(elementi, koliko_puta);
		
		int period = Period(elementi);
		//ako nije periodican niz vratit ce 0
		if (period == 0)
			period = elementi.size();
			
		int konacna_velicina = period * koliko_puta;
		int periodicni_dio = period * (koliko_puta - 1);
		
		//cout &lt;&lt; periodicni_dio &lt;&lt; endl &lt;&lt; endl;
		
		cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; endl;
		for (int i = 0; i &lt; konacna_velicina; i++) {
			int granica;
			if (i &lt; periodicni_dio)
				granica = elementi.at(i);
			else 
				granica = elementi.at(i - period);
				
<a name="2"></a><font color="#0000FF"><a href="match765-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

			for (int j = 0; j &lt; granica; j++)
				cout &lt;&lt; setw(2) &lt;&lt; left &lt;&lt; matrica[i][j] &lt;&lt; " ";
</font>				
			cout &lt;&lt; endl;
		}
		
		// 1 2 3 1 2 3 1 | 2 3 - ovi koji su dodani se moraju takodjer dealocirat
		if (f == 1)
			for (int i = 0; i &lt; konacna_velicina; i++)
				delete[] matrica[i];
		else if (f == 0)
			delete[] matrica[0];
			
		delete[] matrica;
		
	} catch (bad_alloc izuzezak) {
		cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzezak.what() &lt;&lt; endl;
	} catch (domain_error izuzetak) {
		cout &lt;&lt; "Izuzetak: " &lt;&lt; izuzetak.what() &lt;&lt; endl;
	} catch (const char poruka[]) {
		cout &lt;&lt; "Izuzetak: " &lt;&lt; poruka &lt;&lt; endl;
	} 
	
	return 0;
}</pre>
</body>
</html>
