<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3867.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3867.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;type_traits&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match109-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

namespace ab
{
	template &lt; typename T &gt; 
	int Period ( const std::vector &lt; T &gt; &amp;v )
	{
	/*** vraca minimalni period elemenata vektora***/
		int p, i;
		for ( p = 1; p &lt; v.size (); p++ )
		{
			for ( i = 0; i &lt; v.size () - p; i++ )
				if ( v.at ( i ) != v.at ( i + p ) )
					break;
		
			if ( i == v.size () - p )
				break;
		}
		
		return p;
	}
	
	template &lt; typename T &gt; 
	void expand ( const std::vector &lt; T &gt; &amp;v, int &amp;koliko_puta, int &amp;period )
	{
	/*** dodjeljuje vrijednost koliko_puta u skladu sa prosirenjem perioda ili ne; periodu dodjeljuje osnovni period vektora ***/
		period = Period ( v );
		koliko_puta = v.size () / period;
		
		koliko_puta = ( v.size () % koliko_puta != 0 or koliko_puta == 1 ) ? ( koliko_puta == 1 ) ? 2 : koliko_puta + 1 : koliko_puta;
	}
	
	template &lt; typename T &gt; 
	void testException ( const std::vector &lt; T &gt; &amp;v )
	{
	/*** testira izuzetke za vektor ( definisani u zadatku ) ***/
		if ( v.empty () )
			throw ( "Prazan vektor!" );
		
		for ( T x : v )
			if ( x &lt; 1 )
				throw std::domain_error ( "Neispravan vektor!" );
	}
	
	template &lt; typename T &gt; 
	int numOfElements ( const std::vector &lt; T &gt; &amp;v, int koliko_puta, int period )
	{
	/*** vraca broj elemenata koji je potreban za kontinualnu alokaciju matrice ***/
		int n { 0 };
		for ( int i = 0; i &lt; period * koliko_puta; i++ )
			n += v.at ( i % period );
			
		return n;
	}

}

template &lt; typename T &gt;
auto AlocirajFragmentirano ( const std::vector &lt; T &gt; &amp;v, int &amp;koliko_puta ) -&gt;
	typename std::remove_const &lt; typename std::remove_reference &lt; decltype ( v [ 0 ] ) &gt;::type &gt;::type **
{
// sve sto nije alokacija
	ab::testException ( v );
	int period;
	ab::expand ( v, koliko_puta, period );
//
	typedef	typename std::remove_const &lt; typename std::remove_reference &lt; decltype ( v [ 0 ] ) &gt;::type &gt;::type RRCT;
	
	RRCT **p { nullptr };
	try
	{
		p = new RRCT *[ period * koliko_puta ];
		for ( int i = 0; i &lt; v.size (); i++ )
			p [ i ] = nullptr;
		
		for ( int i = 0; i &lt; period * koliko_puta; i++ )
			p [ i ] = new RRCT [ int ( v.at ( i % period ) ) ];
	}
	catch ( std::bad_alloc )
	{
		for ( int i = 0; i &lt; period * koliko_puta; i++ )
			delete [] p [ i ];
		delete [] p;
		throw;
	}
	
	RRCT max = *std::max_element ( std::begin ( v ), std::end ( v ) );
	for ( int i = 0; i &lt; period * koliko_puta; i++ )
	{
		int k = max - v.at ( i % period ) + 1;
		for ( int j = 0; j &lt; v.at ( i % period ); j++ )
			p [ i ] [ j ] = k++;
	}
	
	return p;
}

template &lt; typename T &gt;
auto AlocirajKontinualno ( const std::vector &lt; T &gt; &amp;v, int &amp;koliko_puta ) -&gt;
	typename std::remove_const &lt; typename std::remove_reference &lt; decltype ( v [ 0 ] ) &gt;::type &gt;::type **
{
// sve sto nije alokacija
	ab::testException ( v );
	int period;
	ab::expand ( v, koliko_puta, period );
//	
	typedef	typename std::remove_const &lt; typename std::remove_reference &lt; decltype ( v [ 0 ] ) &gt;::type &gt;::type RRCT;
	
	RRCT **p { nullptr };
	try
	{
		p = new RRCT *[ period * koliko_puta ];
		*p = nullptr;
		
		*p = new RRCT [ ab::numOfElements ( v, koliko_puta, period ) ];
		for ( int i = 0; i &lt; period * koliko_puta - 1; i++ )
			p [ i + 1 ] = p [ i ] + v.at ( i % period );
	}
	catch ( std::bad_alloc )
	{
		delete [] *p;
		delete [] p;
		throw;
	}
	
	int k;
	for ( int i = 0; i &lt; period * koliko_puta; i++ )
	{
		k = v.at ( i % period );
		for ( int j = 0; j &lt; v.at ( i % period ); j++ )
			p [ i ] [ j ] = k--;
	}
	
	return p;
}

int main ( void )
{
	int n, all, koliko_puta;
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	std::cin &gt;&gt; n;
	std::vector &lt; int &gt; v;
	
	int **p { nullptr };
	try
	{	
		v.resize ( n );
		std::cout &lt;&lt; "Unesite elemente vektora: ";
		for ( int &amp;x : v )
			std::cin &gt;&gt; x;
			
		std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		std::cin &gt;&gt; all;
		
		p = ( all == 1 ) ? AlocirajFragmentirano ( v, koliko_puta ) : AlocirajKontinualno ( v, koliko_puta );
	}
	catch ( std::domain_error domain )
	{
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; domain.what ();
		return 0;
	}
	catch ( const char *c )
	{
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; c;
		return 0;
	}
	catch ( std::bad_alloc ball )
	{
		std::cout &lt;&lt; "Izuzetak: " &lt;&lt; ball.what ();
		return 0;
	}
	
	int period = ab::Period ( v );
	
	std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::endl;
	for ( int i = 0; i &lt; period * koliko_puta; i++ )
	{
		for ( int j = 0; j &lt; v.at ( i % period ); j++ )
			std::cout &lt;&lt; std::left &lt;&lt; std::setw ( 3 ) &lt;&lt; p [ i ] [ j ];
		std::cout &lt;&lt; std::endl;
	}
	
	if ( all == 1 )
	{
		for ( int i = 0; i &lt; period * koliko_puta; i++ )
			delete [] p [ i ];
		delete [] p;
	}
	else
	{
		delete [] *p;
		delete [] p;
</font>	}
	
	return 0;
}</pre>
</body>
</html>
