<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student7341.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student7341.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;new&gt;
#include &lt;memory&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

template &lt;typename Tip&gt;
bool DaLiJePeriodican (const std::vector&lt;Tip&gt; v, int p)
{
	for (int i(0); i&lt;v.size(); i++) {
		if (p&lt;1 || p&gt;=v.size()) return false;
		if (i+p&gt;=v.size()) break;
<a name="3"></a><font color="#00FFFF"><a href="match479-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

		if(v.at(i) != v.at(i+p)) return false;
	}
	
	return true;
}

template &lt;typename Tip&gt;
int OdrediPeriod (std::vector&lt;Tip&gt; v, bool &amp;periodicnost) {
</font>	int p(0);
	for (int i(0); i&lt;v.size(); i++) {
		if (DaLiJePeriodican(v, i)) {
			p=i;
			periodicnost=true;
			return p;
		}
	}
	periodicnost=false;
	return p;
}

template &lt;typename Tip&gt;
int BrojElemenata (std::vector &lt;Tip&gt; v) {
	int suma(0);
	for (int i (0); i&lt;v.size(); i++) {
		suma += v.at(i);
	}
	return suma;
}

template &lt;typename Tip&gt;
int MaxElement(std::vector&lt;Tip&gt; v) {
	int max_element(v.at(0));
	for (int i(0); i&lt;v.size(); i++) {
		if (v.at(i)&gt;max_element) max_element=v.at(i);
		}
		
		return max_element;
}

template &lt;typename Tip&gt;
Tip **AlocirajFragmentirano (const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta)
{
	int periodPonavljanja(0);
	int brojElemenata=v.size();
	if (v.size()==0) throw std::domain_error("Prazan vektor!");
	for (int i(0); i &lt; brojElemenata; i++) {
		if (v.at(i)&lt;=0) throw std::domain_error ("Neispravan vektor!");
	}
	Tip **a=nullptr;
	int max_element(MaxElement(v));
	try {
		//a = new Tip* [brojElemenata];
		bool periodicnost;
		periodPonavljanja = OdrediPeriod(v, periodicnost);
		if (periodicnost) a=new Tip* [brojElemenata];
		else a=new Tip* [brojElemenata*2];
		if (periodicnost) {
			// Za cijeli broj ponavljanja
			if (brojElemenata % periodPonavljanja == 0) {
				koliko_puta = brojElemenata / periodPonavljanja;
				for (int i(0); i &lt; brojElemenata; i++) {
					//if (v.at(i) &lt;=0) throw std::domain_error ("Neispravan vektor!");
					a[i] = new Tip[v.at(i)];
					int k(max_element);
					for (int j=0; j&lt;v.at(i); j++) {
						if (v.at(i)==1) a[i][j]=k;
						else {
						  a[i][j]=k-v.at(i)+1;
						  k++;
							
						}
					}

				}

			}
			
			else {
				koliko_puta = (brojElemenata / periodPonavljanja) + 1;
				for (int i(0); i &lt; brojElemenata; i++) {
					a[i] = new Tip[v.at(i)];
					int k(max_element);
					for (int j=0; j&lt;v.at(i); j++){
						 if (v.at(i)==1) a[i][j] = max_element;
						else  {
							a[i][j]=k-v.at(i)+1;
							k++;
						}
					}
				}
				int dodatno = koliko_puta * periodPonavljanja - brojElemenata;
				int brojac(0);
				int brElemenataDaPopuni = brojElemenata-dodatno;
				for (int i=brojac; i&lt;dodatno; i++){
					a[i] = new Tip[v.at(brElemenataDaPopuni)];
					int k(max_element);
					for (int j=0; j&lt;=v.at(brElemenataDaPopuni); j++) {
						if (v.at(brElemenataDaPopuni)==1) a[i][j] = max_element;
						 else {
						 	a[i][j]=k-v.at(brElemenataDaPopuni);
						 	k++;
						 }
					}
					
					brElemenataDaPopuni++;
				}
			}

		}
		else {
			koliko_puta=2; 
			for (int i(0); i&lt;v.size(); i++) {
				a[i]=new Tip[v.at(i)];
				int k(max_element);
				for (int j(0); j&lt;v.at(i); j++){ 
					if (v.at(i)==1) a[i][j]=max_element;
					else {
						a[i][j]=k-v.at(i)+1;
						k++;
					}
				}
			}
			
			for (int i(0); i&lt;v.size(); i++){
				a[i+brojElemenata]= new Tip[v.at(i)];
				int k(max_element);
				for (int j(0); j&lt;v.at(i); j++){
					if (v.at(i)==1) a[i][j]=max_element;
					else {
						a[i][j]=k-v.at(i)+1;
						k++;
					}
				}
			}
		}
	}

	catch (...) {
		for (int i(0); i&lt;brojElemenata; i++) delete[] a[i];
		delete[] a;
		throw ;
		//if (v.size()==0) throw std::domain_error("Prazan vektor!");
		//else throw std::domain_error("Neispravan vektor!");
	}
	return a;

}


template &lt;typename Tip&gt;
Tip **AlocirajKontinualno (const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta){
	
	int periodPonavljanja(0);
	int brojElemenata=v.size();
	if (v.size()==0) throw std::domain_error ("Prazan vektor!");
	for (int i(0); i&lt;v.size(); i++) {
		if (v.at(i)&lt;=0) throw std::domain_error ("Neispravan vektor!");
	}
	Tip **a=nullptr;
	try {

		int BrojUkupnihElemenata(BrojElemenata(v));
		a=new Tip*[v.size()]{};
		a[0] = new Tip[BrojUkupnihElemenata]{};
		bool periodicnost;
		periodPonavljanja = OdrediPeriod(v, periodicnost);
		if (periodicnost){
			if (brojElemenata % periodPonavljanja ==0) {
				koliko_puta = brojElemenata / periodPonavljanja;
				for (int i(0); i &lt; brojElemenata; i++){
					a[i] = a[i-1] + v.at(i);
				}
				
				for (int i(0); i&lt;v.size(); i++) {
					int k(v.at(i));
					for (int j=0; j&lt;=v.at(i); j++){
						a[i][j]=k;
						k--;
					}
				}
			}
		}
		
	}
	
	catch (...) {
		if (a!=nullptr) {
			delete a[0];
		}
		delete[] a;
		throw ;
	}
	return a;
}

int main ()
{
	int brojElemenata;
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	std::cin &gt;&gt; brojElemenata;
	std::vector&lt;int&gt; v(brojElemenata);
	int koliko(0);
	std::cout &lt;&lt; "Unesite elemente vektora: ";
	for (int i(0); i&lt;brojElemenata; i++) {
		double broj;
		std::cin &gt;&gt; broj;
		v.at(i) = broj;
	}
	//for (int i(0); i&lt;brojElemenata; i++) std::cout&lt;&lt;v.at(i)&lt;&lt;" ";
	
	int **p=nullptr;
	int izbor;
	std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	std::cin &gt;&gt; izbor;
	if (izbor  == 1) {
	try{
		p=AlocirajFragmentirano(v, koliko);
		std::cout &lt;&lt; "Dinamicki alocirana matrica:\n";
		bool periodicnost;
		int k(0);
		int periodPonavljanja = OdrediPeriod(v, periodicnost);
		int dodatno = koliko * periodPonavljanja - brojElemenata;
		int brElemenataDaPopuni = brojElemenata-dodatno;
		if (periodPonavljanja!=0)
		{for (int i(0); i&lt;brojElemenata; i++){
<a name="0"></a><font color="#FF0000"><a href="match479-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

			for (int j(0); j&lt;v.at(i); j++){
				std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left &lt;&lt; p[i][j];
			}
			std::cout &lt;&lt; std::endl;
</font>		}
		
		for (int i(0); i&lt;dodatno; i++){
<a name="2"></a><font color="#0000FF"><a href="match479-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

			for (int j=0; j&lt;brElemenataDaPopuni-1; j++){
				std::cout &lt;&lt;  std::setw(3) &lt;&lt; std::left &lt;&lt; p[i][j];
			}
			std::cout &lt;&lt; std::endl;
</font>		}
		
		for (int i(0); i&lt;brojElemenata; i++) delete[] p[i];
		delete[] p;
	}
	else {
		for (int i(0); i&lt;brojElemenata; i++) {
<a name="1"></a><font color="#00FF00"><a href="match479-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

			for (int j(0); j&lt;v.at(i); j++){
				std::cout &lt;&lt;  std::setw(3) &lt;&lt; std::left &lt;&lt; p[i][j];
			}
			std::cout &lt;&lt; std::endl;
</font>		}
		
		for (int i(0); i&lt;brojElemenata; i++){
<a name="4"></a><font color="#FF00FF"><a href="match479-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

			for (int j(0); j&lt;v.at(i); j++) {
				std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left&lt;&lt; p[i][j];
</font>			}
			std::cout &lt;&lt; std::endl;
		}
	}
	}
	catch (std::domain_error e){
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt; e.what();
		/*for (int i(0); i&lt;brojElemenata; i++) delete[] p[i];
		delete[] p; */
	} 
	}
	
	if (izbor==0) {
		try{
			p=AlocirajKontinualno(v, koliko);
			std::cout&lt;&lt;"Dinamicki alocirana matrica:\n";
			bool periodicnost;
			int k(0);
			int periodPonavljanja = OdrediPeriod(v, periodicnost);
			int dodatno = koliko * periodPonavljanja - brojElemenata;
			for (int i(0); i&lt;brojElemenata; i++) {
				for (int j(0); j&lt;=v.at(i)-1 ; j++){
					std::cout&lt;&lt;std::setw(3) &lt;&lt; std::left &lt;&lt; p[i][j] &lt;&lt; " ";				
			}
			std::cout &lt;&lt; std::endl;
		}
		
		delete[] p[0]; 
		delete[] p;
	}
	
	catch(std::domain_error e){
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
	}
	
}
	return 0;
}</pre>
</body>
</html>
