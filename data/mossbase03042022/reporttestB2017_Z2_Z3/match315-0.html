<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4824.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4824.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
template &lt; typename NekiTipVek&gt;
bool DaLiJePeriodican(NekiTipVek v, int period)
{
	int velicina=v.size();
	int i(0);
	if(period==0 ||velicina==1 || velicina==0) return false;
	if((i+period)&gt;velicina) return false;
	for( int i=0; i&lt;(velicina-period); i++)
		if(v[i]!=v[i+period]) return false;
	return true;

}
template &lt;typename NekiTipVek&gt;
int OdrediOP( NekiTipVek v)
{
	int period(1);
	while(period&lt;v.size()) {
		if(DaLiJePeriodican(v,period)!=0) return period;
		period++;

	}
	return 0;
}
template &lt;typename Tip&gt;
<a name="1"></a><font color="#00FF00"><a href="match315-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

int **AlocirajFragmentirano( const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta)
{
	if (v.size()==0) {
		throw std::domain_error("Prazan vektor!");
	}
	for (int i=0; i&lt;v.size(); i++) {
		if (v[i]&lt;=0) {
			throw std::domain_error("Neispravan vektor!");
</font>			break;

		}
	}
	int period(OdrediOP(v));
	if(DaLiJePeriodican(v,period)!=0) {
		Tip broj=(v[period-1]);
		koliko_puta=0;
		for( int i=0; i&lt;v.size(); i++) {
			if(v[i]==broj) koliko_puta++;

		}
		if(v.size()%period!=0) koliko_puta++;

	} else if(DaLiJePeriodican(v,period)==0) {
		koliko_puta=2;
	}
	Tip **matrica(nullptr);
	int nova_vel(0);
	if (koliko_puta==2 &amp;&amp; v.size()%koliko_puta!=0  &amp;&amp; period!=0) nova_vel=(v.size()+koliko_puta-1);
	else if(koliko_puta==2 &amp;&amp; v.size()%koliko_puta!=0 &amp;&amp; period==0) {
		nova_vel=v.size()*2;
		period=v.size();
	} else if(koliko_puta&gt;=2 &amp;&amp; v.size()%koliko_puta==0 &amp;&amp; period!=0) nova_vel=v.size();
	try {
		matrica=new Tip*[nova_vel];
		int j(0);
		while(j&lt;nova_vel) {
			for( int i=0; i&lt;period; i++) {
				int velicina=v[i];
				matrica[j]=new Tip[velicina];
				j++;
			}

		}
		int k(0);
		while(k&lt;nova_vel) {
			for( int i=0; i&lt;period; i++) {
				Tip element(*std::max_element(v.begin(),v.end()));
<a name="3"></a><font color="#00FFFF"><a href="match315-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

				for( int j=v[i]-1; j&gt;=0; j--) {
					matrica[k][j]=element;
					element--;

				}
				k++;
</font>
			}


		}

	} catch(...) {
<a name="0"></a><font color="#FF0000"><a href="match315-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

		for( int i=0; i&lt;nova_vel; i++) delete[] matrica[i];
		delete[] matrica;
		throw;
	}
	return matrica;

}
template &lt;typename Tip&gt;
int **AlocirajKontinualno(const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta)
{
	if (v.size()==0) throw std::domain_error("Prazan vektor!");
	for( int i=0; i&lt;v.size(); i++) {
		if(v[i]&lt;=0) {
			throw std::domain_error("Neispravan vektor!");
</font>			break;
		}
	}
	int period(OdrediOP(v));
	if(DaLiJePeriodican(v,period)!=0) {
		Tip broj=v[period-1];
		koliko_puta=0;
		for( int i=0; i&lt;v.size(); i++) {
			if(v[i]==broj) koliko_puta++;
			
		}
		if(v.size()%period!=0) koliko_puta++;



	} else if(DaLiJePeriodican(v,period)==0) {
		koliko_puta=2;
	}
	int nova_vel(0);
	if(koliko_puta==2 &amp;&amp; v.size()%koliko_puta!=0 &amp;&amp; period!=0) nova_vel=v.size()+koliko_puta-1;

	else if(koliko_puta==2 &amp;&amp; v.size()%koliko_puta!=0 &amp;&amp; period==0) {
		nova_vel=v.size()*2;
		period=v.size();
	} else if(koliko_puta&gt;=2 &amp;&amp; v.size()%koliko_puta==0 &amp;&amp; period!=0) nova_vel=v.size();

Tip **matrica(nullptr);
	int broj_elemenata(0);
	int p(0);
	while(p&lt;nova_vel) {
		for( int i=0; i&lt;period; i++) {
				broj_elemenata+=v[i];
				p++;
			}
			
		}

	
	try {
	matrica=new Tip*[nova_vel+1];
		matrica[0]=new Tip[broj_elemenata];
		int s(1);
		do {
			for(int i=1; i&lt;=period; i++) {
				Tip br(v[i-1]);
				matrica[s]=matrica[i-1]+br; 
			s++;
			}
		}while((s+1)&lt;nova_vel);
		s=0;
		while(s&lt;nova_vel){
			for( int i=0; i&lt;period; i++){
				Tip element(v[i]);
				for( int j=0; j&lt;v[i]; j++){
					matrica[s][j]=element;
					element--;
				}
				s++;
			}
		}
	} catch(...) {
		delete[] matrica[0];
		delete[] matrica;
		throw;
	}
	return matrica;
}
int main ()
{
	try {
		int broj_elemenata(0);
		std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
		std::cin&gt;&gt;broj_elemenata;
		std::vector&lt;int&gt;v(broj_elemenata);
		std::cout&lt;&lt;"Unesite elemente vektora: ";
		for( int i=0; i&lt;broj_elemenata; i++) {
			std::cin&gt;&gt;v[i];
		}
		int pomocni_period(OdrediOP(v));
		int biraj(0),period1(0), period2(0);
		std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		std::cin&gt;&gt;biraj;
		if(biraj==1) {
			auto *v_fragmentirano(AlocirajFragmentirano(v, period1));
			std::cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;std::endl;
			int nova_vel(0);
			if(period1==2 &amp;&amp; v.size()%period1!=0 &amp;&amp; pomocni_period==0) {
				nova_vel=v.size()*2;
				pomocni_period=v.size();

			} else if(period1==2 &amp;&amp; v.size()%period1!=0 &amp;&amp; pomocni_period!=0) nova_vel=v.size()+period1-1;
			else if(period1&gt;=2 &amp;&amp; v.size()%period1==0 &amp;&amp; pomocni_period!=0 ) nova_vel=v.size();
			int k(0);
			while( k&lt;nova_vel) {
				for( int i=0; i&lt;pomocni_period; i++) {
					int velicina(v[i]);
					for(int j=0; j&lt;velicina; j++) {
						std::cout&lt;&lt;std::fixed&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;v_fragmentirano[k][j];
					}
					k++;
					std::cout&lt;&lt;std::endl;
				}

			}
			for( int i=0;  i&lt;nova_vel; i++) delete[] v_fragmentirano[i];
			delete[] v_fragmentirano;

		} else if(biraj==0) {
			auto v_kontinualno(AlocirajKontinualno(v, period2));
			std::cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;std::endl;
			int nova_vel(0);
			if(v.size()%period2==0 &amp;&amp; period2&gt;=2 &amp;&amp; pomocni_period!=0) nova_vel=v.size();
			else if(period2==2 &amp;&amp; v.size()%period2!=0 &amp;&amp; pomocni_period!=0) nova_vel=v.size()+period2-1;
			else if(period2==2 &amp;&amp; v.size()%period2!=0 &amp;&amp; pomocni_period==0) {
				nova_vel=v.size()*2;
				pomocni_period=v.size();
			}
			int k(0);
			while(k&lt;nova_vel) {
				for( int i=0; i&lt;pomocni_period; i++) {
					int velicina(v[i]);
					for(int j=0; j&lt;velicina; j++) {
						std::cout&lt;&lt;std::fixed&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;v_kontinualno[k][j];

					}
					k++;
<a name="2"></a><font color="#0000FF"><a href="match315-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

					std::cout&lt;&lt;std::endl;

				}

			}
			delete[] v_kontinualno[0];
			delete[] v_kontinualno;
		}
	} catch(std::domain_error izuzetak1) {
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak1.what()&lt;&lt;std::endl;
</font>	}
	return 0;
}</pre>
</body>
</html>
