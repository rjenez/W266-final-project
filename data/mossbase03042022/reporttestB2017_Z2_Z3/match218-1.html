<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1531.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8139.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
<a name="0"></a><font color="#FF0000"><a href="match218-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;
	template&lt;typename tip&gt;
	bool jeliperiodican(const vector&lt;tip&gt; &amp;v, int &amp;period){
		tip el=v[0];
		int k(0);
		
		int i(1);
		while(v[i]!=el){
			period++;
			i++;
		}
		while(i!=v.size() &amp;&amp; v[i]==v[k]){
			i++;
			k++;
		}
		if(i==v.size()){
		period+=1;
		return true;
		}
		else period=v.size();
		return false;
	}

	template&lt;typename tip&gt;
	tip **AlocirajFragmentirano(const vector&lt;tip&gt; &amp;v, int &amp;koliko_puta){
		if(v.size()==0)throw "Prazan vektor!";
		/*for(int i=0;i&lt;v.size();i++){
			if(v[i]&lt;0 || v[i]==0)throw domain_error("neispravan vektor");
		}*/
		int period(0);
		bool prom=jeliperiodican(v, period);
		if(prom){
			if(v.size()%period!=0){
				//int pom=v.size()%period;
				//copy(v.begin()+pom, v.begin()+period, back_inserter(v));
				koliko_puta=v.size()/period+1;
			}
			else if(v.size()%period==0)
			koliko_puta=v.size()/period;
			
			
		}
		else if(prom==false)
			
				koliko_puta=2;
				
			//copy(v.begin(), v.end(), back_inserter(v));
		
		int **pok=nullptr;
		try{
			pok=new int *[period*koliko_puta];
			try{
				int z(0);
				for(int i=0;i&lt;period*koliko_puta;i++){
					
					pok[i]=new int[v[z]];
					
					z++;
					if(z==period)z=0;
				}
				
				tip maks=*(max_element(v.begin(), v.end()));
				int t(0);
				for(int k=0;k&lt;period*koliko_puta;k++){
					tip maksi=maks;
				
					for(int m=v[t]-1;m&gt;=0;m--){
					pok[k][m]=maksi;
					maksi--;
			
					}
					t++;
					if(t==period)t=0;
				}
			
		}
		catch(bad_alloc){
			for(int i=0;i&lt;period*koliko_puta;i++)
			delete [] pok[i];
			delete [] pok;
			throw bad_alloc();
		}
		}
		catch(...){
			throw bad_alloc();
		}
		
		return pok;
	}

int main ()
{
	int n;
	cout&lt;&lt;"Unesite broj elemenata vektora: ";
	cin&gt;&gt;n;
	vector&lt;int&gt;v(n);
	cout&lt;&lt;"Unesite elemente vektora: ";
	for(int i=0;i&lt;n;i++){
		int broj;
		cin&gt;&gt;broj;
		v.push_back(broj);
	}
	int opcija;
	cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	cin&gt;&gt;opcija;
	int broj(0);
	int spasi(0);
	bool prom=jeliperiodican(v, spasi);
	if(opcija==1){
		try{
			int z(0);
		int **pok=AlocirajFragmentirano&lt;int&gt;(v, broj);
		cout&lt;&lt;"Dinamicki alocirana matrica:";
		for(int i=0;i&lt;spasi*broj;i++){
			for(int j=0;j&lt;v[z];j++){
				
			cout&lt;&lt;left&lt;&lt;setw(3)&lt;&lt;pok[i][j];
			
			
			}
			z++;
			if(z==spasi)z=0;
			cout&lt;&lt;endl;
		}
		for(int i=0;i&lt;spasi*broj;i++)
		delete [] pok[i];
		delete [] pok;
	}
	/*catch(const char []){
		cout&lt;&lt;"Prazan vektor!";
	}*/
	/*catch(domain_error e){
		cout&lt;&lt;e.what();
	}*/
	catch(bad_alloc){
		cout&lt;&lt;"alokacija neuspjesna";
	}
	catch(...){
		cout&lt;&lt;"Prazan vektor!";
</font>	}
	
	}
	return 0;
}</pre>
</body>
</html>
