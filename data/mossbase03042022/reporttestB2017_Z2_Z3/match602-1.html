<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student2675.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student9949.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;new&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
const double e(0.0001);

template &lt;typename CjelobrojniTip1&gt;
bool TestPerioda(const std::vector&lt;CjelobrojniTip1&gt; &amp;V, int p)
{
	bool Period(true);
	if(p&gt;=1 &amp;&amp; p&lt;V.size()) {
		for(int i=0; i&lt;(V.size()-p); i++) {
			if(fabs(V.at(i)-V.at(i+p))&gt;e) {
				return false;
			}
		}
	} else return false;
	return Period;
}

template &lt;typename CjelobrojniTip3&gt;
int Period(const std::vector&lt;CjelobrojniTip3&gt; &amp;V)
{
	for(int i=0; i&lt;V.size(); i++) {
		if(TestPerioda(V,i)) return i;
	}
	return 0;
}

template &lt;typename CjelobrojniTip4&gt;
int Najveci(const std::vector&lt;CjelobrojniTip4&gt; &amp;V)
{
	int max(V[0]);
	for(int i=1; i&lt;V.size(); i++) {
		if(V[i]&gt;max) max=V[i];
	}
	return max;
}

template &lt;typename CjelobrojniTip&gt;

int **AlocirajFragmentirano(const std::vector&lt;CjelobrojniTip&gt; &amp;V, int &amp;koliko_puta)
{
	if(V.size()==0) throw "Izuzetak: Prazan vektor!";
<a name="3"></a><font color="#00FFFF"><a href="match602-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

	for(int i=0; i&lt;V.size(); i++) {
		if(V[i]&lt;=0) throw std::domain_error("Izuzetak: Neispravan vektor!");
	}
	int max(Najveci(V));
</font>	int duzina(V.size()),period(0);
	for(int i=0; i&lt;V.size(); i++) {
		if(TestPerioda(V,i)==true) {
			period=i;
			if(duzina%i!=0) {
				while(duzina%i!=0) {
					duzina++;
				}
				int br(1),brojac(0);
				for(int j=0; j&lt;duzina; j++) {
					if(j==period*br-1) {
						brojac++;
						br*=2;
					}
				}
				koliko_puta=brojac;
				break;
			} else {
				koliko_puta=duzina/period;
				break;
			}
		}
		if(i==V.size()-1) {
			duzina*=2;
			koliko_puta=2;
			period=V.size();
		}
	}
	int **Mat=nullptr;
	try {
		Mat=new int*[duzina];
		for(int i=0; i&lt;duzina; i++) {
			Mat[i]=nullptr;
		}
		try {
			int k(0);
			for(int i=0; i&lt;duzina; i++) {
				Mat[i]=new int[V[k]];
				k++;
				if(k==period) k=0;
			}
			k=0;
			for(int i=0; i&lt;duzina; i++) {
				int p(max);
<a name="1"></a><font color="#00FF00"><a href="match602-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

				for(int j=V[k]-1; j&gt;=0; j--) {
					Mat[i][j]=p;
					p--;
				}
				k++;
</font>				if(k==period) k=0;
			}
			return Mat;
		} catch(std::bad_alloc) {
			for(int i=0; i&lt;duzina; i++) {
				delete[] Mat[i];
			}
			delete[] Mat;
			throw;
		}
	} catch(std::bad_alloc) {
		throw;
	}
	return Mat;
}

template &lt;typename CjelobrojniTip2&gt;
int **AlocirajKontinualno(const std::vector&lt;CjelobrojniTip2&gt; &amp;V, int &amp;koliko_puta)
{
	if(V.size()==0) throw "Izuzetak: Prazan vektor!";
<a name="4"></a><font color="#FF00FF"><a href="match602-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

	for(int i=0; i&lt;V.size(); i++) {
		if(V[i]&lt;=0) throw std::domain_error("Izuzetak: Neispravan vektor!");
	}

	int duzina(V.size()), period(0);
</font>	for(int i=0; i&lt;V.size(); i++) {
		if(TestPerioda(V,i)==true) {
			period=i;
			if(duzina%i!=0) {
				while(duzina%i!=0) {
					duzina++;
				}
				int br(1),brojac(0);
				for(int j=0; j&lt;duzina; j++) {
					if(j==br*period-1) {
						brojac++;
						br*=2;
					}
				}
				koliko_puta=brojac;
				break;
			} else {
				koliko_puta=duzina/period;
				break;
			}
		}
		if(i==V.size()-1) {
			duzina*=2;
			koliko_puta=2;
			period=V.size();
		}
	}

	int **M=nullptr;
	try {
		M=new int*[duzina];
		try {
			int br_elem(0);
			int m(0);
			for(int i=0; i&lt;duzina; i++) {
				br_elem+=V[i];
				m++;
				if(m==period) break;
			}
			br_elem=koliko_puta*br_elem;
			M[0]=new int[br_elem];
			int k(0);
			for(int i=1; i&lt;duzina; i++) {
				M[i]=M[i-1]+V[k];
				k++;
				if(k==period) k=0;
			}
		} catch(std::bad_alloc) {
			delete[] M;
			throw;
		}
	} catch(std::bad_alloc) {
		throw;
	}
	int k(0);
	for(int i=0; i&lt;duzina; i++) {
		int p(1);
<a name="2"></a><font color="#0000FF"><a href="match602-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

		for(int j=V[k]-1; j&gt;=0; j--) {
			M[i][j]=p;
			p++;
		}
		k++;
</font>		if(k==period) k=0;
	}
	return M;
}

int main ()
{

	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	int br_elem(0);
	std::cin &gt;&gt; br_elem;
	std::cout &lt;&lt; "Unesite elemente vektora: ";
	std::vector&lt;int&gt; Vec;
	for(int i=0; i&lt;br_elem; i++) {
		int broj;
		std::cin &gt;&gt; broj;
		Vec.push_back(broj);
	}
	int fk;
	std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	std::cin &gt;&gt; fk;
	try {
		if(fk==1) {
			int period(Period(Vec));
			int broj_pon;
			int **AF(AlocirajFragmentirano(Vec,broj_pon));
			int br_redova(Vec.size());
			if(period==0) {
				period=Vec.size();
				br_redova*=2;
			} else {
				while(br_redova%period!=0) {
					br_redova++;
				}
			}
			std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::endl;
			int i(0);
			for(int j=0; j&lt;br_redova; j++) {
<a name="0"></a><font color="#FF0000"><a href="match602-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

				for(int k=0; k&lt;Vec[i]; k++) {
					std::cout &lt;&lt; std::left &lt;&lt; std::setw(3) &lt;&lt; AF[j][k];
</font>				}
				std::cout &lt;&lt; std::endl;
				i++;
				if(i==period) i=0;
			}
			for(int i=0; i&lt;br_redova; i++) {
				delete[] AF[i];
			}
			delete[] AF;
		} else if(fk==0) {
			int period(Period(Vec));
			int broj_pon;
			int **AK(AlocirajKontinualno(Vec,broj_pon));
			int br_redova(Vec.size());
			if(period==0) {
				period=Vec.size();
				br_redova*=2;
			} else {
				while(br_redova%period!=0) {
					br_redova++;
				}
			}
			std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::endl;
			int i(0);
			for(int j=0; j&lt;br_redova; j++) {
				for(int k=0; k&lt;Vec[i]; k++) {
					std::cout &lt;&lt; std::left &lt;&lt; std::setw(3) &lt;&lt; AK[j][k];
				}
				i++;
				if(i==period) i=0;
				std::cout &lt;&lt; std::endl;
			}
			delete[] AK[0];
			delete[] AK;
		}
	} catch(std::bad_alloc) {
		std::cout &lt;&lt; "Izuzetak: Nedovoljno memorije" &lt;&lt; std::endl;
	} catch(const char izuzetak[]) {
		std::cout &lt;&lt; izuzetak &lt;&lt; std::endl;
	} catch(std::domain_error izuzetak) {
		std::cout &lt;&lt; izuzetak.what() &lt;&lt; std::endl;
	}
	return 0;
}</pre>
</body>
</html>
