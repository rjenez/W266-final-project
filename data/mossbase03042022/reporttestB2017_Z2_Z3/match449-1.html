<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8797.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1013.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

template &lt;typename element&gt;
bool DaLiJePeriod (int n,std::vector&lt;element&gt; v)
{
	for (int i=0;i&lt;v.size()-n;i++) {
		if (v.at(i)!=v.at(i+n) || i==i+n)
			return false;
	}
	return true;
}

template &lt;typename Neki&gt;
int OdrediOsnovniPeriod (std::vector&lt;Neki&gt; v) 
{
	for (int i=1;i&lt;v.size();i++) {
		if (DaLiJePeriod(i,v))
			return i;
	}
	return 0;
}
void Obrisi (int **mat, int n) 
{
	if (!mat) return;
	for (int i=0;i&lt;n;i++) delete[] mat[i];
	delete[] mat;
}
void Obrisi2 (int **mat, int n)
{
	if (!mat) return;
	delete[] mat[0];
	delete[] mat;
}

template &lt;typename Tip&gt;
<a name="0"></a><font color="#FF0000"><a href="match449-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

int **AlocirajFragmentirano (const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta) 
{
	if (v.size()==0) throw "Prazan vektor!";
	for (int i=0;i&lt;v.size();i++) {
		if (v.at(i)&lt;=0)
			throw std::domain_error ("Neispravan vektor!");
	}
	int period(OdrediOsnovniPeriod(v));
</font>	if (period==0) 
	koliko_puta=2;
	else {
		int vel(v.size());
		while (vel%period!=0)
		vel++;
		koliko_puta=vel/period;
	}
	if (period==0)
	period=v.size();
	int vel1(period*koliko_puta);
	int **pok(new int* [vel1] {});
	try {
		for (int i=0;i&lt;vel1;i++) {
			if (i&lt;v.size())
			pok[i]=new int [v.at(i)];
			else
			pok[i]=new int [v.at(i-period*(koliko_puta-1))];
		}
		for (int i=0;i&lt;vel1;i++) {
			int maxe(*std::max_element(v.begin(),v.end()));
			if (i&lt;v.size()) {
<a name="3"></a><font color="#00FFFF"><a href="match449-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

				for (int j=v.at(i)-1;j&gt;=0;j--) {
				pok[i][j]=maxe;
				maxe--; }
</font>			}
			else {
				for (int j=v.at(i-(koliko_puta-1)*period)-1;j&gt;=0;j--) {
					pok[i][j]=maxe;
					maxe--;
				}
			}
		}
	}	
	catch (std::bad_alloc) {
		Obrisi(pok,vel1);
		throw;
	}
	return pok;
}
template &lt;typename tip&gt; 
<a name="1"></a><font color="#00FF00"><a href="match449-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

int **AlocirajKontinualno (const std::vector&lt;tip&gt; &amp;v, int &amp;koliko_puta) 
{
	if (v.size()==0)	throw "Prazan vektor!";
	for (int i=0;i&lt;v.size();i++) {
		if (v.at(i)&lt;=0)
			throw std::domain_error ("Neispravan vektor!");
	}
	int period(OdrediOsnovniPeriod(v));
</font>	int vel(v.size());
	if (period==0)
	koliko_puta=2;
	else {
		while (vel%period!=0)
		vel++;
		koliko_puta=vel/period;
	}
	if (period==0)
	period=v.size();
	int vel1(period*koliko_puta);
	int **pok(new int *[vel1] {});
	int suma(0);
	for (int i=0;i&lt;vel1;i++) {
		if (i&lt;v.size())
		suma+=v.at(i);
		else
		suma+=v.at(i-(koliko_puta-1)*period);
	}
	try {
		pok[0]=new int[suma];
		for (int i=1;i&lt;vel1;i++) {
			if (i&lt;=period)
			pok[i]=pok[i-1]+v.at(i-1);
			else
			pok[i]=pok[i-1]+v.at(i-period-1);
		}
		for (int i=0;i&lt;vel1;i++) {
			int ubaci(1);
			if (i&lt;v.size()) {
				for (int j=v.at(i)-1;j&gt;=0;j--) {
				pok[i][j]=ubaci;
				ubaci++;}
			}
			else  {
				for (int j=v.at(i-period*(koliko_puta-1))-1;j&gt;=0;j--) {
				pok[i][j]=ubaci;
				ubaci++; }
			}
		}
	}
	catch (std::bad_alloc) {
		Obrisi2(pok,vel1);
		throw;
	}
	return pok;
}

int main ()
{ 
	int n;
	std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
	std::cin&gt;&gt;n;
	int x,vel;
	int **pok(nullptr);
	int **pok1(nullptr);
	std::vector&lt;int&gt; v;
	try {
	std::cout&lt;&lt;"Unesite elemente vektora: ";
	for (int i=0;i&lt;n;i++) {
		int unos;
		std::cin&gt;&gt;unos;
		v.push_back(unos);
	}
	std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	std::cin&gt;&gt;x;
	int koliko_puta;
	int period(OdrediOsnovniPeriod(v));
	if (x==1){
		pok=AlocirajFragmentirano(v,koliko_puta);
		std::cout&lt;&lt;"Dinamicki alocirana matrica:\n";
		if (period==0)
		period=v.size();
		vel=period*koliko_puta;
		for (int i=0;i&lt;vel;i++) {
			if (i&lt;v.size()) {
<a name="2"></a><font color="#0000FF"><a href="match449-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

				for (int j=0;j&lt;v.at(i);j++)
				std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
				std::cout&lt;&lt;"\n";
</font>			}
			else {
				for (int j=0;j&lt;v.at(i-(koliko_puta-1)*period);j++) 
				std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
				std::cout&lt;&lt;"\n";
			}
		}
	}
	else if (x==0) {
		pok1=AlocirajKontinualno(v,koliko_puta);
		std::cout&lt;&lt;"Dinamicki alocirana matrica:\n";
		if (period==0)
		period=v.size();
		vel=period*koliko_puta;
		for (int i=0;i&lt;vel;i++) {
			if (i&lt;v.size()) {
				for (int j=0;j&lt;v.at(i);j++)
				std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok1[i][j];
				std::cout&lt;&lt;"\n";
			}
			else {
				for (int j=0;j&lt;v.at(i-(koliko_puta-1)*period);j++)
				std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok1[i][j];
				std::cout&lt;&lt;"\n";
			}
		}
	}
	}
	catch (std::bad_alloc) {
		std::cout&lt;&lt;"Izuzetak: Nedostatak memorije!";
	}
	catch (const char tekst[]) {
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;tekst;
	}
	catch (std::domain_error izuzetak) {
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
	}
	if (x==1)
		Obrisi(pok,vel);
	if (x==0)
		Obrisi2(pok1,vel);
	return 0;
}</pre>
</body>
</html>
