<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3717.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1200.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;algorithm&gt;

<a name="0"></a><font color="#FF0000"><a href="match5-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

bool TestPerioda(std::vector&lt;int&gt;v, int p){
	if(p&gt;=v.size() || p==0) return false;
	bool periodican(true);
	for(int i=0; i&lt;v.size(); i++){
		if(i+p&gt;=v.size()) break;
		if(v[i]!=v[i+p]){
			periodican=false;
			break;
		}
	}
	return periodican;
}

int OdrediOsnovniPeriod(std::vector&lt;int&gt;v){
	int p(1);
	while(p&lt;v.size()){
		bool periodican=TestPerioda(v,p);
		if(periodican==true){
			return p;
			break;
		}
		p++;
	}
	return 0;
}

std::vector&lt;int&gt; Produzi(std::vector&lt;int&gt;v, int period){
	std::vector&lt;int&gt; vp;
	vp.resize(period);
	for(int i=0; i&lt;vp.size(); i++) vp[i]=v[i];
	int i(1);
	while(v.size()%period!=0 &amp;&amp; i&lt;period){
		if(vp[i]!=v[v.size()-1]) v.push_back(vp[i]);
		i++;
	}
	return v;
}

int maks(const std::vector&lt;int&gt;&amp;v2){
	int max(v2[0]);
	for(int i=1; i&lt;v2.size(); i++){
		if(v2[i]&gt;max) max=v2[i];
	}
	return max;
}

std::vector&lt;int&gt; SimetricnoProduzi(const std::vector&lt;int&gt;&amp;v, int &amp;koliko_puta){
	std::vector&lt;int&gt;v2=v,vp;
	int period(OdrediOsnovniPeriod(v2));
	vp=Produzi(v2,period);
	koliko_puta=vp.size()/period;
	return vp;
}

std::vector&lt;int&gt; NesimetricnoProduzi(const std::vector&lt;int&gt;&amp;v, int &amp;koliko_puta){
	koliko_puta=2;
	std::vector&lt;int&gt;vp(v);
	std::vector&lt;int&gt;vpom(vp);
	for(int i=0; i&lt;vpom.size(); i++) vp.push_back(vpom[i]);
	return vp;
}

int BrojKolona1(const std::vector&lt;int&gt;&amp;v, int i, int &amp;koliko_puta){
	std::vector&lt;int&gt;v1(v);
	v1=SimetricnoProduzi(v,koliko_puta);
	return v1[i];
}

int BrojKolona2(const std::vector&lt;int&gt;&amp;v, int i, int &amp;koliko_puta){
	std::vector&lt;int&gt;v1(v);
	v1=NesimetricnoProduzi(v,koliko_puta);
	return v1[i];
}

int BrojRedova1(const std::vector&lt;int&gt;&amp;v, int &amp;koliko_puta){
	std::vector&lt;int&gt;v1(v);
	v1=SimetricnoProduzi(v,koliko_puta);
	return v1.size();
}

int BrojRedova2(const std::vector&lt;int&gt;&amp;v, int &amp;koliko_puta){
	std::vector&lt;int&gt;v1(v);
	v1=NesimetricnoProduzi(v,koliko_puta);
	return v1.size();
}

//template &lt;typename tipint&gt;
int **AlocirajFragmentirano(const std::vector&lt;int&gt;&amp;v, int &amp;koliko_puta){
	if(v.size()==0) throw "Izuzetak: Prazan vektor!";
	for(int i=0; i&lt;v.size(); i++){
		if(v[i]&lt;=0) throw std::domain_error("Izuzetak: Neispravan vektor!");
	}
	int period(OdrediOsnovniPeriod(v));
	int **a(nullptr);
	if(period){
		int n(BrojRedova1(v,koliko_puta));
		try{
				a=(new int*[n]);
				for(int i=0; i&lt;n; i++) a[i]=nullptr;
				try{
					for(int i=0; i&lt;n; i++) a[i]=new int[BrojKolona1(v,i,koliko_puta)];
					
					for(int i=0; i&lt;n; i++){
						int max(maks(v));
						for(int j=BrojKolona1(v,i,koliko_puta)-1; j&gt;=0; j--){
							a[i][j]=max;		
							max--;
						}
					}
					std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
			for(int i=0; i&lt;n; i++){
				for(int j=0; j&lt;BrojKolona1(v,i,koliko_puta); j++){
					 std::cout&lt;&lt;a[i][j]&lt;&lt;"  ";
				}
				if(i!=n-1) std::cout&lt;&lt;std::endl;
			}
			return a;
				}catch(...){
					for(int i = 0; i&lt;n; i++) delete[] a[i];
					delete[] a;
					throw;
				}
			
			}catch(...){
				std::cout&lt;&lt;"Problemi sa memorijom!";
			}
	}else{
		int n(BrojRedova2(v,koliko_puta));
			try{
				a=(new int*[n]);
				for(int i=0; i&lt;n; i++) a[i]=nullptr;
				try{
					for(int i=0; i&lt;n; i++) a[i]=new int[BrojKolona2(v,i,koliko_puta)];
					
					for(int i=0; i&lt;n; i++){
						int max(maks(v));
						for(int j=BrojKolona2(v,i,koliko_puta)-1; j&gt;=0; j--){
							a[i][j]=max;
							max--;
						}
					}
					std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
			for(int i=0; i&lt;n; i++){
				for(int j=0; j&lt;BrojKolona2(v,i,koliko_puta); j++){
					std::cout&lt;&lt;a[i][j]&lt;&lt;"  ";
				}
				if(i!=n-1) std::cout&lt;&lt;std::endl;
			}
				}catch(...){
					for(int i = 0; i&lt;n; i++) delete[] a[i];
					delete[] a;
					throw;
				}
			
			}catch(...){
				std::cout&lt;&lt;"Problemi sa memorijom!";
			}
	}
	return a;
}

int **AlocirajKontinualno(const std::vector&lt;int&gt;&amp;v, int &amp;koliko_puta){
	if(v.size()==0) throw "Izuzetak: Prazan vektor!";
	for(int i=0; i&lt;v.size(); i++){
		if(v[i]&lt;=0) throw std::domain_error("Izuzetak: Neispravan vektor!");
	}
	int period(OdrediOsnovniPeriod(v));
	int **a(nullptr);
	if(period){
		int n(BrojRedova1(v,koliko_puta));
		try{
				a=(new int*[n]);
				for(int i=0; i&lt;n; i++) a[i]=nullptr;
				try{
					int suma(0);
					for(int i=0; i&lt;n; i++) suma+=BrojKolona1(v,i,koliko_puta);
					a[0]=new int[suma];
					for(int i=1; i&lt;n; i++) a[i]=a[i-1]+BrojKolona1(v,i-1,koliko_puta);
					int k(0);
					for(int i=0; i&lt;n; i++){
						k=BrojKolona1(v,i,koliko_puta);
						for(int j=0; j&lt;BrojKolona1(v,i,koliko_puta); j++){
							a[i][j]=k--;			
						}
					}
			std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
			for(int i=0; i&lt;n; i++){
				for(int j=0; j&lt;BrojKolona1(v,i,koliko_puta); j++){
					std::cout&lt;&lt;a[i][j]&lt;&lt;"  ";
				}
				if(i!=n-1) std::cout&lt;&lt;std::endl;
			}
				}catch(...){
					delete[] a[0];
					throw;
				}
			
			}catch(...){
				delete a;
				std::cout&lt;&lt;"Problemi sa memorijom!";
			}
	}else{
		int n(BrojRedova2(v,koliko_puta));
			try{
				a=(new int*[n]);
				for(int i=0; i&lt;n; i++) a[i]=nullptr;
				try{
					int suma(0);
					for(int i=0; i&lt;n; i++) suma+=BrojKolona2(v,i,koliko_puta);
					a[0]=new int[suma];
					for(int i=1; i&lt;n; i++) a[i]=a[i-1]+BrojKolona2(v,i-1,koliko_puta);
					int k(0);
					for(int i=0; i&lt;suma; i++){
						k=BrojKolona2(v,i,koliko_puta);
						for(int j=0; j&lt;BrojKolona2(v,i,koliko_puta); j++){
							 a[i][j]=k--;
						}
					}
			std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
			for(int i=0; i&lt;n; i++){
				for(int j=0; j&lt;BrojKolona2(v,i,koliko_puta); j++){
					std::cout&lt;&lt;a[i][j]&lt;&lt;"  ";
				}
				if(i!=n-1) std::cout&lt;&lt;std::endl;
			}
				}catch(...){
					delete[] a[0];
					throw;
				}
			
			}catch(...){
				delete a;
				std::cout&lt;&lt;"Problemi sa memorijom!";
			}
	}
	return a;
}

int main ()
{
	int koliko_puta(0),n;
	std::vector&lt;int&gt;v{1,2,3,1};
	std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
	std::cin&gt;&gt;n;
	v.resize(n);
	std::cout&lt;&lt;"Unesite elemente vektora: ";
	for(int i=0; i&lt;n; i++) std::cin&gt;&gt;v[i];
	std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int alok(-1);
	std::cin&gt;&gt;alok;
	if(alok){
		try{
		int **p=AlocirajFragmentirano(v,koliko_puta);
		for(int i=0; i&lt;BrojRedova1(v,koliko_puta); i++) delete[] p[i];
		delete[] p;
		}catch(std::domain_error izuzetak){
			std::cout&lt;&lt;izuzetak.what();
		}catch(std::bad_alloc){
			std::cout&lt;&lt;"Nedovoljno memorije!";
		}catch(...){
			std::cout&lt;&lt;"Izuzetak: Prazan vektor!";
		}
	}else{
		try{
			int **p=AlocirajKontinualno(v,koliko_puta);
			delete[] p[0];
			delete[] p;
		}catch(std::domain_error izuzetak){
			std::cout&lt;&lt;izuzetak.what();
		}catch(std::bad_alloc){
			std::cout&lt;&lt;"Nedovoljno memorije!";
		}catch(...){
			std::cout&lt;&lt;"Izuzetak: Prazan vektor!";
</font>		}
	}
	return 0;
}</pre>
</body>
</html>
