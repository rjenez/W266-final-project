<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student6781.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3001.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;iomanip&gt;

template&lt;typename Tipint&gt;
bool ImaLi(std::vector&lt;Tipint&gt;v,int p)
{
	if(p&lt;1 || p&gt;=v.size())return false;
	for(int i(0);(i+p)&lt;v.size();i++)
	{
		if(v.at(i)!=v.at(i+p))return false;
	}
	return true;
}

template&lt;typename Tipint&gt;
int Osnovni(std::vector&lt;Tipint&gt;v)
{
	for(int i(1);i&lt;v.size();i++)
	{
		if(ImaLi(v,i))return i;
	}
	return 0;
}

template&lt;typename Tipint&gt;
Tipint** AlocirajFragmentirano(const std::vector&lt;Tipint&gt; &amp;v, int&amp; koliko_puta)
{
	if(v.size()==0)throw "Prazan vektor!";
<a name="1"></a><font color="#00FF00"><a href="match677-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

	for(int i(0);i&lt;v.size();i++)
	{
		if(v.at(i)&lt;=0)throw std::domain_error("Neispravan vektor!");
	}
	int e(Osnovni(v));
	if(e&gt;0)
</font>	{
		int a(v.size());
		while(a%e!=0)
		{
			a++;
		}
	
	koliko_puta=a/e;
	Tipint **pok(nullptr);
	try
	{
		pok=new Tipint* [koliko_puta*e];
		for(int i(0);i&lt;koliko_puta*e;i++)pok[i]=nullptr;
		try
		{
			int k(0);
			while(k&lt;koliko_puta*e)
			{
				for(int i(k);i&lt;e+k;i++)pok[i]=new Tipint[v.at(i-k)];
				k+=e;
			}
		}
		catch(std::bad_alloc)
		{
			for(int i(0);i&lt;koliko_puta*e;i++)delete[] pok[i];
			delete[] pok;
			throw std::bad_alloc();
		}
	}
	catch(std::bad_alloc)
	{
		throw std::bad_alloc();
	}
	int h(0);
	while(h&lt;koliko_puta*e)
	{
		int max(1);
		for(int i(0);i&lt;e;i++)
		{
			if(v.at(i)&gt;max)max=v.at(i);
		}
		for(int i(h);i&lt;h+e;i++)
		{
			int max1(max);
			for(int j(v.at(i-h)-1);j&gt;=0;j--)
			{
				//kontinualna pok[i][j]=(v.at(i-h)-j);
				pok[i][j]=max1;
				max1--;
			}
		}
		h+=e;
	}
	return pok;
	}
	
	if(e==0)
	{
		e=v.size();
		koliko_puta=2;
		Tipint **pok(nullptr);
		try
		{
			pok=new Tipint* [koliko_puta*e];
			for(int i(0);i&lt;koliko_puta*e;i++)pok[i]=nullptr;
			try
			{
				int k(0);
				while(k&lt;koliko_puta*e)
				{
					for(int i(k);i&lt;e+k;i++)pok[i]=new Tipint[v.at(i-k)];
					k+=e;
				}
			}
			catch(std::bad_alloc)
			{
				for(int i(0);i&lt;koliko_puta*e;i++)delete[] pok[i];
				delete[] pok;
				throw;
			}
		}
		catch(std::bad_alloc)
		{
			throw;
		}
		int h(0);
		while(h&lt;koliko_puta*e)
		{
			int max(1);
			for(int i(0);i&lt;e;i++)
			{
				if(v.at(i)&gt;max)max=v.at(i);
			}
			for(int i(h);i&lt;h+e;i++)
			{
				int max1(max);
				for(int j(v.at(i-h)-1);j&gt;=0;j--)
				{
					pok[i][j]=max1;
					max1--;
				}
			}
			h+=e;
		}
		return pok;
	}
	return nullptr;
}


template&lt;typename Tipint&gt;
Tipint** AlocirajKontinualno(const std::vector&lt;Tipint&gt; &amp;v, int&amp; koliko_puta)
{
	if(v.size()==0)throw "Prazan vektor!";
<a name="2"></a><font color="#0000FF"><a href="match677-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

	for(int i(0);i&lt;v.size();i++)
	{
		if(v.at(i)&lt;=0)throw std::domain_error("Neispravan vektor!");
	}
	int e(Osnovni(v));
	if(e&gt;0)
</font>	{
		int a(v.size());
		while(a%e!=0)
		{
			a++;
		}
	
	koliko_puta=a/e;
	int m(0);
<a name="3"></a><font color="#00FFFF"><a href="match677-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

	for(int i(0);i&lt;e;i++)
	{
		m+=v.at(i);
	}
	m*=koliko_puta;
	Tipint **pok(nullptr);
	try
	{
		pok=new Tipint* [koliko_puta*e];
</font>		for(int i(0);i&lt;koliko_puta*e;i++)pok[i]=nullptr;
		try
		{
			pok[0]=new Tipint[m];
			int k(0);
			while(k&lt;koliko_puta*e)
			{
				for(int i(k);i&lt;k+e;i++)
				{
					if(i==0)continue;
					int a=i-1-k;
					if(a==-1)a+=e;
				    a=v.at(a);
					pok[i]=pok[i-1]+a;
				}
				k+=e;
			}
		}
		catch(std::bad_alloc)
		{
			delete[] pok[0];
			delete[] pok;
			throw std::bad_alloc();
		}
	}
	catch(std::bad_alloc)
	{
		throw std::bad_alloc();
	}
	int h(0);
	while(h&lt;koliko_puta*e)
	{
		for(int i(h);i&lt;h+e;i++)
		{
			int a(1);
			for(int j(v.at(i-h)-1);j&gt;=0;j--)
			{
				
				pok[i][j]=a;
				a++;
			}
		}
		h+=e;
	}
	return pok;
	}
	
	
	if(e==0)
	{
		e=v.size();
	
	koliko_puta=2;
	int m(0);
	for(int i(0);i&lt;e;i++)
	{
		m+=v.at(i);
	}
	m*=koliko_puta;
	Tipint **pok(nullptr);
	try
	{
		pok=new Tipint* [koliko_puta*e];
		for(int i(0);i&lt;koliko_puta*e;i++)pok[i]=nullptr;
		try
		{
			pok[0]=new Tipint[m];
			int k(0);
			while(k&lt;koliko_puta*e)
			{
				for(int i(k);i&lt;k+e;i++)
				{
					if(i==0)continue;
					int a=i-1-k;
					if(a==-1)a+=e;
				    a=v.at(a);
					pok[i]=pok[i-1]+a;
				}
				k+=e;
			}
		}
		catch(std::bad_alloc)
		{
			delete[] pok[0];
			delete[] pok;
			throw std::bad_alloc();
		}
	}
	catch(std::bad_alloc)
	{
		throw std::bad_alloc();
	}
	int h(0);
	while(h&lt;koliko_puta*e)
	{
		for(int i(h);i&lt;h+e;i++)
		{
			int a(1);
			for(int j(v.at(i-h)-1);j&gt;=0;j--)
			{
				pok[i][j]=a;
				a++;
			}
		}
		h+=e;
	}
	return pok;
		
	}
	
	return nullptr;
}

int main ()
{
<a name="0"></a><font color="#FF0000"><a href="match677-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	try
	{
		std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
		int broj;
		std::cin&gt;&gt;broj;
		std::vector&lt;int&gt;v(broj);
		std::cout&lt;&lt;"Unesite elemente vektora: ";
		for(int i(0);i&lt;broj;i++)
</font>		{
			int n;
			std::cin&gt;&gt;n;
			v.at(i)=n;
		}
		std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		int al;
		std::cin&gt;&gt;al;
		if(al==1)
		{
			int koliko_puta;
			int** pok=AlocirajFragmentirano&lt;int&gt;(v,koliko_puta);
			std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
			int e(Osnovni(v));	
			if(e!=0)
			{
				
				int h(0);
				while(h&lt;koliko_puta*e)
				{
					for(int i(h);i&lt;h+e;i++)
					{
						for(int j(0);j&lt;v.at(i-h);j++)
						{
<a name="4"></a><font color="#FF00FF"><a href="match677-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

							std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
						}
						std::cout&lt;&lt;std::endl;
						delete[] pok[i];
</font>					}
					h+=e;
				}
				delete[] pok;
			}
			
			if(e==0)
			{
				e=v.size();	
				int h(0);
				while(h&lt;koliko_puta*e)
				{
					for(int i(h);i&lt;h+e;i++)
					{
						for(int j(0);j&lt;v.at(i-h);j++)
						{
							std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
						}
						std::cout&lt;&lt;std::endl;
						delete[] pok[i];
					}
					h+=e;
				}
				delete[] pok;
			}
		}
		
		if(al==0)
		{
			int koliko_puta;
			int** pok=AlocirajKontinualno&lt;int&gt;(v,koliko_puta);
			std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
			int e(Osnovni(v));	
			if(e!=0)
			{
				
				int h(0);
				while(h&lt;koliko_puta*e)
				{
					for(int i(h);i&lt;h+e;i++)
					{
						for(int j(0);j&lt;v.at(i-h);j++)
						{
							std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
						}
						std::cout&lt;&lt;std::endl;
					}
					h+=e;
				}
				delete[] pok[0];
				delete[] pok;
			}
			if(e==0)
			{
				e=v.size();	
				int h(0);
				while(h&lt;koliko_puta*e)
				{
					for(int i(h);i&lt;h+e;i++)
					{
						for(int j(0);j&lt;v.at(i-h);j++)
						{
							std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
						}
						std::cout&lt;&lt;std::endl;
					}
					h+=e;
				}
				delete[] pok[0];
				delete[] pok;
			}			
		}
	}
	catch(std::bad_alloc)
	{
		std::cout&lt;&lt;"Nedovoljno memorije!";
	}
	catch(const char poruka[])
	{
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka;
	}
	catch(std::domain_error Izuzetak)
	{
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;Izuzetak.what();
	}
	return 0;
}</pre>
</body>
</html>
