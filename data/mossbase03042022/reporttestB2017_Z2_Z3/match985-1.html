<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student6267.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3671.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;type_traits&gt;
using namespace std;

template&lt;typename Tip&gt;
int TestPerioda(vector&lt;Tip&gt;v,int p)
{
	if(p&lt;1 || v.size()&lt;1 || p&gt;=v.size())
		return 0;
<a name="0"></a><font color="#FF0000"><a href="match985-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

	for(int i=0; i&lt;v.size()-p; i++) {
		if(v[i]!=v[i+p])
			return false;
	}
	return true;
}

template&lt;typename Tip&gt;
int OdrediOsnovniPeriod(vector&lt;Tip&gt;h)
{
	for(int i=0; i&lt;h.size(); i++) {
		if(TestPerioda(h,i))
			return i;
	}
	return 0;
}

template&lt;typename T&gt;
</font>void Parametri(const vector&lt;T&gt;&amp;v,int &amp;koliko_puta,int &amp;period)
{
	period=OdrediOsnovniPeriod(v);
	if(period==0) {
		koliko_puta=2;
		period=v.size();
	}
	koliko_puta=v.size()/period;
	if(v.size()%koliko_puta!=0 || koliko_puta==1) {
		if(koliko_puta==1) {
			koliko_puta=2;
		} else koliko_puta++;
	}
}

//template&lt;typename Tip&gt;
//int** AlocirajFragmentirano(const vector&lt;int&gt;&amp;v,int &amp;koliko_puta)
/*typename remove_const&lt;typename remove_reference&lt;decltype(v[0])&gt;::type&gt;::type** */
//{
/* typedef typename remove_const&lt;typename remove_reference&lt;decltype(v[0])&gt;::type&gt;::type tip; */
/*	if(v.size()==0) {
		throw range_error("Prazan vektor!");
	}
	for(int i=0; i&lt;v.size(); i++) {
		if(v[i]&lt;0) throw domain_error("Neispravan vektor!");
	}
	int period;
	Parametri(v,koliko_puta,period);
	try {
		int **p=new int*[period*koliko_puta];
		for(int i=0; i&lt;v.size(); i++) {
			p[i]=nullptr;
		}
		try {
			for(int i=0; i&lt;period*koliko_puta; i++) {
				p[i]=new int[v[i%v.size()]];
			}
			int max=*max_element(v.begin(),v.end());
			for(int i=0; i&lt;period*koliko_puta; i++) {
				int l=max-v[i%period]+1;
				for(int j=0; j&lt;v[i%period]; j++) {
					p[i][j]=l++;
				}
			}
			return p;
		} catch(bad_alloc) {
			for(int i=0; i&lt;(period*koliko_puta); i++) delete[] p[i];
			delete[] p;
			throw;
		}
	} catch(...) {
		throw;
	}

	return 0;
}*/


int **AlocirajFragmentirano(const vector&lt;int&gt;&amp;v,int &amp;koliko_puta)
{
	int period=OdrediOsnovniPeriod(v);
	cout&lt;&lt;"period: "&lt;&lt;period&lt;&lt;endl;
	if(period==0) {
		period=v.size();
		cout&lt;&lt;"period: "&lt;&lt;period&lt;&lt;endl;
		int i=0;
		while(i&lt;6) {
			cout&lt;&lt;"i%period: "&lt;&lt;i%period&lt;&lt;endl;
			i++;
		}
		koliko_puta=2;
		try {
			int **p=new int*[period*koliko_puta];
			for(int i=0; i&lt;v.size(); i++) {
				p[i]=nullptr;
			}
			try {
				for(int i=0; i&lt;period*koliko_puta; i++) {
					p[i]=new int[int(v[i%period])];
				}
				int max=*max_element(v.begin(),v.end());
				for(int i=0; i&lt;period*koliko_puta; i++) {
					int l=max-v[i%period]+1;
					for(int j=0; j&lt;v[i%period]; j++) {
						p[i][j]=l++;
					}
				}
				return p;
			} catch(bad_alloc) {
				for(int i=0; i&lt;(period*koliko_puta); i++) delete[] p[i];
				delete[] p;
				throw;
			}
		} catch(...) {
			throw;
		}
	}
	return 0;
}


template&lt;typename t&gt;
int BrElemenata(const vector&lt;t&gt;&amp;v,int koliko_puta,int period)
{
	int n(0);
	for(int i=0; i&lt;koliko_puta*period; i++) {
		n+=v[i%period];
	}
	return n;
}

//template&lt;typename Tip&gt;
<a name="1"></a><font color="#00FF00"><a href="match985-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

int** AlocirajKontinualno(const vector&lt;int&gt;&amp;v,int &amp;koliko_puta)
/*typename remove_const&lt;typename remove_reference&lt;decltype(v[0])&gt;::type&gt;::type** */
{
	/* typedef typename remove_const&lt;typename remove_reference&lt;decltype(v[0])&gt;::type&gt;::type tip1; */
	if(v.size()==0) {
		throw range_error("Prazan vektor!");
	}
	for(int i=0; i&lt;v.size(); i++) {
		if(v[i]&lt;0) throw domain_error("Neispravan vektor!");
</font>	}
	int period;
	Parametri(v,koliko_puta,period);
	try {
		int **p=new int*[period*koliko_puta];
		try {
			p[0]=new int[BrElemenata(v,koliko_puta,period)];
			for(int i=0; i&lt;period*koliko_puta; i++) {
				p[i+1]=p[i]+v[i%period];
			}
			int l=0;
			for(int i=0; i&lt;period*koliko_puta; i++) {
				l=v[i%period];
				for(int j=0; j&lt;v[i%period]; j++) {
					p[i][j]=l--;
				}
			}
			return p;
		} catch(bad_alloc) {
			delete[] p;
			throw;
		}
	} catch(...) {
		throw;
	}
	return 0;
}

int main ()
{
	int n;
	cout&lt;&lt;"Unesite broj elemenata vektora: ";
	cin&gt;&gt;n;
<a name="2"></a><font color="#0000FF"><a href="match985-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	vector&lt;int&gt;v;
	cout&lt;&lt;"Unesite elemente vektora: ";
	for(int i=0; i&lt;n; i++) {
		int element;
		cin&gt;&gt;element;
		v.push_back(element);
</font>	}
	int odabir;
	cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	cin&gt;&gt;odabir;
	int period=OdrediOsnovniPeriod(v);
	try {
		if(odabir==1) {
			int k=0;
			//Parametri(v,k,period);
			int **p=AlocirajFragmentirano(v,k);
			cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;endl;
			for(int i=0; i&lt;period*k; i++) {
				for(int j=0; j&lt;v[i%period]; j++) {
					cout&lt;&lt;left&lt;&lt;setw(3)&lt;&lt;p[i][j];
				}
				cout&lt;&lt;endl;
			}
			for(int i=0; i&lt;period*k; i++) delete[] p[i];
			delete[] p;
		}
		if(odabir==0) {
			int k=0;
			int **p=AlocirajKontinualno(v,k);
			cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;endl;
			for(int i=0; i&lt;period*k; i++) {
				for(int j=0; j&lt;v[i%period]; j++) {
					cout&lt;&lt;left&lt;&lt;setw(3)&lt;&lt;p[i][j];
				}
				cout&lt;&lt;endl;
			}
			delete[] p[0];
			delete[] p;
		}
	} catch(domain_error x) {
		cout&lt;&lt;"Izuzetak: "&lt;&lt;x.what();
	} catch(range_error h) {
		cout&lt;&lt;"Izuzetak: "&lt;&lt;h.what();
	}
	return 0;
}
</pre>
</body>
</html>
