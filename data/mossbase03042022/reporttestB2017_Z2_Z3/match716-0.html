<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1704.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1704.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

template &lt;typename NekiTip&gt;
int ** AlocirajFragmentirano(const std::vector&lt;NekiTip&gt; &amp;v, int &amp;koliko_puta) {

int **a;
	if(v.size()==0) throw("Izuzetak: Prazan vektor!");

	bool nije_period(false);
	int period(0);
	for(int i=0; i&lt;v.size(); i++) {
		for(int j=0; j&lt;v.size(); j++) {
			if(j+i&lt;v.size()) {
				if(v.at(j)!=v.at(j+i)) nije_period =true;
			}
		}
		if(!nije_period &amp;&amp; period==0) period=i; 
		nije_period=false;
	}
	
	if(period!=0) {
		if(v.size()%period!=0) koliko_puta=int(v.size()/period)+1;
		else koliko_puta=v.size()/period;
	}
	else {
		koliko_puta=2;
		period=v.size();
	}
	
	
	try {
		a = new int* [koliko_puta*period];
	}
	catch(...) {
		throw;
	}
	
	try {
		for(int i=0; i&lt;koliko_puta*period; i++) a[i]=nullptr;
		int k=0; 
		for(int i=0; i&lt;koliko_puta*period; i++) {
			if(v.at(k)&lt;=0) throw std::domain_error("Izuzetak: Neispravan vektor!");
			a[i]=new int [v.at(k)];
			k++;
			if(k==period) k=0;
		}
		
		int m=period-1;
		int n=0;
		
		for(int i=0; i&lt;period*koliko_puta; i++) {
			for(int j=v[n]-1; j&gt;=0; j--) {
				a[i][j]=v[m];
				m--;
				if(m&lt;0) j=-1;
			
			}
			m=period-1;
<a name="2"></a><font color="#0000FF"><a href="match716-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

			n++;
			if(n==period) n=0;
		}
	}
	catch(...) {
		for(int i=0; i&lt;period*koliko_puta; i++) delete [] a[i];
		delete [] a;
</font>		throw;
	}
	return a;
}

template &lt;typename Tip&gt;
int **AlocirajKontinualno(const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta) {
	int **a;
	if(v.size()==0) throw("Izuzetak: Prazan vektor!");
	
	bool nije_period(false);
	int period(0);
	for(int i=0; i&lt;v.size(); i++) {
		for(int j=0; j&lt;v.size(); j++) {
			if(j+i&lt;v.size()) {
				if(v.at(j)!=v.at(j+i)) nije_period=true;
			}
		}
		if(!nije_period &amp;&amp; period==0) period=i;
		nije_period=false;
	}
	
	if(period!=0) {
		if(v.size()%period!=0) koliko_puta=int(v.size()/period)+1;
		else koliko_puta=v.size()/period;
	}
	else {
		koliko_puta=2;
		period=v.size();
	}
	

		try{
			a=new int* [koliko_puta*period];
		}
		catch(...) {
			throw;
		}
	
	
	try {
		int broj(0);
		int k=0;
		for(int i=0; i&lt;period*koliko_puta; i++) {
			if(v.at(i)&lt;=0) throw std::domain_error("Izuzetak: Neispravan vektor!");
			broj+=v.at(k);
			k++;
			if(k==period) k=0;
		}
	
		a[0]=new int [broj];
		
		k=0;
<a name="1"></a><font color="#00FF00"><a href="match716-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

		for(int i=1; i&lt;koliko_puta*period; i++) {
			a[i]=a[i-1]+v.at(k);
			k++;
			if(k==period) k=0;
</font>		}
		
	    int m=0;
		int n=0;
		
		for(int i=0; i&lt;period*koliko_puta; i++) {
			for(int j=v[n]-1; j&gt;=0; j--) {
				a[i][j]=v[m];
				m++;
				if(m==period) j=-1;
			}
			m=0;
			n++;
			if(n==period) n=0;
		}
		
	}
	catch(...) {
		delete [] a;
		throw;
	}
	
	return a;
	
	}



int main ()
{
	int n;
	std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
	std::cin&gt;&gt;n;
	std::vector&lt;int&gt; v;
	std::cout&lt;&lt;"Unesite elemente vektora: ";
	for(int i=0; i&lt;n; i++) {
		int broj;
		std::cin&gt;&gt;broj;
		v.push_back(broj);
	}
	
	bool nije_period(false);
	int period(0);
	for(int i=0; i&lt;v.size(); i++) {
		for(int j=0; j&lt;v.size(); j++) {
			if(j+i&lt;v.size()) {
				if(v.at(j)!=v.at(j+i)) nije_period=true;
			}
		}
		if(!nije_period &amp;&amp; period==0) period=i;
		nije_period=false;
	}
	if(period==0) period=v.size();
	
	
	int alloc;
	std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	std::cin&gt;&gt;alloc;
	int koliko_puta;
	
	if(alloc) {
		try {
		int** a=AlocirajFragmentirano(v,koliko_puta);
		std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
		int k=0;
		for(int i=0; i&lt;period*koliko_puta; i++) {
			for(int j=0; j&lt;v[k]; j++) {
				std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;a[i][j];
			}
<a name="0"></a><font color="#FF0000"><a href="match716-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

			k++;
			if(k==period) k=0;
			std::cout&lt;&lt;std::endl;
		}
		for(int i=0; i&lt;koliko_puta*period; i++) delete [] a[i];
		delete [] a;
</font>		}
	
	catch(const char poruka[]) {
		std::cout&lt;&lt;poruka;
	}
	catch(std::domain_error poruka) {
		std::cout&lt;&lt;poruka.what();
	}
	catch(...) {
		std::cout&lt;&lt;"Alokacija nije uspjela!";
	}
	}
	
	else {
		try {
			int ** a=AlocirajKontinualno(v,koliko_puta);
			std::cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;std::endl;
			int k=0;
			for(int i=0; i&lt;period*koliko_puta; i++) {
				for(int j=0; j&lt;v[k]; j++) {
					std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;a[i][j];
				}
				k++;
<a name="3"></a><font color="#00FFFF"><a href="match716-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

				if(k==period) k=0;
				std::cout&lt;&lt;std::endl;
			}
			delete [] a[0];
			delete [] a;
		}
		catch(const char poruka[]) {
</font>			std::cout&lt;&lt;poruka;
		}
		catch(std::domain_error poruka) {
			std::cout&lt;&lt;poruka.what();
		}
		catch(...) {
			std::cout&lt;&lt;"Alokacija nije uspjela!";
		}
	}
	
	return 0;
}</pre>
</body>
</html>
