<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4665.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4665.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;new&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;

template &lt;typename Tip&gt;
Tip **AlocirajFragmentirano(const std::vector&lt;Tip&gt; &amp;v, int koliko_puta) {
    Tip **p(nullptr);
    if (!(v.size())) throw "Prazan vektor!";
    int period(1);
	for(int i = 1; i &lt; v.size(); i++) if(v[i] == v[0]) period = i;
    Tip max(*std::max_element(&amp;v[0], &amp;v[period]));
    try {
        p = new Tip*[period*koliko_puta];
        for (int i = 0; i &lt; period*koliko_puta; i++) p[i] = nullptr;
        for (int i = 0; i &lt; koliko_puta; i++)
            for(int j = 0; j &lt; period; j++) {
                p[i*period + j] = new Tip[v[j]];
                for (int k = 0; k &lt; v[j] ; k++) {
                    p[i*period + j][v[j] - 1 -k] = max - k;
                }
            }
    } catch(...) {
        if (p) 
        for (int i = 0; i &lt; period*koliko_puta; i++) delete[] p[i];
        delete[] p;
        throw;
    }
    return p;
}

template &lt;typename Tip&gt;
Tip **AlocirajKontinualno(const std::vector&lt;Tip&gt; &amp;v, int koliko_puta) {
	Tip **p(nullptr);
	if(v.size() == 0) throw "Prazan vektor!";
	int period(1);
	for(int i = 1; i &lt; v.size(); i++) if(v[i] == v[0]) period = i;
	try {
	p = new Tip*[(v.size())*koliko_puta];
    p[0] = nullptr;
        int br_el(0);
        for (int i = 0; i &lt; period; i++) br_el += v[i];
        p[0] = new Tip[br_el*koliko_puta];
        for (int i = 1; i &lt; period; i++) p[i] = p[i - 1] + v[i-1];
        for (int k = 1; k &lt; koliko_puta; k++) {
            p[k*period] = p[k*period -1] + v[period - 1];
            for (int i = 1; i &lt; period; i++) p[k*period + i] = p[k*period + i - 1] + v[i-1];
        }
        for (int i = 0; i &lt; koliko_puta; i++)
        for (int j = 0; j &lt; period; j++) {
            for (int l = 0; l &lt; v[j] ; l++) {
                p[i*period + j][l] = v[j] - l;
            }
        }
	} catch(...){
		if (p) 
        for (int i = 0; i &lt; period*koliko_puta; i++) delete[] p[i];
        delete[] p;
        throw;
	}
	return p;
}

template &lt;typename Tip&gt;
Tip **Kreiraj(std::vector&lt;Tip&gt; &amp;v, bool fragmentirano, int &amp;koliko_puta) {
      Tip **pokic(nullptr);
      if (!(v.size())) throw "Prazan vektor!";

      for (int i = 0; i &lt; v.size(); i++) if(v[i] &lt;= 0) throw std::domain_error("Neispravan vektor!");

          koliko_puta = 1;
          for (int i = 1; i &lt; v.size(); i++) {
              bool indikator = false;
              if (v[i] == v[0]){
                  if (i == v.size() - 1)  {
                      int j(1);
                      while(v[j] != v[0]) {
                          v.push_back(v[j]);
                          j++;
                      }
                      koliko_puta++;
                      indikator = true;
                  } else{
                      int j(i);
                      while(v[j] != v[0] &amp;&amp; j != v.size() - 1) {
                          j++;
                      }
                      if(v[j] == v[0]) {
                          koliko_puta++;
                      } else {
                          if(j == v.size() - 1) {
                              koliko_puta++;
                              indikator = true;
                          }
                      }
                  }
                  
              }
              if(indikator) i = v.size();
          }

      if(koliko_puta == 1) {
          int j = v.size();
          for(int i = 0; i &lt; j; i++) v.push_back(v[i]);
          koliko_puta++;
      }
      try {
      if (fragmentirano) pokic = AlocirajFragmentirano(v, koliko_puta);
      else pokic = AlocirajKontinualno(v, koliko_puta);
      }
      catch(...) {
            throw;
      }
      return pokic;
}
int main ()
{
	try {
        int n;
<a name="0"></a><font color="#FF0000"><a href="match734-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
        std::cin &gt;&gt; n;
        std::vector&lt;int&gt; v(n);
        std::cout &lt;&lt; "Unesite elemente vektora: ";
        for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; v[i];
        bool fragmentirano;
</font>        std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
        std::cin &gt;&gt; fragmentirano;
        int koliko_puta;
        int **p(Kreiraj(v, fragmentirano, koliko_puta));
        std::cout &lt;&lt; "Dinamicki alocirana matrica:" &lt;&lt; std::endl;
        int k(0);
         int period(1);
	     for(int i = 1; i &lt; v.size(); i++) if(v[i] == v[0]) period = i;
        for(int i = 0; i &lt; period*koliko_puta; i++) {
            if (k == period) k = 0;
<a name="1"></a><font color="#00FF00"><a href="match734-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

            for(int j = 0; j &lt; v[k]; j++) std::cout &lt;&lt; std::setw(3) &lt;&lt; std::left &lt;&lt; p[i][j];
            std::cout &lt;&lt; std::endl;
</font>            k++;
        }
        
        if (p) {
            if(fragmentirano) for (int i = 0; i &lt; period*koliko_puta; i++) delete[] p[i];
            else delete[] p[0];
        }
        delete[] p;
    } 
<a name="2"></a><font color="#0000FF"><a href="match734-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

    catch(const char poruka[]) {
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; poruka &lt;&lt; std::endl;
    }
    catch(std::domain_error e) {
        std::cout &lt;&lt; "Izuzetak: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(...) {
</font>        std::cout &lt;&lt; "Izuzetak: ";
    }
    return 0;
}</pre>
</body>
</html>
