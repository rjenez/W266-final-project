<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student7090.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8815.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;new&gt;

<a name="0"></a><font color="#FF0000"><a href="match104-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template&lt;typename tip&gt;
bool TestPerioda(std::vector&lt;tip&gt; v, int p)
{
	if(p&gt;=v.size() || p&lt;1) return false;
	else if(v[0]!=v[p]) return false;
	else if(v[0]==v[p]) {
		for(int i=1; i&lt;(v.size()-p); i++)
			if(v[i]!=v[i+p]) return false;
	}
	return true;
}

template&lt;typename cjel_tip&gt;
int **AlocirajFragmentirano(const std::vector&lt;cjel_tip&gt; &amp;v, int &amp;koliko_puta)
{
	if(v.size()==0) throw "Prazan vektor!";
	int T(v.size());
	for(int i=1; i&lt;v.size(); i++)
		if(TestPerioda(v, i)) {
			T=i;
			break;
		}
	//koliko puta
	if(T!=v.size()) {
		for(int i=0; i&lt;v.size(); i++)
			if((T*i)&gt;=v.size()) {
				koliko_puta=i;
				break;
			}
	} else if(T==v.size()) koliko_puta=2;
	for(int i=0; i&lt;v.size(); i++) {
		if(v[i]&lt;=0) throw std::domain_error ("Neispravan vektor!");
	}
	//alokacija matrice
	try {
		int **pok(new int*[T*koliko_puta] {});
		try {
			int vvel(0);
			auto pocetak(pok);
			for(int i=0; i&lt;T*koliko_puta; i++) {
				pok[i]=new int[v[vvel]];
				vvel++;
				if(vvel==T) vvel=0;
			}
			vvel=0;
			for(int i=0; i&lt;T*koliko_puta; i++) {
				int maax=int(*std::max_element(v.begin(), v.end()));
				for(int j=v[vvel]-1; j&gt;=0; j--)
					pok[i][j]=maax--;
				vvel++;
				if(vvel==T) vvel=0;
			}
			return pocetak;
		} catch(...) {
			for(int i=0; i&lt;v.size(); i++)
				delete[] pok[i];
			delete[] pok;
			throw;
		}
	} catch(...) {
		throw;
	}
}

template&lt;typename cjel_tip&gt;
int **AlocirajKontinualno(const std::vector&lt;cjel_tip&gt; &amp;v, int &amp;koliko_puta)
{
	if(v.size()==0) throw "Prazan vektor!";
	int T(v.size()), duzina(0);
	for(int i=1; i&lt;v.size(); i++)
		if(TestPerioda(v, i)) {
			T=i;
			break;
		}
	//prosiriti vektor
	if(T!=v.size()) {
		for(int i=0; i&lt;v.size(); i++)
			if((T*i)&gt;=v.size()) {
				koliko_puta=i;
				break;
			}
	} else if(T==v.size()) koliko_puta=2;
	for(int i=0; i&lt;T; i++) {
		if(v[i]&lt;=0) throw std::domain_error ("Neispravan vektor!");
		duzina+=v[i];
	}
	//alokacija matrice
	try {
		int **pok(new int*[T*koliko_puta] {});
		try {
			auto pocetak(pok);
			pok[0]=new int[duzina*koliko_puta];
			int vvel(0);
			for(int i=1; i&lt;T*koliko_puta; i++) {
				pok[i]=pok[i-1]+v[vvel];
				vvel++;
				if(vvel==T) vvel=0;
			}
			vvel=0;
			for(int i=0; i&lt;T*koliko_puta; i++) {
				int br(1);
				for(int j=v[vvel]-1; j&gt;=0; j--) {
					pok[i][j]=br++;
				}
				vvel++;
				if(vvel==T) vvel=0;
			}
			return pocetak;
		} catch(...) {
			delete[] pok[0];
			delete[] pok;
			throw;
		}
	} catch(...) {
		throw;
	}
}

int main ()
{
	int n, alok, koliko_puta;
	std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
	std::cin&gt;&gt;n;
	try {
		std::vector&lt;int&gt; v(n);
		std::cout&lt;&lt;"Unesite elemente vektora: ";
		for(int i=0; i&lt;n; i++) std::cin&gt;&gt;v[i];
		std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		std::cin&gt;&gt;alok;
		int period(v.size());
		for(int i=1; i&lt;v.size(); i++) {
			if(TestPerioda(v, i)) {
				period=i;
				break;
			}
		}
		int **pok, vvel(0);
		if(alok==0) pok=AlocirajKontinualno(v, koliko_puta);
		else if(alok==1) pok=AlocirajFragmentirano(v, koliko_puta);
		std::cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;std::endl;
		for(int i=0; i&lt;period*koliko_puta; i++) {
			for(int j=0; j&lt;v[vvel]; j++) std::cout&lt;&lt;std::left&lt;&lt;std::setw(3)&lt;&lt;pok[i][j];
			std::cout&lt;&lt;std::endl;
			vvel++;
			if(vvel==period) vvel=0;
		}
		if(alok==1) {
			for(int i=0; i&lt;period*koliko_puta; i++)
				delete[] pok[i];
		} else if(alok==0) delete[] pok[0];
		delete[] pok;
	} catch(std::bad_alloc izuz) {
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuz.what()&lt;&lt;std::endl;
	} catch(std::domain_error izuz2) {
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;izuz2.what()&lt;&lt;std::endl;
	} catch(const char poruka[]) {
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka&lt;&lt;std::endl;
	}
	return 0;
</font>}</pre>
</body>
</html>
