<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1483.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student1483.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
<a name="0"></a><font color="#FF0000"><a href="match2-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;
template&lt;typename tip1&gt;
int DajPeriod(vector&lt;tip1&gt; w){
	int period(0);
	for(int i=1;i&lt;w.size();i++){
		for(int j=0;i&lt;w.size();j++){
			if((j+i)&lt;w.size()){
				if(w.at(j)!=w.at(j+i))break;
			}
			if(j==(w.size()-1)){
				period=i;
				break;
			}
		}
		if(period!=0)break;
	}
	return period;
}
template&lt;typename tip&gt;
tip **AlocirajFragmentirano(const vector&lt;tip&gt; &amp;v,int &amp;koliko_puta){
	for(int i=0;i&lt;v.size();i++){
		if(v.at(i)&lt;=0) throw domain_error("Neispravan vektor!");
	}
	if(v.size()==0) throw domain_error("Prazan vektor!");
	int p,k=0;
	tip **mat(nullptr);
	int brojac=0;
	p=DajPeriod(v);
	tip max=v.at(0);
	for(int i=0;i&lt;v.size();i++){
		if(v.at(i)&gt;max){
			max=v.at(i);
		}
	}
	if(p!=0){
		if((v.size())%p!=0){
			while((v.size()+brojac)%p!=0){
			brojac++;
			}
		koliko_puta=(v.size()+brojac)/p;
		try{
			mat=new tip*[v.size()+brojac];
			for(int i=0;i&lt;(v.size()+brojac);i++){
				if(i&lt;v.size()){
					try{
			  	mat[i]=new tip[v.at(i)];
				}
				catch(...){
					throw;
				}
				}
				else{
					mat[i]=new tip[v.at(i-p)];
				}
			}
			
		}
		catch(...){
		
			throw;
		}
		}
	else{
		koliko_puta=(v.size()+brojac)/p;
		mat=new tip*[v.size()+brojac];
			for(int i=0;i&lt;(v.size()+brojac);i++){
				if(i&lt;v.size()){
				mat[i]=new tip[v.at(i)];
				}
				else{
					mat[i]=new tip[v.at(i-p)];
				}
			}
    	}
	for(int i=0;i&lt;v.size()+brojac;i++){
		if(i&lt;v.size()){
			if(i&gt;max-1 &amp;&amp; k&gt;max-1) k=0;
		 for(int j=0;j&lt;v.at(i);j++){
		 	
		 	if(k==j){
		 		
		 		mat[i][j]=max;
		 	}
			else{
				mat[i][j]=max-k+j;
			}
			
	      }
	      k++;
	
	    }
     	else{
     		
     		for(int j=0;j&lt;v.at(i-p);j++){
     			if(k==j){
     			mat[i][j]=max;	
     			}
     			else{
     			mat[i][j]=max-k+j;
     			}
     		} 
     	}
	}
		
	return mat;
}
else{
	koliko_puta=2;
	try{
	mat=new tip*[(v.size())*2];
	for(int i=0;i&lt;2*v.size();i++){
		if(i&lt;v.size()){
	   try{
		mat[i]=new tip[v.at(i)];
	   }
	   catch(...){
	   	throw;
	   }
		}
	else{
		
		mat[i]=new tip[v.at(i-v.size())];
		
	 }
   }
 }
 catch(...){
 		
 	throw;
 }
 for(int i=0;i&lt;2*v.size();i++){
 	if(i&lt;v.size()){
 		if(i&gt;=v.size() &amp;&amp; k&gt;=v.size()) k=0;
 	for(int j=0;j&lt;v.at(i);j++){
 		if(k==j){
 		mat[i][j]=max;
 		}
 		else{
 			mat[i][j]=max-k+j;
 		}
 	}
 	k++;
  }
  else{
  	if(k&gt;=v.size())k=0;
  	for(int j=0;j&lt;v.at(i-v.size());j++){
  		
  		if(k==j){
  	mat[i][j]=max;
  	
  		}
  		else{
  			mat[i][j]=max-k+j;
  		}
  	}
  	k++;
  }
 }
}
return mat;
}
template&lt;typename tip&gt;
tip **AlocirajKontinualno(const vector&lt;tip&gt; &amp;v,int &amp;koliko_puta){
	for(int i=0;i&lt;v.size();i++){
		if(v.at(i)&lt;=0) throw domain_error("Neispravan vektor!");
	}
	if(v.size()==0) throw domain_error("Prazan vektor!");
	int p;
	tip **mat(nullptr);
	int brojac(0),brel(0);
	p=DajPeriod(v);
	if(p!=0){
		if((v.size())%p!=0){
			while((v.size()+brojac)%p!=0){
				brojac++;
			}
			for(int i=0;i&lt;v.size()+brojac;i++){
				if(i&lt;v.size()){
					brel=brel+v.at(i);
				}
				else{
					brel=brel+v.at(i-p);
				}
			}
			koliko_puta=(v.size()+brojac)/p;
			try{
				mat=new tip*[v.size()+brojac];
				mat[0]=new tip[brel];
				for(int i=1;i&lt;v.size()+brojac;i++){
					if(i&lt;v.size()){
					mat[i]=mat[i-1]+v.at(i-1);
					}
					else{
						mat[i]=mat[i-1]+v.at(i-p-1);
					}
				}
			}
			catch(...){
				throw;
			}
		 }
		else{
			koliko_puta=(v.size())/p;
			try{
				mat=new tip*[v.size()];
				for(int i=0;i&lt;v.size()+brojac;i++){
					brel=brel+v.at(i);
				}
				mat[0]=new tip[brel];
				for(int i=1;i&lt;v.size();i++){
					mat[i]=mat[i-1]+v.at(i);
				}
			}
			catch(...){
				throw;
			}
		}
		for(int i=0;i&lt;v.size()+brojac;i++){
			if(i&lt;v.size()){
			for(int j=0;j&lt;v.at(i);j++){
				mat[i][j]=v.at(i)-j;
			}
			}
			else{
				for(int j=0;j&lt;v.at(i-p);j++){
					mat[i][j]=v.at(i-p)-j;
				}
			}
		}
		return mat;
	}
	else{
		for(int i=0;i&lt;2*v.size();i++){
			if(i&lt;v.size()){
			 brel=brel+v.at(i);
			}
			else{
			 brel=brel+v.at(i-v.size());
			}
		}
		mat=new tip*[2*(v.size())];
		mat[0]=new tip[brel];
		for(int i=1;i&lt;2*(v.size());i++){
			if(i&lt;=v.size()){
				mat[i]=mat[i-1]+v.at(i-1);
			}
			else{
				mat[i]=mat[i-1]+v.at(i-v.size());
			}
		}
		for(int i=0;i&lt;2*v.size();i++){
			if(i&lt;v.size()){
			for(int j=0;j&lt;v.at(i);j++){
				mat[i][j]=v.at(i)-j;
			 }
			}
			else{
				for(int j=0;j&lt;v.at(i-v.size());j++){
					mat[i][j]=v.at(i-v.size())-j;
				}
			}
		}
	}
return mat;
}

int main (){
	
		int n,x,f,koliko(0);
		int T;
			int **mat;
		try{
		vector&lt;int&gt; v;
		cout&lt;&lt;"Unesite broj elemenata vektora: ";
		cin&gt;&gt;n;
		cout&lt;&lt;"Unesite elemente vektora: ";
		for(int i=0;i&lt;n;i++){
			cin&gt;&gt;x;
			v.push_back(x);
		}
		T=DajPeriod(v);
		cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
		cin&gt;&gt;f;
		if(f==1){
			mat=AlocirajFragmentirano(v,koliko);
			cout&lt;&lt;"Dinamicki alocirana matrica: ";
			cout&lt;&lt;endl;
			if(T!=0){
				for(int i=0;i&lt;T*koliko;i++){
				if(i&lt;v.size()){
				for(int j=0;j&lt;v.at(i);j++){
					cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;mat[i][j];
				}
				cout&lt;&lt;endl;
				}
				else{
					for(int j=0;j&lt;v.at(i-T);j++){
						cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;mat[i][j];
					}
				
				cout&lt;&lt;endl;
			}
			}
			for(int i=0;i&lt;T*koliko;i++){
		     delete [] mat[i];
	         }
        	 delete [] mat;
	         return 0;
		}
		else{
			for(int i=0;i&lt;2*v.size();i++){
				if(i&lt;v.size()){
					for(int j=0;j&lt;v.at(i);j++){
						cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;mat[i][j];
					}
					cout&lt;&lt;endl;
				}
				else{
					for(int j=0;j&lt;v.at(i-v.size());j++){
						cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;mat[i][j];
					}
					cout&lt;&lt;endl;
				}
			}
			for(int i=0;i&lt;2*v.size();i++){
		     delete [] mat[i];
	         } 
	         delete [] mat;
	         return 0;
				
		}
		
	}
	else{
		if(T!=0){
		mat=AlocirajKontinualno(v,koliko);
		cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;endl;
		for(int i=0;i&lt;T*koliko;i++){
			if(i&lt;v.size()){
			for(int j=0;j&lt;v.at(i);j++){
				cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;mat[i][j];
			}
			cout&lt;&lt;endl;
		  }
		  else{
		  	for(int j=0;j&lt;v.at(i-T);j++){
		  		cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;mat[i][j];
		  	}
		  	cout&lt;&lt;endl;
		  }
		}
		delete [] mat[0];
		delete [] mat;
	}
	else{
		mat=AlocirajKontinualno(v,koliko);
		cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;endl;
		for(int i=0;i&lt;2*v.size();i++){
			if(i&lt;v.size()){
				for(int j=0;j&lt;v.at(i);j++){
					cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;mat[i][j];
				}
				cout&lt;&lt;endl;
			}
			else{
				for(int j=0;j&lt;v.at(i-v.size());j++){
					cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;mat[i][j];
				}
				cout&lt;&lt;endl;
			}
		}
			delete [] mat[0];
		    delete [] mat;
	}
		}
		}
	catch(domain_error izuzetak){
		cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
		return 0;
</font>	}
}</pre>
</body>
</html>
