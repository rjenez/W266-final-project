<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4682.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4682.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match35-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using std::cin;
using std::cout;

template &lt;typename tip&gt;
int Periodican(std::vector&lt;tip&gt; v) {
	int i(0), period(0);
	while(1) {
	for(int k=1; k&lt;(v.size()/2); k++) {
		while(v[i]==v[i+k]) {
			i++;
			if(i==v.size()/2) {
				period=k;
				break;
			}
		}
	}
	if(period==0) break;
	}
	return period;
}

template &lt;typename tip&gt;
tip NadjiMaksimum(std::vector&lt;tip&gt; v) {
	tip max(v[0]);
	for(int i=1; i&lt;v.size(); i++) 
		if(v[i]&gt;max) max=v[i];
	return max;
}


template &lt;typename tip&gt;
auto AlocirajFragmentirano(const std::vector&lt;tip&gt; &amp;v, int &amp;koliko_puta)-&gt; decltype(v[0]+v[0])** {
	if(v.size()==0) throw "Prazan vektor!";
	for(int i=0; i&lt;v.size(); i++) if(v[i]&lt;=0) throw std::domain_error("Neispravan vektor!");
	int period(Periodican(v));
	int k(0), broj_redova(0), duzina(0);
	
	decltype(v[0]+v[0])** p(nullptr);
	if(period!=0) {
	while((v.size()+k)%period!=0) k++;
	int nova_duzina(v.size()+k);
	koliko_puta=nova_duzina/period;
	
	//alokacija matrice
		decltype(v[0]+v[0])** p(nullptr);
		duzina=period*koliko_puta;
		try {
		
		p=new decltype(v[0]+v[0])*[duzina];
		for(int i=0; i&lt;koliko_puta; i++) {
			for(int j=0; j&lt;period; j++) p[j]=new decltype(v[0]+v[0])[int(v[j])];
		}
		broj_redova=period;
		}
		
		catch(std::bad_alloc) {
			if(p!=nullptr) for(int i=0; i&lt;duzina; i++) delete[] p[i];
			delete[] p;
		}
	}
	
	else {
	koliko_puta=2;
	
	decltype(v[0]+v[0])** p(nullptr);
	duzina=v.size()*2;
	try {
	p=new decltype(v[0]+v[0])*[duzina];
	for(int i=0; i&lt;koliko_puta; i++) {
		for(int j=0; j&lt;v.size(); j++) p[j]=new decltype(v[0]+v[0])[int(v[j])];
	}
		
	broj_redova=v.size();	
	}
	
	catch(std::bad_alloc) {
		if(p!=nullptr) for(int i=0; i&lt;duzina; i++) delete[] p[i];
		delete[] p;
	}
	}
	//popunjavanje matrice; 
	tip max(NadjiMaksimum(v));
	for(int i=0; i&lt;koliko_puta; i++) {
		for(int j=0; j&lt;broj_redova; j++) {
			int vel(v[j]);
			p[j][vel]=max;
			for(int k=vel-1; k&gt;0; k--)
		//	if(k==vel) 	p[j][k]=max;
		//	else
			p[j][k]=p[j][k+1]-1;
		}
	}

	
	return p;
}

template &lt;typename tip&gt;
auto AlocirajKontinualno(const std::vector&lt;tip&gt; &amp;v, int &amp;koliko_puta)-&gt; decltype(v[0]+v[0])** {
	if(v.size()==0) throw "Prazan vektor!";
	for(int i=0; i&lt;v.size(); i++) {
		if(v[i]&lt;=0) throw std::domain_error("Neispravan vektor!");
	}
	
	int period(Periodican(v));
	int k(0);
	decltype(v[0]+v[0])** p(nullptr);
	
	if(period!=0) {
		while ((v.size()+k)%period!=0) k++;
		int nova_duzina(v.size()+k);
		koliko_puta=nova_duzina/period;
		
	int duzina(0);
	for(int i=0; i&lt;period; i++) duzina+=v[i];
	duzina*=koliko_puta;
		
			decltype (v[0]+v[0])** p(nullptr);
			try {
			p=new decltype(v[0]+v[0])* [koliko_puta*period];
			p[0]=new decltype(v[0]+v[0])[duzina];
			for(int j=1; j&lt;period; j++) p[j]=p[j-1]+int(v[j]);
			}
			
			catch(std::bad_alloc) {
				if(p!=nullptr) delete[] p[0];
				delete[] p;
			}
		}
		
	else{
		koliko_puta=2;
		decltype(v[0]+v[0])** p(nullptr);
		int duzina(0);
		for(int i=0; i&lt;v.size(); i++) duzina+=v[i];
		duzina*=2;
		try {
		p=new decltype(v[0]+v[0])*[2*v.size()];
		p[0]=new decltype(v[0]+v[0])[duzina];
		for(int j=1; j&lt;v.size(); j++) p[j]=p[j-1]+int(v[j]);
		}
		catch(std::bad_alloc) {
			if(p!=nullptr) delete[] p[0];
			delete[] p;
		}
	}
	
	for(int i=0; i&lt;koliko_puta; i++) {
		for(int j=0; j&lt;v.size(); j++) {
		int vel(v[j]);
			for(int k=vel; k&gt;0; k--) {
				if(k==vel) p[j][k]=1;
				else p[j][k]=p[j][k+1]+1;
			}
		}
	}
	return p;	
}




int main ()
{
	try {
	std::vector&lt;double&gt; v;
	cout&lt;&lt;"Unesite broj elemenata vektora: ";
	int n;
	cin&gt;&gt;n;
	double broj;
	cout&lt;&lt;"Unesite elemente vektora: ";
	for(int i=0; i&lt;n; i++) {
		cin&gt;&gt;broj;
		v.push_back(broj);
	}
	int f;
	cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	cin&gt;&gt;f;
	int br(0);
	double **p=nullptr;
	if(f==1) p=AlocirajFragmentirano(v,br);
	
	else auto p=AlocirajKontinualno(v,br);
	
	for(int i=0; i&lt;br; i++) {
		for(int j=0; j&lt;br; j++)
		cout&lt;&lt;std::setw(3)&lt;&lt;std::left&lt;&lt;p[i][j]&lt;&lt;" ";
		cout&lt;&lt;std::endl;
	}
	if(f==1) {
		for(int i=0; i&lt;v.size(); i++) delete[] p[i];
		delete[] p;
	}
	else if(f==0){
		delete[] p[0];
		delete[] p;
	}
	}
	catch(std::domain_error izuzetak) {
		cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
	}
	catch(const char poruka[]) {
		cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka;
	}
	return 0;
</font>}</pre>
</body>
</html>
