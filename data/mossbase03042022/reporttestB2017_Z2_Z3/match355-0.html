<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3288.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3288.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;type_traits&gt;
using namespace std;
template &lt;typename Tip&gt;
bool Periodican(const vector&lt;Tip&gt; &amp;v, int n){
<a name="0"></a><font color="#FF0000"><a href="match355-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

	if(v.size()&lt;=n || n&lt;=0) return false;
	for(int i=0;i&lt;v.size()-n;i++){
		if(v.at(i)!=v.at(i+n))
		return false;
	}
	return true;
}
template &lt;typename Tip&gt;
int OsnovniPeriod(const vector&lt;Tip&gt; &amp;v){
</font>	for(int i=0;i&lt;v.size();i++){
		if(Periodican(v,i))
		return i;
	}
	return 0;
}
template &lt;typename Tip&gt;
auto AlocirajKontinualno(const vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta) -&gt; Tip **{
	if(!v.size()) throw "Prazan vektor!";
	int period(OsnovniPeriod(v));
	int nova_vel(v.size());
	if(period){
		if(v.size()%period!=0) nova_vel+=period-v.size()%period;
		koliko_puta=nova_vel/period;
	}
	else{
		nova_vel=2*v.size();
		koliko_puta=2;
	}
	Tip suma{};
	for(int i=0;i&lt;v.size();i++){
		if(v.at(i)&lt;=0) throw domain_error("Neispravan vektor!");
		else suma+=v.at(i);
	}
	if(period &amp;&amp; v.size()%period!=0){
		for(int i=v.size();i&lt;nova_vel;i++)
		suma+=v.at(i%period);
	}
	else if(!period) suma+=suma;
	try{
	Tip **p(new Tip*[nova_vel]);
	try{
		p[0]=new Tip[suma];
		if(period){
<a name="1"></a><font color="#00FF00"><a href="match355-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

		for(int i=1;i&lt;v.size();i++) p[i]=p[i-1]+v.at(i-1);
</font>		for(int i=v.size();i&lt;nova_vel;i++) p[i]=p[i-1]+v.at(i%period-1);	
		} 
		else{
		for(int i=1;i&lt;=v.size();i++) p[i]=p[i-1]+v.at(i-1);
		for(int i=v.size()+1;i&lt;nova_vel;i++) p[i]=p[i-1]+v.at(i-v.size()-1);
		}
<a name="2"></a><font color="#0000FF"><a href="match355-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

		for(int i=0;i&lt;v.size();i++){
			for(int j=1;j&lt;=v.at(i);j++){
				p[i][v.at(i)-j]=j;
</font>			}
		}
		if(period)
		for(int i=v.size();i&lt;nova_vel;i++){
			for(int j=1;j&lt;=v.at(i%period);j++){
				p[i][v.at(i%period)-j]=j;
			}
		}
		else
		for(int i=v.size();i&lt;nova_vel;i++){
			for(int j=1;j&lt;=v.at(i-v.size());j++){
				p[i][v.at(i-v.size())-j]=j;
			}
		}
		return p;
	}catch(...){
		delete [] p;
		throw;
	}
	}catch(...){
		throw;
	}
	
}
template &lt;typename Tip&gt;
auto AlocirajFragmentirano(const vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta) -&gt; Tip **{
	if(!v.size()) throw "Prazan vektor!";
	int period(OsnovniPeriod(v));
	int nova_vel(v.size());
	if(period){
		if(v.size()%period!=0) nova_vel+=period-v.size()%period;
		koliko_puta=nova_vel/period;
	}
	else{
		nova_vel=2*v.size();
		koliko_puta=2;
	}
	Tip max(v.at(0));
	for(int i=0;i&lt;v.size();i++){
		if(v.at(i)&lt;=0) throw domain_error("Neispravan vektor!");
		if(v.at(i)&gt;max) max=v.at(i);
	}
	try{
	Tip **p(new Tip*[nova_vel]{});
	try{
		if(period){
		for(int i=0;i&lt;v.size();i++){
		p[i]=new Tip[v.at(i)];
		}
		for(int i=v.size();i&lt;nova_vel;i++){
			p[i]=new Tip[v.at(v.size()%period)];
		}
		}
		else{
		for(int i=0;i&lt;v.size();i++){
			p[i]=new Tip[v.at(i)];
		}
		for(int i=v.size();i&lt;nova_vel;i++){
			p[i]=new Tip[v.at(i-v.size())];
		}
		}
		for(int i=0;i&lt;v.size();i++){
			int k(0);
			for(int j=max;j&gt;0;j--){
				p[i][v.at(i)-1-k]=j;
				k++;
				if(k==v.at(i)) break;
			}
		}
		if(period)
		for(int i=v.size();i&lt;nova_vel;i++){
			int k(0);
			for(int j=max;j&gt;0;j--){
				p[i][v.at(v.size()%period)-1-k]=j;
				k++;
				if(k==v.at(v.size()%period)) break;
			}
		}
		else
		for(int i=v.size();i&lt;nova_vel;i++){
			int k(0);
			for(int j=max;j&gt;0;j--){
				p[i][v.at(i-v.size())-1-k]=j;
				k++;
				if(k==v.at(i-v.size())) break;
			}
		}
		return p;
	}catch(...){
		for(int i=0;i&lt;nova_vel;i++) delete [] p[i];
		delete [] p;
		throw;
	}
	}catch(...){
		throw;
	}
}

int main ()
{
	cout&lt;&lt;"Unesite broj elemenata vektora: ";
	int n;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n);
	cout&lt;&lt;"Unesite elemente vektora: ";
	for(int i=0;i&lt;n;i++) cin&gt;&gt;v.at(i);
	int f;
	cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	cin&gt;&gt;f;
	int x;
	if(f==1){
		try{
		int vel(OsnovniPeriod(v));
		int **p(nullptr);
		p=AlocirajFragmentirano(v,x);
		cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;endl;
		if(vel){
		int k(1);
		for(int i=0;i&lt;vel*x;i++){
			for(int j=0;j&lt;k;j++){
				cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;p[i][j];
			}
			if(k&lt;vel) k++;
			else k=1;
			cout&lt;&lt;endl;
		}
		}
		else{
<a name="4"></a><font color="#FF00FF"><a href="match355-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		for(int i=0;i&lt;v.size();i++){
			for(int j=0;j&lt;v.at(i);j++)
			cout&lt;&lt;left&lt;&lt;setw(3)&lt;&lt;p[i][j];
</font>			cout&lt;&lt;endl;
		}
		for(int i=v.size();i&lt;v.size()*x;i++){
			for(int j=0;j&lt;v.at(i-v.size());j++)
			cout&lt;&lt;left&lt;&lt;setw(3)&lt;&lt;p[i][j];
			cout&lt;&lt;endl;
		}
		}
		if(vel){
		for(int i=0;i&lt;vel*x;i++) delete[] p[i];
		delete[] p;
		}else{
		for(int i=0;i&lt;v.size()*x;i++) delete[] p[i];
		delete[] p;
		}
		}catch(bad_alloc){
			cout&lt;&lt;"Nedovoljno memorije";
		}
		catch(domain_error izuzetak){
			cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
		}
		catch(const char poruka[]){
			cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka;
		}
	}
	else if(!f){
		try{
		int vel(OsnovniPeriod(v));
		int **p=AlocirajKontinualno(v,x);
		cout&lt;&lt;"Dinamicki alocirana matrica: "&lt;&lt;endl;
		if(vel){
		int k(1);
		for(int i=0;i&lt;vel*x;i++){
			for(int j=0;j&lt;k;j++){
				cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;p[i][j];
			}
			if(k&lt;vel) k++;
			else k=1;
			cout&lt;&lt;endl;
		}
		}
		else{
<a name="5"></a><font color="#FF0000"><a href="match355-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

		for(int i=0;i&lt;v.size();i++){
			for(int j=0;j&lt;v.at(i);j++)
			cout&lt;&lt;left&lt;&lt;setw(3)&lt;&lt;p[i][j];
</font>			cout&lt;&lt;endl;
		}
		for(int i=v.size();i&lt;v.size()*x;i++){
			for(int j=0;j&lt;v.at(i-v.size());j++)
			cout&lt;&lt;left&lt;&lt;setw(3)&lt;&lt;p[i][j];
			cout&lt;&lt;endl;
		}
		}
		delete[] p[0];
		delete[] p;
		}catch(bad_alloc){
			cout&lt;&lt;"Nedovoljno memorije";
		}catch(domain_error izuzetak){
			cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
		}
		catch(const char poruka[]){
			cout&lt;&lt;"Izuzetak: "&lt;&lt;poruka;
		}
	}
	return 0;
}</pre>
</body>
</html>
