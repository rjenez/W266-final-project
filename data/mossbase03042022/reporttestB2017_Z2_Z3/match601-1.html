<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student3108.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4740.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3

	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!

	NAPOMENA: nece svi (javni) testovi sa zamgera biti
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;

template &lt;typename Tip&gt; bool jel_period(const std::vector&lt;Tip&gt;  &amp;v, int p)
{

	if(p&lt;1  || p&gt;=v.size()) return false;
	for(int i=0; i&lt;v.size()-p; i++) 	if(v.at(i)!=v.at(i+p)) return false;
	return true;
}
template &lt;typename Tip&gt; int osnovni_period (const std::vector&lt;Tip&gt; &amp;v)
{
	int osnovni(0);
	for(int i=0; i&lt;v.size(); i++) if(jel_period(v,i)) return i;
	return osnovni;
}

template &lt;typename Tip&gt; auto AlocirajFragmentirano (const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta)-&gt; Tip ** {
	int vel(v.size());
	if(v.size()==0) throw "Prazan vektor!";
<a name="1"></a><font color="#00FF00"><a href="match601-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	for(int i=0; i&lt;v.size(); i++) if(v.at(i)&lt;=0) throw std::domain_error ("Neispravan vektor!");
	int osnovni(osnovni_period(v));
</font>	if(osnovni!=0) {
		while((vel%osnovni)!=0) {
			vel++;
		}
		koliko_puta=vel/osnovni;
	} else{
		osnovni=vel;
		vel=(2*v.size());
		koliko_puta=2;
	}
	Tip **a(nullptr);
	try{

		a = new Tip*[vel]{};
		int br(0);
		for(int i=0; i&lt;vel; i++) {
			a[i]=new Tip[v.at(br)];
			br++;
			if(br==osnovni) br=0;
		}

	} catch(...) {
		for(int i=0; i&lt;vel; i++) delete[] a[i];
		delete[] a;
		throw;
	}

	int br(0);
	for(int i=0; i&lt;vel; i++) {
		Tip max(*(std::max_element(v.begin(), v.end())));

		for(int j=v.at(br)-1; j&gt;=0; j--) {
			a[i][j]=max;
			max--;
		}
		br++;
		if(br==osnovni) br=0;
	}
	return a;
}

template &lt;typename Tip&gt; auto AlocirajKontinualno (const std::vector&lt;Tip&gt; &amp;v, int &amp;koliko_puta)-&gt; Tip ** {
	int vel(v.size());
	if(v.size()==0) throw "Prazan vektor!";
<a name="2"></a><font color="#0000FF"><a href="match601-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	for(int i=0; i&lt;v.size(); i++) if(v.at(i)&lt;=0) throw std::domain_error ("Neispravan vektor!");
	int osnovni(osnovni_period(v));
</font>	if(osnovni!=0) {
		while((vel%osnovni)!=0) {
			vel++;
		}
		int koliko(vel/osnovni);
		koliko_puta=koliko;
	} else{
		osnovni=vel;
		vel=(2*v.size());
		koliko_puta=2;
	}
	int kolicina(0);
	for(int i=0; i&lt;osnovni; i++) kolicina+=v.at(i);
	kolicina*=koliko_puta;
	Tip **a(nullptr);
	try{
		a=new Tip *[vel]{};
		a[0]=new Tip [kolicina];
		int br(0);
		for(int i=1; i&lt;vel; i++) {
			a[i]=a[i-1]+v[br];
			br++;
			if(br==osnovni) br=0;
		}

	} catch(...) {
		delete[] a[0];
		delete[] a;
		throw;
	}
	int br(0);
	for(int i=0; i&lt;vel; i++) {
		Tip broj(0);
		broj++;

		for(int j=v.at(br)-1; j&gt;=0; j--) {
			a[i][j]=broj;
			broj++;
		}
		br++;
		if(br==osnovni) br=0;
	}
	return a;
}

<a name="0"></a><font color="#FF0000"><a href="match601-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

int main()
{
	std::cout &lt;&lt; "Unesite broj elemenata vektora: ";
	int n;
	std::cin &gt;&gt; n;

	std::vector&lt;int&gt; v(n);
	std::cout &lt;&lt; "Unesite elemente vektora: " ;
	for(int i=0; i&lt;n; i++) {
		std::cin &gt;&gt; v.at(i);
	}
	std::cout &lt;&lt; "Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int alokacija;
	std::cin &gt;&gt; alokacija;
</font>	int koliko;
	if(alokacija==1) {
		try {
			int **mat (AlocirajFragmentirano(v, koliko));
			int osnovni;
			if(osnovni_period(v)!=0) osnovni=osnovni_period(v);
			else osnovni=v.size();
			int vel(osnovni*koliko);
			std::cout &lt;&lt; "Dinamicki alocirana matrica: " &lt;&lt; std::endl;

			int br(0);
			for(int i =0; i&lt;vel; i++) {
				for(int j=0; j&lt;v.at(br); j++) {
					std::cout &lt;&lt; std::left&lt;&lt; std::setw(3) &lt;&lt;mat[i][j];
				}
				std::cout &lt;&lt; std::endl;
				br++;
				if (br==osnovni) br=0;
			}
<a name="3"></a><font color="#00FFFF"><a href="match601-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

			for(int i=0; i&lt;vel; i++) delete[] mat[i];
			delete[] mat;
		} catch(std::bad_alloc) {
			std::cout &lt;&lt; "Nedovoljno memorije!" &lt;&lt; std::endl;
</font>		} catch(const char poruka[]) {
			std::cout &lt;&lt; "Izuzetak: "&lt;&lt; poruka &lt;&lt; std::endl;
		} catch(std::domain_error greska) {
			std::cout &lt;&lt; "Izuzetak: "&lt;&lt; greska.what() &lt;&lt; std::endl;
		}
	} else {
		try {
			int **mat(AlocirajKontinualno(v,koliko));
			int osnovni;
			if(osnovni_period(v)!=0) osnovni=osnovni_period(v);
			else osnovni=v.size();
			int vel(osnovni*koliko);
			std::cout &lt;&lt; "Dinamicki alocirana matrica: " &lt;&lt; std::endl;
			int br(0);
			for(int i=0; i&lt;vel; i++) {
				for(int j=0; j&lt;v.at(br); j++) {
					std::cout &lt;&lt; std::left &lt;&lt; std::setw(3) &lt;&lt; mat[i][j];
				}
				br ++;
				if(br==osnovni) br=0;
				std::cout &lt;&lt; std::endl;
			}
			delete[] mat[0];
			delete[] mat;
		} catch(std::bad_alloc) {
			std::cout &lt;&lt; "Nedovoljno memorije!" &lt;&lt; std::endl;
		} catch(const char poruka[]) {
			std::cout &lt;&lt; "Izuzetak: "&lt;&lt; poruka &lt;&lt; std::endl;
		} catch(std::domain_error greska) {
			std::cout &lt;&lt;"Izuzetak: "&lt;&lt; greska.what() &lt;&lt; std::endl;
		}
	}
	return 0;
}</pre>
</body>
</html>
