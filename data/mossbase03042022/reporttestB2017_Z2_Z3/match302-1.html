<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student5695.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student5348.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;

using namespace std;


typedef vector&lt;vector&lt;int&gt;&gt; Matrica;

 void UnistiMatricu(int **mat, int br_redova) {
 if(!mat) return;
 for(int i = 0; i &lt; br_redova; i++) delete[] mat[i];
 delete[] mat;
 }
 


template&lt;typename t1&gt;
bool Test(vector&lt;t1&gt; v){
	if(v.size()==0)return false;
	
		for(int i=0;i&lt;v.size();i++){
		if(v.at(i)&lt;=0)return false;
		
	}
	return true;
	
}

template&lt;typename t1&gt;
bool TestPerioda(vector&lt;t1&gt; v,int p){
	if(p&lt;=0)return false;
	if(int(v.size())-p&lt;=0)return false;
	for(int i=0;i&lt;int(v.size())-p;i++)
<a name="0"></a><font color="#FF0000"><a href="match302-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

		if(v[i]!=v[p+i])return false;
	return true;
}

template&lt;typename t1&gt;
int OdrediOsnovniPeriod (vector&lt;t1&gt; v){
	for(int i=1;i&lt;v.size();i++)
		if(TestPerioda(v,i))return i;
	return 0;
}



template&lt;typename t1&gt;
</font><a name="1"></a><font color="#00FF00"><a href="match302-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

int **AlocirajKontinualno(vector&lt;t1&gt; &amp;v,int &amp;koliko_puta){
	
	if(v.size()==0)throw domain_error("Prazan vektor!");
	
	for(int i=0;i&lt;v.size();i++){
		if(v.at(i)&lt;=0)throw domain_error("Neispravan vektor!");
</font>	}
	
	int x=OdrediOsnovniPeriod(v);
	
	if(x==0){
		int y=v.size();
		for(int i=0;i&lt;y;i++)
			v.push_back(v.at(i));
			koliko_puta=2;
	}
	else{
		int y=v.size();
		if(y%x!=0){
			int z=y%x;
			for(int i=z;i&lt;x;i++)
			v.push_back(v.at(i));
		}
	}
	
	
 int **a(new int*[v.size()]{});
 
 try {
 for(int i = 0; i &lt; v.size(); i++)
 a[i] = new int[v.at(i)];
 }
 catch(...) {
 UnistiMatricu(a, v.size());
 }

	for(int i=0;i&lt;v.size();i++){
		for(int j=0;j&lt;v.at(i);j++){
			a[i][j]=v.at(i)-j;
		}
	}
	
return a;
}

//----------------------------------

template&lt;typename t1&gt;
<a name="2"></a><font color="#0000FF"><a href="match302-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

int **AlocirajFragmentirano(vector&lt;t1&gt; &amp;v,int &amp;koliko_puta){
	
	if(v.size()==0)throw domain_error("Prazan vektor!");
	
		for(int i=0;i&lt;v.size();i++){
		if(v.at(i)&lt;=0)throw domain_error("Neispravan vektor!");
</font>	}
	
	t1 max=v.at(0);
	for(int i=0;i&lt;v.size();i++)
	if(max&lt;v.at(i))max=v.at(i);
	
	
	int x=OdrediOsnovniPeriod(v);
	
	if(x==0){
		int y=v.size();
		for(int i=0;i&lt;y;i++)
			v.push_back(v.at(i));
			koliko_puta=2;
	}
	else{
		int y=v.size();
		if(y%x!=0){
			int z=y%x;
			for(int i=z;i&lt;x;i++)
			v.push_back(v.at(i));
		}
	}
	
	

	 int **a(new int*[v.size()]{});
 try {
 for(int i = 0; i &lt; v.size(); i++)
 a[i] = new int[v.at(i)];
 }
 catch(...) {
 UnistiMatricu(a, v.size());
 }

	for(int i=0;i&lt;v.size();i++){
		for(int j=0;j&lt;v.at(i);j++){
			a[i][j]=max+j-v.at(i)+1;
		}
	}

	return a;
}


int main ()
{
	
	
	vector&lt;int&gt; v={};
	int k;
	
	cout&lt;&lt;"Unesite broj elemenata vektora: ";
	int n;
	cin&gt;&gt;n;
	
	cout&lt;&lt;"Unesite elemente vektora: ";
<a name="4"></a><font color="#FF00FF"><a href="match302-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

	for(int i=0;i&lt;n;i++){
		int x;
		cin&gt;&gt;x;
		v.push_back(x);
	}
	
	cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int s;
	cin&gt;&gt;s;
</font>	if(s==0)
	try{
		if(Test(v))
		cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;endl;
		int **a=AlocirajKontinualno(v,k);
		
<a name="3"></a><font color="#00FFFF"><a href="match302-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

		for(int i=0;i&lt;v.size();i++){
			for(int j=0;j&lt;v.at(i);j++){
				cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;a[i][j];
</font>			}cout&lt;&lt;endl;
		}
		UnistiMatricu(a,v.size());
		
	
	}catch(domain_error izuzetak){
		cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
	}
	else try{
		if(Test(v))
		cout&lt;&lt;"Dinamicki alocirana matrica:"&lt;&lt;endl;
		int **a=AlocirajFragmentirano(v,k);
		
		for(int i=0;i&lt;v.size();i++){
			for(int j=0;j&lt;v.at(i);j++){
				cout&lt;&lt;setw(3)&lt;&lt;left&lt;&lt;a[i][j];
			}cout&lt;&lt;endl;
		}
		UnistiMatricu(a,v.size());
	}catch(domain_error izuzetak){
		cout&lt;&lt;"Izuzetak: "&lt;&lt;izuzetak.what();
	}
	
	
	return 0;
}</pre>
</body>
</html>
