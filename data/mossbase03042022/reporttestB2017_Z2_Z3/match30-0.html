<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student2956.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student2956.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;limits&gt;
#include &lt;iomanip&gt;

<a name="0"></a><font color="#FF0000"><a href="match30-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

template&lt;typename neka&gt;
int Nova(const std::vector&lt;neka&gt;&amp; vektor,int &amp;zabrojac) //int &amp;kolikoseponavlja)
{
	int i(0), j(1), dodaj(0), kolikoseponavlja(0), period(0), b1(1),b2(2);
	bool kraj(true);
	for(;;)
	{
		for(int k = 0;k&lt;b1;k++)
		{
			if()
		}
	}
	for(;;)
	{
		if(vektor.at(i)!=vektor[j]) j++;
		else if(vektor.at(i)==vektor[j]) {i++;j++; kolikoseponavlja=&amp;vektor[j]-&amp;vektor.at(i);}
		if(j==vektor.size())
		{
			zabrojac=i;
			dodaj=kolikoseponavlja-i;
			std::cout&lt;&lt;"dodaj je: "&lt;&lt;dodaj&lt;&lt;std::endl;
			break;
		}
	}
	if(dodaj==0) return vektor.size();
	/*if(dodaj &lt; 0)
	{
		i=1;
		j=2;
		for(;;)
		{
			
		}
	}*/
	std::cout&lt;&lt;"zabrojac je: "&lt;&lt;zabrojac&lt;&lt;", a dodaj je: "&lt;&lt;dodaj;
	return dodaj;
}

template&lt;typename neka&gt;
int TrazenjePerioda(const std::vector&lt;neka&gt;&amp; vektor, int &amp;zabrojac, int &amp;koliko_puta, int &amp;kontinualnaproblem)
{
	int i(2),j(3),period{},kolikoseponavlja{},b1(0),b2(1),dodaj(0);
	bool kraj(true), test(false);
	for(;;)
	{
		for(;;)
		{
			if(!std::equal(vektor.begin(),vektor.begin()+i,vektor.begin()+j)) break;
			else
			{
				//std::cout&lt;&lt;"pozvana";
				period++;
				j+=1+i;
				if(j+i&gt;=vektor.size())
				{
					//if(!std::equal(vektor.begin(), vektor.begin()+i, vektor.begin()+j-1-i)) period--;
					//else period++;
					kolikoseponavlja=&amp;vektor.at(i)-&amp;vektor.at(0)+1;
					kraj=0;
					break;
				}
			}
		}
		if(kraj==false) break;
		if(j&gt;=vektor.size()-1) break;
		i++;
		j=i+1;
		period=0;
		if(j+i&gt;=vektor.size())
			{
				for(;;)
				{
					if(vektor.at(b1)!=vektor.at(b2)) b2++;
					else if(vektor.at(b1)==vektor[b2]) {b2++;b1++; kolikoseponavlja=&amp;vektor[b2]-&amp;vektor.at(b1); test=true;}
					if(b2==vektor.size()){
						koliko_puta=2;
						if(b2==vektor.size())
						{
							zabrojac=b1;
							dodaj=kolikoseponavlja-b1;
						}
						else
						{
							zabrojac=b1+1;
							dodaj=kolikoseponavlja-b1-1;
						}
						return dodaj;
						test=true;
						break;
					}
				}
			}
	}
	//if(test==true) return dodaj;
	if(period==0) return -1;
	//int pomocna((&amp;vektor.at(i)-&amp;vektor.at(0))*period+1);
	//pomocna=vektor.size()-pomocna;
	std::cout&lt;&lt;"pozvana a ne treba"&lt;&lt;std::endl;
	dodaj=(vektor.size()%period);
	if(kolikoseponavlja*period!=vektor.size()){ dodaj=vektor.size()-kolikoseponavlja*period; zabrojac=dodaj; dodaj=kolikoseponavlja-dodaj;}
	std::cout&lt;&lt;"dodaj je: "&lt;&lt;dodaj&lt;&lt;", a period je: "&lt;&lt;period&lt;&lt;", a kolikoseponavlja: "&lt;&lt;kolikoseponavlja;
	//return pomocna;
	koliko_puta=period+1;
	kontinualnaproblem=kolikoseponavlja;
	return dodaj;
}

template&lt;typename neka&gt;
int Zbroji(const std::vector&lt;neka&gt;&amp; vektor, int &amp;kolikofali,int &amp;josjedna)
{
	int i{},j{},k{},suma{};
	bool tacno(false);
	for(int i = 0; i &lt; kolikofali+vektor.size(); i++)
	{
		if(i&gt;=vektor.size()&amp;&amp;!tacno&amp;&amp;josjedna!=vektor.size())
		{
			j=josjedna;
			tacno=true;
		}
		if(josjedna==vektor.size()&amp;&amp;i==vektor.size()-1)
		{
			return suma*=2;
		}
		suma+=vektor.at(j);
		//std::cout&lt;&lt;"Suma je: "&lt;&lt;suma&lt;&lt;std::endl;
		j++;
	}
	return suma;
}

template&lt;typename neka&gt;
int**	AlocirajFragmentirano(const std::vector&lt;neka&gt;&amp; vektor,int koliko_puta)
{
	bool periodicnost{};
	int kolikofali{},pomocna(vektor.size()),josjedna(0),zabrojac(0),kontinualnaproblem(0);
	//periodicnost=TestiranjePeriodicnosti(vektor);
	//if(periodicnost)
	//{
	kolikofali=Nova(vektor, zabrojac);
	//if(kolikofali!=-1)
//	{
//		josjedna=zabrojac;
		//std::cout&lt;&lt;"pozvana traziperiod";
//	}
	//else if(kolikofali==0)
	//}
//	else kolikofali=pomocna;
	//if(kolikofali==-1) kolikofali=pomocna;
	//else kolikofali+=vektor.size();
	//kolikofali++;
	int **p(new int*[kolikofali+vektor.size()]);
	int j(0);
	bool tacno(false);
	std::cout&lt;&lt;"vektor size: "&lt;&lt;vektor.size()&lt;&lt;std::endl;
	std::cout&lt;&lt;"Dinamicki alocirana matrica: ";
	for(int i = 0; i &lt; kolikofali+vektor.size(); i++)
	{
		if(i&gt;=vektor.size()&amp;&amp;!tacno)
		{
			j=zabrojac;
			tacno=true;
		}
		p[i]=new int[vektor[j]];
		for(int k = 0, pomocna= vektor[j]; k &lt; vektor[j]; k++, pomocna--)
		{
			p[i][k]=pomocna;
			//std::cout&lt;&lt;std::setw(4);
			//std::cout&lt;&lt;std::left&lt;&lt;p[i][k-1];//"i je: "&lt;&lt;i&lt;&lt;", a j: "&lt;&lt;j&lt;&lt;", a k: "&lt;&lt;k;
		}
		std::cout&lt;&lt;i&lt;&lt;" ";//std::endl;
		j++;
	}
	return p;
}

template&lt;typename neka&gt;
int**	AlocirajKontinualno(const std::vector&lt;neka&gt;&amp; vektor, int koliko_puta)
{
	int kolikofali{},pomocna(vektor.size()),josjedna(0),zabrojac(0),kontinualnaproblem(0);
	kolikofali=TrazenjePerioda(vektor,zabrojac,koliko_puta,kontinualnaproblem);
	if(kolikofali!=-1)
	{
		josjedna=zabrojac;
	}
	else kolikofali=pomocna;
	int **p(new int*[kolikofali+vektor.size()]{});
	int j(0);
	bool tacno(false);
	int ukupnoelemenata{};
	ukupnoelemenata=Zbroji(vektor, kolikofali, josjedna);
	std::cout&lt;&lt;ukupnoelemenata;
	//ukupnoelemenata++;
	p[0]=new int[ukupnoelemenata]{};
	int zakontinualnu{1},proba(1);
	//std::cout&lt;&lt;"koliko_puta: "&lt;&lt;koliko_puta&lt;&lt;std::endl;
	for(int i = 1; i &lt; kolikofali + vektor.size(); i++)
	{
		//if(zakontinualnu==kontinualnaproblem+1) zakontinualnu=1;
		if(i==1) p[i]=p[0]+proba;
		if(i&gt;=vektor.size()&amp;&amp;!tacno)
		{
			j=josjedna;
			tacno=true;
		}
		if(i!=1)
		{
			proba+=vektor.at(j);
			//std::cout&lt;&lt;"vektor at j je: "&lt;&lt;vektor.at(j)&lt;&lt;"a suma je: "&lt;&lt;proba&lt;&lt;std::endl;
			p[i]=p[0]+proba;
		}
		//zakontinualnu++;
		//proba+=zakontinualnu;
		j++;
	}
	j=0;
	tacno=false;
	//std::cout&lt;&lt;proba&lt;&lt;std::endl;
	//std::cout&lt;&lt;"koliko fali je: "&lt;&lt;kolikofali&lt;&lt;std::endl;
	std::cout&lt;&lt;"Dinamicki alocirana matrica: ";
	proba=0;
	for(int i = 0; i &lt; kolikofali+vektor.size(); i++)
	{
		if(i&gt;=vektor.size()&amp;&amp;!tacno)
		{
			j=josjedna;
			tacno=true;
		}
		//p[i]=new int[vektor[j]];
		for(int k = 0; k &lt; vektor[j]; k++)
		{
			p[i][k]=k+1;
			std::cout&lt;&lt;std::setw(4);
			std::cout&lt;&lt;std::left&lt;&lt;p[i][k];//
			//std::cout&lt;&lt;"i je: "&lt;&lt;i&lt;&lt;", a j: "&lt;&lt;j&lt;&lt;", a k: "&lt;&lt;k&lt;&lt;std::endl;
		}
		proba++;
		std::cout&lt;&lt;std::endl;
		j++;
	}
	return p;
}

int main()
{
	std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
	int brojelemenata{},koliko_puta{0};
	std::cin&gt;&gt;brojelemenata;
	std::vector&lt;int&gt; vektor(brojelemenata);
	std::cout&lt;&lt;"Unesite elemente: ";
	int pomocna{};
	for(int i = 0; i &lt; brojelemenata; i++)
	{
		std::cin&gt;&gt;pomocna;
		vektor[i]=pomocna;
	}
	std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int alokacija{},kontinualnaproblem(0);
	std::cin&gt;&gt;alokacija;
	int** p;
	int zabrojac(0);
	if(alokacija==1)
	{
		p=(AlocirajFragmentirano(vektor,koliko_puta));
		pomocna=Nova(vektor, zabrojac);
		pomocna+=vektor.size();
		bool test(false);
	int k(0);
	for(int i = 0; i &lt; pomocna; i++)
	{
		for(int j = 0; j &lt; vektor[k]; j++)
		{
			std::cout&lt;&lt;p[i][j]&lt;&lt;" ";
		}
		k++;
		if(i&gt;=vektor.size()-1&amp;&amp;!test)
		{
			k=zabrojac;
			test=true;
		}
	//	k++;
		std::cout&lt;&lt;i&lt;&lt;" "&lt;&lt;std::endl;
	}
		for(int i = 0; i &lt; pomocna; i++)
		{
			delete[] p[i];
		}
		delete[] p;
	}
	else p=(AlocirajKontinualno(vektor,koliko_puta));
//	std::cout&lt;&lt;"Dinamicki alocirana matrica: ";
	
	return 0;
</font>}
</pre>
</body>
</html>
