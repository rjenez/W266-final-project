<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student4412.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z3/student8886.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 3
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;new&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;


int OdrediOsnovniPeriod(std::vector&lt;int&gt; v){
	int t(1);
	for(int i=0; i&lt;static_cast&lt;int&gt; (v.size())-t; i++)
	if(v.at(i)!=v.at(i+t)){
		t++;
		i=-1;
	}
	return t!=static_cast&lt;int&gt; (v.size()) ? t:0;
}
template &lt;typename tip&gt;
int  **AlocirajFragmentirano(const std::vector&lt;tip&gt; &amp;v, int &amp;koliko_puta){
	for(int i=0; i&lt;v.size(); i++) if(v.at(i)&lt;=0) throw std::domain_error("Neispravan vektor!");
	if(v.size()==0) throw std::domain_error("Prazan vektor!");
	int br_redova(0);
	int duzina(0);
	int period(0);
	 if(v.size()!=OdrediOsnovniPeriod(v) &amp;&amp; OdrediOsnovniPeriod(v)!=0){
	 	duzina=v.size();
	 	while(duzina&gt;=OdrediOsnovniPeriod(v)){
	 		duzina-=OdrediOsnovniPeriod(v);
	 		koliko_puta++;
	 	} 
	 	if(duzina!=0)koliko_puta++;
	 	br_redova=koliko_puta*OdrediOsnovniPeriod(v);
	 	period=OdrediOsnovniPeriod(v);

	 }
	 if(OdrediOsnovniPeriod(v)==0){
	 	duzina=0;
	 	koliko_puta=2;
	 	br_redova=v.size()*koliko_puta;
	 	period=v.size();

	 }
	 
     try{
     	int** p=new int* [br_redova];
     	for(int i=0; i&lt;br_redova; i++)
     	p[i]=nullptr;
     	try {
     		int j(duzina);
     		for(int i=0; i&lt;br_redova; i++){
     			if(i&gt;=v.size() &amp;&amp; j&lt;period){
     			p[i]=new int[v[j]];
     			j++;
     			} 
     			else p[i]=new int[v[i]];
     		}
     		
<a name="3"></a><font color="#00FFFF"><a href="match892-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

     	}catch(std::bad_alloc){
     		for(int i=0; i&lt;br_redova; i++)
     		delete[] p[i];
     		delete[] p;
     		throw;
</font>     	}
     	//nesto radi matrica
     	int j(duzina);
     	for(int i=0; i&lt;br_redova; i++){
     		if(i&gt;=v.size() &amp;&amp; j&lt;period){
     			for(int k=v[j]-1; k&gt;=0; k--) p[i][k]=period-v[j]+k+1;
     			j++;
     			} 
     			else for(int k=v[i]-1; k&gt;=0; k--) p[i][k]=period-v[i]+k+1;
     	}
     	return p;
     }catch(std::bad_alloc){
     	throw;
     }
}
template &lt;typename tip&gt;
int  **AlocirajKontinualno(const std::vector&lt;tip&gt; &amp;v, int &amp;koliko_puta){
	for(int i=0; i&lt;v.size(); i++) if(v.at(i)&lt;=0) throw std::domain_error("Neispravan vektor!");
	if(v.size()==0) throw std::domain_error("Prazan vektor!");
	int br_redova(0);
	int duzina(0);
	int period(0);
	 if(v.size()!=OdrediOsnovniPeriod(v) &amp;&amp; OdrediOsnovniPeriod(v)!=0){
	 	duzina=v.size();
	 	while(duzina&gt;=OdrediOsnovniPeriod(v)){
	 		duzina-=OdrediOsnovniPeriod(v);
	 		koliko_puta++;
	 	} 
	 	if(duzina!=0)koliko_puta++;
	 	br_redova=koliko_puta*OdrediOsnovniPeriod(v);
	 	period=OdrediOsnovniPeriod(v);

	 }
	 if(OdrediOsnovniPeriod(v)==0){
	 	duzina=0;
	 	koliko_puta=2;
	 	br_redova=v.size()*koliko_puta;
	 	period=v.size();

	 }
	 
     try{
     	int** p=new int* [br_redova];
     	try {
     		int brojac(0);
     		int j=duzina;
     		for(int i=0; i&lt;br_redova; i++){
     			if(i&gt;=v.size() &amp;&amp; j&lt;period){
     			brojac+=v[j];
     			j++;
     			} 
     			else brojac+=v[i];
     		}
     		p[0]=new int[brojac];
     		j=duzina;
     		for(int i=1; i&lt;br_redova; i++){
     			if(i&gt;= v.size() &amp;&amp; j&lt;period){
     		    if(j!=0)p[i]=p[i-1]+v[j-1];
     		    else p[i]=p[i-1]+v[i-1];
     			j++;
     			} 
     			else p[i]=p[i-1]+v[i-1];
     		}
     		
     	}catch(std::bad_alloc){
     		delete[] p;
     		throw;
     	}
     	//nesto radi matrica
     	int j(duzina);
     	for(int i=0; i&lt;br_redova; i++){
     		if(i&gt;=v.size() &amp;&amp; j&lt;period){
     			for(int k=v[j]-1; k&gt;=0; k--) p[i][k]=v[j]-k;
     			j++;
     			} 
     			else for(int k=v[i]-1; k&gt;=0; k--) p[i][k]=v[i]-k;
     	}
     	return p;
     }catch(std::bad_alloc){
     	throw;
     }
}
std::vector&lt;int&gt; ProsireniVektor(std::vector&lt;int&gt; v){
	if(v.size()!=OdrediOsnovniPeriod(v) &amp;&amp; OdrediOsnovniPeriod(v)!=0){
        int duzina(v.size());
        while(duzina&gt;=OdrediOsnovniPeriod(v)) duzina-=OdrediOsnovniPeriod(v);
        if(duzina!=0) for(int i=duzina; i&lt;OdrediOsnovniPeriod(v); i++) v.push_back(v.at(i));
    }
    if(OdrediOsnovniPeriod(v)==0){
        int duzina(v.size());
        for(int i=0; i&lt;duzina; i++) v.push_back(v.at(i));
    }
   
    return v;
}
int main ()
{
	try{
	int koliko_puta(0);
	std::cout&lt;&lt;"Unesite broj elemenata vektora: ";
	int n(0);
	std::cin&gt;&gt;n;
	std::vector&lt;int&gt; v(n);
	std::cout&lt;&lt;"Unesite elemente vektora: ";
<a name="2"></a><font color="#0000FF"><a href="match892-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	for(int i=0; i&lt;n; i++) std::cin&gt;&gt;v.at(i);
	
	std::cout&lt;&lt;"Odaberite alokaciju: 1 - fragmentirana, 0 - kontinualna: ";
	int f;
	std::cin&gt;&gt;f;
</font>	//if(v.size()==0) throw std::domain_error("Prazan vektor!");
	if(f==0){ 
	auto m=AlocirajKontinualno(v, koliko_puta);
	auto v1=ProsireniVektor(v);
	std::cout&lt;&lt;"Dinamicki alocirana matrica: ";
	std::cout&lt;&lt;std::endl;
<a name="0"></a><font color="#FF0000"><a href="match892-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

	for(int i=0; i&lt;v1.size(); i++){
		for(int j=0; j&lt;v1.at(i); j++){
			std::cout&lt;&lt;std::left&lt;&lt;m[i][j]&lt;&lt;std::setw(3);
</font>		}
		std::cout&lt;&lt;std::endl;
	}
       delete[] m[0];
	delete[] m;
	}
	if(f==1){ 
	auto m=AlocirajFragmentirano(v, koliko_puta);
	auto v1=ProsireniVektor(v);
	std::cout&lt;&lt;"Dinamicki alocirana matrica: ";
	std::cout&lt;&lt;std::endl;
<a name="1"></a><font color="#00FF00"><a href="match892-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

	for(int i=0; i&lt;v1.size(); i++){
		for(int j=0; j&lt;v1.at(i); j++){
			std::cout&lt;&lt;std::left&lt;&lt;m[i][j]&lt;&lt;std::setw(3);
</font>		}
		std::cout&lt;&lt;std::endl;
	}
     	for(int i=0; i&lt;v1.size(); i++) delete[] m[i];
	delete[] m;
	}
	}catch(std::domain_error Izuzetak){
		std::cout&lt;&lt;"Izuzetak: "&lt;&lt;Izuzetak.what()&lt;&lt;std::endl;
	
	}catch(std::bad_alloc){
		std::cout&lt;&lt;"Izuzetak: Nedovoljno memorije!"&lt;&lt;std::endl;
	}
	return 0;
}</pre>
</body>
</html>
