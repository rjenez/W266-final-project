<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z2/student4770.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z2/student2240.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;type_traits&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;


enum class SmjerKretanja {NaprijedNazad, NazadNaprijed, GoreDolje, DoljeGore, LijevoDesno, DesnoLijevo};

template &lt;typename tip&gt;
tip PjescaniSat (tip kont, SmjerKretanja smjer)
{
    for (int i{};i&lt;kont.size();i++)
    {
        if (kont.size() != kont.at(i).size())
            throw std::domain_error ("3D matrica nema oblik kocke");
            
        if (kont.at(0).size() != kont.at(i).size())
            throw std::domain_error ("3D matrica nema oblik kocke");
        
        for (int j{};j&lt;kont.at(i).size();j++)
        {
            if (kont.at(i).at(0).size() != kont.at(i).at(j).size())
                throw std::domain_error ("3D matrica nema oblik kocke");
        }
        
    }
    
    for (int i{};i&lt;kont.size();i++)
    {
        if (kont.at(i).size() % 2 == 0)
            throw std::length_error ("3D kontejner ne zadovoljava uvjet neparnosti");
            
        for (int j{};j&lt;kont.at(i).size();j++)
        {
            if (kont.at(i).at(j).size() % 2 == 0)
                throw std::length_error ("3D kontejner ne zadovoljava uvjet neparnosti");
            
        }
    }
    
    if (kont.size() == 1)
        return kont;
    
    tip rezultat;
    
   if (smjer == SmjerKretanja::GoreDolje)
   {
       int n = kont.size()/2;
       for (int i{};i&lt;kont.size();i++)
       {
           typename std::remove_reference&lt;decltype(kont.at(0))&gt;::type pomocni_matrica;
           
           int pomocni_k = 0;
           int pomocni_granica = kont.size();
           for (int j{};j&lt;kont.size();j++)
           {
               typename std::remove_reference&lt;decltype(kont.at(0).at(0))&gt;::type pomocni_red;
               int granica_kolone = pomocni_granica;
               int k = pomocni_k;
               for (k;k&lt;granica_kolone;k++)
                    pomocni_red.push_back(kont.at(i).at(j).at(k)); 
               
               pomocni_matrica.push_back(pomocni_red);
               
               if (j &lt; n)
               {
                   pomocni_k++;
                   pomocni_granica--;
               }
               else
               {
                   pomocni_k--;
                   pomocni_granica++;
               }
               
           }
           
           rezultat.push_back(pomocni_matrica);
       }
       
   }
   
   if (smjer == SmjerKretanja::DoljeGore)
   {
       int n = kont.size()/2;
       for (int i{};i&lt;kont.size();i++)
       {
           typename std::remove_reference&lt;decltype(kont.at(0))&gt;::type pomocni_matrica;
           
           int pomocni_k = 0;
           int pomocni_granica = kont.size();
<a name="0"></a><font color="#FF0000"><a href="match969-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

           for (int j{kont.size()-1};j&gt;=0;j--)
           {
               typename std::remove_reference&lt;decltype(kont.at(0).at(0))&gt;::type pomocni_red;
</font>               int granica_kolone = pomocni_granica;
               int k = pomocni_k;
               for (k;k&lt;granica_kolone;k++)
                    pomocni_red.push_back(kont.at(i).at(j).at(k)); 
               
               pomocni_matrica.push_back(pomocni_red);
               
               if (j &gt; n)
               {
                   pomocni_k++;
                   pomocni_granica--;
               }
               else
               {
                   pomocni_k--;
                   pomocni_granica++;
               }
               
           }
           
           rezultat.push_back(pomocni_matrica);
       }
       
   }
   
   if (smjer == SmjerKretanja::DesnoLijevo)
   {
       int n = kont.size()/2;
       for (int i{};i&lt;kont.size();i++)
       {
           typename std::remove_reference&lt;decltype(kont.at(0))&gt;::type pomocni_matrica;
           
           int pomocni_k = 0;
           int pomocni_granica = kont.size();
<a name="1"></a><font color="#00FF00"><a href="match969-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

           for (int j{kont.size()-1};j&gt;=0;j--)
           {
               typename std::remove_reference&lt;decltype(kont.at(0).at(0))&gt;::type pomocni_red;
</font>               int granica_kolone = pomocni_granica;
               int k = pomocni_k;
               for (k;k&lt;granica_kolone;k++)
                    pomocni_red.push_back(kont.at(i).at(k).at(j)); 
               
               pomocni_matrica.push_back(pomocni_red);
               
               if (j &gt; n)
               {
                   pomocni_k++;
                   pomocni_granica--;
               }
               else
               {
                   pomocni_k--;
                   pomocni_granica++;
               }
               
           }
           
           rezultat.push_back(pomocni_matrica);
       }
       
   }
   
   if (smjer == SmjerKretanja::LijevoDesno)
   {
       int n = kont.size()/2;
       for (int i{};i&lt;kont.size();i++)
       {
           typename std::remove_reference&lt;decltype(kont.at(0))&gt;::type pomocni_matrica;
           
           int pomocni_k = 0;
           int pomocni_granica = kont.size();
           for (int j{};j&lt;kont.size();j++)
           {
               typename std::remove_reference&lt;decltype(kont.at(0).at(0))&gt;::type pomocni_red;
               int granica_kolone = pomocni_granica;
               int k = pomocni_k;
               for (k;k&lt;granica_kolone;k++)
                    pomocni_red.push_back(kont.at(i).at(k).at(j)); 
               
               pomocni_matrica.push_back(pomocni_red);
               
               if (j &lt; n)
               {
                   pomocni_k++;
                   pomocni_granica--;
               }
               else
               {
                   pomocni_k--;
                   pomocni_granica++;
               }
               
           }
           
           rezultat.push_back(pomocni_matrica);
       }
       
   }
   
   if (smjer == SmjerKretanja::NaprijedNazad)
   {
       int n = kont.size()/2;
       for (int i{};i&lt;kont.size();i++)
       {
           typename std::remove_reference&lt;decltype(kont.at(0))&gt;::type pomocni_matrica;
           
           int pomocni_k = 0;
           int pomocni_granica = kont.size();
           for (int j{};j&lt;kont.size();j++)
           {
               typename std::remove_reference&lt;decltype(kont.at(0).at(0))&gt;::type pomocni_red;
               int granica_kolone = pomocni_granica;
               int k = pomocni_k;
               for (k;k&lt;granica_kolone;k++)
                    pomocni_red.push_back(kont.at(j).at(i).at(k)); 
               
               pomocni_matrica.push_back(pomocni_red);
               
               if (j &lt; n)
               {
                   pomocni_k++;
                   pomocni_granica--;
               }
               else
               {
                   pomocni_k--;
                   pomocni_granica++;
               }
               
           }
           
           rezultat.push_back(pomocni_matrica);
       }
       
   }
   
   if (smjer == SmjerKretanja::NazadNaprijed)
   {
       int n = kont.size()/2;
       for (int i{};i&lt;kont.size();i++)
       {
           typename std::remove_reference&lt;decltype(kont.at(0))&gt;::type pomocni_matrica;
           
           int pomocni_k = 0;
           int pomocni_granica = kont.size();
<a name="2"></a><font color="#0000FF"><a href="match969-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

           for (int j{kont.size()-1};j&gt;=0;j--)
           {
               typename std::remove_reference&lt;decltype(kont.at(0).at(0))&gt;::type pomocni_red;
</font>               int granica_kolone = pomocni_granica;
               int k = pomocni_k;
               for (k;k&lt;granica_kolone;k++)
                    pomocni_red.push_back(kont.at(j).at(i).at(k)); 
               
               pomocni_matrica.push_back(pomocni_red);
               
               if (j &gt; n)
               {
                   pomocni_k++;
                   pomocni_granica--;
               }
               else
               {
                   pomocni_k--;
                   pomocni_granica++;
               }
               
           }
           
           rezultat.push_back(pomocni_matrica);
       }
       
   }
    
    
    
    return rezultat;
}

int main ()
{
    try
    {
        std::cout&lt;&lt;"Unesite dimenziju (x/y/z): ";
        int n;
        std::cin&gt;&gt;n;
        std::cin.ignore(10000, '\n');
        while (n&lt;=0)
        {
            std::cout&lt;&lt;"Dimenzija nije ispravna, unesite opet: ";
            std::cin&gt;&gt;n;
            std::cin.ignore(10000, '\n');
        }
        
<a name="3"></a><font color="#00FFFF"><a href="match969-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        std::vector&lt;std::deque&lt;std::deque&lt;int&gt;&gt;&gt; upis;
        
        std::cout&lt;&lt;"Unesite elemente kontejnera: ";
        for (int i{};i&lt;n;i++)
</font>        {
            std::deque&lt;std::deque&lt;int&gt;&gt; d;
            
            for (int j{};j&lt;n;j++)
            {
                std::deque&lt;int&gt; red;
                
                for (int k{};k&lt;n;k++)
                {
                    int x;
                    std::cin&gt;&gt;x;
                    red.push_back(x);
                }
                
                std::cin.ignore(10000, '\n');
                d.push_back(red);
            }
            
            upis.push_back(d);
        }
        
        std::cout&lt;&lt;"Unesite smjer kretanja [0 - 5]: ";
        int smjer;
        std::cin&gt;&gt;smjer;
        
        while (true)
        {
            if (smjer&gt;=0 &amp;&amp; smjer&lt;=5)
                break;
            std::cout&lt;&lt;"Smjer nije ispravan, unesite opet: ";
            std::cin&gt;&gt;smjer;
            std::cin.ignore(10000, '\n');
        }
        
        std::cout&lt;&lt;std::endl;
        auto ispis = PjescaniSat(upis,(SmjerKretanja)smjer);
        
        std::cout&lt;&lt;"Pjescani sat unesene matrice je:"&lt;&lt;std::endl;
        
        int velicina = n/2;
        for (int i{}; i&lt;n; i++)
        {
            std::cout&lt;&lt;std::endl;
            int pomocni_l = 0;
            int pomocni_granica = n;
            
            for (int j{};j&lt;n;j++)
            {
                int granica_kolone = pomocni_granica;
                int l = pomocni_l;
                int m = 0;
                for (int k{};k&lt;n;k++)
                {
                    if (k&gt;=l &amp;&amp; k&lt;granica_kolone)
                        std::cout&lt;&lt;std::right&lt;&lt;std::setw(4)&lt;&lt;ispis[i][j][m++];
                    else
                        std::cout&lt;&lt;"    ";
                }
                
                if (j&lt;velicina)
                {
                    pomocni_l++;
                    pomocni_granica--;
                }
                else
                {
                    pomocni_l--;
                    pomocni_granica++;
                }
                
                std::cout&lt;&lt;std::endl;
            }
            
        }
    }
    catch (std::domain_error e)
    {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
    }
    catch (std::length_error e)
    {
        std::cout&lt;&lt;"Izuzetak: "&lt;&lt;e.what();
    }
    
	return 0;
}</pre>
</body>
</html>
