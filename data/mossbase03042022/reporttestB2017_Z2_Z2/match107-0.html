<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z2/student1531.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z2/student1531.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 2
	
	NAPOMENA: ulaz/izlaz za zadatke je specificiran
	javnim autotestovima. Zalbe za ne analiziranje testova
	se ne uvazavaju!
	
	NAPOMENA: nece svi (javni) testovi sa zamgera biti 
	dostupni na c9.

	Za sva ostala pitanja i nedoumice vezane za 
	autotestove javiti se na forum (c2).
*/
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
<a name="0"></a><font color="#FF0000"><a href="match107-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

using namespace std;
enum class Boje {Pik, Tref, Herc, Karo} boja;
vector&lt;string&gt;v{"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"};
vector&lt;string&gt;v2{"Pik", "Tref", "Herc", "Karo"};

void IspisiKarte(std::list&lt;std::pair&lt;Boje, std::string&gt; &gt; l){
    for(auto i : l){
            if(i.first == Boje(0)) std::cout&lt;&lt;"pik";
            else if(i.first == Boje(1)) std::cout&lt;&lt;"tref";
            else if(i.first == Boje(2)) std::cout&lt;&lt;"herc";
            else std::cout&lt;&lt;"karo";
        std::cout&lt;&lt;" | " &lt;&lt; i.second&lt;&lt;std::endl;
    }
}

   list&lt;pair&lt;Boje, string&gt;&gt; KreirajSpil(){
       list&lt;pair&lt;Boje, string&gt;&gt;lista(52);
       int x = 0;
       boja=Boje(x);
       int k(0);
       for(auto it=lista.begin();it!=lista.end();it++){
           *it=make_pair(boja, v[k]);
           k++;
           if(k==v.size()){
               k=0;
               x++;
               boja=Boje(x);
           }

       }
       return lista;
   }

   bool pom(pair&lt;Boje,string&gt;p, multimap&lt;Boje, string&gt;&amp;m){
       for(auto it=m.begin(); it!=m.end();it++){
           // std::cout&lt;&lt;"g";
           if(p.first==it-&gt;first &amp;&amp; p.second==it-&gt;second)
           return true;
       }
       return false;
   }

   int pretraziVektor(string s){
    for(int i = 0; i&lt;v.size(); i++)
        if(s == v[i]) return i;
    return -1;
   }

   bool SmislenSpil(list&lt;pair&lt;Boje, string&gt;&gt; l){
    Boje trenutna_boja = (*(l.begin())).first;
    int trenutni_broj = pretraziVektor((*(l.begin())).second);

    for(auto it = l.begin(); it!=l.end(); it++){
        if(it == l.begin()) continue;
        Boje procitana_boja = it-&gt;first;
        int procitani_broj = pretraziVektor(it-&gt;second);

        if((int)procitana_boja == (int)trenutna_boja){
            if(trenutni_broj &gt;= procitani_broj) return false;
        }
        if((int)procitana_boja &lt; (int)trenutna_boja) return false;
    }
return true;
   }

    void IzbaciKarte(list&lt;pair&lt;Boje, string&gt;&gt;&amp;l, multimap&lt;Boje, string&gt;&amp;m){
    if(l.size()&gt;52)throw logic_error("Neispravna lista!");
        if(!SmislenSpil(l)) throw logic_error("nije smisleno");
        for(auto it=l.begin();it!=l.end();it++){
            pair&lt;Boje, string&gt;p=*it;
            if(pom(*it, m)){
                it = l.erase(it);
                it = l.begin();
                for(auto it2 = m.begin(); it2 != m.end(); it2++){
                    if(p.first==it2-&gt;first &amp;&amp; p.second==it2-&gt;second){
                        m.erase(it2);
                    }
                }
            }
        }
    }

    queue&lt;pair&lt;string,string&gt;&gt;IzbaciKarteRazbrajanjem(list&lt;pair&lt;Boje, string&gt;&gt;&amp;l, const short int &amp;r, const int &amp;b){
        if(r&lt;1 || r&gt;52 ||b&lt;1)throw logic_error("Neispravni elementi za izbacivanje!");
        if(l.size()&gt;52)throw logic_error("Neispravna lista!");
        queue&lt;pair&lt;string, string&gt;&gt; red;
        short int br(1);
        int koliko(0);

        for(auto it=l.begin();it!=l.end();){
            if(br==r) {
            koliko++;
            string pom=v2[(int)it-&gt;first];
            red.push(make_pair(pom,it-&gt;second));
            it=l.erase(it);
            br=1;
            it--;
            }
            else br++;
            if(koliko == b) break;
            it++;
            if(it == l.end()) it = l.begin();
        }
        return red;
    }

    int pretraziBoje(string s){
        for(int i = 0; i&lt;v2.size(); i++)
            if(s == v2[i]) return i;
        return -1;
    }

    void VratiPrvihNKarata(list&lt;pair&lt;Boje,string&gt;&gt;&amp;l, queue&lt;pair&lt;string, string&gt;&gt;&amp;red, int n){
        if(n&gt;red.size())throw range_error("Nedovoljno karata u redu!");
        if(n&lt;0)throw domain_error("Broj n je besmislen!");
        if(l.size()&gt;52)throw logic_error("Neispravna lista!");
        int br(0);
        while(n != 0){
            auto element = red.front();
            red.pop();
            n--;
            int redni_broj_boje = pretraziBoje(element.first);
            int redni_broj_broja = pretraziVektor(element.second);

            for(auto it = l.begin(); it != l.end(); it++){
                int boja_u_listi = (int)it-&gt;first;
                int redni_broj_u_listi = pretraziVektor(it-&gt;second);
                if(redni_broj_boje == boja_u_listi &amp;&amp; redni_broj_u_listi &gt; redni_broj_boje){
                    l.insert(it, std::make_pair(Boje(redni_broj_boje), element.second));
                    break;
                }
                else if(redni_broj_boje &gt; boja_u_listi){
                    l.insert(it, std::make_pair(Boje(redni_broj_boje), element.second));
                    break;
                }
            }
        }
    }


int main ()
{
    auto l = KreirajSpil();
    std::multimap&lt;Boje, string&gt; m{ {Boje(0), "5"}, {Boje(0), "6"}, {Boje(0), "6"}
    };
    auto red = IzbaciKarteRazbrajanjem(l, 12, 6);
    IspisiKarte(l);
    std::cout&lt;&lt;red.size();
    std::cout&lt;&lt;std::boolalpha&lt;&lt;SmislenSpil(l);
	return 0;
</font>}</pre>
</body>
</html>
