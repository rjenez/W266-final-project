<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z2/student2664.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z2/Z2/student2664.cpp<p></p><pre>
/*B 2017/2018, ZadaÄ‡a 2, Zadatak 2 */
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;type_traits&gt;
#include &lt;iomanip&gt;
<a name="0"></a><font color="#FF0000"><a href="match63-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

enum class SmjerKretanja{NaprijedNazad, NazadNaprijed, GoreDolje, DoljeGore, LijevoDesno, DesnoLijevo};
enum class Provjera{Kocka, NeparneDimenzije};
using std::domain_error;
using std::length_error;
using std::cout;
using std::endl;
using std::cin;
using std::vector;
using std::deque;
using std::remove_reference;
using std::setw;

template &lt;typename Tip&gt;
bool ProvjeraDim(const Tip &amp;kont, Provjera provjera){
    int dimenzija(kont.size());
    for(int i=0; i&lt;kont.size(); i++){
        if(provjera == Provjera::Kocka &amp;&amp; kont.at(i).size() != dimenzija) return false;
        else if(provjera == Provjera::NeparneDimenzije &amp;&amp; kont.at(i).size() % 2 == 0) return false;
        for(int j=0; j&lt;kont.at(i).size(); j++)
            if(provjera == Provjera::Kocka &amp;&amp; kont.at(i).at(j).size() != dimenzija) return false;
            else if(provjera == Provjera::NeparneDimenzije &amp;&amp; kont.at(i).at(j).size() % 2 == 0) return false;
    }
    return true;
}

template &lt;typename TipElem&gt;
void RazmjenaElem(TipElem &amp;a, TipElem &amp;b){
    TipElem pom(a);
    a = b;
    b = pom;
}

template &lt;typename Tip&gt;
void RazmjenaRedova(Tip &amp;a, Tip &amp;b){
    for(int j=0; j&lt;a.size(); j++)
        RazmjenaElem(a.at(j), b.at(j));
}

template &lt;typename Tip&gt;
Tip ObrniRedove(const Tip &amp;kont){
    Tip novi(kont);
    for(int i=0; i&lt;novi.size(); i++){
        int n(novi.at(i).size());
        for(int j=0; j&lt;n/2; j++)
            RazmjenaRedova(novi.at(i).at(j), novi.at(i).at(n-1-j));
    }
    return novi;
}

template &lt;typename Tip&gt;
Tip TransformRedoveUKolone(Tip kont){
    Tip novi(kont);
    int n(kont.size());
    for(int i=0; i&lt;n; i++)
        for(int j=0; j&lt;n; j++)
            for(int k=0; k&lt;n; k++)
                novi.at(i).at(j).at(k) = kont.at(i).at(k).at(j);
    
    return novi;
}

template &lt;typename Tip&gt;
Tip TransformNaprijedNazad(Tip kont){
    Tip novi(kont);
    int n(kont.size());
    for(int i=0; i&lt;n; i++){
        for(int j=0; j&lt;n; j++){
            for(int k=0; k&lt;n; k++){
                novi.at(i).at(j).at(k) = kont.at(i).at(i).at(k);
            }
        }
    }
    return novi;
}


template &lt;typename Tip&gt;
Tip PjescaniSat(Tip kont, SmjerKretanja smjer){
	if(!ProvjeraDim(kont, Provjera::Kocka)) throw domain_error("3D matrica nema oblik kocke");
	if(!ProvjeraDim(kont, Provjera::NeparneDimenzije)) throw length_error("3D kontejner ne zadovoljava uvjet neparnosti");
    
    int n(kont.size());
    Tip novi;
    
    if(SmjerKretanja::LijevoDesno == smjer || SmjerKretanja::DesnoLijevo == smjer) kont = TransformRedoveUKolone(kont);
    if(smjer == SmjerKretanja::DesnoLijevo) kont = ObrniRedove(kont);
    
    if(smjer == SmjerKretanja::NaprijedNazad) kont = TransformNaprijedNazad(kont);
    
    for(int i=0; i&lt;n; i++){
        typename remove_reference&lt;decltype(kont.at(i))&gt;::type tabla;
        for(int j=0; j&lt;n; j++){
            typename remove_reference&lt;decltype(kont.at(i).at(j))&gt;::type red_table;
            for(int k=0; k&lt;n; k++){
                if(j==k || k == -j+n-1 || (j&lt;n/2 &amp;&amp; j&lt;k &amp;&amp; k&lt;-j+n-1) || (j&gt;n/2 &amp;&amp; j&gt;k &amp;&amp; k&gt;-j+n-1)){
                    auto element(kont.at(i).at(j).at(k));
                    red_table.push_back(element);
                }
            }
            tabla.push_back(red_table);
        }
        novi.push_back(tabla);
    }
    
    if(smjer == SmjerKretanja::DoljeGore) return ObrniRedove(novi);
    
    return novi; 
}


int main (){
    cout &lt;&lt; "Unesite dimenziju (x/y/z): ";
    int n(1);
    do{
        cin &gt;&gt; n;
        if(n &lt;= 0) cout &lt;&lt; "Dimenzija nije ispravna, unesite opet: ";
        else break;
    }while(1);
    cout &lt;&lt; "Unesite elemente kontejnera: ";
    vector&lt;deque&lt;deque&lt;int&gt;&gt;&gt; kontejner(n, deque&lt;deque&lt;int&gt;&gt; (n, deque&lt;int&gt;(n)));
    
    for(int i=0; i&lt;n; i++)
        for(int j=0; j&lt;n; j++)
            for(int k=0; k&lt;n; k++)
                cin &gt;&gt; kontejner.at(i).at(j).at(k);
    
    
    cout &lt;&lt; "Unesite smjer kretanja [0 - 5]: ";
    int sm;
    do{
        cin &gt;&gt; sm;
        if(sm &lt; 0 || sm &gt; 5) cout &lt;&lt; "Smjer nije ispravan, unesite opet: ";
        else break;
    }while(1);
    SmjerKretanja niz[6]{SmjerKretanja::NaprijedNazad, SmjerKretanja::NazadNaprijed, SmjerKretanja::GoreDolje, SmjerKretanja::DoljeGore, SmjerKretanja::LijevoDesno, SmjerKretanja::DesnoLijevo};
    SmjerKretanja smjer(niz[sm]);
    
    try{
        auto novi(PjescaniSat(kontejner, smjer));
        cout &lt;&lt; "\nPjescani sat unesene matrice je:\n\n";
        int n(novi.size());
        for(int i=0; i&lt;n; i++){
            int nn(novi.at(i).size());
            for(int j=0, br=0; j&lt;nn; j++){
                int nnn(novi.at(i).at(j).size());
                for(int z=0; z&lt;br; z++) cout &lt;&lt; "    ";
                for(int k=0; k&lt;nnn; k++)
                    cout &lt;&lt; setw(4) &lt;&lt; novi.at(i).at(j).at(k);
                cout &lt;&lt; endl;
                if(br &lt; n/2) br++;
                else br--;
            }
            cout &lt;&lt; endl;
        }
        cout &lt;&lt; endl;
    }
    catch(length_error er){
        cout &lt;&lt; "\nIzuzetak: " &lt;&lt; er.what() &lt;&lt; endl;
    }
	catch(domain_error er){
	    cout &lt;&lt; "\nIzuzetak: " &lt;&lt; er.what() &lt;&lt; endl;
	}
	return 0;
</font>}</pre>
</body>
</html>
