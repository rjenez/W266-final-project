<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student3871.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student9671.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;iomanip&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;initializer_list&gt;
#include &lt;functional&gt;

const double PI = 4*std::atan(1);

class FourierovRed
{
    double a0;
    std::vector&lt;double&gt; ak;
    std::vector&lt;double&gt; bk;
    double T;
    int N;
    double b0;

  public:

  FourierovRed(double period, std::initializer_list&lt;double&gt; a, std::initializer_list&lt;double&gt; b) : T(period)
  {
      if(a.size() == b.size())
      {
          a0 = *(a.begin()); //nulti clan
          N = a.size();
          ak.resize(N); bk.resize(N);
          int i(0); auto it(a.begin()); it++;
          for(; it != a.end() ; it++)
          {
              ak[i] = *it; i++;
          }
          ak[i+1] = 0; int j(0);
          for(auto it1(b.begin()); it1 != b.end(); it1++)
          {
              bk[j] = *it1; j++;
          }
      }
      if(a.size() &lt; b.size())
      {
           a0 = *(a.begin());
           N = b.size();
           ak.resize(N); bk.resize(N); int i(0), j(0);// bk[0] = 0;
           for(auto it(b.begin()); it != b.end(); it++)
           {
               bk[i] = *it;
               i++;
           }
           auto it2(a.begin());
           if(it2 != a.end()){it2++;
           for(; it2 != a.end(); it2++)
           {
               ak[j] = *it2; j++;
           }}
           for(int k(j); k &lt; N; k++)
           {
               ak[k] = 0;
           }
      }
      if(a.size() &gt; b.size())
      {
          a0 = *(a.begin());
          N = a.size();
          ak.resize(N); bk.resize(N); int i(0), j(0);
          auto it(a.begin()); it++;
          for(; it != a.end(); it++)
           {
               ak[i] = *it; i++;
           }
           //bk[0] = 0;
           for(auto it1(b.begin()); it1 != b.end(); it1++)
           {
               bk[j] = *it1;
               j++;
           }
           for(int k(j); k &lt; i; k++)
           {
               bk[k] = 0;
           }
          // for(int i(0); i &lt; N; i++) std::cout&lt;&lt;ak[i]&lt;&lt;" ";
          //for(int i(0); i &lt; N; i++) std::cout&lt;&lt;bk[i]&lt;&lt;" ";
      }
  };
  FourierovRed(int n, double period, std::function&lt;double(int)&gt; f1, std::function&lt;double(int)&gt; f2) : T(period)
  {
      if(n &lt; 0) throw std::domain_error("Stepen mora biti pozitivan\n");
      N = n;
      ak.resize(N); bk.resize(N);
      a0 = f1(0);
      for(int i(1); i &lt; n; i++)
      {
          ak[i-1] = f1(i);
          bk[i-1] = f2(i);
          //if(i == 0) bk[0] = 0;
      }
  };
<a name="0"></a><font color="#FF0000"><a href="match976-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

  FourierovRed(int n, double p, double q, std::function&lt;double(double)&gt; f, int M)
  {
      if(n &lt; 0) throw std::domain_error("Stepen mora biti pozitivan\n");
      if(M &lt; 0) throw std::domain_error("Broj podintervala mora biti pozitivan\n");
      if(p &gt; q) throw std::range_error("Neispravan interval\n");
      N = n; T = q - p;
</font>      ak.resize(N); bk.resize(N);
      for(int k(0); k &lt;= n; k++)
      {
          double sumaA(0), sumaB(0);
          for(int i(1); i &lt;= M-1; i++)
          {
              sumaA += f(p + (i*T)/M)*std::cos(2*k*PI*(p/T + i/M));
              if(k != 0) sumaB += f(p + (i*T)/M)*std::sin(2*k*PI*(p/T + i/M));
          }
          if(k == 0) {a0 = (2*sumaA)/M + ((f(p) + f(q))/M); }//bk[0] = 0;}
          if(k != 0) ak[k-1] = (2*sumaA)/M + ((f(p) + f(q))/M)*std::cos((2*k*PI*p)/T);
          if(k != 0) bk[k-1] = (2*sumaB)/M + ((f(p) + f(q))/M)*std::sin((2*k*PI*p)/T);
      }
  };
  FourierovRed(const FourierovRed &amp;r) : N(r.N), T(r.T), a0(r.a0)
  {
       ak.resize(N); bk.resize(N);
       for(int i(0); i &lt; r.N; i++)
       {
           ak[i] = r.ak[i]; bk[i] = r.bk[i];
       }
  };
  FourierovRed(FourierovRed &amp;&amp;r) : N(r.N), T(r.T), a0(r.a0)
  {
      ak = std::move(r.ak);
      bk = std::move(r.bk);
      /*double *pomocni1(r.ak);
      double *pomocni2(r.bk);
      ak = pomocni1;
      bk = pomocni2;
      pomocni1 = pomocni2 = r.ak = r.bk = nullptr;*/
  };
  FourierovRed &amp;operator =(const FourierovRed &amp;r)
  {
     N = r.N; T = r.T; a0 = r.a0;
     ak.clear(); bk.clear();
     //ak = nullptr; bk = nullptr;
     ak.resize(r.N); bk.resize(r.N);
     for(int i(0); i &lt; r.N; i++)
       {
           ak[i] = r.ak[i]; bk[i] = r.bk[i];
       }
     return *this;
  };
  FourierovRed &amp;operator =(FourierovRed &amp;&amp;r)
  {
     N = r.N; T = r.T; a0 = r.a0;
     //delete [] ak; delete [] bk;
     //ak = nullptr; bk = nullptr;
     //ak = new double[r.N]; bk = new double[r.N];
     ak.clear(); bk.clear();
     /*double *pomocni1(r.ak); double *pomocni2(r.bk);
     ak = pomocni1;
     bk = pomocni2;
     pomocni1 = pomocni2 = r.ak = r.bk = nullptr;*/
     ak = std::move(r.ak);
     bk = std::move(r.bk);
     return *this;
  };
 /* ~FourierovRed()
  {
     delete [] ak;
     delete [] bk;
  };*/
  double operator ()(double x)
  {
      double rezultat(a0/2);
      for(int k(1); k &lt;= N; k++)
      {
          rezultat += ak[k-1]*std::cos((2*k*PI*x)/T) + bk[k-1]*std::sin((2*k*PI*x)/T);
      }
      return rezultat;
  };
  std::pair&lt;double, double&gt; operator [](int k) const
  {
      double pomocni(a0);
      if(k &lt; 0 || k &gt; N) throw std::range_error("Neispravan indeks\n");
      if(k == 0) return std::make_pair&lt;double, double&gt;(std::remove_reference&lt;double&amp;&gt;::type(pomocni), 0.);
      else return std::make_pair&lt;double, double&gt;(std::remove_reference&lt;double&amp;&gt;::type(ak[k-1]), std::remove_reference&lt;double&amp;&gt;::type(bk[k-1]));
  };
  std::pair&lt;double&amp;, double&amp;&gt; operator [](int k)
  {
      b0 = 0.;
      double pomocni(a0), pomocni1(b0);
      if(k &lt; 0 || k &gt; N) throw std::range_error("Neispravan indeks\n");
      if(k == 0) {std::pair&lt;double&amp;, double&amp;&gt; p0(pomocni, pomocni1); return p0; }
      std::pair&lt;double&amp;, double&amp;&gt; p(ak[k - 1],bk[k - 1]);
      return p;
  };
};

int main ()
{
    FourierovRed f(4, {}, {-1.27324, 0.63662, -0.42441, 0.31831, -0.25465, 0.21221, -0.18189, 0.15915, -0.14147, 0.12732});
    try{
        for(int i(0); i &lt;= 10; i++) std::cout&lt;&lt;f[i].second&lt;&lt;" ";
        std::cout&lt;&lt;"\n";
    }
    catch(std::range_error r)
    {
        std::cout&lt;&lt;r.what();
    }
    FourierovRed f1(4, {4, 1}, {});
    try{
        for(int i(0); i &lt;= 2; i++) std::cout&lt;&lt;f1[i].first&lt;&lt;" ";
        std::cout&lt;&lt;"\n";
        for(int i(0); i &lt;= 2; i++) std::cout&lt;&lt;f1[i].second&lt;&lt;" ";
        std::cout&lt;&lt;"\n";
    }
    catch(std::range_error r)
    {
        std::cout&lt;&lt;r.what();
    }
	return 0;
}
</pre>
</body>
</html>
