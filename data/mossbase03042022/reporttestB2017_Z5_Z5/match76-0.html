<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student7123.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student7123.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;iomanip&gt;
#include &lt;functional&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;initializer_list&gt;
using namespace std;

double  PI = 4*atan(1);

class FourierovRed{
    double T;
    int N;
    vector&lt;double&gt; koef_a, koef_b;
public:
    FourierovRed(int br, double t, double fun1(int), double fun2(int)){
        if(br&lt;=0) throw domain_error("Stepen mora biti pozitivan");
        N=br+1; T=t;
        koef_a.resize(N); 
        koef_b.resize(N); 
<a name="7"></a><font color="#0000FF"><a href="match76-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

        koef_b[0]=0;
        for(int i=0; i&lt;N; i++) koef_a[i]=fun1(i);
        for(int i=1; i&lt;N; i++) koef_b[i]=fun2(i);
</font>    }
    ~FourierovRed() { }
    FourierovRed(double t, initializer_list&lt;double&gt; lista1, initializer_list&lt;double&gt;lista2)
    {
        list&lt;double&gt; l1=lista1;
<a name="3"></a><font color="#00FFFF"><a href="match76-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

        list&lt;double&gt; l2; l2.push_back(0);
        for(auto it=lista2.begin(); it!=lista2.end(); it++) l2.push_back(*it);
        while(l1.size()&lt;l2.size()) l1.push_back(0);
        while(l2.size()&lt;l1.size()) l2.push_back(0);
        koef_a.resize(l1.size());
</font>        N=l2.size()+1; 
<a name="5"></a><font color="#FF0000"><a href="match76-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        koef_b.resize(l2.size());
        int i=0;
        for(auto it=l1.begin(), it1=l2.begin(); it!=l1.end(); it++, it1++){ koef_a[i]=*it; koef_b[i]=*it1; i++;}
</font>    }
    FourierovRed(int br, double p, double q, double f(double), int M){
        if(M&lt;=0) throw domain_error("Broj podintervala mora biti pozitivan");
        if(br&lt;0) throw domain_error("Stepen mora biti pozitivan");
        if(p&gt;=q) throw range_error("Neispravan interval");
        T=q-p; N=br+1;
        koef_a.resize(N);
        koef_b.resize(N);
         koef_b[0]=0;
<a name="0"></a><font color="#FF0000"><a href="match76-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

        for(int i=0; i&lt;N; i++)
        {
            double prvi=((f(p)+f(q))/M)*cos((2*i*PI*p)/T);
            double suma=0;
            for(int j=1; j&lt;=M-1; j++)
               {
                   suma+=(f(p+(j*T)/M)*cos(2*j*PI*((p/T)+(j/M))));
               }
            koef_a[i]=prvi+(2/M)*suma;
</font>            
<a name="4"></a><font color="#FF00FF"><a href="match76-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

             double prvi1=((f(p)+f(q))/M)*sin((2*(i+1)*PI*p)/T);
            double suma1=0;
            for(int j=1; j&lt;=M-1; j++)
                {
                    suma1+=f(p+(j*T)/2)*sin(2*j*PI*((p/T)+(j/M)));
                }
            koef_b[i]=prvi1+(2/M)*suma1;
</font>        
        }
    }
    pair&lt;double &amp;,double &amp;&gt; operator [] (int ind){
        if(ind&lt;0 || ind&gt;=N-1) throw range_error("Neispravan indeks");
<a name="10"></a><font color="#FF0000"><a href="match76-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

        pair&lt;double&amp;,double&amp;&gt; p(koef_a[ind],koef_b[ind]);
        return p;
    }
    FourierovRed(const FourierovRed &amp;f){
        N=f.N; T=f.T; 
</font>        koef_a.resize(N+1);
<a name="1"></a><font color="#00FF00"><a href="match76-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

        koef_b.resize(N+1);
        for(int i=0; i&lt;N; i++) { koef_a[i]=(f.koef_a[i]); }
        for(int i=0; i&lt;N; i++) { koef_b[i]=(f.koef_b[i]); }
    }    
    FourierovRed &amp;operator = (FourierovRed &amp;f)
    {
        koef_b.resize(0);
        koef_a.resize(0);
        N=f.N; T=f.T;
        koef_a.resize(N);
</font>        koef_b.resize(N);
<a name="6"></a><font color="#00FF00"><a href="match76-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

        for(int i=0; i&lt;N; i++) { koef_a[i]=(f.koef_a[i]); }
        for(int i=0; i&lt;N; i++) { koef_b[i]=(f.koef_b[i]); }
        return *this;

    }
    pair&lt;double,double&gt; operator [] (int ind) const{
</font>        if(ind&lt;0 || ind&gt;=N-1) throw range_error("Neispravan indeks");
        pair&lt;double,double&gt; p=make_pair(koef_a[ind],koef_b[ind]);
        return p;
    }
    FourierovRed(FourierovRed &amp;&amp;f)
    {
<a name="8"></a><font color="#00FFFF"><a href="match76-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

        N=f.N; T=f.T; koef_a=f.koef_a; koef_b=f.koef_b;
        f.N=0; f.T=0; 
</font>    }
<a name="2"></a><font color="#0000FF"><a href="match76-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

    double operator ()(double x){
        double prvia=(koef_a[0])/2;
        double sumaa=0;
        for(int i=1; i&lt;N; i++)
            sumaa+=((koef_a[i]*cos((2*i*PI*x)/T)) + (koef_b[i]*sin((2*i*PI*x)/T)));
        return prvia + sumaa;
</font>
    }
    FourierovRed &amp;operator = (FourierovRed &amp;&amp;f)
    {
        if(&amp;f==this) return *this;
        koef_b.resize(0);
        koef_a.resize(0);
<a name="9"></a><font color="#FF00FF"><a href="match76-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

        N=f.N; T=f.T; koef_a=f.koef_a; koef_b=f.koef_b;
        f.N=0; f.T=0; 
</font>        return *this;
    }
    
};

int main ()
{
    
   
	return 0;
}
</pre>
</body>
</html>
