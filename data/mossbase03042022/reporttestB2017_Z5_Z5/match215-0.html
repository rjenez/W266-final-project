<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student7795.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student7795.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

class FourierovRed {
private:
    double static constexpr PI = 4 * std::atan(1);
    double static constexpr ERROR = 0.0000000001;
    int N;
    double T;
    std::vector&lt;double&gt; a, b;
    
    void static checkParams(int num, int M = 1, double p = 1, double q = 1, bool ntype = false) {
      if(num &lt;= 0) throw std::domain_error("Stepen mora biti pozitivan");
      if(ntype) {
        if(M &lt;= 0) throw std::domain_error("Broj podintervala mora biti pozitivan");
        if(p - q &gt;= ERROR) throw std::range_error("Neispravan interval");
      }
    }
    void IsprazniMemoriju();
public:
  ~FourierovRed();
  FourierovRed(const FourierovRed&amp; red);
  FourierovRed(FourierovRed&amp;&amp; red);
  
  FourierovRed&amp; operator=(const FourierovRed&amp; red);
  FourierovRed&amp; operator=(FourierovRed&amp;&amp; red);
  
<a name="0"></a><font color="#FF0000"><a href="match215-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_10.gif"/></a>

  FourierovRed(double T, std::initializer_list&lt;double&gt; k_a, std::initializer_list&lt;double&gt; k_b);
  FourierovRed(int N, double T, std::function&lt;double(int)&gt; funk_a, std::function&lt;double(int)&gt; funk_b);
  FourierovRed(int N, double p, double q, std::function&lt;double(double)&gt; f, int M);
  
  double operator()(double x) const;
  std::pair&lt;double, double&gt; operator[](int k) const;
  std::pair&lt;double&amp;, double&amp;&gt; operator[](int k);
</font>};

/// implementation of FourierovRed interface
FourierovRed::~FourierovRed() {
	this-&gt;IsprazniMemoriju();
}
void FourierovRed::IsprazniMemoriju() {
	  a.clear(); b.clear();
    this-&gt;N = 0; this-&gt;T = 0;
}
/// ctors
FourierovRed::FourierovRed(double t, std::initializer_list&lt;double&gt; k_a, std::initializer_list&lt;double&gt; k_b) : 
    T(t), a(k_a) {
  N = std::max(k_a.size(), k_b.size()) + (k_b.size() &gt;= k_a.size() ? 1 : 0);
  a.resize(N, 0);
  b.push_back(0);
  b.insert(b.end(), k_b);
  b.resize(N, 0);
}
<a name="3"></a><font color="#00FFFF"><a href="match215-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

FourierovRed::FourierovRed(int N, double T, std::function&lt;double(int)&gt; funk_a, std::function&lt;double(int)&gt; funk_b) : 
	  N(N), T(T) {
</font>  checkParams(N);
  
  a.push_back(funk_a(0));
  b.push_back(0); 
  
  for(int i(1); i &lt;= N; ++i) {
      a.push_back(funk_a(i));
<a name="2"></a><font color="#0000FF"><a href="match215-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

      b.push_back(funk_b(i));
  }
}
FourierovRed::FourierovRed(int N, double p, double q, std::function&lt;double(double)&gt; f, int M) : 
	  N(N), T(q - p){
</font>  checkParams(N, M, p, q, true);
 
  double konstanta ((f(p) + f(q)) / M); /// downcasting, potential bug
  auto gen_function = [=](int k, std::function&lt;double(double)&gt; nizFunkcija) -&gt; double {
    double sum(0);
    for(int i(1); i &lt; M; ++i)
      sum += f(p + (i * T / M)) * nizFunkcija((2 * k * PI * (p / T + double(i) / M))); /// downcasting, potential bug
    return (konstanta * nizFunkcija(2 * k * PI * p / T) + 2. * sum / M);
  };
  
  a.push_back(gen_function(0, ::cos));
  b.push_back(0);

  for(int i(1); i &lt;= N; ++i) {
      a.push_back(gen_function(i, ::cos));
      b.push_back(gen_function(i, ::sin));
  }
}
FourierovRed::FourierovRed(const FourierovRed&amp; red) : N(red.N), T(red.T), a(red.a), b(red.b) { }
FourierovRed::FourierovRed(FourierovRed&amp;&amp; red) {
    this-&gt;IsprazniMemoriju();
    std::swap(N, red.N); std::swap(T, red.T);
    a.swap(red.a); b.swap(red.b);
}

/// operator implementation for class FourierovRed
/// DIJELJENJE NULOM, STA OVDJE? ZA T = 0
double FourierovRed::operator()(double x) const {
  double sum(0);
  for(int k(1); k &lt;= N; ++k) 
    sum += a[k]*::cos(2*k*PI*x/T) + b[k]*::sin(2*k*PI*x/T);
  return a[0]/2. + sum;
}
<a name="4"></a><font color="#FF00FF"><a href="match215-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

std::pair&lt;double, double&gt; FourierovRed::operator[](int k) const {
  if(k &lt; 0 || k &gt;= N)
    throw std::range_error("Neispravan indeks");
</font>
  if(k == 0) return { a[k], 0 };
<a name="1"></a><font color="#00FF00"><a href="match215-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

  return {a[k], b[k]};
}
std::pair&lt;double&amp;, double&amp;&gt; FourierovRed::operator[](int k) {
  if(k &lt; 0 || k &gt;= N)
    throw std::range_error("Neispravan indeks");

  b[0] = 0;
</font>  return {a[k], b[k]};
}

/// copy and move operators
FourierovRed&amp; FourierovRed::operator=(const FourierovRed&amp; red) {    
  this-&gt;IsprazniMemoriju();
  N = red.N;  T = red.T;
  a = red.a;  b = red.b;
  return *this;
}
FourierovRed&amp; FourierovRed::operator=(FourierovRed&amp;&amp; red) {
   this-&gt;IsprazniMemoriju();
   std::swap(N, red.N); std::swap(T, red.T);
   a.swap(red.a); b.swap(red.b);
   return *this;
}

int main () {

	return 0;
}</pre>
</body>
</html>
