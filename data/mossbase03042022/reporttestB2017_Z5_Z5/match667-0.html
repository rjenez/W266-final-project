<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student2267.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student2267.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include&lt;initializer_list&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;functional&gt;
#include &lt;cmath&gt;
#include &lt;utility&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

static constexpr double PI = 3.141592653589793;

class FourierovRed
{

    double T;
    int N;
    std::vector&lt;double&gt; koeficijenti_a, koeficijenti_b;
    double ignorisi = 0;                                            // pomocna varijabla koja 'kupi' b koeficijent pri red[0] = std::make_pair...


<a name="0"></a><font color="#FF0000"><a href="match667-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

public:
    FourierovRed(double T, std::initializer_list&lt;double&gt; lista_a, std::initializer_list&lt;double&gt; lista_b);
    FourierovRed(int N, double T, std::function&lt;double(int)&gt; f_1, std::function&lt;double(int)&gt; f_2 );
    FourierovRed(int N, double p, double q, std::function&lt;double(double)&gt; f, int M);
</font>    FourierovRed(const FourierovRed &amp;red)= default;
    FourierovRed &amp;operator =(const FourierovRed &amp;red) = default;
    FourierovRed(FourierovRed &amp;&amp;red) = default;
    FourierovRed &amp;operator =(FourierovRed &amp;&amp;red) = default;

    double operator() (double x) const;
    std::pair&lt;double, double&gt; operator [](int x) const;
    std::pair&lt;double &amp;, double &amp;&gt; operator [](int x);

};

FourierovRed::FourierovRed(double T, std::initializer_list&lt;double&gt; lista_a,
                           std::initializer_list&lt;double&gt; lista_b) : T(T)
{

    int velicina(0);
    N = 0;
    for(auto it = lista_a.begin(); it != lista_a.end(); it++) N++;
    for(auto it = lista_b.begin(); it != lista_b.end(); it++) velicina++;

    velicina++;

    if(N &lt; velicina) N = velicina;


    koeficijenti_a.resize(N);

    koeficijenti_b.resize(N);

    std::fill(koeficijenti_a.begin(), koeficijenti_a.end(), 0);
    std::fill(koeficijenti_b.begin(), koeficijenti_b.end(), 0);

    std::copy(lista_a.begin(), lista_a.end(), koeficijenti_a.begin());
    std::copy(lista_b.begin(), lista_b.end(), koeficijenti_b.begin() + 1);

}

<a name="1"></a><font color="#00FF00"><a href="match667-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

FourierovRed::FourierovRed(int N, double T, std::function&lt;double(int)&gt; f_1, std::function &lt;double(int)&gt; f_2 )
{
    if(N &lt;= 0) throw std::domain_error("Stepen mora biti pozitivan");
</font>    FourierovRed::N = N;
    FourierovRed::T = T;

    for(int i = 0; i &lt;= N; i++) {
        koeficijenti_a.emplace_back(i);
        koeficijenti_b.emplace_back(i);
    }

    std::transform(koeficijenti_a.begin(), koeficijenti_a.end(), koeficijenti_a.begin(), f_1);
    std::transform(koeficijenti_b.begin() + 1, koeficijenti_b.end(), koeficijenti_b.begin() + 1, f_2);
}

FourierovRed::FourierovRed(int N, double p, double q, std::function&lt;double(double)&gt; f, int M)
{

    if(N &lt;= 0) throw std::domain_error("Stepen mora biti pozitivan");
    if(M &lt;= 0) throw std::domain_error("Broj podintervala mora biti pozitivan");
    if(!(p &lt; q)) throw std::range_error("Neispravan interval");

    T = q - p;
    FourierovRed::N = N;

    koeficijenti_a.resize(N + 1);
    koeficijenti_b.resize(N + 1);


    for(int i = 0; i &lt;= N; i++) {
        koeficijenti_a[i] = i;
        koeficijenti_b[i] = i;
    }

    std::transform(koeficijenti_a.begin(), koeficijenti_a.end(), koeficijenti_a.begin(), [=](int k) {
        double red(0);
        for(int i = 0; i &lt; M; i++)
            red += (f(p + i*T/M) * std::cos(2 * k * PI * (p/T + (double)i/M)));
        return ((red * 2. /M) + (((f(p) + f(q))/M )* std::cos((2 * k * PI * p )/ T)));
    });

    std::transform(koeficijenti_b.begin() + 1, koeficijenti_b.end(), koeficijenti_b.begin() + 1, [=](int k) {
        double red(0);
        for(int i = 0; i &lt; M ; i++)
            red += (f(p + i*T/M) * std::sin(2* k *PI*(p/T + (double)i/M)));
        return ((red * 2. / M) + ((f(p) + f(q))/M ) * std::sin((2 * k * PI * p )/ T));
    });
}
double FourierovRed::operator() (double x) const
{

    double red(0);
    for(int i = 1; i &lt;= N ; i++)
        red += (koeficijenti_a[i] * std::cos((2 * i * PI * x )/ T) + koeficijenti_b[i] * std::sin((2 * i * PI * x) /T));

    return koeficijenti_a[0]/2. + red;

}
std::pair&lt;double, double&gt; FourierovRed::operator [](int x) const
{
    if(x &lt; 0 || x &gt;= N) throw std::range_error("Neispravan indeks");
    if(x == 0) return std::make_pair(koeficijenti_a.at(0), 0);
    return std::make_pair(koeficijenti_a[x], koeficijenti_b[x]);
}
std::pair&lt;double &amp;, double &amp;&gt; FourierovRed::operator [](int x)
{
    if(x &lt; 0 || x &gt;= N) throw std::range_error("Neispravan indeks");


    if(x == 0) {
        auto novi = std::tie (koeficijenti_a[x], ignorisi);
        std::pair &lt;double &amp;, double&amp; &gt; povratni(std::get&lt;0&gt; (novi),std::get&lt;1&gt; (novi));
        return povratni;
    }
    auto novi = std::tie (koeficijenti_a[x], koeficijenti_b[x]);
    std::pair &lt;double &amp;, double &amp;&gt; povratni(std::get&lt;0&gt; (novi),std::get&lt;1&gt; (novi));
    return povratni;
}

int main ()
{
    FourierovRed aproksimacija(50, 0, 2 * PI, [](double x) {
        return x * x;
    }, 1000);

    FourierovRed tacni (50, 2 * PI, [] (int k) {
        return k == 0 ? 8 * PI * PI/ 3 : 4. / (k * k);
    }, [] (int k) {
        return -4 * PI/ k;
    });
    std::cout &lt;&lt; "x * x za x = 2: " &lt;&lt; std::endl;
    std::cout &lt;&lt; aproksimacija(2) &lt;&lt; std::endl;
    std::cout &lt;&lt; tacni(2) &lt;&lt; std::endl;


    return 0;
}
</pre>
</body>
</html>
