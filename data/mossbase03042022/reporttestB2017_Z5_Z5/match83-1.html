<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student1649.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student7673.cpp<p></p><pre>
/B2017/2018: ZadaÄ‡a 5, Zadatak 4
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;initializer_list&gt;
#include &lt;iomanip&gt;
#define PI 4*atan(1)

using namespace std;




class FourierovRed{
    double T;
    int N, velicinaa,velicinab;
    vector&lt;double&gt; aovi, bovi;
public:
    FourierovRed(double t, initializer_list&lt;double&gt; l11, initializer_list&lt;double&gt;l22)
    {
        list&lt;double&gt; l1;
        for(auto it=l11.begin(); it!=l11.end(); it++) l1.push_back(*it);
<a name="3"></a><font color="#00FFFF"><a href="match83-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

        list&lt;double&gt; l2; l2.push_back(0);
        for(auto it=l22.begin(); it!=l22.end(); it++) l2.push_back(*it);
        
        
        while(l1.size()&lt;l2.size()) l1.push_back(0);
        while(l2.size()&lt;l1.size()) l2.push_back(0);
        
        
        aovi.resize(l1.size());
</font><a name="5"></a><font color="#FF0000"><a href="match83-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

        bovi.resize(l2.size());
        int i=0;
        for(auto it=l1.begin(), it1=l2.begin(); it!=l1.end(); it++, it1++){ aovi[i]=*it; bovi[i]=*it1; i++;}
</font>        N=l2.size(); velicinaa=l1.size(); velicinab=l2.size();
    }
    FourierovRed(int br, double per, double f1(int), double f2(int)){
        if(br&lt;=0) throw domain_error("Stepen mora biti pozitivan");
        N=br; T=per;
        aovi.resize(N+1); velicinaa=N+1;
        bovi.resize(N+1); velicinab=N+1;
<a name="7"></a><font color="#0000FF"><a href="match83-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

        bovi[0]=0;
        for(int i=0; i&lt;=N; i++) aovi[i]=f1(i);
        for(int i=1; i&lt;=N; i++) bovi[i]=f2(i);
</font>    }
    FourierovRed(int br, double p, double q, double f(double), int M){
        if(p&gt;=q) throw range_error("Neispravan interval");
        if(M&lt;=0) throw domain_error("Broj podintervala mora biti pozitivan");
        if(br&lt;0) throw domain_error("Stepen mora biti pozitivan");
        T=q-p; N=br;
        aovi.resize(N+1); velicinaa=N+1;
        bovi.resize(N+1); velicinab=N+1;
<a name="0"></a><font color="#FF0000"><a href="match83-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

        for(int i=0; i&lt;=N; i++)
        {
            double nesuma=((f(p)+f(q))/M)*cos((2*i*PI*p)/T);
            double suma=0;
            for(int j=1; j&lt;=M-1; j++)
               {
                   suma+=(f(p+(j*T)/M)*cos(2*j*PI*((p/T)+(j/M))));
               }
            aovi[i]=nesuma+(2/M)*suma;
</font>        
        }
        bovi[0]=0;
        for(int i=1; i&lt;=N; i++)
        {
<a name="4"></a><font color="#FF00FF"><a href="match83-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

            double nesuma=((f(p)+f(q))/M)*sin((2*(i)*PI*p)/T);
            double suma=0;
            for(int j=1; j&lt;=M-1; j++)
                {
                    suma+=f(p+(j*T)/2)*sin(2*j*PI*((p/T)+(j/M)));
                }
            bovi[i]=nesuma+(2/M)*suma;
</font>           
        }
    }
    
    ~FourierovRed() {aovi.resize(0);}
    
    pair&lt;double &amp;,double &amp;&gt; operator [] (int ind){
        if(ind&lt;0 || ind&gt;=N) throw range_error("Neispravan indeks");
        if(ind==0){
            pair&lt;double&amp;,double&amp;&gt; p0(aovi[0],bovi[0]);
            return p0;
        }
        pair&lt;double&amp;,double&amp;&gt; p(aovi[ind],bovi[ind]);
        return p;
    }
    pair&lt;double,double&gt; operator [] (int ind) const{
        if(ind&lt;0 || ind&gt;=N) throw range_error("Neispravan indeks");
        if(ind==0){
            pair&lt;double,double&gt; p0(aovi[0],0);
            return p0;
        }
<a name="10"></a><font color="#FF0000"><a href="match83-0.html#10" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

        pair&lt;double,double&gt; p=make_pair(aovi[ind],bovi[ind]);
        return p;
    }
    FourierovRed(const FourierovRed &amp;f)
    {
        //cout&lt;&lt;"ASDAD"&lt;&lt;endl;
        N=f.N; T=f.T; velicinaa=f.velicinaa; velicinab=f.velicinab;
</font>        aovi.resize(f.N+1);
<a name="1"></a><font color="#00FF00"><a href="match83-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

        bovi.resize(f.N+1);
        for(int i=0; i&lt;=N; i++) { aovi[i]=(f.aovi[i]); }
        for(int i=0; i&lt;=N; i++) { bovi[i]=(f.bovi[i]); }
    }
    FourierovRed &amp;operator = (FourierovRed &amp;f)
    {
        //cout&lt;&lt;"ADADSASDADS"&lt;&lt;endl;
        aovi.resize(0); bovi.resize(0);
        N=f.N; T=f.T; velicinaa=f.velicinaa; velicinab=f.velicinab;
</font>        aovi.resize(N+1);
        bovi.resize(N+1);
<a name="6"></a><font color="#00FF00"><a href="match83-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

        for(int i=0; i&lt;=N; i++) { aovi[i]=(f.aovi[i]); }
        for(int i=0; i&lt;=N; i++) { bovi[i]=(f.bovi[i]); }
        return *this;

    }
    FourierovRed(FourierovRed &amp;&amp;f)
</font>    {
       // cout&lt;&lt;"ADADSASDADS"&lt;&lt;endl;
<a name="8"></a><font color="#00FFFF"><a href="match83-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

        N=f.N; T=f.T; velicinaa=f.velicinaa; velicinab=f.velicinab; aovi=f.aovi; bovi=f.bovi;
        f.N=0; f.T=0; f.velicinaa=0; f.velicinab=0; 
</font>    }
    FourierovRed &amp;operator = (FourierovRed &amp;&amp;f)
    {
        if(this==&amp;f) return *this;
        aovi.resize(0); bovi.resize(0);
<a name="9"></a><font color="#FF00FF"><a href="match83-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

        N=f.N; T=f.T; velicinaa=f.velicinaa; velicinab=f.velicinab; aovi=f.aovi; bovi=f.bovi;
        f.N=0; f.T=0; f.velicinaa=0; f.velicinab=0; 
</font>        return *this;
    }
    void Ispisi(){
        cout&lt;&lt;"Period: "&lt;&lt;T&lt;&lt;endl&lt;&lt;"Stepen: "&lt;&lt;N&lt;&lt;endl;
        cout&lt;&lt;"Koeficijenti a: "&lt;&lt;endl;
        for(int i=0; i&lt;velicinaa; i++) cout&lt;&lt;aovi[i]&lt;&lt;" ";
        cout&lt;&lt;endl&lt;&lt;"Koeficijenti b: "&lt;&lt;endl;
        for(int i=0; i&lt;velicinab; i++) cout&lt;&lt;bovi[i]&lt;&lt;" ";

    }
<a name="2"></a><font color="#0000FF"><a href="match83-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

    double operator ()(double x){
        double onajprvia=(aovi[0])/2;
        double sumaa=0;
        for(int i=1; i&lt;=N; i++)
            sumaa+=((aovi[i]*cos((2*i*PI*x)/T)) + (bovi[i]*sin((2*i*PI*x)/T)));
        return onajprvia + sumaa;
</font>
    }
};

int main ()
{
    
   
	return 0;
}
</pre>
</body>
</html>
