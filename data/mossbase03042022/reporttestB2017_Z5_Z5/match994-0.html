<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student9081.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student9081.cpp<p></p><pre>
/B2017/2018: Zadaća 5, Zadatak 5
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;initializer_list&gt;
#include &lt;utility&gt;
#include &lt;functional&gt;
#include &lt;cmath&gt;

const double PI(4*std::atan(1));
double nula(0);

class FourierovRed
{
    double period;
    int stepen;
    std::vector&lt;double&gt; ak,bk;
<a name="0"></a><font color="#FF0000"><a href="match994-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

public:
    FourierovRed (double T, std::initializer_list&lt;double&gt; koef1, std::initializer_list&lt;double&gt; koef2);
    FourierovRed (int n, double T, std::function&lt;double(int)&gt; f1, std::function&lt;double(int)&gt; f2);
    FourierovRed (int n, double p, double q, std::function&lt;double(double)&gt; f, int M);
</font>    ~FourierovRed () = default;
    FourierovRed (const FourierovRed &amp;f) = default;
    FourierovRed (FourierovRed &amp;&amp;f);
    FourierovRed &amp;operator= (const FourierovRed &amp;f) = default;
    FourierovRed &amp;operator= (FourierovRed &amp;&amp;f);
    double operator () (double x) const;
    std::pair&lt;double,double&gt; operator[] (int k) const;
    std::pair&lt;double&amp;,double&amp;&gt; operator [] (int k);
};

std::pair&lt;double,double&gt; FourierovRed::operator[] (int k) const
{
    if (k&lt;0 || k&gt;stepen) throw std::range_error ("Neispravan indeks");
    if (k==0) return std::make_pair(ak[0],0);
    return std::make_pair(ak[k],bk[k-1]);
}

std::pair&lt;double&amp;,double&amp;&gt; FourierovRed::operator[] (int k)
{
    if (k&lt;0 || k&gt;stepen) throw std::range_error ("Neispravan indeks");
    if (k==0)
    {
        nula=0;
        std::pair&lt;double&amp;,double&amp;&gt; par(ak[0],nula);
        return par;
    }
    std::pair&lt;double&amp;,double&amp;&gt; par(ak[k],bk[k-1]);
    return par;
}

double FourierovRed::operator() (double x) const
{
    double vrati(0);
    for (int i=1;i&lt;stepen+1;i++)
        vrati+=ak[i]*std::cos(2*i*PI*x/period);
    for (int i=0;i&lt;stepen;i++)
        vrati+=bk[i]*std::sin(2*(i+1)*PI*x/period);
    vrati+=ak[0]/2;
    return vrati;
}

FourierovRed::FourierovRed (int n, double p, double q, std::function&lt;double(double)&gt; f, int M): period(q-p),stepen(n)
{
    if (n&lt;=0) throw std::domain_error ("Stepen mora biti pozitivan");
    if (M&lt;=0) throw std::domain_error ("Broj podintervala mora biti pozitivan");
    if (!(p&lt;q)) throw std::range_error ("Neispravan interval");
    ak.resize(n+1); bk.resize(n);
    for (int i=0;i&lt;n+1;i++)
    {
        double suma(0);
        for (int j=1;j&lt;=M-1;j++)
            suma+=(f(p+j*period/M))*std::cos(2*i*PI*(double(p)/period+double(j)/M));
        suma*=2; suma/=M;
        ak[i]=(f(p)+f(q))/M*std::cos(double(2*i*PI*p)/period)+suma;
    }
    for (int i=0;i&lt;n;i++)
    {
        double suma(0);
        for (int j=1;j&lt;=M-1;j++)
            suma+=(f(p+j*period/M))*std::sin(2*(i+1)*PI*(double(p)/period+double(j)/M));
        suma*=2; suma/=M;
        bk[i]=(f(p)+f(q))/M*std::sin(double(2*(i+1)*PI*p)/period)+suma;
    }
}

FourierovRed::FourierovRed (int n, double T, std::function&lt;double(int)&gt; f1, std::function&lt;double(int)&gt; f2): period(T),stepen(n)
{
    if (n&lt;=0) throw std::domain_error ("Stepen mora biti pozitivan");
    ak.resize(n+1); bk.resize(n);
    for (int i=0;i&lt;n+1;i++)
        ak[i]=f1(i);
    for (int i=0;i&lt;n;i++)
        bk[i]=f2(i+1);
}

FourierovRed::FourierovRed (double T, std::initializer_list&lt;double&gt; koef1, std::initializer_list&lt;double&gt; koef2): period(T)
{
    int vel(koef2.size());
    if (int(koef1.size())-1&gt;int(koef2.size())) vel=koef1.size()-1;
    stepen=vel;
    ak.resize(stepen+1); bk.resize(stepen);
    auto lista1(koef1.begin()),lista2(koef2.begin());
    for (int i=0;i&lt;vel+1;i++)
    {
        if (i&lt;koef1.size())
        {
            ak[i]=*lista1;
            lista1++;
        }
        else ak[i]=0;
    }
    for (int i=0;i&lt;vel;i++)
    {
        if (i&lt;koef2.size())
        {
            bk[i]=*lista2;
            lista2++;
        }
        else bk[i]=0;
    }
}

FourierovRed::FourierovRed (FourierovRed &amp;&amp;f): period(f.period),stepen(f.stepen),ak(f.ak),bk(f.bk)
{
    f.ak.resize(0); f.bk.resize(0);
}

FourierovRed &amp;FourierovRed::operator= (FourierovRed &amp;&amp;f)
{
    std::swap(period,f.period); std::swap(stepen,f.stepen);
    std::swap(ak,f.ak); std::swap(bk,f.bk);
    return *this;
}

int main ()
{
    for (;;)
    {
        std::cout&lt;&lt;"Unesite stepen Fourierovovog reda: ";
        int m;
        std::cin&gt;&gt;m;
        if (m==-1) break;
        std::cout&lt;&lt;"Unesite broj podintervala za procjenu: ";
        int n;
        std::cin&gt;&gt;n;
        std::cout&lt;&lt;"Unesite tačku gdje se računa vrijednost Fourierovovog reda: ";
        double x;
        std::cin&gt;&gt;x;
        try 
        {
            FourierovRed f1(m,0,2*PI,[] (double x) {return x*x;},n),f2(m,2*PI,[] (int k) {return k==0 ? 8*PI*PI/3 : 4./(k*k);}, [](int k) {return -4*PI/k;});
            std::cout&lt;&lt;"Vrijednosti su:\n";
            std::cout&lt;&lt;"f1("&lt;&lt;x&lt;&lt;") = "&lt;&lt;f1(x)&lt;&lt;" i "&lt;&lt;"f2("&lt;&lt;x&lt;&lt;") = "&lt;&lt;f2(x);
        }
        catch(...)
        {std::cout&lt;&lt;"Greska!Unesite ponovo!\n";}
    }
	return 0;
}
</pre>
</body>
</html>
