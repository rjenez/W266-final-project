<html>
<head>
<title>../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student2941.cpp</title>
</head>
<body bgcolor="white">
<hr/>
../../data/programming-homework-dataset-plagiarism-detection/src/B2017/Z5/Z5/student8705.cpp<p></p><pre>
#include &lt;iostream&gt;
#include &lt;initializer_list&gt;
#include &lt;cmath&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using std::vector;

double _PI_(std::atan(1) * 4);

class FourierovRed
{
    vector&lt;double&gt; a, b;
    double T;
    int n;
    double Ak(int k, std::function&lt;double(double)&gt; f, double p, double q, int M);
    double Bk(int k, std::function&lt;double(double)&gt; f, double p, double q, int M);
<a name="0"></a><font color="#FF0000"><a href="match207-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

public:
    FourierovRed(double T, std::initializer_list&lt;double&gt; a, std::initializer_list&lt;double&gt; b);
    FourierovRed(int N, double T, std::function&lt;double(int)&gt; f, std::function&lt;double(int)&gt; g);
    FourierovRed(int N, double p, double q, std::function&lt;double(double)&gt; f, int M);
</font>    ~FourierovRed() = default;
    FourierovRed(const FourierovRed &amp;f);
    FourierovRed(FourierovRed &amp;&amp;f) { std::swap(a, f.a); std::swap(b, f.b); T = f.T; n = f.n; }
    FourierovRed &amp;operator =(FourierovRed f) { std::swap(a, f.a); std::swap(b, f.b); T = f.T; n = f.n; return *this; }
    double operator ()(double) const;
    std::pair&lt;double&amp;, double&amp;&gt; operator[](int);
    std::pair&lt;double, double&gt; operator[](int) const;
};

double FourierovRed::Ak(int k, std::function&lt;double(double)&gt; f, double p, double q, int M)
{
    double ak(0), T(q-p);
    for (int i(1); i &lt; M; ++i)
        ak += f(p + i*T/M) * std::cos(2*k*_PI_*(p/T + double(i)/M));
    ak *= 2. / M;
    ak += (f(p) + f(q)) / M * std::cos(2 * k * _PI_*p / T);
    return ak;
}
double FourierovRed::Bk(int k, std::function&lt;double(double)&gt; f, double p, double q, int M)
{
    double bk(0);
    for (int i(1); i &lt; M; ++i)
        bk += f(p + i*T/M) * std::sin(2*k*_PI_*(p/T + double(i)/M));
    bk *= 2. / M;
    bk += (f(p) + f(q)) / M * std::sin(2 * k * _PI_*p / T);
    return bk;
}

FourierovRed::FourierovRed(double T, std::initializer_list&lt;double&gt; _a, std::initializer_list&lt;double&gt; _b)
: T(T)
{
    n = std::max(int(_a.size()) - 1, int(_b.size()));
    a.resize(n+1); b.resize(n+1);
    int i(0);
    for (auto it(_a.begin()); it != _a.end(); ++it, ++i)
        a[i] = *it;
    i = 1;
    for (auto it(_b.begin()); it != _b.end(); ++it, ++i)
        b[i] = *it;
    //?Izuzetak za T&lt;=0?
}
<a name="4"></a><font color="#FF00FF"><a href="match207-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

FourierovRed::FourierovRed(int N, double T, std::function&lt;double(int)&gt; f, std::function&lt;double(int)&gt; g)
: T(T)
</font>{
    if (N &lt;= 0) throw std::domain_error("Stepen mora biti pozitivan");
    n = N;
    a.resize(n+1); b.resize(n+1);
    for (int i(0); i &lt;= n; ++i)
    {
        a[i] = f(i);
<a name="5"></a><font color="#FF0000"><a href="match207-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

        if (i &gt; 0) b[i] = g(i);
    }
}
FourierovRed::FourierovRed(int N, double p, double q, std::function&lt;double(double)&gt; f, int M)
</font>{
    if (N &lt;= 0) throw std::domain_error("Stepen mora biti pozitivan");
    if (M &lt;= 0) throw std::domain_error("Broj podintervala mora biti pozitivan");
    if (q &lt;= p) throw std::range_error("Neispravan interval");
    n = N;
    a.resize(n+1); b.resize(n+1);
    T = q - p;
    for (int i(0); i &lt;= n; ++i)
    {
        a[i] = Ak(i, f, p, q, M);
        if (i &gt; 0) b[i] = Bk(i, f, p, q, M);
    }
}
FourierovRed::FourierovRed(const FourierovRed &amp;f)
{
    if (&amp;f == this) return;
    auto _a(f.a), _b(f.b);
    a = std::move(_a); b = std::move(_b);
    n = f.n; T = f.T;
}

double FourierovRed::operator ()(double x) const
{
    double r(a[0] / 2);
    for (int k(1); k &lt;= n; ++k)
<a name="1"></a><font color="#00FF00"><a href="match207-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

        r += a[k] * std::cos(2*k*_PI_*x / T) + b[k] * std::sin(2*k*_PI_*x / T);
    return r;
}
std::pair&lt;double&amp;, double&amp;&gt; FourierovRed::operator[](int k)
</font><a name="3"></a><font color="#00FFFF"><a href="match207-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

{
    if (k &lt; 0 || k &gt; n) throw std::range_error("Neispravan indeks");
    b[0] = 0;
</font>    return std::pair&lt;double&amp;, double&amp;&gt;(a[k], b[k]);
}
<a name="2"></a><font color="#0000FF"><a href="match207-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

std::pair&lt;double, double&gt; FourierovRed::operator[](int k) const
{
    if (k &lt; 0 || k &gt; n) throw std::range_error("Neispravan indeks");
    return std::make_pair(a[k], k == 0 ? 0. : b[k]);
</font>}

int main()
{
    double x;
    int M;
    FourierovRed f1(100, 2*_PI_, [](int i) { return i == 0 ? 8*_PI_*_PI_ / 3 : 4. / (i*i); }, [](int i) { return -4*_PI_ / i; });
    while ((std::cout &lt;&lt; "x=", std::cin &gt;&gt; x) &amp;&amp; (std::cout &lt;&lt; "M=", std::cin &gt;&gt; M))
    {
        FourierovRed f2(100, 0, 2*_PI_, [](double x) { return x*x; }, M);
        std::cout &lt;&lt; "delta=" &lt;&lt; f2(x) - f1(x) &lt;&lt; '\n';
    }
    std::cin.clear(); std::cin.ignore(10000, '\n');
    std::cout &lt;&lt; "-----------------------------------";
    for (int i(1); i &lt;= 101; i += 20)
    {
        FourierovRed f2(i, 0, 2*_PI_, [](double x) { return x*x; }, 2000);
        std::cout &lt;&lt; "\nN=" &lt;&lt; i &lt;&lt; " delta=" &lt;&lt; f2(3) - f1(3);
    }
	return 0;
}</pre>
</body>
</html>
